{
    "search_index": {
        "description_for_embedding": "Home Assistant Tado integration: add support for multiple Tado accounts, fix per-account polling, and avoid entity ID collisions by including home/device ID in climate and sensor unique IDs. Also fix incorrect detection of open-window state by using the correct API field.",
        "keywords": [
            "Home Assistant",
            "tado",
            "multiple accounts",
            "multi-account support",
            "unique_id collision",
            "entity unique_id",
            "open window detection",
            "lambda closure bug",
            "integration config schema",
            "PyTado API"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant Tado integration was extended from supporting a single Tado account to supporting multiple accounts simultaneously. Previously, the configuration schema assumed a single `tado:` block with `username` and `password`. This caused structural limitations when users had several Tado accounts (e.g. multiple homes/bridges), and also risked entity unique_id collisions if multiple homes were ever supported.\n\nTo address this, the `tado` configuration was changed to accept a list of account configs via `vol.All(cv.ensure_list, [...])`. The `setup` function now iterates over this list, creates a `TadoConnector` for each account (storing username, password, and `fallback`), and calls `setup()` and `update()` on each. All connectors are collected into `api_data_list`, which is stored in `hass.data[DOMAIN][DATA]` instead of a single connector instance. Each connector also extracts its `device_id` from `self.tado.getMe()[\"homes\"][0][\"id\"]` to distinguish entities per home/account.\n\nPreviously, polling for Tado updates was done using a single lambda that captured `tadoconnector` by reference in a loop, which could lead to closure issues (all lambdas referencing the last connector). The new code fixes this by using `lambda now, tc=tadoconnector: tc.update()` so each scheduled callback keeps a reference to its own connector.\n\nThe climate and sensor platforms were updated to handle multiple connectors: instead of reading a single `hass.data[DOMAIN]`, they now pull `api_list = hass.data[DOMAIN][DATA]` and iterate over each connector. For each connector's zones and devices, they create entities. The climate entity `TadoClimate` now generates a unique_id that includes the `zone_type`, `zone_id`, and `tado.device_id`. Similarly, `TadoZoneSensor` unique_id now includes the `zone_variable`, `zone_id`, and `tado.device_id`. This avoids unique_id collisions when the same zone IDs or variable names exist across multiple Tado homes or accounts, but is a breaking change for existing users' entity registry entries.\n\nAdditionally, a bug was fixed in open-window detection for sensors. The code previously looked at `data[\"openWindowDetected\"]`, which did not correctly reflect the Tado API's actual schema. It has been updated to consider the presence and non-null value of `data[\"openWindow\"]` as the indicator of an open window and to expose the `openWindow` object as state attributes when present. Similar simplifications were applied to the 'overlay' and 'early start' sensors: boolean states are now derived via concise presence checks (e.g. `\"overlay\" in data and data[\"overlay\"] is not None`) and attributes are populated conditionally.\n\nOverall, this PR enables multiple Tado accounts in Home Assistant, resolves potential entity ID conflicts by incorporating the home/device ID into unique IDs, fixes an event-loop closure bug in scheduled updates, and corrects open-window sensor behavior to match the Tado API.",
        "semantic_memory": "Generalizable lessons from this fix:\n\n1. Multi-account / multi-instance integration design:\n   - When an integration needs to support multiple accounts or instances of an external service, the configuration schema should accept a list of account entries rather than a single dict. In Home Assistant, this can be done with `vol.All(cv.ensure_list, [schema])` so that both single-object and list forms are valid.\n   - Internally, instead of storing a single API client in `hass.data[DOMAIN]`, store a collection (e.g. a list or dict keyed by a stable ID) under a specific key like `hass.data[DOMAIN][\"data\"]`. All platforms (climate, sensor, etc.) should iterate over this collection to create entities per account.\n\n2. Avoiding closure capture bugs in loops:\n   - When scheduling callbacks in a loop (e.g., time-based events), lambdas can accidentally capture the loop variable by reference, ending up with all callbacks bound to the last value. Using default arguments in lambdas (e.g. `lambda now, tc=connector: tc.update()`) or using `functools.partial` avoids this common pitfall by binding the current value at definition time.\n\n3. Designing robust `unique_id` values for entities:\n   - Unique IDs used for entity registries should be globally unique across all possible instances. If an integration may connect to multiple accounts, devices, or homes, the `unique_id` values should incorporate stable identifiers from both the device (e.g., home ID) and the logical entity (e.g., zone ID, variable name). Simple combinations such as `f\"{zone_type} {zone_id} {device_id}\"` are often sufficient.\n   - Changing unique_id formats is a breaking change for systems that persist entity IDs, so such changes should be documented as breaking and clearly communicated.\n\n4. Correctly mapping API data structures to sensor states:\n   - External APIs may expose state as nested objects or via updated field names. Code that checks a boolean flag (e.g., `openWindowDetected`) may be incorrect if the API actually uses an object field (e.g., `openWindow`) to convey richer state. Robust integration code should align with the API's actual structure and treat presence/non-null values as state where appropriate.\n   - When presence (rather than a boolean) indicates state, a pattern like `state = key in data and data[key] is not None` is a clear and concise way to derive the sensor state, and attributes can be populated with the object data when active.\n\n5. Fallback behavior and configuration per account:\n   - When a behavior such as \"fallback to Smart Schedule\" is configurable, it should be stored on the per-account or per-connector object (e.g., `self._fallback`) and referenced by entities through that object (e.g., `if tado.fallback:`). This ensures that entities respect account-specific configuration rather than a single global flag.\n\n6. Backward compatibility considerations:\n   - Enabling multi-account support and changing unique_id formats at the same time may cause users' existing entities to be re-created. When making such changes, clearly mark them as breaking, update documentation, and provide migration guidance where possible (e.g., how to update automations that reference old entity IDs).",
        "procedural_memory": [
            "How to diagnose and implement multi-account support and avoid entity unique_id collisions in a Home Assistant-like integration:",
            "Step 1: Identify assumptions of single-account usage.",
            "Review your integration's configuration schema and storage. Look for patterns where a domain is configured as a single dict (e.g., `config[DOMAIN][CONF_USERNAME]`) and where a single API client is stored globally (e.g., `hass.data[DOMAIN] = api_client`). Determine whether entity IDs or unique IDs might collide if multiple accounts or homes are introduced.",
            "Step 2: Update the configuration schema to accept multiple accounts.",
            "If you want to support both a single config block and a list, wrap your schema in something like `vol.All(cv.ensure_list, [schema])`. This allows users to specify either one account or a list of accounts under the same top-level key.",
            "Step 3: Instantiate one connector/client per account.",
            "In your `setup` or initialization logic, iterate over the list of account definitions. For each, construct a dedicated API connector object with the account's credentials and configuration options (e.g., username, password, fallback flags). Attempt to authenticate or otherwise perform `setup()` for each; skip or log failure if setup fails, but continue with others.",
            "Step 4: Structure `hass.data` (or equivalent global state) to hold multiple connectors.",
            "Instead of overwriting `hass.data[DOMAIN]` with a single connector, store a collection, e.g. `hass.data[DOMAIN] = {\"data\": [connector1, connector2, ...]}`. Ensure all platforms (sensor, climate, etc.) look up this collection and iterate over it when creating entities, rather than assuming a single connector.",
            "Step 5: Avoid closure-capture bugs when scheduling periodic updates.",
            "When scheduling periodic callbacks in a loop, avoid using `lambda` that references the loop variable directly. Instead, bind the current connector into the lambdaâ€™s default argument (e.g., `lambda now, tc=connector: tc.update()`) or use `functools.partial`. This guarantees that each scheduled callback refers to the correct connector instance.",
            "Step 6: Add stable per-account identifiers for entities.",
            "From your external API, obtain a stable ID that represents the account/home/bridge (e.g., `home_id = api.getMe()[\"homes\"][0][\"id\"]`). Store this on the connector (e.g., `self.device_id = home_id`). Use this in all entity `unique_id` definitions, combining it with per-zone or per-device identifiers. Example: `self._unique_id = f\"{zone_type} {zone_id} {tado.device_id}\"`.",
            "Step 7: Update entities to use the per-account identifiers in `unique_id`.",
            "In each entity class (climate, sensor, etc.), define or update a `unique_id` property to incorporate both the entity-specific identifiers (zone ID, variable name) and the per-account/home ID. This prevents collisions when multiple accounts have identical zone IDs or names.",
            "Step 8: Validate and correct mapping of external API fields to sensor states.",
            "Check your integration against the latest API documentation or actual responses. Ensure that the fields you read (e.g., `openWindow` vs `openWindowDetected`) exist and have the expected types. For sensors that represent the presence of a feature (overlay, early start, open window), use presence checks (e.g. `key in data and data[key] is not None`) to derive boolean states, and attach meaningful attributes from the API payload where appropriate.",
            "Step 9: Test entity creation and behavior for multiple accounts.",
            "Configure multiple account entries in a local test environment. Verify that all expected sensors and climate entities are created for each account, that their unique IDs are distinct, and that each entity's state updates correctly. Confirm that scheduled updates call the correct connector and that no unexpected cross-account data leakage occurs.",
            "Step 10: Communicate breaking changes and migration impact.",
            "If you change unique_id formats or configuration semantics, mark them as breaking changes in release notes. Explain that existing entities may be re-created or renamed and provide guidance on how to adjust automations or dashboards. Whenever possible, offer a migration path or mapping from old IDs to new ones."
        ]
    }
}
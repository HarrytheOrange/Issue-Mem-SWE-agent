{
    "search_index": {
        "description_for_embedding": "Home Assistant KNX integration enhancement adding configuration options to broadcast current time and an outside temperature sensor value to the KNX bus. Implements a state-change listener to convert a Home Assistant sensor state into a KNX DPT float payload and send it as a Telegram to a configured group address.",
        "keywords": [
            "Home Assistant",
            "KNX",
            "xknx",
            "broadcast sensor value",
            "outside temperature",
            "time_address",
            "group address",
            "async_track_state_change",
            "DPTFloat",
            "DPTArray",
            "Telegram",
            "configuration schema",
            "voluptuous Inclusive"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set targeted the Home Assistant KNX integration to support broadcasting additional information—current time and outside temperature—to the KNX bus. The original issue requested a simple configuration for sending an outdoor temperature sensor value to a KNX group address, so that KNX devices like wall panels could display the outside temperature.\n\nThe developer first added a `time_address` configuration option and a helper `_add_time_device` that creates an `xknx.devices.Time` device and adds it to the xknx device queue. If `time_address` is present in the `knx:` config, this time device is initialized and will broadcast time onto the KNX bus via xknx.\n\nNext, they introduced two new configuration keys for the outside temperature feature: `outside_temperature_sensor` (the Home Assistant entity_id of the temperature sensor) and `outside_temperature_address` (the KNX group address to publish to). These keys are declared with `vol.Inclusive` so that they must be provided together in the `knx` configuration.\n\nIn the KNX component’s `register_callbacks` method, if `outside_temperature_address` is configured, the code calls `async_track_state_change` with the specified sensor entity_id and registers `async_broadcast_temperature` as the callback. This coroutine checks that the new state is not `None`, converts `new_state.state` to a float, uses `DPTFloat().to_knx()` to encode it into KNX format wrapped in a `DPTArray`, and then constructs an xknx `Telegram`. The target group address is built from `outside_temperature_address`, and the payload is set to the DPT array. Finally, the telegram is put onto `self.xknx.telegrams`, which sends the update to the KNX bus.\n\nThere was architectural discussion in the PR: maintainers preferred a generic 'expose' configuration mechanism instead of special-case options for time and outside temperature. While the code demonstrates how to implement such broadcasting, the PR ultimately went stale and was closed, but it provides a concrete pattern for listening to entity state changes and emitting corresponding KNX telegrams based on configuration.",
        "semantic_memory": "This PR illustrates how to expose internal application state (e.g., Home Assistant entities) to an external field bus (KNX) in a configurable, event-driven way.\n\nKey concepts:\n\n1. **Config-driven exposure of internal data to external protocols**: Rather than hard-coding logic, you can let users map internal entities to external addresses via configuration (e.g., sensor entity_id to KNX group address). This separation keeps the core integration flexible and reduces code-level coupling.\n\n2. **Event-based state propagation**: Hook into the platform’s event system (like Home Assistant’s `async_track_state_change`) to react immediately when an entity’s state changes. The callback then translates and forwards this state to the external system (KNX here), ensuring the external bus reflects current application state with minimal polling.\n\n3. **Type and format conversion**: External protocols often require specific data point types and binary encodings (e.g., KNX DPT 9.xxx/14.xxx for floats). The pattern is: take raw entity state (string), validate and convert to the correct Python type (float), then pass it through a protocol-specific encoder (e.g. `DPTFloat().to_knx()` and `DPTArray`) before sending.\n\n4. **Configuration validation and pairing with Voluptuous**: `vol.Inclusive` is used so that related options must appear together (`outside_temperature_sensor` and `outside_temperature_address`). This prevents partially configured features that would fail at runtime.\n\n5. **Leveraging existing protocol libraries**: Instead of reimplementing KNX details, the integration relies on xknx abstractions (`Telegram`, `Address`, `Time` device) and its telegram queue. This keeps protocol handling consistent and minimizes the risk of low-level bugs.\n\n6. **Generic vs. special-purpose features**: The discussion highlights an architectural best practice: favor a generic exposure mechanism (e.g., `knx: expose:` blocks mapping entity_id, type/DPT, and address) over one-off options like `outside_temperature_*` and `time_address`. A generic approach scales better and avoids proliferation of bespoke config keys.",
        "procedural_memory": [
            "When implementing or debugging a feature that exposes internal sensor values or time to an external bus/protocol (like KNX), follow these steps:",
            "Step 1: Clarify the mapping requirements",
            "- Identify which internal entities (e.g., temperature sensors, time) should be exposed.",
            "- Determine the external identifiers/addresses needed (e.g., KNX group addresses).",
            "- Decide what data type / DPT or encoding is required by the external protocol (e.g., KNX DPT 9.xxx float).",
            "",
            "Step 2: Extend configuration schema",
            "- Add configuration options for the entity_id and external address (e.g., `outside_temperature_sensor`, `outside_temperature_address`).",
            "- Use a validation library (like Voluptuous) to enforce that dependent options appear together, e.g.:",
            "  - `vol.Inclusive('outside_temperature_sensor', 'outside_temp'): cv.string`",
            "  - `vol.Inclusive('outside_temperature_address', 'outside_temp'): cv.string`",
            "- For time broadcasting, a single address option may be sufficient (e.g., `time_address`).",
            "",
            "Step 3: Initialize protocol devices or callbacks during setup",
            "- In the component's async setup or initialization routine:",
            "  - If a time address is configured, create a protocol-specific time device (e.g., `xknx.devices.Time`) and add it to the device list/queue.",
            "  - If an outside temperature mapping is configured, register a state-change listener on the specified entity_id using the platform’s event helper (e.g., `async_track_state_change`).",
            "",
            "Step 4: Implement the state-change callback",
            "- Write an async callback that receives `(entity_id, old_state, new_state)`.",
            "- Immediately guard against invalid states:",
            "  - If `new_state` is `None`, return without sending anything.",
            "  - Optionally, handle non-numeric or unknown values gracefully (e.g., try/except for float conversion).",
            "- Convert `new_state.state` to the appropriate Python type (`float` for temperature).",
            "- Use the protocol library’s encoding utilities to create a payload:",
            "  - For KNX float: `payload = DPTArray(DPTFloat().to_knx(value))`.",
            "- Construct a telegram/message with the target address and payload:",
            "  - `address = Address(configured_group_address)`",
            "  - `telegram = Telegram()`",
            "  - `telegram.group_address = address`",
            "  - `telegram.payload = payload`",
            "- Put the telegram onto the library’s send queue (e.g., `yield from self.xknx.telegrams.put(telegram)`).",
            "",
            "Step 5: Test the round-trip",
            "- Configure the integration with the new options (sensor + address).",
            "- Trigger changes in the sensor value and monitor the external bus (e.g., with a KNX bus monitor) to verify telegrams are sent with the expected addresses and values.",
            "- Test boundary cases: startup with no initial state, invalid sensor reading, turning the sensor entity off, etc.",
            "",
            "Step 6: Generalize when possible",
            "- Instead of introducing many special-case options (e.g., `outside_temperature_*`, `time_address`, etc.), consider a generic configuration block like `expose:` mapping:",
            "  - `entity_id` -> external address",
            "  - `type` or `dpt` definition for encoding",
            "- Implement the above pattern in a loop over the configured exposures, so each mapping automatically gets a state-change listener and the correct encoding/telegram sending logic.",
            "",
            "Step 7: Handle lifecycle and cleanup",
            "- Ensure callbacks and protocol devices are registered only when config is present.",
            "- If needed, unregister callbacks or stop devices on component shutdown using the platform’s stop event (e.g., `EVENT_HOMEASSISTANT_STOP`).",
            "",
            "Following this pattern allows you to reliably expose internal states to KNX or other field buses, keep configuration flexible, and avoid runtime errors due to bad or incomplete configuration."
        ]
    }
}
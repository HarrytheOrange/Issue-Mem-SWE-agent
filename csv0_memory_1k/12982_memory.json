{
    "search_index": {
        "description_for_embedding": "Refactor Home Assistant HTTP and websocket components to use modern async/await syntax instead of asyncio.coroutine/yield from, extract HomeAssistantView into its own module, and update middleware, views, websocket API, emulated_hue integration, and tests accordingly while fixing pylint issues.",
        "keywords": [
            "HomeAssistantView",
            "http component",
            "aiohttp middleware",
            "async/await migration",
            "asyncio.coroutine deprecation",
            "websocket_api",
            "pylint coroutine warning",
            "emulated_hue",
            "Home Assistant tests",
            "yield from to await"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant project refactored its HTTP stack and related components to use modern async/await syntax and to improve structure. Previously, the HTTP component mixed legacy asyncio.coroutine/yield from style with newer async idioms, and the HomeAssistantView base class lived inside homeassistant/components/http/__init__.py. This caused stylistic and tooling friction, including pylint coroutine warnings (relating to PyCQA/pylint#996) and made the HTTP module large and harder to maintain.\n\nThe fix involved several coordinated changes:\n\n1. **HomeAssistantView extraction**:\n   - The HomeAssistantView class and its request_handler_factory were moved from homeassistant/components/http/__init__.py into a new module homeassistant/components/http/view.py.\n   - http.__init__ now re-exports HomeAssistantView (and constants KEY_AUTHENTICATED, KEY_REAL_IP) to preserve the public API and avoid breaking existing imports.\n   - The new view module maintains the same behavior: JSON helpers (json, json_message), an async file() helper, view registration with router.add_route, and the request handler wrapper that enforces authentication, logs requests, and normalizes handler return values into aiohttp web.Response.\n\n2. **Async/await migration in HTTP component**:\n   - async_setup in http.__init__ was converted from an asyncio.coroutine with yield from calls to a native async def using await.\n   - The internal server methods start and stop on the HTTP server class were converted to async def, and their internal logic was updated to await app.startup(), loop.create_server, server.wait_closed(), app.shutdown(), handler.shutdown(), and app.cleanup().\n   - The HTTP component's helper function register_static_path now defines async def serve_file handlers instead of asyncio.coroutine functions.\n\n3. **Async/await in HTTP middlewares and utilities**:\n   - homeassistant/components/http/auth.py: The auth_middleware and auth_startup functions were converted to async def with await handler(request), ensuring compatibility with aiohttp's @middleware.\n   - homeassistant/components/http/ban.py: ban_startup, ban_middleware, and process_wrong_login became async def. Calls to hass.async_add_job and handler(request) now use await. This preserves IP ban logic while aligning with async style.\n   - homeassistant/components/http/cors.py: cors_startup is now async def.\n   - homeassistant/components/http/real_ip.py: real_ip_middleware and app_startup are async def, and they now await handler(request).\n   - homeassistant/components/http/static.py: CachingStaticResource._handle, the overridden sendfile function, and staticresource_middleware are async def and use await for super()._handle(...) and handler(request). Fingerprinted static asset handling behavior remains unchanged.\n   - homeassistant/components/http/data_validator.py: The RequestDataValidator decorator's wrapper is now async def, uses await request.json() / await request.content.read(), and awaits the wrapped method, solving the mismatch between decorator and async view methods that could trigger pylint warnings.\n\n4. **Websocket API modernization**:\n   - In homeassistant/components/websocket_api.py, async_setup was converted to async def.\n   - WebsocketAPIView.get is now async def and awaits ActiveConnection(...).handle().\n   - ActiveConnection._writer and handle are async def; they now await self.to_write.get(), wsock.send_json(), wsock.prepare(), wsock.receive_json(), async_get_all_descriptions(), and hass.services.async_call(), instead of using yield from.\n   - The inner helper coroutines forward_events, call_service_helper, and get_services_helper were converted to async def and updated to use await.\n   - The cleanup logic ensures all pending messages are sent by awaiting self._writer_task before closing the websocket.\n\n5. **Emulated Hue integration updates**:\n   - In homeassistant/components/emulated_hue/__init__.py, stop_emulated_hue_bridge and start_emulated_hue_bridge were converted to async def and now await server.stop() and server.start() instead of yield from. asyncio import was removed as it was no longer needed.\n\n6. **Test suite conversion to async/await**:\n   - All HTTP-related tests under tests/components/http were updated to use native async def and await, including:\n     - test_auth.py: mock_handler, test_auth_middleware_loaded_by_default, test_access_without_password, ... now use async/await with aiohttp test_client.\n     - test_ban.py: test_access_from_banned_ip, test_ban_middleware_not_loaded_by_config, test_ban_middleware_loaded_by_default, test_ip_bans_file_creation, and the unauth_handler became async/await-based.\n     - test_cors.py: mock_handler, test_cors_middleware_not_loaded_by_default, test_cors_middleware_loaded_from_config, test_cors_requests, test_cors_preflight_allowed are all async and await client calls.\n     - test_data_validator.py: get_client, TestView.post, test_validator, and test_validator_allow_empty now use async def and await; validating that RequestDataValidator works with async views.\n     - test_init.py: TestView.get and tests around registering views at runtime, API base URL configuration, and logging behavior are updated to async/await including calls to async_setup_component, hass.async_start, and aiohttp client operations.\n     - test_real_ip.py: mock_handler, test_ignore_x_forwarded_for, and test_use_x_forwarded_for are async, reading response text via await.\n   - The HTTP test helper in tests/components/http/__init__.py was updated so the mock_real_ip middleware and its startup hook use async def and await handler(request).\n\n7. **Pylint cleanup**:\n   - Parenthesized await expressions like return (await handler(request)) were simplified to return await handler(request) to satisfy pylint.\n   - Imports were reordered and cleaned up to satisfy linting (e.g., moving CONTENT_TYPE_JSON import to group with other Home Assistant imports, removing now-unused asyncio imports).\n\nOverall, this refactor modernized the HTTP and websockets portions of Home Assistant, reduced technical debt, maintained backwards compatibility for public APIs (like HomeAssistantView), and ensured that both runtime behavior and tests continue to function using the updated async/await style.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices for migrating an async codebase and structuring HTTP/websocket components:\n\n1. **Migrating from asyncio.coroutine/yield from to async/await**:\n   - Legacy asyncio.coroutine decorators and yield from calls should be converted to native async def functions and await expressions. This improves readability, aligns with modern Python, and avoids linter issues.\n   - When doing such a migration, update both production code and tests. Tests that use yield from against async APIs must themselves become async def functions that use await.\n\n2. **Aiohttp middleware & handlers as async def**:\n   - In aiohttp-based applications, middlewares must be async callables accepting (request, handler) and typically call return await handler(request).\n   - Startup hooks (app.on_startup callbacks) can be async def, allowing you to perform asynchronous initialization (e.g., reading configuration files, populating shared state) at application startup.\n   - Wrapping middlewares with decorators (like @middleware) should be done on async functions, not on functions decorated with asyncio.coroutine.\n\n3. **Maintaining library public API while refactoring internals**:\n   - When moving a widely used class/function into a new module, keep the original import path working by re-exporting the symbol from the old module. This avoids breaking downstream code.\n   - Using `# noqa` on re-export lines can be necessary to avoid unused-import warnings while preserving public API.\n\n4. **Centralized request handling for class-based views**:\n   - A base view class that registers HTTP methods onto a router and wraps method handlers in a request_handler_factory centralizes cross-cutting concerns: authentication, logging, return-type normalization, etc.\n   - The wrapper (request_handler_factory) can enforce that handlers are either async functions or simple callbacks (using a helper like is_callback) and should consistently coerce return values (str, bytes, tuple, or None) into a proper aiohttp web.Response.\n   - Placing this shared logic into its own module (e.g., http.view) encourages reuse and decouples it from unrelated HTTP server setup.\n\n5. **Auth and security middleware patterns**:\n   - Authentication middleware can operate early in the stack, setting flags (e.g., KEY_AUTHENTICATED) on the request, with views checking those flags or enforcing requires_auth at the wrapper level.\n   - IP ban middleware should consult shared state (e.g., request.app[KEY_BANNED_IPS]) and mutate it on authentication failures. Asynchronous helper functions (like process_wrong_login) can be used to update persisted ban lists via the main event loop.\n   - Middlewares should generally behave like pass-through functions that either short-circuit (e.g., raise HTTPForbidden for banned IPs) or call await handler(request) and handle exceptions.\n\n6. **Decorator compatibility with async methods**:\n   - Decorators like RequestDataValidator that wrap view methods must themselves be async-aware: the wrapper must be async def, await asynchronous operations (request.json(), request.content.read()), and await the wrapped method.\n   - If a decorator yields or awaits, but the decorated method is not declared async (or vice versa), it can cause both runtime issues and static analysis/lint warnings. Ensuring that both the decorator and decorated method are async-compatible is crucial.\n\n7. **WebSocket connection management**:\n   - For WebSockets, separating read and write loops is a robust pattern: one task reads and handles incoming messages; a separate task pulls outbound messages from an asyncio.Queue and writes them to the websocket.\n   - When closing a WebSocket, ensure that you signal the writer queue to stop (e.g., by putting None) and await the writer task to drain any remaining messages before closing the socket.\n   - Authentication over WebSocket can follow a simple handshake: send an auth_required message, await an auth payload, validate it (e.g., via existing password validation), and then continue with the normal message loop; send auth_invalid or auth_ok messages as appropriate.\n\n8. **Async-aware test patterns**:\n   - Tests for async code should be written as async def functions, using pytest-asyncio or similar mechanisms. Interactions with aiohttp test_client should be awaited.\n   - Test helpers (e.g., a function that constructs an app, registers views, and returns a test client) should also be async def and awaited.\n   - This ensures that tests mimic realistic asynchronous control flow, preventing subtle bugs that could arise from synchronous test code interacting with async APIs.\n\nOverall, the fix embodies a clean, systematic approach to modernizing an async codebase: keep the public API stable, update internals and tests to async/await, make middlewares and decorators properly async-aware, and ensure that tooling (pylint, etc.) is satisfied.",
        "procedural_memory": [
            "When modernizing or debugging async HTTP/websocket code (especially in aiohttp-based systems), follow a structured approach:",
            "Step 1: Identify legacy async patterns and their scope",
            "  - Search the codebase for `@asyncio.coroutine`, `yield from`, and other deprecated asynchronous constructs.",
            "  - Identify modules that provide HTTP servers, middleware, views, websockets, and tests that interact with them.",
            "  - Map out where coroutines are used in decorators (e.g., middleware, validation) and how they wrap handlers.",
            "Step 2: Convert coroutines to async/await consistently",
            "  - For each function decorated with `@asyncio.coroutine`, convert it to `async def`.",
            "  - Replace every `yield from` call with `await` on the corresponding coroutine.",
            "  - Ensure function signatures are consistent with the framework expectations (e.g., aiohttp middleware: `async def middleware(request, handler):`).",
            "  - Remove now-unused `asyncio` imports where applicable.",
            "Step 3: Ensure decorators and wrappers are async-compatible",
            "  - For any decorator that wraps async handlers (e.g., a data validation decorator for request handlers), change the wrapper to `async def`.",
            "  - Inside the wrapper, use `await` for any asynchronous I/O (e.g., `await request.json()`, `await request.content.read()`).",
            "  - At the end of the wrapper, `return await method(...)` to invoke the wrapped async function.",
            "  - Validate with linters (pylint) to ensure the decorator and wrapped function signatures are compatible and no coroutine is left un-awaited.",
            "Step 4: Update middleware to async def and propagate await correctly",
            "  - For each middleware defined via `@middleware` or similar, update it to `async def`.",
            "  - Use `return await handler(request)` when passing control to the next middleware/handler.",
            "  - If the middleware may short-circuit (e.g., authentication failure, banned IP), raise the appropriate HTTP exception or return a Response early.",
            "  - For startup/shutdown hooks that perform async work (loading configs, initializing state), define them as `async def` and register them with the app lifecycle.",
            "Step 5: Refactor shared logic into dedicated modules while preserving public APIs",
            "  - If a large module mixes many responsibilities (e.g., HTTP server setup plus view base classes), consider extracting reusable classes/functions into a dedicated module (e.g., http.view).",
            "  - After moving the code, re-export key classes/functions from the original module to keep public import paths stable.",
            "  - Annotate such re-exports with `# noqa` if needed to avoid lint warnings about unused imports.",
            "Step 6: Normalize request handler patterns",
            "  - Provide a centralized wrapper (like `request_handler_factory`) that does the following for each view method: checks server state, enforces authentication, logs requests, and normalizes return values into a `web.Response`.",
            "  - Assert that the wrapped handler is either async or a recognized callback to catch misconfigured handlers early.",
            "  - In the wrapper, handle the case where handlers return a coroutine, `web.StreamResponse`, bytes, string, tuple(result, status_code), or None, and convert each to a valid HTTP response.",
            "Step 7: Modernize websocket handling",
            "  - For WebSocket endpoints, create an async `handle()` method that:\n    - Prepares the WebSocket (`await wsock.prepare(request)`).\n    - Performs an authentication handshake (send auth_required, await client message, validate password, send auth_ok/auth_invalid).\n    - Sets up separate tasks for reading from and writing to the WebSocket, typically using an `asyncio.Queue` for outgoing messages.\n    - Handles exceptions and cleanup: signal the writer task to exit (e.g., by putting `None`), await the writer task to flush messages, then `await wsock.close()`.",
            "  - Use `asyncio.CancelledError` and suppression of expected cancellation/connection errors for robust shutdown.",
            "Step 8: Update and validate tests for async behavior",
            "  - Convert test functions interacting with async code to `async def` and use `await` when calling async setup functions and test client operations.",
            "  - Update any test helper middlewares and startup hooks to `async def` and ensure they `await handler(request)` or other async calls.",
            "  - Run the async test suite with the appropriate pytest plugins (e.g., pytest-asyncio) and ensure that all tests pass and no `RuntimeWarning: coroutine '...' was never awaited` messages appear.",
            "Step 9: Run linters and static analysis",
            "  - Run pylint (or your chosen linter) after the migration to catch remaining patterns like `return (await ...)` that may violate style preferences; clean them up (e.g., use `return await ...`).",
            "  - Fix import order and unused imports caused by the refactor.",
            "Step 10: Regression test behavior and performance",
            "  - Verify that all key HTTP endpoints and WebSocket APIs still behave as expected, including authentication, IP bans, CORS behavior, static file serving, and emulated services like emulated_hue.",
            "  - Confirm that logging (especially around authentication) does not leak sensitive information like passwords.",
            "  - Check that startup and shutdown semantics remain correct: servers start on event signals, and resources are cleaned up properly on stop (sockets closed, handlers shut down, tasks cancelled)."
        ]
    }
}
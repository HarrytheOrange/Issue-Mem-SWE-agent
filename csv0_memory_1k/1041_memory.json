{
    "search_index": {
        "description_for_embedding": "Optuna's sklearn integration was updated to avoid using scikit-learn's private _safe_indexing API directly. A version-guarded alias sklearn_safe_indexing is imported from sklearn.utils (either _safe_indexing for >=0.22 or safe_indexing for older versions), and all internal calls that relied on the private helper were switched to this alias when indexing X, y, groups, and fit_params.",
        "keywords": [
            "optuna",
            "sklearn integration",
            "scikit-learn",
            "safe_indexing",
            "_safe_indexing",
            "sklearn_safe_indexing",
            "private API usage",
            "version compatibility",
            "integration bug",
            "indexing X y groups",
            "fit_params indexing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Optuna project had an issue (Fixes #1004) related to its integration with scikit-learn. The code relied on scikit-learn's private utility function `_safe_indexing` from `sklearn.utils`. Because private APIs in scikit-learn are not stable and can change or be removed between versions, this posed a compatibility and maintenance risk. The proposed fix introduced a version-guarded import: for scikit-learn >= 0.22, it imports `_safe_indexing` as `sklearn_safe_indexing`; for older versions, it imports the public `safe_indexing` as `sklearn_safe_indexing`. Inside `optuna/integration/sklearn.py`, calls that previously used the internal `_safe_indexing` helper were changed to use `sklearn_safe_indexing` instead. Specifically, in `_check_fit_params`, the fit parameters are first made indexable then passed to `sklearn_safe_indexing` with the selected indices; and in the `fit` method, `X_res`, `y_res`, and `groups_res` are obtained by calling `sklearn_safe_indexing` with `self.sample_indices_`. A reviewer pointed out that `_safe_indexing` in this file was itself an Optuna-private helper, not scikit-learn's function, highlighting some confusion in the initial patch. Nonetheless, the central intent was to ensure all indexing of X, y, groups, and fit parameters goes through a compatibility alias that correctly maps to scikit-learn's supported indexing API for the installed version, thereby avoiding direct reliance on scikit-learn's private internals.",
        "semantic_memory": "This fix illustrates a general best practice when integrating with third-party libraries: avoid direct use of private or underscored APIs (`_something`) because they are not part of the library's stable public interface and may change without notice. For libraries that evolve over time (like scikit-learn), it is safer to introduce a small compatibility layer. This layer can version-check the dependency and import or adapt the appropriate functions into a single internal alias that the rest of the codebase uses. By routing all calls through this alias, the codebase centralizes dependency handling and can easily be updated when upstream APIs change. Additionally, when wrapping external APIs, it is important to distinguish between your own internal helpers and those coming from the dependency, to avoid confusion and accidental reliance on the wrong implementation. In general, any integration with external ML libraries should maintain: (1) explicit version conditionals for breaking changes, (2) public-API-only usage whenever possible, and (3) a thin abstraction that isolates external API differences from the rest of the project.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of private API usage problems. Look for ImportError or AttributeError referring to underscored functions (e.g., `sklearn.utils._safe_indexing`) or failing tests after upgrading a dependency like scikit-learn. Search the codebase for direct imports or uses of private (underscore-prefixed) symbols from third-party libraries.",
            "Step 2: Confirm public alternatives and version behavior. Consult the third-party library's documentation and changelog to see if there is a documented public equivalent (e.g., `safe_indexing`) or if the private function has moved or been renamed across versions.",
            "Step 3: Implement a compatibility alias. In a central module (e.g., your integration layer), add version-detection logic (using the library's `__version__` or a helper) and conditionally import the appropriate function into a single alias. For example: if version >= X, import the newer or private function as `my_safe_indexing`; otherwise, import the older public function as `my_safe_indexing`.",
            "Step 4: Refactor internal call sites. Replace all direct uses of the problematic private function or mixed indexing helpers with calls to the new alias (e.g., switch `_safe_indexing(...)` or `safe_indexing(...)` to `my_safe_indexing(...)` everywhere in the integration layer). Ensure that data structures such as X, y, groups, and fit_params are adapted consistently.",
            "Step 5: Disambiguate internal vs external helpers. If your project already defines helpers with similar names (e.g., `_safe_indexing` inside your own code), clearly separate naming (e.g., `sklearn_safe_indexing` for the imported alias and `_project_safe_indexing` for your internal wrapper) to prevent confusion about which implementation is being used.",
            "Step 6: Add or update tests. Create tests that exercise the indexing paths (e.g., fitting models with sample indices, groups, and fit_params) to ensure they work correctly across supported versions of the dependency. If possible, run CI against multiple versions of the external library.",
            "Step 7: Monitor upstream changes. Keep track of deprecations and API changes in the third-party library. When a private function becomes public, is removed, or changes semantics, update the compatibility alias logic accordingly while keeping the rest of the codebase unchanged."
        ]
    }
}
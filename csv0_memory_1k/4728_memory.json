{
    "search_index": {
        "description_for_embedding": "Home Assistant 0.34.1 patch release with several bug fixes: emulated_hue is refactored to support Google Home by introducing a type switch (alexa/google_home), enforcing port 80 for Google Home, and mapping entity IDs to numeric IDs. Sonos config validation is fixed by properly validating host lists with voluptuous. Synology DSM sensors no longer perform I/O in the event loop by caching API objects instead of calling them as methods on each state access. Homematic event handling is made non-blocking by dispatching bus events asynchronously from the Homematic thread. Nest camera image issues are fixed by bumping python-nest to a specific zip commit. TP-Link switch support is stabilized by reverting to pyHS100 0.2.0 due to regressions. HTTP CORS is fixed to correctly handle static routes/resources by attaching CORS once per resource.",
        "keywords": [
            "emulated_hue",
            "Google Home",
            "Alexa",
            "UPnP",
            "Hue API emulation",
            "port 80 requirement",
            "entity id to numeric mapping",
            "Sonos",
            "voluptuous",
            "ensure_list",
            "Synology DSM",
            "I/O in event loop",
            "asyncio",
            "Homematic",
            "thread safety",
            "async_fire",
            "python-nest",
            "Nest camera image bug",
            "TP-Link",
            "pyHS100 revert",
            "CORS bug",
            "aiohttp_cors",
            "static resources",
            "HomeAssistantWSGI"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request is the Home Assistant 0.34.1 patch release, focused on multiple targeted bug fixes.\n\n1) emulated_hue & Google Home\nPreviously, the emulated_hue component worked for Alexa but not for Google Home. Google Home expects Hue bridges to listen on port 80 and to expose lights using numeric IDs, whereas the existing implementation exposed entity IDs directly. The old implementation lived in a single monolithic emulated_hue.py file and did not distinguish between client types.\n\nThe fix refactors emulated_hue into a proper package with three modules: __init__.py (configuration and setup), hue_api.py (HTTP API implementation), and upnp.py (UPnP/SSDP discovery and description.xml). A new configuration option 'type' is added, with values 'alexa' (default) or 'google_home'. For Google Home, the Config class now maps entity IDs to sequential string numbers (1, 2, 3, ...) via entity_id_to_number and the reverse via number_to_entity_id. The HTTP views are updated so that list endpoints return these numbers as light IDs, and state/change endpoints accept numbers and resolve them back to entity_ids for internal use. There is also a warning when type is 'google_home' and the configured listen_port is not 80, because Google Home requires port 80. Tests are split and updated to account for the new package structure, and UPnPResponderThread is patched in tests to avoid network usage.\n\n2) Synology DSM I/O in event loop\nThe Synology DSM sensor component previously exposed methods utilisation() and storage() that did I/O each time they were called, and the sensors called them inside their state property accessors, which run in the event loop. This could cause blocking I/O inside the event loop and degrade performance.\n\nThe fix removes these methods and instead caches the API attributes in __init__ of the data object: self.utilisation = self._api.utilisation and self.storage = self._api.storage. The sensor state properties are updated to use self._api.utilisation and self._api.storage as cached objects, not callable methods. This ensures that I/O happens only during the Throttle-controlled update() call, keeping the event loop non-blocking.\n\n3) Sonos config validation\nThe Sonos media_player platform schema previously used vol.Optional(CONF_HOSTS): cv.ensure_list(cv.string), which is an incorrect use of ensure_list and caused invalid config errors in some cases.\n\nThe fix changes it to vol.Optional(CONF_HOSTS): vol.All(cv.ensure_list, [cv.string]), correctly ensuring a list and validating that each entry is a string.\n\n4) Homematic occasional hangs\nHomematic events were previously processed by directly calling hass.bus.fire() from the Homematic thread, which could cause occasional hangs or deadlocks because it interacted synchronously with Home Assistant's event bus from a foreign thread.\n\nThe fix changes keypress and impulse event handling to schedule asynchronous event firing using hass.add_job(hass.bus.async_fire(...)) instead of hass.bus.fire(). This decouples the Homematic callback thread from the event loop and prevents it from blocking.\n\n5) Nest camera image issues\nThere was a bug in camera image loading for Nest cameras, traced to the underlying python-nest library.\n\nThe fix updates the python-nest requirement to a specific commit (2512973b4b390d3965da43529cd20402ad374bfa) on the nest-cam branch in both the component and requirements_all.txt, which contains the camera-related fixes while keeping the version at 3.0.0.\n\n6) TP-Link switch stability\nA previous update bumped the pyHS100 library to 0.2.1, which caused issues with the TP-Link switch integration.\n\nThe fix reverts the requirement back to pyHS100 0.2.0 by pointing REQUIREMENTS and requirements_all.txt to the older commit zip. This stabilizes the integration until the newer version can be safely adopted.\n\n7) HTTP CORS with static resources\nWhen static resources were registered (e.g., via hass.http.register_static_path), the CORS setup code iterated over routes and called self.cors.add(route) directly. For static resources, aiohttp's routing model uses Resource objects, and this could cause CORS to misbehave or error due to duplicate or incompatible targets.\n\nThe fix updates HomeAssistantWSGI.start() so that when CORS is enabled, it loops over routes, but if a route has a 'resource' attribute, it uses the resource instead. It also maintains a set of cors_added to ensure that each resource is only added once to CORS. Tests are updated to register a static path and ensure CORS still works when using the API URL with an Origin header.\n\nFinally, the version is bumped by changing PATCH_VERSION from '0' to '1' in homeassistant/const.py, finalizing the 0.34.1 release.",
        "semantic_memory": "This PR illustrates several generalizable patterns and best practices in integrating with third-party systems, maintaining async correctness, and managing dependencies in a large Home Assistant-style application.\n\n1) Adapting to third-party protocol quirks\n- Different clients (Alexa vs Google Home) can have subtly different expectations even when ostensibly speaking the same protocol (Hue API). Alexa tolerates entity IDs as light identifiers and arbitrary ports, whereas Google Home expects numeric IDs and port 80.\n- A robust design introduces an abstraction (Config.type) and conversion methods (entity_id_to_number, number_to_entity_id), rather than hardcoding client-specific assumptions throughout the code. This allows the same core logic (state translation, service calling) to work for multiple clients by simply changing the mapping logic.\n- It is useful to make the supported client type explicit in configuration and to validate or warn about incompatible settings (e.g., warn if Google Home is used but listen_port != 80).\n\n2) Avoiding blocking I/O in the event loop\n- In an asyncio-based architecture, any network or disk I/O performed in properties or simple attribute accessors that run in the main event loop can cause jitter and timeouts. Data retrieval should be centralized in throttled update methods (often decorated with Throttle) and cached in memory for read-only access in state properties.\n- Exposing methods that perform I/O and then calling them from state properties is a smell. Better is to treat API objects as data providers updated periodically and use pure attribute access when the event loop is rendering states.\n\n3) Thread-safe interaction with the event bus\n- When callbacks from external libraries run on their own threads, they must not directly execute synchronous operations that interact with the event loop (e.g., hass.bus.fire). Instead, they should schedule asynchronous work using methods like hass.add_job, hass.loop.call_soon_threadsafe, or hass.bus.async_fire.\n- Doing synchronous work on foreign threads can cause deadlocks or hangs, especially when those operations interact with shared locks or the main event loop.\n\n4) Configuration validation with voluptuous\n- When validating list configuration, use vol.All(cv.ensure_list, [cv.string]) to both normalize to a list and validate the type of each element. Passing a validator directly to cv.ensure_list (e.g., cv.ensure_list(cv.string)) is incorrect and can produce confusing errors.\n- Keeping schema strict and correct prevents subtle runtime errors and provides clear feedback to users when their config is invalid.\n\n5) Dependency management and rollback\n- Upgrading a third-party library can introduce regressions that may not be immediately apparent. Pinning to a specific commit (via URL+hash) or reverting to a known-good version is a pragmatic short-term fix when a new version breaks functionality.\n- Separating versioning concerns at the component level and in a central requirements file helps ensure consistency across the codebase.\n\n6) CORS configuration with aiohttp and static resources\n- aiohttp distinguishes between Routes and Resources; some CORS libraries (like aiohttp_cors) are designed to operate at the resource level. When adding CORS support globally, you should detect whether a route wraps a resource and add CORS to the underlying resource, not the route object itself.\n- To avoid duplicate CORS registration, maintain a set of resources that have already been processed. This is especially important when static paths or multiple routes map to the same resource.\n\n7) Testing infrastructure-bound code\n- For code that interacts with sockets (UPnP/SSDP) or long-running threads, it is good practice to patch out those components in unit tests so that tests run reliably and quickly. Here, UPNPResponderThread is patched when setting up the emulated_hue component for tests.\n- Splitting tests along module boundaries (hue_api vs upnp vs init) improves clarity and allows more targeted test scenarios.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: When a third-party client (e.g., Google Home, Alexa) fails to discover or control devices via a bridge emulation component, first confirm protocol-level expectations. Capture network traffic or consult documentation to check required ports, URI paths, ID formats, and payload shapes. If one client works and another doesn't, diff their expectations and factor client-specific behavior into a configuration option (e.g., type='google_home') with explicit mapping logic.",
            "Step 2: For integrations emulating an external API (like Hue), design a translation layer that maps internal entity identifiers to the external representation. Use helper methods to translate in both directions (entity_id_to_number and number_to_entity_id). Ensure that these methods are deterministic and maintain a stable mapping across requests. Add tests verifying the mapping behavior for each supported client type.",
            "Step 3: When you suspect blocking I/O in an asyncio-based event loop (e.g., slow UI, delayed automations, or warnings about I/O in the event loop), inspect where API objects are being called. If state properties call methods that hit the network or disk, refactor so that data retrieval happens in a Throttle-controlled update() method. Cache the results as attributes on a data object (e.g., self.utilisation = self._api.utilisation) and update the state properties to read from these cached attributes only.",
            "Step 4: Review all callbacks that originate from external threads (device libraries, long-polling listeners). If they call hass.bus.fire() or other synchronous Home Assistant methods, change them to schedule asynchronous work instead. Use hass.add_job(hass.bus.async_fire(...)) or hass.loop.call_soon_threadsafe to ensure thread-safe interaction with the event loop. Add logging around these paths to confirm events are dispatched without blocking.",
            "Step 5: When configuration validation fails or produces unexpected errors, re-check voluptuous schema usage. For list fields, prefer vol.All(cv.ensure_list, [cv.string]) or analogous patterns. Validate that default values match the schema type and that optional fields handle None correctly. Add unit tests that exercise malformed and well-formed configs to codify expected behavior.",
            "Step 6: If after upgrading a third-party library (like pyHS100 or python-nest) you see new runtime exceptions or broken behavior, identify the minimal version/commit that works. Temporarily revert to the last known-good version in both the component's REQUIREMENTS and your global requirements file. File or review upstream issues, and only re-upgrade once the breaking change is understood and handled in your code.",
            "Step 7: For CORS issues in an aiohttp-based HTTP server, particularly when static paths are involved, inspect how routes and resources are registered. In your server startup, iterate over app.router.routes(), and if a route has a resource attribute, apply your CORS configuration to route.resource instead of the route. Keep a set of processed resources to avoid adding CORS multiple times. Write a test that registers a static path and verifies that API requests with an Origin header still receive proper CORS headers.",
            "Step 8: In tests for network-related components like UPnP responders or bridge emulators, patch out actual networking threads/classes (e.g., using unittest.mock.patch) so that test runs remain fast and deterministic. Focus tests on HTTP behavior, configuration, and mapping logic rather than actual multicast traffic.",
            "Step 9: After refactoring a large monolithic component into multiple modules (e.g., emulated_hue into __init__, hue_api, and upnp), update and reorganize tests accordingly. Ensure that behavior remains the same by keeping the existing test cases whenever possible, adjusting only the import paths and any API changes introduced by the refactor.",
            "Step 10: When shipping a patch release that includes non-trivial functional changes, clearly document any new configuration requirements (e.g., emulated_hue: type: google_home, listen_port: 80) and add runtime warnings to guide users who upgrade but forget to adjust their config."
        ]
    }
}
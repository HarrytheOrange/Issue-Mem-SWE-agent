{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant OpenWrt ubus device_tracker where router reboot invalidated ubus session IDs, causing 'Access denied' errors. The solution detects 'Access denied' responses, refreshes the ubus session (re-login) transparently, and retries the request, while raising explicit errors for other ubus error messages.",
        "keywords": [
            "OpenWrt",
            "ubus",
            "device_tracker",
            "session invalidation",
            "router reboot",
            "Access denied",
            "PermissionError",
            "HomeAssistantError",
            "JSON-RPC",
            "automatic re-authentication",
            "session refresh",
            "Home Assistant"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant `ubus` device_tracker integration was failing after an OpenWrt router reboot. When the router restarted, its ubus session store was wiped and all previously issued session IDs became invalid. However, the integration continued to use the stale `session_id` for JSON-RPC calls to `/ubus`. The ubus API responded with an error containing the message 'Access denied', and the integration neither recognized this as a session problem nor attempted to re-login. This caused device tracking and device name lookup to silently break after a router reboot.\n\nThe fix introduced a robust handling layer around ubus calls:\n- The function `_req_json_rpc` was updated to inspect the JSON response even when the HTTP status was 200. If the response contains an `error` object with `message == 'Access denied'`, it now raises a `PermissionError`. For any other ubus error, it raises a `HomeAssistantError` with the error message.\n- A decorator `_refresh_on_acccess_denied` was created to wrap ubus-dependent methods. It executes the wrapped function and, if a `PermissionError` is raised, logs a warning, refreshes `self.session_id` by calling `_get_session_id(self.url, self.username, self.password)`, and then retries the original function once.\n- The `UbusDeviceScanner` class was updated to store `username` and `password` as instance attributes, so they are available for session refresh. The initial `session_id` is now created from `self.username` and `self.password`.\n- The decorator was applied to `get_device_name` and `_update_info`, ensuring that device name resolution and device scan updates automatically recover from invalid sessions caused by router reboots.\n\nAfter these changes, when the router reboots and the old session becomes invalid, the next ubus call will detect the 'Access denied' error, refresh the session by logging in again, and transparently retry the operation, restoring normal device tracker functionality.",
        "semantic_memory": "This fix illustrates a general pattern for handling stateful API sessions that can become invalid outside the client's control, such as after server restarts or timeouts.\n\nKey concepts and best practices:\n1. **Treat transport and application errors separately**: Even if the HTTP status code is 200, the application-level response (JSON body) may encode errors. Always inspect the API's contract for error objects (e.g., `error` field in JSON-RPC) and handle them explicitly.\n\n2. **Detect session invalidation via domain-specific error codes/messages**: When an API uses textual messages or structured codes like 'Access denied' to indicate invalid or expired sessions, map these to a specific, distinguishable exception (e.g., `PermissionError`) rather than treating them as generic failures.\n\n3. **Automatic session refresh with retry**: Encapsulate re-authentication logic in a reusable decorator or wrapper. The wrapper should:\n   - Call the underlying operation.\n   - On a known session-related exception, refresh the session (re-login) using stored credentials or refresh tokens.\n   - Retry the original operation once with the new session.\n   This pattern keeps application code clean and centralizes session management.\n\n4. **Store credentials or refresh tokens at the right scope**: The class managing the session should keep the necessary credentials (username/password or token refresh material) so that it can re-establish the session without external coordination.\n\n5. **Differentiate between recoverable and non-recoverable errors**: Session expiration ('Access denied' due to invalid session) is often recoverable. Other error messages should result in a different exception type (e.g., a domain-specific `HomeAssistantError`) so they can be surfaced and handled differently.\n\n6. **Transparent resilience for user-facing features**: For long-lived integrations (like device trackers) that are expected to survive server restarts, build in automatic recovery mechanisms so users do not need to manually reconfigure or restart the client after backend restarts.\n\nOverall, the pattern is: inspect API-level errors → classify them → for session-related ones, refresh authentication and retry → for others, fail fast with clear error signaling.",
        "procedural_memory": [
            "When working with stateful APIs (sessions, tokens) that might be invalidated by server restarts or timeouts, implement logic to detect and automatically recover from invalid session states.",
            "Step 1: Identify the failure mode.\n- Observe logs or error reports that show API calls failing after a server restart or after some time.\n- Look for error messages like 'Access denied', 'invalid session', 'token expired', or specific error codes in the API response body.\n- Confirm that the failures occur even though the HTTP status is 200, indicating that the problem is at the application layer, not the network/transport layer.",
            "Step 2: Inspect the API's error schema.\n- Review the API documentation to understand how errors are encoded (e.g., JSON-RPC `error` field with `code`/`message`).\n- Update the client code to always parse the response body and check for error structures, even if the HTTP status code is successful.\n- Decide how to map different error types to appropriate exceptions.",
            "Step 3: Introduce explicit exceptions for session-related and generic errors.\n- In the central request function (e.g., `_req_json_rpc`), after parsing the JSON, check if an `error` field exists.\n- If the error indicates a session problem (e.g., `message == 'Access denied'` or a known error code), raise an explicit session-related exception (e.g., `PermissionError`, `SessionExpiredError`).\n- For all other error messages, raise a general domain-specific exception (e.g., `HomeAssistantError`) that can be propagated to the caller for visibility.",
            "Step 4: Centralize automatic session refresh logic.\n- Implement a decorator or wrapper, e.g., `_refresh_on_access_denied`, that takes a function using the session.\n- In the wrapper:\n  - Call the wrapped function.\n  - Catch the session-related exception (e.g., `PermissionError`).\n  - Log a clear warning that the session is invalid and will be refreshed.\n  - Re-authenticate by calling your login/session-init function (e.g., `_get_session_id(url, username, password)`), and update the stored session token/ID.\n  - Retry the original function once with the new session.\n- Return the result of the retried call, or re-raise if it still fails.",
            "Step 5: Ensure the session manager has the credentials to re-authenticate.\n- Modify the class that manages the session (e.g., `UbusDeviceScanner`) to store credentials (`self.username`, `self.password`, or equivalent token refresh data) as instance attributes.\n- Use these stored credentials for initial session creation and for subsequent refreshes.\n- Avoid having to pass credentials around for each call; keep them in one place.",
            "Step 6: Apply the decorator to all session-dependent operations.\n- Identify methods that directly or indirectly make authenticated calls (e.g., `get_device_name`, `_update_info`).\n- Decorate them with your session-refresh wrapper so that any session invalidation is handled uniformly.\n- Ensure that the wrapper plays nicely with other decorators (e.g., throttling); test the order of decorators (`@Throttle`, then `@_refresh_on_access_denied` or vice versa) as needed.",
            "Step 7: Log and monitor behavior.\n- Add warning logs when a session is found invalid and is being refreshed, so you can detect frequent re-authentications that might indicate deeper issues.\n- For non-session errors (raised as general exceptions), log them at an appropriate level and surface them in the UI or metrics.",
            "Step 8: Test the recovery behavior.\n- Manually or programmatically simulate a server reboot or session invalidation:\n  - Start the service, establish a session, verify that normal calls work.\n  - Restart the backend (e.g., router) to invalidate sessions.\n  - Trigger a client operation that uses the session and confirm it:\n    - Fails once with a session-related error.\n    - Refreshes the session automatically.\n    - Retries and succeeds without requiring user intervention.\n- Also test error paths where the server returns other kinds of errors to ensure they are not mistakenly treated as session issues.",
            "Step 9: Make the pattern reusable.\n- Extract the session-refresh decorator and error handling into a shared module if multiple components interact with the same kind of backend.\n- Document the behavior so future developers know that session renewal and retry are automatic and can rely on that abstraction."
        ]
    }
}
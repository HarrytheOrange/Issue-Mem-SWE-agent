{
    "search_index": {
        "description_for_embedding": "Home Assistant Wunderground sensor bug where alert attributes were never reset between API updates, causing stale alert attributes to persist after alerts disappeared. Fix: reinitialize the sensor attributes dict on every update and add tests that bypass the Throttle decorator and mock multiple API responses with changing alerts.",
        "keywords": [
            "homeassistant",
            "wunderground",
            "wunderground sensor",
            "weather alerts",
            "sensor attributes",
            "stale attributes",
            "state attributes not cleared",
            "multiple alerts",
            "dynamic attributes",
            "Throttle decorator",
            "throttled update",
            "mocking throttled methods",
            "unit test",
            "reset attributes per update"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant Wunderground sensor, the web service can return multiple alerts at once. For each alert, the integration added sensor attributes (like 'Message', 'Message_FLO', 'Message_WND') to a shared attributes dictionary. The dictionary was only initialized in the constructor and then incrementally updated, never cleared. When the set of alerts changed (e.g., going from FLO+WND to only FLO), the old attributes for the removed alerts (like 'Message_WND') stayed in the entity attributes, exposing stale data in Home Assistant.\n\nTo fix this, the developer refactored attribute initialization into a helper, `_init_attrs`, that returns a base dict containing the attribution metadata. The constructor now calls `_init_attrs()` to create the initial attributes dict, and `_update_attrs()` resets `self._attributes` to a fresh `_init_attrs()` at the start of every update. That guarantees that attributes always reflect the current API payload and that removed alerts do not leave residual keys.\n\nThe PR also added a test `test_alert_data` to confirm this behavior. It mocks `requests.get` with `mocked_requests_get_alerts`, which returns two alerts (FLO and WND) on the first two calls and only the FLO alert on later calls. Because the Wunderground data fetch is wrapped with a `Throttle` decorator, the test had to patch the `WUndergroundData.update` method to call the underlying implementation with `no_throttle=True`, effectively bypassing throttling in tests. The test sets up a Wunderground sensor with only 'alerts' monitored, calls device.update() twice, and asserts that the state reflects 1 alert, that the general 'Message' attribute is present, and that suffixed attributes 'Message_FLO' and 'Message_WND' are now absent. This confirms the attributes dict is reinitialized on each update and no stale alert-specific attributes remain.",
        "semantic_memory": "When building entity or sensor attributes from external API data, it is easy to accumulate stale state if you only augment a long-lived attributes dictionary without clearing it. If the remote payload can remove items (e.g., alerts that expire, sensors that go offline, list entries that shrink), then previously-added keys will persist unless the attributes structure is rebuilt from scratch at each update.\n\nA robust pattern is to treat each update as a fresh snapshot: compute attributes in a new dictionary, starting from a minimal base (such as fixed metadata like attribution), then populate it solely from the current API response. After constructing the new dict, replace the old attributes entirely. This ensures the entity's state matches the current reality and does not leak historical values.\n\nAnother key pattern is handling decorators like throttling or caching in tests. When an update method is wrapped with a Throttle decorator, unit tests that rely on multiple logical 'calls' with different mocked API responses might not actually trigger the underlying logic because the decorator suppresses calls within the throttle window. A common solution is to patch the decorated method to call the original implementation with parameters that bypass throttling (if supported, e.g., `no_throttle=True`) or to patch the decorator itself in the test environment. This allows tests to exercise multi-step state transitions reliably, without being blocked by time-based behavior.\n\nMore generally, always ensure that tests for dynamic, time-varying behavior (like alert lists) simulate realistic sequences of API responses and verify that previously-present elements are correctly removed, not just that new ones are added. This catches lifecycle bugs where disappearing items are mishandled.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving stale attributes and throttled updates:",
            "Step 1: Identify symptoms of stale state",
            "- Observe whether an entity or sensor retains attributes or values that should have disappeared when upstream data changed (e.g., alerts that expired, list entries that are no longer returned).",
            "- Compare the current API response with the entity's attributes; if attributes exist that are not present in the API payload, suspect that the update path is only appending or merging, not resetting.",
            "Step 2: Inspect the update logic and attribute handling",
            "- Locate the entity or data object responsible for updating state (e.g., a SensorEntity class or data coordinator).",
            "- Check how its attributes dictionary (or equivalent structure) is managed: is it created once in __init__ and then mutated, or is it recreated each update?",
            "- Look for patterns like `self._attributes[key] = value` without ever clearing or replacing `self._attributes`.",
            "Step 3: Introduce a clean initialization helper",
            "- Extract any constant or base attributes (e.g., attribution, fixed metadata) into a dedicated initializer function, such as `_init_attrs()` that returns a new dict.",
            "- In the constructor, set `self._attributes = self._init_attrs()` to ensure a clean starting point.",
            "- In the update method (or any method that rebuilds attributes), reset the attributes dict at the start:\n  - `self._attributes = self._init_attrs()`\n  - Then populate attributes exclusively from the current API response.",
            "- Avoid assigning the initializer function itself (e.g., `self._attributes = self._init_attrs`); always call it to get a new dict.",
            "Step 4: Design tests that reproduce the stale-attribute bug",
            "- Mock the external API call (e.g., `requests.get`) to return a sequence of responses:\n  - First response: contains multiple items (e.g., two alerts, FLO and WND).\n  - Second or later response: contains a subset (e.g., only FLO).\n  - Use a counter in the mock to control which response is returned on each call.",
            "- In the test, set up the platform or entity with a configuration that triggers the attribute in question (e.g., monitored condition 'alerts').",
            "- Call the entity or data object's update method twice to simulate two API polls.",
            "- Assert that:\n  - The state reflects the current number of items (e.g., 1 alert).\n  - Attributes corresponding to removed items are now absent (e.g., no 'Message_WND' key).",
            "Step 5: Deal with throttling or decorators in tests",
            "- If the update method is decorated with a Throttle or similar time-based decorator, repeated calls in quick succession may not hit the underlying implementation.",
            "- Solutions:\n  - If the decorated method supports a bypass parameter (e.g., `no_throttle=True`), use it in tests by patching or wrapping the method:\n    - Patch the decorated method via unittest.mock.patch, with `side_effect=functools.partial(OriginalClass.update, no_throttle=True)`.\n    - Ensure you use the fully qualified path for patching (e.g., `homeassistant.components.sensor.wunderground.WUndergroundData.update`).\n  - Alternatively, patch or disable the Throttle decorator in the test module so that calls are always executed.",
            "- After patching, invoke update multiple times within the test to exercise the state transition logic.",
            "Step 6: Validate code style and correctness",
            "- Ensure helper methods that don't depend on instance state can be made `@staticmethod` or `@classmethod` if appropriate, but be careful to call them correctly (with parentheses) when you want their return value.",
            "- Run the full test suite (e.g., `tox`) to catch regressions or style violations.",
            "Step 7: Generalize the pattern for future work",
            "- For any component that mirrors external lists or collections (alerts, devices, notifications, etc.), adopt the practice of rebuilding state structures from scratch on each update.",
            "- Document in the code that updates use a snapshot model and why: to avoid stale attributes when items disappear from the upstream source.",
            "- In new tests, always include scenarios where items are removed from the upstream data, not just added or changed."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Added UK Met Office (DataPoint API) integration to Home Assistant as both sensor and weather platforms. Implementation includes shared data-fetching logic, proper throttling via SCAN_INTERVAL as timedelta, configuration via standard CONF_API_KEY and optional latitude/longitude overrides, mapping Met Office weather codes to Home Assistant CONDITION_CLASSES, correct units for wind, and dependency wiring (datapoint==0.4.3, requirements_all, coverage).",
        "keywords": [
            "Met Office",
            "DataPoint API",
            "homeassistant.components.sensor.metoffice",
            "homeassistant.components.weather.metoffice",
            "weather integration",
            "sensor integration",
            "SCAN_INTERVAL timedelta",
            "CONF_API_KEY",
            "CONF_LATITUDE",
            "CONF_LONGITUDE",
            "CONDITION_CLASSES mapping",
            "datapoint==0.4.3",
            "third-party API integration",
            "Home Assistant platform schema"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request added support for the UK Met Office (DataPoint) weather service to Home Assistant via two new platforms: `sensor.metoffice` and `weather.metoffice`. The author introduced a shared data-fetching class `MetOfficeCurrentData` that wraps the `datapoint` Python library and provides a forecast snapshot (`forecast.now()`) for the nearest Met Office site. Both the sensor and weather platforms reuse this shared data layer. The initial implementation included some rough edges that were iteratively corrected through review:\n\n1. **Core feature implementation**:\n   - Created `homeassistant/components/sensor/metoffice.py` with `MetOfficeCurrentSensor` entities for multiple `monitored_conditions` (station name, weather, temperature, feels_like_temperature, wind_speed, wind_direction, wind_gust, visibility, UV, precipitation probability, humidity).\n   - Created `homeassistant/components/weather/metoffice.py` with a `MetOfficeWeather` entity implementing the `WeatherEntity` interface (condition, temperature, humidity, wind speed/bearing, etc.).\n   - Both platforms use `datapoint.connection(api_key=...)` and `get_nearest_site(latitude, longitude)` to pick the appropriate station based on the Home Assistant configuration or overriding lat/long.\n\n2. **Configuration and API key handling**:\n   - Initially a custom `CONF_MO_API_KEY = 'api_key'` constant was used. This was refactored to use the standardized `CONF_API_KEY` from `homeassistant.const` for both sensor and weather schemas.\n   - The sensor and weather platforms were updated to allow optional `latitude` and `longitude` settings in the platform config (via `CONF_LATITUDE` and `CONF_LONGITUDE`). If not provided, they fall back to `hass.config.latitude` and `hass.config.longitude`. This solved the limitation that only the global Home Assistant coordinates could be used.\n   - Both platforms now validate presence of coordinates and log a helpful error if missing.\n\n3. **Polling and throttling**:\n   - The initial `SCAN_INTERVAL` was an integer (`35`), which is not the expected type for Home Assistant's `Throttle` decorator. This was corrected to `SCAN_INTERVAL = timedelta(minutes=35)`, ensuring that the `MetOfficeCurrentData.update` method is throttled correctly.\n\n4. **Weather condition normalization**:\n   - Initially, the weather condition was exposed as `variable.text` from the `datapoint` object. To comply with Home Assistant's weather condition conventions, the PR added a `CONDITION_CLASSES` mapping from Met Office numeric weather codes (`value`) to Home Assistant standard condition strings (e.g., `sunny`, `cloudy`, `rainy`, `snowy-rainy`, etc.).\n   - The sensor's `weather` state and the weather entity's `condition` now compute the condition by looking up the code in `CONDITION_CLASSES` and returning the first matching key. This yields consistent condition values across integrations.\n\n5. **Units and attributes**:\n   - The wind speed unit was corrected from `mps` to `m/s` for both `wind_speed` and `wind_gust` sensor types.\n   - Sensor entities expose relevant attributes: sensor id, site id, site name, last update timestamp (handled via the data object), and a fixed attribution string (\"Data provided by the Met Office\"). The weather entity also exposes this attribution via its `attribution` property.\n\n6. **Dependency and infrastructure wiring**:\n   - The `datapoint` dependency (`datapoint==0.4.3`) was declared in both components via `REQUIREMENTS` and added to `requirements_all.txt` with comments referencing both new components.\n   - The new files were excluded from coverage in `.coveragerc` in line with other third-party-integrated components.\n   - An unused import (`datetime`) was removed after review, and minor style issues were fixed (import formatting, documentation URL pointing to `weather.metoffice` instead of `sensor.metoffice`).\n\nDuring community usage, some users reported it \"not working\" on the forum. The author engaged and requested a link to investigate, but no additional bug-specific code changes are shown in this PR. The final merged result is a functioning, reusable Met Office integration with proper throttling, configuration, condition mapping, and dependency management.",
        "semantic_memory": "This PR illustrates several generalizable best practices for integrating an external weather API into a home automation platform, particularly Home Assistant:\n\n1. **Shared data layer across multiple entities/platforms**:\n   - When multiple entities (e.g., sensors and a weather entity) rely on the same API call, centralize the data-fetching logic in a shared class or module (here, `MetOfficeCurrentData`). This avoids duplicate API calls and ensures consistent state across entities.\n   - Use platform features like `Throttle` (with a `timedelta` interval) to handle polling frequency centrally rather than per-entity.\n\n2. **Using platform-wide configuration conventions**:\n   - Prefer standard configuration constants (`CONF_API_KEY`, `CONF_LATITUDE`, `CONF_LONGITUDE`, `CONF_NAME`) over custom ones to keep integrations consistent and documentation simpler.\n   - Allow per-platform overrides of global configuration values (e.g., specific latitude/longitude for a custom location) while defaulting to global config when overrides are absent.\n\n3. **Normalization of external API data**:\n   - Third-party APIs often expose domain-specific codes or verbose text. Map them into the platform's canonical representation (e.g., mapping Met Office numeric weather codes to Home Assistant's standardized `CONDITION_CLASSES`). This provides a uniform interface across integrations, enabling UI and automation reuse.\n   - Separate external data representation (`.value`, `.text`) from internal representation via explicit mapping logic.\n\n4. **Clear error handling around external services**:\n   - Wrap network/API calls in `try/except` blocks that catch the library's exceptions (e.g., `dp.exceptions.APIException`) and log meaningful messages. Fail early in `setup_platform` if you cannot obtain a site or initial data; it is better than exposing half-initialized entities.\n   - Provide specific log messages for common configuration problems (like missing coordinates) to make it obvious to users why a platform fails.\n\n5. **Consistent units and metadata**:\n   - Carefully choose units that align with platform expectations (`m/s` for wind speed) and maintain consistency across all sensors.\n   - Expose useful metadata on entities (site id, site name, last updated, attribution) so users and other parts of the system can understand data provenance and context.\n\n6. **Dependency management and code organization**:\n   - Declare external dependencies via the platform's `REQUIREMENTS` mechanism and also add them to global requirements lists when required by the project. Import those dependencies only inside functions or methods that use them to avoid import-time failures.\n   - Exclude integration modules from coverage if they primarily exercise external systems that are hard to test deterministically.\n\nThese patterns can be applied to any integration with third-party weather or sensor APIs: create a shared, throttled data provider, normalize external data formats into platform-wide standards, follow configuration conventions, and handle errors and units consistently.",
        "procedural_memory": [
            "When integrating a new external weather or sensor API into a platform like Home Assistant, follow these steps to design and debug the integration effectively:",
            "Step 1: Identify shared data and design a data provider class",
            "  - Determine what data will be shared across multiple entities or platforms (e.g., current conditions for sensors and a weather entity).",
            "  - Implement a data provider class (e.g., `MetOfficeCurrentData`) that encapsulates API connection setup, site selection, and data retrieval.",
            "  - Store the latest API snapshot (`self.data`) in this class so that entities can read from it without performing redundant API calls.",
            "Step 2: Wire up the external dependency correctly",
            "  - Add the library version to the component's `REQUIREMENTS` and to the project-wide `requirements_all.txt` if required.",
            "  - Import the external library inside `setup_platform` or other functions rather than at module import time, so that missing dependencies fail gracefully.",
            "  - Pin to a specific library version when compatibility matters (e.g., `datapoint==0.4.3`).",
            "Step 3: Implement setup_platform with validation and error handling",
            "  - In `setup_platform`, parse configuration using platform schemas and constants (`CONF_API_KEY`, `CONF_LATITUDE`, `CONF_LONGITUDE`, etc.).",
            "  - Allow configuration-level latitude/longitude overrides, falling back to `hass.config` values when not provided.",
            "  - Validate that you have both latitude and longitude; if not, log a clear error and return `False` to abort setup.",
            "  - Call the API (e.g., `get_nearest_site`) inside a `try/except` block catching the library-specific exceptions, log errors, and return `False` on failure.",
            "  - Initialize the shared data provider, call an initial `update()`, catch errors, and only create entities if the initial data load succeeds.",
            "Step 4: Throttle API calls appropriately",
            "  - Determine an appropriate polling interval for your data source (e.g., based on API rate limits or update frequency).",
            "  - Define `SCAN_INTERVAL` as a `datetime.timedelta` (not a bare integer) to be compatible with `homeassistant.util.Throttle`.",
            "  - Decorate the data provider's `update` method with `@Throttle(SCAN_INTERVAL)` to ensure all entities share the same rate-limited API calls.",
            "Step 5: Normalize external data to platform standards",
            "  - Study the external API's representation for conditions or other enumerated fields (e.g., numeric weather codes).",
            "  - Create a mapping dictionary (such as `CONDITION_CLASSES`) from API-specific codes to platform-standard condition strings.",
            "  - In entity properties (e.g., `condition` for `WeatherEntity`, `state` for `weather` sensor), use the mapping to convert API values into the platform's standard values.",
            "  - Keep this mapping close to the integration so it is easy to update when the external API changes.",
            "Step 6: Design entity classes to expose clean states and attributes",
            "  - For each sensor/attribute you expose, define clear `SENSOR_TYPES` with human-readable names and proper units.",
            "  - Implement `state` to return the normalized value (e.g., `variable.value` or mapped condition), and return a default (`STATE_UNKNOWN`) when data is not available.",
            "  - Implement `unit_of_measurement` and metadata attributes such as site id, site name, last update time, and attribution, so debugging and UI presentation are straightforward.",
            "  - For weather entities, implement `temperature`, `temperature_unit`, `humidity`, `wind_speed`, `wind_bearing`, `attribution`, etc., following the platform's interface.",
            "Step 7: Ensure consistent units and documentation",
            "  - Verify units against platform conventions (e.g., `m/s` instead of `mps`) for all speed and distance values.",
            "  - Update platform documentation URLs in module docstrings to reflect the correct component path (e.g., `weather.metoffice` instead of `sensor.metoffice`).",
            "  - Add or update user documentation to include example configuration and supported monitored conditions.",
            "Step 8: Add test/coverage configuration and handle community feedback",
            "  - Add new component files to coverage exclusion lists if they rely heavily on external services and are hard to unit-test reliably.",
            "  - Run the project's test suite (`tox` for Home Assistant) to ensure that the new integration does not break existing code.",
            "  - When users report issues (e.g., via community forums), gather their configurations and logs, then validate: API key validity, coordinate correctness, initial data fetch success, and any exceptions logged in `setup_platform`.",
            "  - Iterate on the integration to fix misconfigurations or oversight (such as missing imports, wrong unit strings, or incorrect mapping logic)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant iaqualink integration: add a binary_sensor platform for freeze protection and introduce stable unique_id support for all iaqualink entities via a shared AqualinkEntity base class, including proper config_entry setup/unload and domain forwarding.",
        "keywords": [
            "homeassistant",
            "iaqualink",
            "binary_sensor",
            "freeze_protection",
            "DEVICE_CLASS_COLD",
            "unique_id",
            "AqualinkEntity",
            "config_entries.async_forward_entry_setup",
            "multi-pool support",
            "entity_id stability"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant iaqualink integration, the freeze protection functionality was not exposed correctly as an entity. Specifically, the freeze protection status behaved like a binary state but was only available as a generic sensor, so it wasn’t identified or treated as a binary sensor (e.g., no cold device class, less intuitive UI). At the same time, the integration didn’t use unique_id for its entities, which blocked robust future support for multiple pools and could lead to entity_id instability if unique IDs were added later.\n\nThe fix introduced a new iaqualink binary_sensor platform and wired it into the config entry–based integration:\n- Added `AqualinkBinarySensor` handling to `__init__.py`, collecting discovered binary sensor devices into `hass.data[DOMAIN][BINARY_SENSOR_DOMAIN]` alongside climates, lights, sensors, and switches.\n- Implemented `homeassistant/components/iaqualink/binary_sensor.py` with `HassAqualinkBinarySensor`, subclassing the shared `AqualinkEntity` and `BinarySensorDevice`, exposing `name`, `is_on`, and `device_class`. Freeze protection is identified by name (\"Freeze Protection\") and mapped to `DEVICE_CLASS_COLD` so Home Assistant treats it as a cold-related binary sensor.\n- Hooked up config entry forwarding for the new platform in `async_setup_entry` and `async_unload_entry` using `async_forward_entry_setup`/`async_forward_entry_unload` and the binary sensor domain.\n\nTo support stable unique IDs across all iaqualink entities, the PR refactored the integration to use a shared entity base class:\n- Replaced the prior mixin approach with a concrete `AqualinkEntity(Entity)` base class in `__init__.py` that takes an `AqualinkDevice` in its constructor and stores it as `self.dev`.\n- Centralized behavior common to all iaqualink entities: dispatcher-based updates (`async_dispatcher_connect` listening on the integration’s signal), `async_update` that delegates to `self.dev.update()`, `should_poll` returning `False`, and a `unique_id` property.\n- The `unique_id` is derived from the underlying iaqualink device: `f\"{self.dev.system.serial}_{self.dev.name}\"`. This makes the ID stable and unique per physical device, and avoids unnecessary prefixes that might affect entity_id behavior.\n- Updated all platform entities (climate, light, sensor, switch, and the new binary_sensor) to subclass `AqualinkEntity` instead of each managing `self.dev` separately or using a separate mixin. Constructors were simplified or removed where redundant, since `AqualinkEntity` now handles `self.dev`.\n\nThe author initially experimented with a mixin (`AqualinkEntityMixin`) and a slightly different unique_id format (`\"iaqualink_{serial}_{name}\"`), but reverted to a concrete base class and simplified unique_id after review. During testing, there was concern that adding unique_id might change existing entity_ids, but after resetting the integration and re-testing with the final `unique_id` implementation, entity_ids remained stable.\n\nCoverage and style were adjusted as well: the new binary_sensor file was added to `.coveragerc` omits, and minor style cleanups (import ordering, base class ordering, f-strings) were applied.",
        "semantic_memory": "This change illustrates several general patterns for Home Assistant and similar integrations:\n\n1. **Expose the right platform type for the semantics of the data**:\n   - A freeze protection flag is fundamentally binary (on/off) rather than numeric or generic; modeling it as a `binary_sensor` with `device_class_cold` improves user understanding, UI representation, and automation capabilities.\n   - Selecting the appropriate platform/domain (binary_sensor, sensor, switch, light, climate, etc.) is crucial to make devices behave naturally in the ecosystem.\n\n2. **Use a shared base entity class to centralize integration-specific behavior**:\n   - Many entities in an integration share logic: how they update, how they subscribe to dispatcher signals, how they construct their `unique_id`, and how they reference the underlying device object.\n   - Implementing a concrete base like `AqualinkEntity(Entity)` that stores the device, handles dispatcher registration, implements `async_update`, and exposes `unique_id` ensures consistency across platforms and reduces boilerplate.\n   - This approach is often preferable to mixins when the behavior is core to all entities of the integration.\n\n3. **Introduce `unique_id` early and derive it from stable device properties**:\n   - `unique_id` should be based on stable identifiers (e.g., hardware serial, logical device ID, consistent name) to support reliable entity registry entries and future multi-device/multi-pool scenarios.\n   - When introducing `unique_id` to existing entities, care must be taken not to inadvertently break or rename existing entities. A mismatch or change in `unique_id` format can cause entity_id churn or duplication.\n   - Keeping the `unique_id` simple and deterministic (e.g., `\"{serial}_{name}\"`) avoids complexities that might arise from integration-specific prefixes or changes over time.\n\n4. **Config entry–driven platform forwarding**:\n   - For integrations using `ConfigEntry`, each platform (sensor, switch, climate, binary_sensor, etc.) should be wired via `async_forward_entry_setup` and `async_forward_entry_unload`. This ensures that adding a new platform only requires hooking it into the shared device registry (`hass.data[DOMAIN][PLATFORM_DOMAIN]`) and forwarding setup/unload.\n   - Proper cleanup on unload (checking `hass.data[DOMAIN][DOMAIN_NAME]` and forwarding unload only when needed) avoids dangling entities and resource leaks.\n\n5. **Rely on dispatcher-based updates instead of polling where possible**:\n   - If the integration already maintains its own update loop and dispatches update signals, entities should opt out of polling (`should_poll = False`) and update when signaled. This reduces load and ensures a single refresh path per integration.\n\nThese patterns apply broadly to any integration that:\n- Groups multiple related physical/logical devices under one config entry.\n- Needs to add new platforms over time without breaking existing users.\n- Wants to maintain stable, registry-backed entities via `unique_id`.\n\nProper abstraction (base entity), clear semantics (correct platform and device_class), and careful unique_id design are key to evolving an integration safely.",
        "procedural_memory": [
            "When you need to expose a new binary-style condition (like freeze protection) and introduce stable unique IDs in a Home Assistant integration, follow steps like these:",
            "Step 1: Identify the correct platform and device_class",
            "  - Examine the raw device data: is it truly binary (on/off)? numeric? stateful? Choose the platform accordingly (binary_sensor vs sensor vs switch).",
            "  - Map the concept to an appropriate `device_class` (e.g., `DEVICE_CLASS_COLD` for freeze protection) so the UI and automations behave intuitively.",
            "Step 2: Create or extend a shared base entity for the integration",
            "  - Implement an integration-specific base class (e.g., `AqualinkEntity(Entity)`) that:\n    - Accepts the underlying device object in `__init__` and stores it as `self.dev`.\n    - Implements `async_added_to_hass` to subscribe to dispatcher signals for this integration (`async_dispatcher_connect`).\n    - Implements `async_update` delegating to the device’s own update method.\n    - Returns `False` from `should_poll` if updates are driven by a central timer/dispatcher.\n    - Exposes a `unique_id` property that returns a stable ID based on device attributes (e.g., `f\"{self.dev.system.serial}_{self.dev.name}\"`).",
            "Step 3: Implement the new platform module",
            "  - Create a new file under the integration’s directory (e.g., `binary_sensor.py`).",
            "  - Implement `async_setup_entry(hass, entry, async_add_entities)` to:\n    - Read the list of devices for that platform from `hass.data[INTEGRATION_DOMAIN][PLATFORM_DOMAIN]`.\n    - Wrap each device in your platform entity class (e.g., `HassAqualinkBinarySensor`).\n    - Call `async_add_entities(devs, True)` to register them with Home Assistant.",
            "  - Define the entity class as subclassing the integration base + the platform type (e.g., `class HassAqualinkBinarySensor(AqualinkEntity, BinarySensorDevice)`), relying on the base for `self.dev` and unique_id.",
            "  - Implement platform-specific properties: `name`, `is_on`, and `device_class` (using name or a device attribute to decide e.g. freeze protection => `DEVICE_CLASS_COLD`).",
            "Step 4: Wire the platform into config entry setup/unload",
            "  - In the integration’s `__init__.py` inside `async_setup_entry`:\n    - Initialize an empty list for the new platform in `hass.data[DOMAIN][BINARY_SENSOR_DOMAIN] = []`.\n    - When discovering devices, check their type (e.g., `isinstance(dev, AqualinkBinarySensor)`) and append them to the correct list.\n    - After building lists, call `hass.config_entries.async_forward_entry_setup(entry, BINARY_SENSOR_DOMAIN)` (usually via `hass.async_create_task`) only if you have any binary sensors.\n  - In `async_unload_entry`, if `hass.data[DOMAIN][BINARY_SENSOR_DOMAIN]` is non-empty, append a task to `tasks` using `async_forward_entry_unload(entry, BINARY_SENSOR_DOMAIN)`.",
            "Step 5: Introduce unique_id carefully to existing entities",
            "  - Use the new base class’s `unique_id` for all platforms (climate, light, sensor, switch, binary_sensor) to ensure consistency.",
            "  - Base the unique ID on stable backend identifiers (e.g., device serial and logical name) and keep the format simple. Avoid changing the format later, as that can create new entities instead of updating old ones.",
            "  - If the integration already has deployed entities, test upgrading:\n    - Remove and re-add the integration in a test environment.\n    - Verify that entity_ids do not change unexpectedly after adding unique_id.\n    - If you see entity_id changes, adjust the unique_id scheme to better match existing naming/registry behavior.",
            "Step 6: Update coverage and style",
            "  - Add the new platform file to `.coveragerc` if it’s not yet fully tested and your project maintains an omit list.",
            "  - Ensure imports are ordered per project style, class inheritance order is consistent, and string formatting uses the preferred style (e.g., f-strings).",
            "Step 7: Test end-to-end",
            "  - Run local tests (e.g., `tox`) and exercise the integration against a real or mocked backend:\n    - Confirm the new binary sensor appears with the correct name and device_class.\n    - Confirm state transitions (e.g., freeze protection on/off) are reflected promptly.\n    - Verify that all entities expose `unique_id` and that entity_ids remain stable between restarts.",
            "These steps can be reused whenever you add a new platform to an existing Home Assistant integration or retrofit it with `unique_id` support while preserving entity stability."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant sensor platform added to read temperature from Eddystone BLE beacons. Initial implementation manually parsed HCI advertisements via pybluez, then was refactored to use an external PyPI library (beacontools) for scanning and decoding Eddystone UID/TLM frames. The Monitor uses BeaconScanner with Eddystone filters, starts/stops on Home Assistant lifecycle events, and pushes state updates (no polling). Configuration specifies Bluetooth device ID and a mapping of beacon namespace/instance IDs to sensor entities.",
        "keywords": [
            "Home Assistant",
            "sensor platform",
            "Eddystone",
            "Eddystone TLM",
            "Eddystone UID",
            "BLE",
            "Bluetooth LE",
            "temperature sensor",
            "beacontools",
            "BeaconScanner",
            "pybluez",
            "telemetry",
            "TLM frame",
            "UID namespace instance",
            "EVENT_HOMEASSISTANT_START",
            "EVENT_HOMEASSISTANT_STOP",
            "should_poll False",
            "schedule_update_ha_state",
            "requirements_all",
            "external dependency",
            "packet parsing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request implements a new Home Assistant sensor platform to read temperature data from Eddystone beacons broadcasting TLM frames and identify them via UID frames. The initial version directly used pybluez and low-level HCI access. It opened the Bluetooth device, enabled scanning, parsed raw advertisement packets, manually detected Eddystone service data, parsed UID and TLM frames, and matched namespace/instance IDs to configured beacons. Reviewers requested that the Eddystone parsing and scanning be moved into a dedicated PyPI package instead of embedding raw protocol handling in Home Assistant. In response, the author created the 'beacontools' library, which provides high-level Eddystone parsing and a BeaconScanner.\n\nThe PR was then refactored to rely on beacontools[scan]==1.0.1. The Monitor no longer subclasses Thread or handles HCI details. Instead, it instantiates a BeaconScanner with a callback, a list of EddystoneFilter instances (one per configured beacon, identified by namespace and instance strings), and EddystoneTLMFrame as the frame type. The callback receives the beacon address, the parsed TLM frame, and additional_info containing namespace and instance. Monitor.process_packet uses this to find the corresponding EddystoneTemp entity and update its temperature. When the temperature changes, it calls schedule_update_ha_state() to push the new state into Home Assistant.\n\nThe configuration schema validates beacons as a mapping of entity IDs to objects containing namespace, instance, and optional name, plus an optional bt_device_id (hciX) parameter. Utility function get_from_conf ensures namespace and instance have the correct length (20 and 12 characters respectively). The entity's should_poll property is set to False because updates are push-based.\n\nLifecycle integration was added: the Monitor starts scanning on Home Assistant startup and stops on shutdown, using EVENT_HOMEASSISTANT_START and EVENT_HOMEASSISTANT_STOP listeners. Internal flags prevent double start/stop calls. The PR also includes housekeeping: adding REQUIREMENTS for beacontools[scan], excluding beacontools from gen_requirements_all auto-generation, updating requirements_all.txt comments, and excluding the platform file from coverage in .coveragerc. Constants that were briefly added to homeassistant.const (CONF_BEACONS, CONF_BT_DEVICE_ID, CONF_INSTANCE, CONF_NAMESPACE) were later moved back into the component as local constants, simplifying the global const module.",
        "semantic_memory": "Key generalizable lessons from this change:\n\n1. **Use dedicated libraries for protocol parsing and device access**: When integrating with complex protocols (like BLE beacons and Eddystone), avoid embedding low-level parsing logic directly in the main application. Instead, create or reuse a focused PyPI library (here, 'beacontools') that encapsulates protocol details. This simplifies the component code, improves reusability, and allows independent evolution of the protocol implementation.\n\n2. **Follow Home Assistant patterns for external dependencies**: External libraries should be declared in REQUIREMENTS at the component level and imported lazily inside functions (or class initializers) that use them. requirements_all.txt and gen_requirements_all exclusion lists must be kept in sync, and libraries used only on certain platforms (like Bluetooth/BlueZ) are often commented out or excluded from global requirements.\n\n3. **Prefer event-driven, callback-based designs over manual threads for IO-bound tasks**: Instead of manually handling sockets and threads for BLE scanning, leverage a higher-level abstraction (BeaconScanner) with callbacks. This concentrates concurrency concerns in the library, reduces boilerplate, and makes start/stop semantics clearer.\n\n4. **Use filters as early as possible to reduce workload**: The beacon scanner is configured with per-device EddystoneFilter instances, so only matching frames trigger callbacks. This reduces CPU load and avoids unnecessary parsing, which is important on constrained devices like Raspberry Pis.\n\n5. **Integrate with the host application's lifecycle**: Long-running background tasks (scanners, monitors) should start and stop in sync with the host application's lifecycle. In Home Assistant, this means listening to EVENT_HOMEASSISTANT_START and EVENT_HOMEASSISTANT_STOP instead of starting threads at import time or leaving scanners running after shutdown.\n\n6. **Push-based entities should disable polling and trigger updates on state change**: When a sensor gets its state via asynchronous callbacks (e.g., BLE advertisements), set should_poll = False and call schedule_update_ha_state() when the internal state changes. This avoids unnecessary polling load and ensures timely state propagation.\n\n7. **Keep generic constants local to the component unless widely reused**: Component-specific configuration keys (e.g., 'namespace', 'instance', 'beacons', 'bt_device_id') need not be promoted to a global constants module unless they are shared across multiple components. Keeping them local reduces global namespace clutter.\n\n8. **Validate configuration early and clearly**: Config schemas (voluptuous) and helper functions should enforce constraints like string length (e.g., hexadecimal namespace/instance fields). Failing fast with clear log messages helps users fix configuration errors and prevents silent misbehavior.\n\n9. **Consider multi-scanner concurrency and hardware limitations**: BLE scanning can be CPU-intensive and chipset-specific. Using non-blocking scanners that do not establish BLE connections (only read advertisements) can mitigate conflicts with other Bluetooth activities, but designers should still be aware of potential hardware limitations and integrate scanners carefully.",
        "procedural_memory": [
            "How to add a BLE-based sensor platform using Eddystone beacons and an external library:",
            "Step 1: Define configuration schema with voluptuous.\n- Decide on the config keys (e.g., 'bt_device_id', 'beacons', 'namespace', 'instance', 'name').\n- Use a BEACON_SCHEMA for each beacon entry, requiring namespace and instance strings of fixed length and an optional friendly name.\n- Extend PLATFORM_SCHEMA to include 'bt_device_id' (optional, with default) and a mapping of beacon IDs to BEACON_SCHEMA definitions.",
            "Step 2: Validate configuration values and normalize them.\n- Implement a helper like get_from_conf(config, key, length) that fetches the string, checks that its length matches the expected number of characters (e.g., 20 for namespace, 12 for instance), logs a clear error, and returns None on failure.\n- In setup_platform, skip any beacon entry that fails validation and log which one was skipped.",
            "Step 3: Implement the entity class with push-based semantics.\n- Subclass Entity (or the appropriate base) and store identifying attributes (namespace, instance) plus state (temperature).\n- Implement properties name, state, unit_of_measurement.\n- Define should_poll = False to indicate that Home Assistant should not poll this entity.\n- Ensure that when the state changes (e.g., temperature updated from a callback), you call schedule_update_ha_state() so the change is propagated to the frontend.",
            "Step 4: Introduce a Monitor or controller object for scanning.\n- Create a Monitor class that owns the external scanner (e.g., BeaconScanner from beacontools) and a list of devices (entities).\n- In Monitor.__init__, construct filters (e.g., EddystoneFilter(namespace, instance) for each entity) so the scanner only produces callbacks for relevant beacons.\n- Define a callback(bt_addr, device, packet, additional_info) that extracts variables like namespace, instance, and temperature from the parsed packet and passes them to a helper method (process_packet).",
            "Step 5: Map callback data to entities and update state.\n- In Monitor.process_packet(namespace, instance, temperature), log a debug message and iterate over self.devices to find a device whose namespace and instance match.\n- If found and the temperature changed, update dev.temperature and call dev.schedule_update_ha_state(). This ensures Home Assistant knows about the change without polling.",
            "Step 6: Manage scanner lifecycle via application events.\n- In setup_platform, create the Monitor instance after you’ve created the list of EddystoneTemp entities.\n- Register a monitor_start listener for EVENT_HOMEASSISTANT_START to call mon.start() and a monitor_stop listener for EVENT_HOMEASSISTANT_STOP to call mon.stop().\n- Inside Monitor.start/stop, track a boolean flag (e.g., self.scanning) to avoid double starts or stops, and log warnings if start/stop is called in the wrong state.",
            "Step 7: Hook up external dependencies correctly.\n- Add the external library to the component’s REQUIREMENTS constant (e.g., REQUIREMENTS = ['beacontools[scan]==1.0.1']).\n- Only import the library inside functions or methods that use it (e.g., in Monitor.__init__), with pylint import-error suppression if needed.\n- Update requirements_all.txt with a commented reference to the library and add the library name to gen_requirements_all.py’s EXCLUDE list if it should not be part of the global requirements (common for platform-specific deps like Bluetooth).",
            "Step 8: Avoid low-level protocol handling in the main application.\n- If you initially wrote manual packet parsing (e.g., reading raw HCI packets via pybluez and struct.unpack), factor that logic into a dedicated library instead. This reduces complexity in the Home Assistant component, encourages reuse, and makes testing easier.\n- Replace low-level parsing in the component with calls to the library’s high-level abstractions (e.g., BeaconScanner, EddystoneTLMFrame).",
            "Step 9: Integrate code with existing tooling and standards.\n- Add the new component file to .coveragerc’s omit list if it’s impractical to test in CI (e.g., due to hardware dependencies like BLE).\n- Follow project coding standards and linting (pylint) requirements, including limiting line lengths and adding or removing constants in global modules as appropriate.\n- Ensure all tests and scripts (e.g., tox, gen_requirements_all.py) run cleanly after adding or changing dependencies.",
            "Step 10: When diagnosing similar integration issues:\n- Check whether the current implementation is duplicating protocol logic that belongs in a library; if yes, consider moving it out.\n- Verify that scanners or background tasks respect the host application’s lifecycle and don’t start or run outside of it.\n- Ensure entities receiving push-based updates are not polled and that they trigger state updates correctly.\n- For BLE and other hardware-based components, confirm that filters are in place to limit processing load and that conflicting simultaneous access to hardware is avoided or minimized."
        ]
    }
}
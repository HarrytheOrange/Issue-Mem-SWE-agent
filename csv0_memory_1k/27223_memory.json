{
    "search_index": {
        "description_for_embedding": "Adds a shorthand in Home Assistant scripts to activate scenes using `- scene: scene.<scene_name>` instead of an explicit `scene.turn_on` service call. Implements new script action type, schema validation for scene entity IDs, and tests to ensure the correct service call with preserved context.",
        "keywords": [
            "Home Assistant",
            "script shortcut",
            "scene activation",
            "SCRIPT_SCHEMA",
            "entity_domain",
            "scene.turn_on",
            "config_validation",
            "helpers.script",
            "YAML script syntax"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the goal was to make Home Assistant scripts easier to write when activating scenes. Previously users had to write:\n\n  - service: scene.turn_on\n    data:\n      entity_id: scene.<scene_name>\n\nThe PR introduces a shorthand syntax:\n\n  - scene: scene.<scene_name>\n\nThe implementation required three main changes:\n1) **Configuration validation**: In `homeassistant/helpers/config_validation.py`, a new `_SCRIPT_SCENE_SCHEMA` was added and integrated into `SCRIPT_SCHEMA`. Initially it accepted any string, but after review it was updated to use `entity_domain(\"scene\")`, enforcing that the value is a full scene entity ID (e.g., `scene.morning_living_room`) instead of a bare object ID. This decision aligned with the project’s convention of always using full entity IDs, as mentioned in the discussion.\n\n2) **Script execution path**: In `homeassistant/helpers/script.py`, the script engine was extended to recognize the new `scene` action key. New constants were introduced: `CONF_SCENE = \"scene\"` and `ACTION_ACTIVATE_SCENE = \"scene\"`. The `_determine_action` function was updated to return `ACTION_ACTIVATE_SCENE` when a script step contains the `scene` key. A corresponding handler `_async_activate_scene` was implemented to call the scene domain’s `turn_on` service:\n\n- Domain: `scene.DOMAIN`\n- Service: `SERVICE_TURN_ON`\n- Data: `{ATTR_ENTITY_ID: action[CONF_SCENE]}`\n- `blocking=True`\n- `context=context`\n\nIt also sets `last_action` (defaulting alias to \"activate scene\") and logs execution.\n\n3) **Tests**: A new test `test_activating_scene` was added in `tests/helpers/test_script.py`. It:\n- Registers a fake `scene.turn_on` service and records calls.\n- Invokes `script.call_from_config` with a config `{\"scene\": \"scene.hello\"}` and a specific `Context` object.\n- Waits for all tasks to finish and then asserts that:\n  - Exactly one service call was made.\n  - The call’s `context` matches the provided context.\n  - The call’s data includes `ATTR_ENTITY_ID == \"scene.hello\"`.\n\nThrough these changes, the system now supports a cleaner YAML syntax for scene activation in scripts while maintaining strong schema validation (scene-specific entity IDs) and proper context propagation.",
        "semantic_memory": "This change illustrates a general pattern for extending a declarative automation DSL (like Home Assistant scripts) with new syntactic sugar while remaining consistent with existing architecture and conventions.\n\nKey generalizable concepts:\n\n1. **Shorthand actions in declarative configs**:\n   - Users frequently repeat certain service calls; providing syntactic sugar (e.g., `scene: <entity_id>`) improves readability and reduces boilerplate.\n   - Such shorthand should map cleanly onto existing service calls and execution paths (here: mapping to `scene.turn_on` with `entity_id`).\n\n2. **Schema-driven validation and consistency**:\n   - Configuration schemas (via tools like voluptuous) help ensure that new shortcuts accept exactly what the system expects: in this case, a scene entity ID rather than a free-form string.\n   - Using domain-specific validators (e.g., `entity_domain(\"scene\")`) enforces conventions across the codebase and avoids silent misconfigurations.\n   - Design discussions may arise around whether to accept object IDs vs full entity IDs; aligning with established conventions (always use full entity IDs) avoids special cases and user confusion.\n\n3. **Extending an action dispatcher**:\n   - Script/automation engines often use a dispatcher pattern: they examine a config step and choose a handler based on which keys are present (`service`, `event`, `device`, `scene`, etc.).\n   - Adding a new action involves:\n     - Defining a new constant for the key and action type.\n     - Updating the action detection logic to recognize the new key.\n     - Implementing a handler function that uses existing service APIs.\n   - This keeps the core engine extensible without altering existing actions.\n\n4. **Preserving execution context**:\n   - When mapping shorthand actions to service calls, it’s important to pass through tracing information (`Context`) and blocking/non-blocking semantics so logging, attribution, and chaining behave consistently.\n\n5. **Testing new syntactic constructs**:\n   - For new config syntax, tests should verify the end-to-end behavior: that the correct service is called with the correct data and context, not just that validation passes.\n   - Registering a fake service and capturing its calls is a robust way to test script/automation execution logic.\n\nThis pattern applies broadly whenever extending configuration-driven automation frameworks with higher-level, user-friendly primitives built atop existing primitives.",
        "procedural_memory": [
            "When adding a new shorthand or high-level action to a configuration-driven automation engine, follow a structured process that covers validation, dispatching, execution, and testing.",
            "Step 1: Define the new config shape in the schema.\n- Identify the new key(s) you want to support in config (e.g., `scene`).\n- Extend the existing configuration schema (e.g., `SCRIPT_SCHEMA`) with a dedicated sub-schema for that key.\n- Use domain-aware validators where possible (e.g., `entity_domain(\"scene\")` instead of a generic string) so users must provide valid entity IDs.\n- Ensure the new schema element is added to the correct place in any `vol.Any`/`vol.All` constructs that define allowed action types.",
            "Step 2: Integrate the new action into the dispatcher.\n- Add a constant for the config key (e.g., `CONF_SCENE = \"scene\"`) and for the action type (e.g., `ACTION_ACTIVATE_SCENE = \"scene\"`).\n- Update the function that determines the action type from a config step (such as `_determine_action`) to detect the presence of the new key and return the new action type.\n- Add the new action type to any mapping/dictionary of action type → handler method in the script/automation engine.",
            "Step 3: Implement the execution handler.\n- Create a handler method (e.g., `_async_activate_scene`) that:\n  - Sets `last_action` and logs a meaningful description (use an alias if provided, a reasonable default otherwise).\n  - Invokes the appropriate underlying service (e.g., `hass.services.async_call(scene.DOMAIN, SERVICE_TURN_ON, {ATTR_ENTITY_ID: action[CONF_SCENE]}, blocking=True, context=context)`).\n  - Passes the current `context` so attribution and logging remain accurate.\n- Make sure the handler respects asynchronous patterns used in the codebase (e.g., `async`/`await`).",
            "Step 4: Maintain consistency with existing conventions.\n- Check how similar features are represented; for example, whether configurations typically use full entity IDs or object IDs.\n- Prefer reusing existing validation helpers (like `entity_domain`) rather than rolling your own string checks.\n- Adjust your design if reviewers point out inconsistencies (as in switching from arbitrary string to `entity_domain(\"scene\")`).",
            "Step 5: Write end-to-end tests for the new syntax.\n- In test code, register a fake or stub service for the underlying operation (e.g., `scene.turn_on`) and record incoming calls.\n- Invoke the automation/script engine with a configuration that uses the new shorthand (e.g., `{\"scene\": \"scene.hello\"}`).\n- Wait for all tasks to finish (`await hass.async_block_till_done()` in Home Assistant) and then assert:\n  - The number of calls to the underlying service is as expected.\n  - The service data contains the expected fields and values (e.g., `ATTR_ENTITY_ID` equals the configured scene entity ID).\n  - The execution context (`Context`) is preserved and matches what was provided.\n- Optionally add negative tests to ensure invalid configs are rejected by the schema.",
            "Step 6: Update documentation and examples.\n- Provide clear example snippets (e.g., in `configuration.yaml` docs) showing how to use the new shorthand.\n- Explain that the shorthand is equivalent to the explicit service call, so users understand behavior and can fall back to the explicit form if needed.",
            "Step 7: For diagnosing issues with similar features in the future:\n- If a shorthand action does not work, first confirm the configuration passes schema validation (wrong entity format is a common cause).\n- Verify that the dispatcher correctly identifies the action type by checking which path is taken in `_determine_action` (or equivalent).\n- Confirm the handler calls the expected service with correct parameters by temporarily logging or using test-like instrumentation.\n- Ensure any required imports (e.g., `homeassistant.components.scene`) and constants (`ATTR_ENTITY_ID`, `SERVICE_TURN_ON`) are present and correct."
        ]
    }
}
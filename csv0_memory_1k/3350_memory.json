{
    "search_index": {
        "description_for_embedding": "Implements a safe, typed expression system on top of Python's ast for declarative 'when' conditions, enabling plugin/config expressions to be parsed, validated, serialized, and evaluated safely without exposing full eval. Only a whitelisted subset of AST nodes is supported (names, constants, comparisons, boolean/binary/unary ops, conditional expressions), with a custom Expr hierarchy, parser, and serializer, plus Python 3.7â€“3.9 compatibility handling.",
        "keywords": [
            "safe eval",
            "expression language",
            "ast",
            "ast.parse",
            "NodeTransformer",
            "NodeVisitor",
            "whitelist AST nodes",
            "plugin conditions",
            "when clauses",
            "napari",
            "context expressions",
            "BoolOp",
            "Compare",
            "BinaryOp",
            "UnaryOp",
            "IfExp",
            "security",
            "Python 3.7 compatibility",
            "Python 3.9 ast.dump indent"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the project needed a way to express and evaluate conditional 'when' clauses (similar to VS Code when clauses) for internal logic and plugin manifests, without exposing the full power and risk of Python's eval. The solution was to implement a small, safe expression language on top of Python's ast module.\n\nA new module napari.utils.context._expressions introduces an Expr base class (subclassing ast.AST and Generic[T]) and several concrete subclasses mirroring a subset of Python expression nodes: Name, Constant, Compare, BinOp, BoolOp, UnaryOp, and IfExp. These classes wrap AST nodes but add rich operator dunder methods so that expression trees can be built in Python code using operators instead of strings:\n\n- Name[bool](\"image_active\") & (Name[int](\"ndim\") > 2) builds a BoolOp(And) over a Compare.\n- The bitwise operators & and | are repurposed to mean logical 'and' and 'or' for Expr objects because Python's 'and'/'or' would eagerly evaluate and return non-expression values. True bitwise and/or remain available via Expr.bitand and Expr.bitor.\n\nExpressions can be created from strings with parse_expression(expr: str) which uses ast.parse(..., mode='eval') and a custom ExprTranformer (NodeTransformer) that:\n- Whitelists only certain expression node types (those mapped to Expr subclasses: Name, Constant, Compare, BoolOp, BinOp, UnaryOp, IfExp).\n- Rejects unsupported or unsafe nodes such as Call, Attribute, containers (list/tuple/dict/set), indexing/slicing, f-strings, comprehensions, assignments, etc., raising SyntaxError with a clear message.\n- On Python 3.7, where constants are represented as Num/Str/Bytes/NameConstant instead of Constant, maps those legacy nodes to the new Constant Expr using a small compatibility dict.\n\nExpr.eval(context: Dict[str, Any]) compiles the Expr into an ast.Expression and evaluates it with eval in a restricted context dictionary. If NameError arises, it post-processes to list missing names using a helper _iter_names, giving a helpful error about missing variables rather than propagating a raw NameError.\n\nExpressions can also be serialized back to their string form via Expr.__str__ / _serialize(), which use an ExprSerializer (NodeVisitor) to walk the Expr tree and emit a canonical string using an _OPS mapping from operator classes (ast.And, ast.Gt, ast.Add, ast.Not, etc.) to their textual representations ('and', '>', '+', 'not', etc.). The serializer properly formats operations, comparisons, unary ops, and IfExp ('a if b else c').\n\nThe module exposes a convenience safe_eval(expr: str, context: dict) which is essentially parse_expression(expr).eval(context), but with significantly stricter safety than Python eval and broader capabilities than ast.literal_eval.\n\nOn the API side, the initial commit exposed these classes and helpers via napari.utils.context.__init__, but following review the public exports were removed to keep the API private (underscore-prefixed module) for now, with the intention that it might move into the napari plugin engine (npe2) later. Tests were adjusted accordingly to import directly from napari.utils.context._expressions.\n\nThe implementation also adds Python-version-specific behavior: Expr.__repr__ uses ast.dump(indent=2) only on Python 3.9+ (where the indent argument is supported), and falls back to ast.dump(node) on older versions. For Python 3.7, ExprTranformer recognizes deprecated constant node types (Num, Str, Bytes, NameConstant) and converts them to Constant Expr objects.\n\nA comprehensive test suite (napari/utils/context/_tests/test_expressions.py) validates:\n- Name evaluation, missing-name errors, and repr.\n- Constant evaluation, allowed types (None, str, bytes, bool, int, float), and TypeError for unsupported types (e.g., tuple).\n- BoolOp semantics with Expr & and | combined with both Constant Exprs and literal Python booleans, plus the fact that 'and' does not build an Expr tree.\n- Binary ops (+, -, *, /, //, %, **, ^).\n- Unary ops (+, -, bitwise-not repurposed as logical 'not').\n- Comparison operators (<, <=, ==, !=, >, >=) with Expr and literal values, and in_/not_in convenience methods.\n- _iter_names correctly collecting all variable names from nested expressions.\n- Round-trip parsing and serialization for a set of GOOD_EXPRESSIONS (including all operators present in _OPS, boolean expressions, and simple conditionals).\n- Rejection of BAD_EXPRESSIONS with SyntaxError (typos, assignments, attributes, calls, containers, indexing, slicing, f-strings, named expressions, comprehensions, etc.).\n\nFinally, some minor typing refinements were made to __and__ and __or__ signatures to better express the union of possible operand types, and tests were updated with explicit generic usages (e.g., Name[bool], Name[int]) and type: ignore hints where needed.",
        "semantic_memory": "This work illustrates a robust pattern for implementing a safe, declarative expression language on top of Python's ast, which is particularly useful for configuration systems, plugin manifests, and user-editable conditions.\n\nKey concepts and patterns:\n\n1. **Whitelisting AST Nodes for Safety**\n   - Instead of trying to sanitize full Python eval, parse the expression with ast.parse(..., mode='eval') and traverse the resulting AST.\n   - Use a NodeTransformer that explicitly allows only known-safe node types (e.g., Name, Constant, Compare, BoolOp, BinOp, UnaryOp, IfExp) and rejects everything else (Call, Attribute, containers, comprehensions, etc.).\n   - This whitelist approach gives clear control over what language features are allowed and prevents arbitrary code execution.\n\n2. **Expression Objects as First-Class Values**\n   - Wrap AST nodes in domain-specific expression classes (e.g., Expr, Name, Constant, Compare, BoolOp, BinOp, UnaryOp, IfExp) to add behaviors beyond raw AST:\n     - Operator overloading to build expression trees (a & (b > 2)).\n     - Type parameters (Generic[T]) to propagate the expected evaluation type.\n     - Helper methods like eval(context), parse, and serialization.\n   - This improves type safety and discoverability (via static typing and IDEs) when constructing expressions in code.\n\n3. **Overloading Bitwise Operators for Logical Composition**\n   - In Python, logical 'and'/'or' are not overloadable and perform short-circuit evaluation, returning one of the operands. This makes them unsuitable for building expression trees.\n   - Instead, overload bitwise operators & and | on Expr to represent logical 'and' and 'or' at the expression level.\n   - Keep real bitwise operations available through alternate methods (e.g., Expr.bitand, Expr.bitor) to avoid losing functionality.\n\n4. **Safe Evaluation with Explicit Context**\n   - Evaluate expressions by compiling the expression AST to a code object (ast.Expression) and calling eval with a restricted context dictionary.\n   - Do not inject builtins or globals unless explicitly needed.\n   - When NameError occurs, introspect the expression tree to find missing variable names and present a clear error message listing them.\n\n5. **Reusable Serialization and Round-Trip Validation**\n   - Use a NodeVisitor-based serializer that walks the expression tree and reconstructs a canonical string representation.\n   - Maintain a mapping from operator node types to their textual symbols or keywords (e.g., ast.And -> 'and', ast.Gt -> '>', ast.Not -> 'not').\n   - Ensure that parse(new_string) followed by str(expr) will round-trip for all supported expressions, which is important for storing expressions in manifests or configuration files.\n\n6. **Version-Resilient AST Handling**\n   - Python's AST representation changes across versions (e.g., constants became ast.Constant in 3.8+, with legacy Num/Str/Bytes/NameConstant in 3.7; ast.dump gained an indent parameter in 3.9).\n   - A robust AST-based system should:\n     - Detect Python version and normalize legacy node types to the current model (e.g., convert Num/Str/Bytes/NameConstant to Constant on 3.7).\n     - Feature-detect APIs like ast.dump(indent=...) and provide fallbacks when not available.\n   - This keeps the higher-level expression API stable across Python versions.\n\n7. **Incremental, Private API Introduction**\n   - Introduce new, foundational infrastructure as an internal/private API first (_expressions, no exports from __init__), backed by tests.\n   - After real-world validation and iteration, consider promoting it to a public API or moving it to a dedicated package (e.g., plugin engine) to reduce churn and compatibility issues.\n\nOverall, this pattern provides a blueprint for building safe, typed, and serializable expression systems in any Python application that needs user- or plugin-specified conditions without compromising security.",
        "procedural_memory": [
            "Step-by-step instructions on how to design and implement a safe, declarative expression system using Python's AST, similar to this PR:",
            "Step 1: Define the requirements for your expression language",
            "Clarify what expressions you need to support (e.g., names, numeric and string constants, comparisons, boolean logic, basic math, ternary-like conditionals).",
            "Decide what must be forbidden for safety: function calls, attribute access, comprehensions, containers, assignments, indexing, f-strings, etc.",
            "Determine the evaluation context: what variables will expressions reference, and how will you pass them in (e.g., a dict of context values).",
            "Step 2: Choose a representation and create an Expr hierarchy",
            "Create a base Expr class that subclasses ast.AST and Generic[T] to represent typed expressions.",
            "Define subclasses that mirror the subset of AST nodes you want to support, e.g.:",
            "- Name(Expr[T], ast.Name)",
            "- Constant(Expr[V], ast.Constant)",
            "- Compare(Expr[bool], ast.Compare)",
            "- BoolOp(Expr[T], ast.BoolOp)",
            "- BinOp(Expr[T], ast.BinOp)",
            "- UnaryOp(Expr[T], ast.UnaryOp)",
            "- IfExp(Expr, ast.IfExp).",
            "In Expr, implement key methods: eval(context: dict), parse(cls, expr: str), __str__ (serialization), __repr__, and a helper _cast(obj) to wrap python literals in Constant.",
            "Step 3: Implement operator overloading to build expression trees",
            "Add dunder methods in Expr to construct new expression objects instead of performing immediate computation:",
            "- __and__ and __or__ to create BoolOp(And/Or) from Expr operands, using bitwise operators (&, |) as logical combinators.",
            "- Comparison operators (__lt__, __le__, __eq__, __ne__, __gt__, __ge__) to create Compare nodes.",
            "- Binary operators (__add__, __sub__, __mul__, __truediv__, __floordiv__, __mod__, __pow__, __xor__, and explicit bitand/bitor methods).",
            "- Unary operators (__neg__, __pos__, __invert__) to create UnaryOp nodes, repurposing __invert__ (~) for logical not if desired.",
            "Ensure these operators cast literal operands to Constant via Expr._cast so that 'expr + 1' and 'expr + Constant(1)' both work.",
            "Step 4: Implement parsing from strings using ast.parse and a NodeTransformer",
            "Write a function parse_expression(expr: str) that:",
            "- Calls ast.parse(expr, mode='eval') to ensure the input is a single expression, not a statement.",
            "- Extracts tree.body (an ast.expr) and passes it to a custom ExprTranformer().visit().",
            "Implement ExprTranformer(ast.NodeTransformer) that:",
            "- Maintains a whitelist of supported node names, i.e., the names of Expr subclasses you defined (Name, Constant, Compare, BoolOp, BinOp, UnaryOp, IfExp).",
            "- Visits operator nodes (cmpop, operator, boolop, unaryop, expr_context) and returns them unmodified (they're safe metadata).",
            "- For 3.7 compatibility, recognizes legacy constant node types (Num, Str, Bytes, NameConstant) and converts them into Constant Expr instances.",
            "- For any node type not in the whitelist (and not a supported operator/expr_context), raises SyntaxError with a helpful message (e.g., 'Type Call not supported').",
            "- Builds new Expr instances using globals()[type_name](**field_values), recursively visiting child expressions.",
            "Step 5: Implement safe evaluation of expressions",
            "In Expr.eval(context: Dict[str, Any]):",
            "- Wrap self in ast.Expression(body=self) to create an expression root.",
            "- Compile it via compile(ast.Expression(...), '<Expr>', 'eval').",
            "- Evaluate it with eval(code, context), using only the provided context dict (no implicit globals/builtins unless explicitly needed).",
            "Catch NameError and replace it with a more informative error:",
            "- Write a helper _iter_names(expr: Expr) that traverses the expression tree and yields all Name.id values.",
            "- When NameError occurs, compute missing = {name for name in _iter_names(self) if name not in context} and raise NameError with a message listing the missing names.",
            "Optionally, provide a convenience function safe_eval(expr: str, context: dict) that just calls parse_expression(expr).eval(context).",
            "Step 6: Implement serialization (stringification) of expression trees",
            "Create an ExprSerializer(ast.NodeVisitor) that:",
            "- Walks Expr trees and appends string fragments to an internal result list.",
            "- Uses a mapping _OPS from operator node types (ast.And, ast.Or, ast.Gt, ast.Not, ast.Add, etc.) to their textual form ('and', 'or', '>', 'not', '+', etc.).",
            "Implement visit_ methods:",
            "- visit_Name: write the variable name.",
            "- visit_Constant: write repr(node.value).",
            "- visit_BoolOp: join values with ' and ' or ' or ' using the _OPS map.",
            "- visit_Compare: serialize left expression, then each op/comparator pair.",
            "- visit_BinOp: serialize 'left op right'.",
            "- visit_UnaryOp: serialize 'op operand', adding a space only for word operators like 'not'.",
            "- visit_IfExp: serialize 'body if test else orelse'.",
            "In Expr._serialize and __str__, use ExprSerializer(self) to produce a canonical string representation.",
            "Step 7: Handle Python version compatibility in AST behaviors",
            "Check sys.version_info and adjust behavior as needed:",
            "- For repr(Expr), use ast.dump(self, indent=2) only on Python 3.9+, fall back to ast.dump(self) on older versions.",
            "- For Python 3.7, normalize old constant node types (Num, Str, Bytes, NameConstant) into Constant Expr using a mapping (e.g., {'Num': 'n', 'Str': 's', 'Bytes': 's', 'NameConstant': 'value'}).",
            "Keep this compatibility layer until you decide to drop support for older Python versions.",
            "Step 8: Add comprehensive tests",
            "Write tests to cover:",
            "- Evaluation of Name with provided context and proper error for missing names.",
            "- Evaluation of Constant for each allowed type (None, str, bytes, bool, int, float) and TypeError for unsupported types.",
            "- Behavior of boolean operators with Expr & | and literal booleans, and the fact that Python 'and' does not build Expr trees.",
            "- All binary and unary operators you support.",
            "- Comparisons for all operators, including use of literal values and Expr constants, plus in_ and not_in helpers.",
            "- Parsing and serializing a variety of valid expressions (GOOD_EXPRESSIONS), including every operator mapped in _OPS and conditional expressions.",
            "- Rejecting invalid or unsafe expressions (BAD_EXPRESSIONS) with SyntaxError (assignments, attributes, calls, containers, indexing, slicing, f-strings, named expressions, comprehensions, etc.).",
            "- Helper functions like _iter_names to ensure complete coverage.",
            "Step 9: Keep the API private initially and integrate incrementally",
            "Place implementation details in a private module (e.g., mypkg._expressions).",
            "Avoid exporting Expr and helper functions from a public __init__ until the API is stable.",
            "Integrate the expression language into internal features first (like 'when' conditions in menu actions or plugin manifests).",
            "Once stable and proven, consider migrating the module to a more appropriate package (e.g., a plugin engine) or exposing a public API, and ensure versioning and compatibility guarantees.",
            "Step 10: Use expressions in higher-level features",
            "Define typed Name expressions representing context values (e.g., Name[bool]('image_active'), Name[int]('ndim')).",
            "Compose them into higher-level conditions using operators (e.g., ready = image_active & (ndim > 2)).",
            "Expose configuration or plugin manifest fields that accept expression strings, parse them with parse_expression at load time, and store the resulting Expr objects.",
            "When the context changes (e.g., UI state, active layer, plugin state), call expr.eval(context_dict) to determine whether certain actions should be enabled, shown, or executed."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant template sensor configuration schema using voluptuous: move default for entity_id into the validation schema and adjust access to validated config, resolving broken tests after a previous refactor.",
        "keywords": [
            "Home Assistant",
            "template sensor",
            "voluptuous schema",
            "configuration validation",
            "default values",
            "MATCH_ALL",
            "entity_id",
            "broken tests",
            "binary_sensor template parity"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant template sensor component had its configuration schema tightened and aligned with the binary sensor template implementation. Previously, the voluptuous schema declared `vol.Optional(ATTR_ENTITY_ID): cv.entity_ids` with no default, and the runtime code manually provided a default using `device_config.get(ATTR_ENTITY_ID, MATCH_ALL)`. A refactor earlier had moved towards relying on voluptuous defaults and direct indexing (`device_config[...]`), but the template sensor schema was not updated accordingly, which led to broken tests when the PR was merged. The fix updated the schema in `homeassistant/components/sensor/template.py` so that `ATTR_ENTITY_ID` is declared as `vol.Optional(ATTR_ENTITY_ID, default=MATCH_ALL): cv.entity_ids`, and the code was updated to access validated configuration consistently: `state_template = device_config[CONF_VALUE_TEMPLATE]` (since it is required in the schema) and `entity_ids = device_config[ATTR_ENTITY_ID, MATCH_ALL]`, instead of using `.get(...)` with defaults in the code. This makes the template sensor’s behavior consistent with the binary sensor template and resolves the test failures caused by the earlier, partially applied change.",
        "semantic_memory": "When using voluptuous for configuration validation, defaults and requiredness should be defined at the schema level, not scattered as ad-hoc `.get(..., default)` calls in the runtime logic. This centralizes configuration semantics: the schema expresses what is required and what defaults are applied, and the consuming code can then treat the resulting config as fully normalized, safely using direct key access. Mismatches between how code accesses config (e.g., expecting defaults to be present) and how the schema is defined (e.g., no default provided) are a common source of runtime errors and test failures. Maintaining parity between similar components (e.g., template sensors vs. template binary sensors) helps prevent subtle inconsistencies. Tests that include minimal configurations (omitting optional fields) often reveal these schema/usage mismatches, because the code may assume a key exists or has a default that the schema never provided.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and inspect failing tests.\n- Run the full or targeted test suite (e.g., `tox` or the specific component tests).\n- Identify failures that indicate missing configuration keys, `KeyError`, or unexpected `None` values for config options that are supposed to be optional or have defaults.",
            "Step 2: Compare schema expectations with code usage.\n- Open the component’s voluptuous `PLATFORM_SCHEMA` (or similar schema) and inspect how each config option is defined: `vol.Required(...)` vs `vol.Optional(...)`, and whether `default=` is provided.\n- In the setup code (e.g., `setup_platform`), check how those options are accessed: via `config[...]` (direct indexing), `config.get(...)`, or with explicit default handling.\n- Look for mismatches, such as direct indexing of an optional key without a default in the schema, or code assuming a default value that the schema does not specify.",
            "Step 3: Decide where defaults should live.\n- Prefer putting default values into the voluptuous schema using `vol.Optional(KEY, default=VALUE)`.\n- Reserve `config.get(KEY, default)` for truly dynamic or context-dependent defaults that cannot be expressed statically in the schema.\n- Aim for consistency with other, similar components (e.g., align template sensor behavior with template binary sensor behavior).",
            "Step 4: Update the voluptuous schema.\n- For any optional configuration that the code treats as having a default, add or correct the `default=` in the schema, e.g.: `vol.Optional(ATTR_ENTITY_ID, default=MATCH_ALL): cv.entity_ids`.\n- For required options (like a value template), use `vol.Required(CONF_VALUE_TEMPLATE): cv.template` so you can reliably access it without `.get` and without needing to handle `None`.",
            "Step 5: Simplify and harden the consuming code.\n- After normalizing the schema, update config access patterns:\n  - Use `config[CONF_SOME_KEY]` for keys guaranteed by `vol.Required`.\n  - For keys with defaults defined in the schema, you can usually also use direct indexing (`config[CONF_OPTIONAL_KEY]`), since validation will always set a value.\n- Remove redundant defaulting logic like `config.get(KEY, DEFAULT)` when the default is already handled by voluptuous.\n- Ensure your access pattern matches any special behavior of the validation library (for example, if the library stores keys with a `(key, default)` tuple as the dictionary key, access them accordingly or adjust the schema/usage to the recommended pattern).",
            "Step 6: Re-run tests and validate behavior.\n- Execute the tests that previously failed and verify they now pass.\n- Add or refine tests for minimal configurations that omit optional fields to ensure the new defaults are correctly applied and that no `KeyError` or misbehavior occurs.\n- If your change is harmonizing behavior with another component (e.g., binary_sensor template), add cross-check tests or at least manually compare sample configurations to ensure parity.",
            "Step 7: Document and propagate the pattern.\n- If this is part of a broader codebase (like Home Assistant), document the standard pattern: define defaults in voluptuous schemas and treat config as normalized afterward.\n- When modifying similar components, replicate this pattern to avoid reintroducing schema/usage mismatches in other parts of the system."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant fix to prevent the sensitive 'config' component from being auto-loaded as a dependency or via discovery. Introduces a central dependency blacklist and enforces it in bootstrap and discovery paths, raising HomeAssistantError if blacklisted components are implicitly loaded unless explicitly configured.",
        "keywords": [
            "Home Assistant",
            "config component",
            "dependency blacklist",
            "bootstrap.async_from_config_dict",
            "bootstrap.async_prepare_setup_platform",
            "helpers.discovery.async_discover",
            "helpers.discovery.async_load_platform",
            "HomeAssistantError",
            "auto-configuration",
            "discovery security",
            "component dependencies",
            "platform dependencies"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant 'config' component—used to configure the system via an API—could be loaded implicitly through dependencies or discovery, even when the user had not explicitly enabled it in their configuration. This was a security/behavioral problem: a component intended to be opt-in could be pulled in indirectly.\n\nThe initial patch hard-coded checks for 'config' in two places: (1) when loading platform DEPENDENCIES in `async_prepare_setup_platform`, and (2) when iterating components to set up in `async_from_config_dict`. If 'config' appeared as a dependency or was about to be auto-loaded without being explicitly present in the config, `HomeAssistantError` was raised. Similarly, discovery helpers (`async_discover` and `async_load_platform`) were guarded to forbid discovering 'config'.\n\nAfter discussion (specifically the idea of a general blacklist), the implementation was generalized. A new `DEPENDENCY_BLACKLIST` set was added in `loader.py` (initially containing only `'config'`). `bootstrap.async_prepare_setup_platform` was updated to check every platform dependency against this blacklist and raise `HomeAssistantError` with a component-specific message if any blacklisted component was referenced. `bootstrap.async_from_config_dict` now computes `dependency_blacklist = loader.DEPENDENCY_BLACKLIST - set(components)`, meaning blacklisted components are forbidden unless explicitly present in the user’s configuration. If the current domain being set up is in this blacklist, a `HomeAssistantError` is raised.\n\nIn `helpers.discovery.py`, both `async_discover` and `async_load_platform` now check if the requested component is in `DEPENDENCY_BLACKLIST`. If so, they raise `HomeAssistantError` to prevent blacklisted components from being loaded via discovery.\n\nTests were added and/or updated to verify this behavior:\n- `test_component_cannot_depend_config` ensures a component depending on 'config' causes `async_from_config_dict` to raise `HomeAssistantError`.\n- `test_platform_cannot_depend_config` ensures a platform with 'config' in DEPENDENCIES causes `async_prepare_setup_platform` to raise.\n- `test_load_platform_forbids_config` and `test_discover_forbids_config` ensure discovery APIs raise `HomeAssistantError` when trying to load or discover the 'config' component.\n\nThe end result: the 'config' component can no longer be implicitly loaded via dependencies or discovery. It can only be loaded when explicitly configured by the user, and this logic is centralized through a reusable blacklist.",
        "semantic_memory": "This fix illustrates a general pattern for handling sensitive or privileged modules in a modular system: centralize and enforce a blacklist for components that must never be pulled in implicitly.\n\nKey concepts and best practices derived from this fix:\n\n1. **Sensitive components must be opt-in**: Components that expose administrative capabilities or configuration APIs should not be auto-loaded as a side effect of other components’ dependencies or discovery events. They must only be activated through explicit user configuration.\n\n2. **Centralized dependency blacklist**: Instead of scattering special-case checks across the codebase (e.g., `if component == 'config'`), maintain a central `DEPENDENCY_BLACKLIST` (or similarly named structure). This:\n   - Makes the security policy explicit and discoverable.\n   - Enables easy extension (adding more components to the blacklist).\n   - Reduces duplication and the risk of missing a code path.\n\n3. **Guard all entry points**: Any pathway that can load components—bootstrap, dependency resolution, discovery, platform loading—must be validated against the blacklist. It’s not sufficient to enforce constraints at a single layer (e.g., only in configuration parsing) because other mechanisms (like discovery or platform loading) might bypass that layer.\n\n4. **Allow explicit override via configuration**: In this design, a blacklisted component is blocked *unless* the user has explicitly configured it. This is implemented by subtracting the set of configured components from the blacklist before enforcing it. This pattern balances safety (no implicit loading) with flexibility (explicit opt-in is allowed).\n\n5. **Fail fast with explicit errors**: When the system detects a forbidden dependency or discovery request, it throws a clearly labeled exception (`HomeAssistantError`) with a descriptive message. This ensures that incorrect configurations or component designs fail early and visibly rather than silently enabling unwanted behavior.\n\n6. **Test negative paths (forbidden cases)**: The tests explicitly assert that attempts to depend on or discover blacklisted components raise the appropriate errors. Negative testing is crucial for enforcing security/behavioral constraints, not just for verifying positive functionality.\n\nThese practices are broadly applicable to any plugin/component-based architecture where some modules are more sensitive than others and must not be implicitly activated.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify sensitive or privileged components\n- Review your component/module list and flag any that expose administrative functions, configuration APIs, or other sensitive capabilities.\n- Investigate how these components can be loaded (configuration, dependencies, discovery, dynamic loading APIs).",
            "Step 2: Analyze existing loading paths\n- Search code for all mechanisms that load components (bootstrap routines, dependency resolution, discovery helpers, dynamic loader APIs).\n- Map out which of these paths can indirectly load the sensitive components without explicit user intent.",
            "Step 3: Design a central blacklist or policy mechanism\n- Create a central data structure (e.g., `DEPENDENCY_BLACKLIST = {'config', ...}`) in a common module responsible for component metadata (like a loader or registry).\n- Document the purpose of this blacklist: components in this set cannot be implicitly loaded.",
            "Step 4: Enforce the blacklist in dependency resolution\n- In any function that resolves and sets up dependencies (e.g., `async_prepare_setup_platform` or similar), iterate over declared dependencies.\n- If a dependency is in the blacklist, raise a clear, domain-specific exception (e.g., `HomeAssistantError`) and abort setup.\n- Provide an error message that identifies the forbidden component and the rule being violated.",
            "Step 5: Enforce the blacklist during bootstrap/config loading\n- In the bootstrap routine that iterates over configured components (e.g., `async_from_config_dict`), compute a runtime blacklist that respects explicit configuration: `effective_blacklist = DEPENDENCY_BLACKLIST - set(configured_components)`.\n- Before setting up each component, check if it is in `effective_blacklist` and, if so, raise an exception rather than silently loading it.\n- This ensures sensitive components are only allowed when explicitly configured by the user.",
            "Step 6: Enforce the blacklist in discovery and dynamic loading\n- For all discovery helpers or dynamic loading functions (e.g., `async_discover`, `async_load_platform`, or similar APIs), add checks to reject any attempt to load components from the blacklist.\n- Raise the same kind of explicit exception with a message like: 'Cannot discover the <component> component.'",
            "Step 7: Add tests for forbidden behavior\n- Write tests that simulate components or platforms depending on blacklisted components and assert that the appropriate exception is raised.\n- Write tests that invoke discovery/dynamic loading of blacklisted components and assert they fail with the expected error.\n- Ensure tests cover both dependency-based and discovery-based loading paths.",
            "Step 8: Verify behavior and edge cases\n- Confirm that explicitly configured sensitive components still load correctly when allowed by policy.\n- Confirm that other, non-blacklisted components continue to work normally.\n- Check log output or exception messages to ensure they are informative for users and developers.",
            "Step 9: Document the policy for future developers\n- Update developer documentation to explain that certain components are blacklisted for implicit dependency or discovery.\n- Instruct component authors not to declare blacklisted components as dependencies and not to try to load them via discovery.",
            "Step 10: Consider future extensibility\n- If new sensitive components are introduced, add them to the central `DEPENDENCY_BLACKLIST` instead of scattering ad-hoc checks.\n- Periodically review the blacklist and related tests to ensure they still reflect current security and configuration policies."
        ]
    }
}
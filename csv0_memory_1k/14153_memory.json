{
    "search_index": {
        "description_for_embedding": "Home Assistant SQL sensor failed when query results contained datetime/date values, causing 'Object of type date is not JSON serializable' errors in recorder and websocket. Fix: detect datetime values from SQLAlchemy query and cast them to strings before storing them as sensor attributes.",
        "keywords": [
            "Home Assistant",
            "SQL sensor",
            "SQLAlchemy",
            "datetime serialization",
            "date not JSON serializable",
            "Object of type 'date' is not JSON serializable",
            "recorder error",
            "websocket_api error",
            "sensor attributes",
            "MariaDB"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's SQL sensor was querying a MariaDB database via SQLAlchemy. When a query returned a datetime-like value (e.g. '2018-04-28 12:12:12'), the system began logging errors such as 'Object of type \"date\" is not JSON serializable' from both the recorder and websocket_api components. As a result, the Home Assistant web UI would not fully load because the sensor's state attributes, which included the raw datetime/date object from the query, could not be serialized to JSON. The existing code already normalized decimal.Decimal values to floats before adding them to the attributes, but did nothing for datetime/date types. The fix added an import of the datetime module and extended the normalization inside the sensor's update() method: for each key/value in the SQL query result, if the value is a decimal.Decimal it is converted to float, and if it is a datetime.date (which also covers datetime.datetime instances, since they subclass date) it is converted to a string. The string representation is JSON-serializable, so recorder and websocket could now serialize the sensor state, eliminating the errors and allowing the web frontend to load correctly.",
        "semantic_memory": "Whenever application state needs to be serialized to JSON (for REST APIs, websockets, or persistence layers), all values must be JSON-serializable primitives (strings, numbers, booleans, arrays, objects), not raw Python objects like datetime, date, Decimal, or database-specific types. In systems that surface database query results directly as state or attributes (like Home Assistant sensors backed by SQL), one must normalize or coerce these types. A common pattern is to convert Decimals to floats and datetime/date objects to standardized strings (e.g., ISO 8601) before passing them to any JSON serializer. Additionally, entity attribute schemas should be constrained to simple, serializable types, and integration code should act as a boundary that maps complex back-end types (from SQLAlchemy, ORMs, etc.) into those simpler types. Ignoring this can result in serialization errors that not only log noise but can break higher-level behaviors like UI rendering or state recording.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the serialization error context.\nCheck logs for messages like 'Object of type X is not JSON serializable' in components that serialize state (e.g., recorder, websocket_api, REST API). Note which entity or feature was being processed when the error occurred.",
            "Step 2: Locate the source of non-serializable data.\nTrace back from the error to the code that builds the object being serialized. For Home Assistant-like systems, inspect how entity state and attributes are constructed, especially for integrations that use databases, external APIs, or custom objects.",
            "Step 3: Inspect the data types returned from backends.\nIf the integration uses SQL or an ORM, log or debug-print the types of fields returned (e.g., type(value) for each column). Look for datetime/date, Decimal, or other non-JSON-native types.",
            "Step 4: Normalize backend types to JSON-serializable forms.\nIn the code that maps query results to attributes, add explicit conversions:\n- Convert decimal.Decimal to float (or to str if precision must be preserved).\n- Convert datetime.datetime and datetime.date to strings (ideally ISO 8601 via value.isoformat() or str(value)).\n- Convert any other custom/complex objects to appropriate primitive representations.",
            "Step 5: Centralize type handling when possible.\nImplement this normalization at a single integration boundary (e.g., in the sensor's update() method or a helper function) so that all attributes pass through a consistent conversion pipeline before serialization.",
            "Step 6: Retest serialization and UI behavior.\nAfter changes, restart the system and re-run the scenario that previously failed. Confirm that logs no longer show JSON serialization errors and that dependent features (e.g., web UI loading, state history/recorder) work correctly.",
            "Step 7: Add regression coverage where feasible.\nIf the project has tests, add or extend tests for the integration to include datetime/date and Decimal values in mocked query results and assert that the resulting attributes are JSON-serializable and have the expected string/float form."
        ]
    }
}
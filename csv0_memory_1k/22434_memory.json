{
    "search_index": {
        "description_for_embedding": "Home Assistant Yeelight integration enhancement: add an optional per-device configuration flag `power_mode_icon` so the light entity's icon dynamically reflects the Yeelight bulb's power mode. When enabled, the icon shows waves for flow mode and a moon for nightlight mode, using the `flowing` property and nightlight state. Also ensures state is refreshed after setting effects so icons stay in sync.",
        "keywords": [
            "Home Assistant",
            "Yeelight",
            "power_mode_icon",
            "dynamic icon",
            "entity icon",
            "light entity",
            "flowing property",
            "nightlight mode",
            "frontend state representation",
            "device.update() after service call"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant Yeelight integration, users wanted visual feedback in the UI about the bulb's power mode, especially to distinguish flow mode and nightlight mode from the normal on state. The existing implementation only exposed a generic icon based on on/off and did not capture these Yeelight-specific modes. The fix added a new optional configuration key `power_mode_icon` to each Yeelight device's YAML config. When this flag is true, the Yeelight light entity's `icon` property is overridden to return a mode-specific Material Design icon. The code adds `CONF_POWER_MODE_ICON` to the component's config schema with a default of `False`, and includes the Yeelight `flowing` property in the list of updatable attributes so it's stored in the device state. In the light entity class, the `icon` property checks the config flag; if disabled, it returns `None` and preserves default behavior. If enabled, it reads the `flowing` property: when `'flowing' == '1'`, it returns `'mdi:waves'`; otherwise, if `_is_nightlight_enabled` is true, it returns `'mdi:weather-night'`; if neither condition applies, it returns `None`. During review, it was clarified that this is not simply duplicating the `is_on` state but exposing additional device information. A small logic fix ensures that the nightlight check is not in an `elif`, so it still runs when the flow condition is false, and the method always returns `None` when no special mode applies. Additionally, after setting a custom effect via `set_effect`, the code now calls `self.device.update()` so the entity state (including `flowing`) is refreshed, ensuring the icon immediately reflects the new mode after effect changes.",
        "semantic_memory": "This change illustrates several general practices for stateful hardware integrations and UI representation:\n\n1. **UI-specific behavior can be driven from backend state when it exposes meaningful semantics.** Rather than hardcoding icons in the frontend, the integration's entity exposes a richer `icon` property derived from device-specific state (`flowing`, nightlight mode). This is appropriate when the backend has access to domain-specific concepts that the generic frontend does not.\n\n2. **Config flags preserve backward compatibility for visual changes.** Changing icons or other UI semantics can surprise existing users. A boolean configuration option (`power_mode_icon`, default `False`) makes the feature opt-in, allowing users to adopt the new behavior gradually while maintaining existing defaults.\n\n3. **Keep entity state consistent by updating after device commands.** When service calls change device behavior (e.g., start a flow effect), the integration should refresh its cached properties (`device.update()` or equivalent) so that dependent UI attributes (like icons) immediately reflect the new state. Relying solely on periodic updates or events can cause lag or inconsistency in the UI.\n\n4. **Expose only what is needed in the extra properties list.** The Yeelight integration maintains a list of properties to fetch from the device. Adding `flowing` to this list is necessary so the entity can reason about the current mode. This pattern generalizes: when introducing new UI or logic based on device state, you often need to ensure that state is actually retrieved and stored.\n\n5. **Entity property overrides should be robust and always return a default.** The `icon` property checks configuration and internal state and then returns a string or `None`, ensuring that in all branches the method yields a defined value. This avoids subtle bugs in the frontend, which expects a stable contract for entity attributes.\n\nOverall, the pattern is: when adding richer UI semantics for hardware entities, gate behavior behind configuration, ensure the backend exposes the right state, and keep that state in sync after commands.",
        "procedural_memory": [
            "When you need a Home Assistant entity to expose a mode-specific icon or other UI hint that depends on device-specific state, follow these steps:",
            "Step 1: Identify the device properties that represent the modes or states you want reflected in the UI (e.g., Yeelight `flowing` status, nightlight mode flag). Verify that the underlying library or API exposes these properties.",
            "Step 2: Ensure those properties are fetched and stored in the integration. For integrations like Yeelight that maintain a list of updatable attributes, add the relevant property names (e.g., add `\"flowing\"` to the updateable attributes list) so they are included in the cached state.",
            "Step 3: Add a configuration option to control the new UI behavior, especially if it alters existing appearance. Define a new constant (e.g., `CONF_POWER_MODE_ICON`), add it to the integration's config schema with an appropriate default (`default=False`), and document it. This allows opt-in behavior and avoids breaking changes.",
            "Step 4: In the entity class (e.g., `YeelightLight`), override or implement the relevant property, such as `@property def icon(self)`. First, check the config flag; if disabled, return `None` so default frontend behavior applies. Then derive the icon based on device state, using a clear priority order. For example, if `flowing == '1'` return a flow icon, else if nightlight is enabled return a nightlight icon, else return `None`.",
            "Step 5: Make sure the code path that changes device modes also updates the cached state. After sending commands that can change the mode (e.g., in `set_effect` or custom service handlers), call the integration's update mechanism (like `self.device.update()`) or schedule an update so that `flowing`/mode properties are refreshed immediately.",
            "Step 6: Verify that all branches of the new property logic return a defined value and that there are no unreachable or missing returns. For boolean or multi-state logic, avoid overly restrictive `elif` chains that prevent later checks from running when earlier ones fail.",
            "Step 7: Run the integration's tests and, if applicable, add or extend tests to cover the new configuration flag and behavior. Include tests for each mode (normal, flow, nightlight) and for the flag enabled/disabled states to ensure the icon changes only when expected.",
            "Step 8: Update documentation to describe the new config option, including examples in `configuration.yaml`, and note that enabling it will change the entity's icon based on the device's power mode."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant iaqualink integration was missing support for pool lights. This PR adds a light platform that wraps iaqualink AqualinkLight devices as Home Assistant Light entities, including brightness (0–100% to 0–255) and effect support via AqualinkLightEffect. It wires lights into the config_entry-based setup/unload flow, reuses the shared polling mechanism via AqualinkEntity/refresh_system, and updates coverage configuration.",
        "keywords": [
            "Home Assistant",
            "iaqualink",
            "AqualinkLight",
            "AqualinkLightEffect",
            "light platform",
            "entity platform integration",
            "config_entry async_setup_entry",
            "refresh_system decorator",
            "AqualinkEntity",
            "brightness conversion 0-100 to 0-255",
            "effects support",
            "shared polling",
            "integration architecture"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The iaqualink integration in Home Assistant initially only exposed climate (thermostat) devices, even though the underlying iaqualink library also supported pool lights. Users wanted light control, including brightness and lighting effects, to be available in Home Assistant.\n\nTo address this, the PR made three main changes:\n\n1. **Core integration wiring (`__init__.py`)**:\n   - Imported `AqualinkLight` alongside existing `AqualinkThermostat` and added `LIGHT_DOMAIN` from `homeassistant.components.light`.\n   - During `async_setup_entry`, the integration now creates two lists in `hass.data[DOMAIN]`: one for climates and one for lights.\n   - After calling `await aqualink.get_devices()`, the code iterates over `devices.values()` and partitions them by type using `isinstance` checks. `AqualinkThermostat` instances go into the climate list, and `AqualinkLight` instances go into the light list.\n   - If any climates are found, it forwards the entry setup to the climate domain as before. If any lights are found, it now also forwards the entry setup to the light domain using `hass.config_entries.async_forward_entry_setup(entry, LIGHT_DOMAIN)`.\n   - In `async_unload_entry`, it mirrors this behavior: if there are climate or light entities stored in `hass.data[DOMAIN]`, it forwards unload calls to those platforms.\n   - The integration continues to use a central timer-based `_async_systems_update` task to refresh all iaqualink systems, and the light platform will rely on that instead of polling per entity.\n\n2. **Light platform implementation (`light.py`)**:\n   - Introduced a new `homeassistant/components/iaqualink/light.py` module and excluded it from coverage in `.coveragerc` (as with the climate platform).\n   - Implemented `async_setup_entry` for the light platform. It reads `hass.data[AQUALINK_DOMAIN][DOMAIN]` (where `DOMAIN` here is the HA light domain) and wraps each `AqualinkLight` in a `HassAqualinkLight` entity, then calls `async_add_entities(devs, True)` to add them to Home Assistant.\n   - Defined `HassAqualinkLight(Light, AqualinkEntity)`:\n     - `name` returns `self.dev.label` (the upstream label).\n     - `is_on` mirrors `self.dev.is_on`.\n     - `async_turn_on` and `async_turn_off` are decorated with `@refresh_system`, tying them into the integration’s shared refresh behavior so that system state is updated after changes.\n     - `async_turn_on` supports both brightness and effects:\n       - Reads `ATTR_BRIGHTNESS` and `ATTR_EFFECT` from `kwargs`.\n       - If an effect is provided, it looks up that effect in the `AqualinkLightEffect` enum by name (e.g., `AqualinkLightEffect[effect].value`) and calls `await self.dev.set_effect(effect_value)`.\n       - Else if brightness is provided, it converts the 0–255 HA brightness to a 0–100 percentage in 25% increments: `pct = int(round(brightness * 4.0 / 255)) * 25`, and calls `await self.dev.set_brightness(pct)`.\n       - If neither is provided, it simply calls `await self.dev.turn_on()`.\n     - `async_turn_off` calls `await self.dev.turn_off()`.\n     - `brightness` converts back from the device’s 0–100 percentage to HA’s 0–255 scale: `self.dev.brightness * 255 / 100`.\n     - `effect` returns the current effect as a string name using `AqualinkLightEffect(self.dev.effect).name`.\n     - `effect_list` exposes all supported effect names using `list(AqualinkLightEffect.__members__)` so HA can show a dropdown of valid effects.\n     - `supported_features` returns `SUPPORT_BRIGHTNESS` if `self.dev.is_dimmer` is true, `SUPPORT_EFFECT` if `self.dev.is_color` is true, and `0` otherwise.\n   - `PARALLEL_UPDATES = 0` is declared to rely on the shared polling/timer rather than per-entity parallel updates.\n   - An earlier version had an `async_update` no-op, but after the polling was moved to a timer in the component, this method was removed; the entity now relies entirely on the component-level refresh.\n\n3. **Style and plumbing cleanups**:\n   - Fixed the docstring in `async_setup_entry` in the light platform to say \"lights\" instead of \"switches\".\n   - Removed redundant base-class `Light.__init__` call from the entity `__init__`.\n   - Simplified argument access (`kwargs.get(ATTR_BRIGHTNESS)` instead of specifying default `None`).\n   - Adjusted `effect_list` to return keys directly from `AqualinkLightEffect.__members__` instead of `.keys()` (both work similarly, but the code was aligned with style expectations).\n\nAfter review, maintainers indicated that the changes were acceptable and remaining refinements would be handled in future PRs. The result is that Home Assistant users of iaqualink now see pool lights as proper light entities, with brightness and effect support exposed according to each device’s capabilities, and integrated with the same configuration entry and polling model used by the climate platform.",
        "semantic_memory": "This change illustrates a general pattern for extending an integration that sits between a third-party device API and a home automation framework.\n\nKey generalizable concepts:\n\n1. **Platform-based integration architecture**:\n   - Many frameworks (e.g., Home Assistant) separate integrations into platforms by device class (climate, light, switch, etc.). When the underlying library supports more device types than the integration exposes, the correct way to extend functionality is usually:\n     - Enhance the central integration setup to discover, classify, and store new device types.\n     - Implement a dedicated platform module that adapts the new devices’ API into the framework’s entity interface.\n     - Use the framework’s existing config_entry or discovery mechanisms to forward setup/unload to these new platforms.\n\n2. **Device-type classification and storage**:\n   - During discovery, devices from a client library are often generic objects; classification by type (via `isinstance` or capabilities) is used to separate them into distinct platform lists.\n   - These platform-specific lists are stored in a shared integration data structure (such as `hass.data[DOMAIN][platform_domain]`), which the platform modules later read to construct entities. This avoids re-discovery per platform and centralizes device lifecycle management.\n\n3. **Value-range adaptation between APIs**:\n   - Different systems often use different scales or representations for the same concept (e.g., brightness in 0–100% vs 0–255, effects as numeric IDs vs human-readable names).\n   - A robust entity implementation must:\n     - Convert values both ways (incoming state and outgoing commands) without losing important resolution or violating device constraints.\n     - Honor device-specific quantization rules (e.g., 25% increments) and round appropriately while avoiding off-by-one behavior.\n   - Enumerations (`Enum` / named constants) are an effective way to bridge the gap between low-level numeric values and UI-friendly human-readable identifiers.\n\n4. **Centralized polling vs per-entity updates**:\n   - When an integration communicates with a single remote system that exposes many devices, it is often more efficient to poll that system centrally and update all device entities as a batch instead of each entity polling independently.\n   - The pattern here uses a timer in the main integration (`__init__.py`) to refresh the whole system, and has entities rely on that instead of implementing their own `async_update` logic.\n   - When commands are issued from an entity (`turn_on`, `turn_off`, etc.), they can be wrapped in a decorator (like `@refresh_system`) that triggers or schedules a refresh; this keeps state in sync without redundant network calls.\n\n5. **Feature capability reporting**:\n   - The entity should advertise capabilities (e.g., brightness, effects) based on the underlying device’s properties (`is_dimmer`, `is_color`). This allows consumers (UI, automations) to adapt to what is actually supported and prevents errors from calling unsupported methods.\n   - Capability flags are a compact way to express supported features and should be derived systematically from the device’s own capability flags or attributes.\n\n6. **Lifecycle symmetry (setup vs unload)**:\n   - For each platform that is set up via a config entry, the integration should also handle its unload in a symmetric way to avoid resource leaks and lingering entities.\n   - Forwarding `async_unload_entry` calls to each active platform ensures the platform’s cleanup logic executes and references in shared data structures are cleared consistently.\n\n7. **Consistency and style in async integrations**:\n   - Using standard async patterns (e.g., `async_setup_entry`, `async_add_entities`, `async_turn_on`, `async_turn_off`) keeps the integration predictable and maintainable.\n   - Avoiding unnecessary inheritance initialization, aligning docstrings, and using idiomatic dictionary access (`kwargs.get`) are small but important details that make contributions easier to review and extend.\n\nOverall, this PR demonstrates best practices in extending a multi-platform integration: classify additional device types, adapt their API semantics into the framework’s entity model, factor updates through a central refresh system, and expose capabilities accurately.\n",
        "procedural_memory": [
            "When adding a new device type (e.g., lights) to an existing API-based integration that already supports other platforms (e.g., climate), follow a staged approach that combines discovery, entity adaptation, and lifecycle wiring.",
            "Step 1: Confirm upstream library support and identify device classes",
            " - Verify that the underlying client library (e.g., iaqualink) exposes the new device type (`AqualinkLight`) and any relevant enums or properties (brightness, color/effects, capability flags).",
            " - Identify which properties correspond to framework concepts: on/off state, brightness scale, color or effect identifiers, and any capability indicators (`is_dimmer`, `is_color`, etc.).",
            "Step 2: Wire the new device type into central discovery",
            " - In the integration’s main setup file (e.g., `__init__.py`), import the new device class and its platform domain:\n   - `from library import NewDeviceType`\n   - `from homeassistant.components.light import DOMAIN as LIGHT_DOMAIN` (or equivalent for your framework).",
            " - During the config entry setup (`async_setup_entry`), initialize a list for the new platform in the shared data structure, e.g.:\n   - `hass.data[DOMAIN][LIGHT_DOMAIN] = []`.",
            " - After discovering devices (e.g. `devices = await client.get_devices()`), classify them by type using `isinstance` or capability checks:\n   - `if isinstance(dev, AqualinkLight): hass.data[DOMAIN][LIGHT_DOMAIN].append(dev)`.",
            " - For each non-empty platform list, forward the config entry setup to the platform:\n   - `hass.async_create_task(hass.config_entries.async_forward_entry_setup(entry, LIGHT_DOMAIN))`.",
            "Step 3: Implement the new platform’s entity module",
            " - Create a new module for the platform (e.g., `light.py`) and define `async_setup_entry` for that platform:\n   - Read the devices from `hass.data[INTEGRATION_DOMAIN][PLATFORM_DOMAIN]`.\n   - Wrap each device in a framework-specific entity class and pass them to `async_add_entities`.",
            " - Implement an entity class that inherits from the appropriate base (e.g., `Light` plus your integration’s base entity like `AqualinkEntity`).",
            " - Map device attributes and methods to the entity interface:\n   - `name` from the device label.\n   - `is_on` from the device’s on/off state.\n   - `brightness` and/or `effect` using properties from the device, applying any necessary conversions.",
            "Step 4: Adapt value ranges and enums correctly",
            " - Identify each property where the device’s scale differs from the framework’s scale (e.g., 0–100% vs 0–255 for brightness).",
            " - Implement conversion functions or inline conversions in property/getter methods:\n   - To HA: `brightness_255 = device_brightness_percent * 255 / 100`.\n   - From HA: `percent = int(round(brightness_255 * 100 / 255))` and apply device-specific quantization (round to nearest supported step, e.g. 25%).",
            " - For effects or modes represented as enums:\n   - Use the enum to map between human-friendly names (for UI) and underlying numeric values or codes.\n   - Example: `AqualinkLightEffect[effect_name].value` when sending to the device, and `AqualinkLightEffect(device.effect).name` when reporting current state.",
            "Step 5: Implement commands and integrate with central polling",
            " - Implement `async_turn_on` and `async_turn_off` (and any other command methods) on the entity, translating from framework kwargs (e.g., `ATTR_BRIGHTNESS`, `ATTR_EFFECT`) into device method calls.",
            " - If the integration uses a central polling or refresh mechanism (e.g., a timer in `__init__.py`):\n   - Prefer not to implement per-entity polling in `async_update`.\n   - Introduce or reuse a decorator (like `@refresh_system`) that wraps command methods and triggers a system refresh after state changes.\n   - Apply the decorator to your command methods so that the device state remains in sync without redundant network calls.",
            "Step 6: Advertise supported features based on device capabilities",
            " - Inspect the device’s capability attributes (`is_dimmer`, `is_color`, flags, feature sets) and map them to the framework’s capability flags (e.g., `SUPPORT_BRIGHTNESS`, `SUPPORT_EFFECT`).",
            " - Implement a `supported_features` (or equivalent) property that returns the correct flags depending on the device’s capabilities.",
            " - This allows UIs and automations to only expose controls that the device can actually handle.",
            "Step 7: Ensure symmetric unload/cleanup",
            " - In `async_unload_entry` for the integration, mirror the setup by forwarding unload calls to each platform that has active entities:\n   - `if hass.data[DOMAIN][LIGHT_DOMAIN]: tasks.append(forward_unload(entry, LIGHT_DOMAIN))`.",
            " - Clear shared data structures appropriately after all platforms are unloaded to prevent stale references.",
            "Step 8: Update test and coverage configuration as needed",
            " - If tests are not yet written for the new platform but the project requires explicit coverage exclusions, add the new module to `.coveragerc` as a temporary measure.",
            " - Plan to add unit tests that validate:\n   - Device classification.\n   - Brightness/effect conversions.\n   - Correct setting of supported features and handling of commands.",
            "Step 9: Verify behavior end-to-end",
            " - Run the integration locally with real or mocked devices and confirm:\n   - New light entities appear and reflect correct names and states.\n   - Brightness adjustments map cleanly to the device’s discrete brightness levels.\n   - Effect selections match the device’s supported effects and are applied correctly.\n   - State remains in sync after commands due to the shared refresh mechanism.",
            " - Confirm that configuration entry setup and unload behave correctly for both existing platforms (e.g., climate) and the new platform (e.g., light)."
        ]
    }
}
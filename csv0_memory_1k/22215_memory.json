{
    "search_index": {
        "description_for_embedding": "Home Assistant Dyson integration updated from libpurecoollink to libpurecool to add support for 2018 Dyson Pure Cool models (TP04/DP04). Introduces a new DysonPureCool fan entity, new per-component Dyson services (night/auto mode, oscillation angle, flow direction, timer, precise speed), moves filter-life attributes from sensor to fan, and prevents duplicate entities by tracking device serials. Tests updated to async patterns and new library API.",
        "keywords": [
            "homeassistant",
            "dyson",
            "purecool",
            "TP04",
            "DP04",
            "libpurecool",
            "libpurecoollink",
            "fan component",
            "entity duplication",
            "custom services",
            "async_setup_component",
            "integration upgrade"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The Dyson integration in Home Assistant originally depended on the libpurecoollink library, which only supported older Dyson Pure Cool Link devices. Newer 2018 Dyson Pure Cool models (TP04/DP04 and similar) use an updated Dyson API and were not supported. To close this gap, the contributor switched the integration to a forked library, libpurecool==0.5.0, which includes support for the new API.\n\nConcretely, imports throughout the dyson component were changed from libpurecoollink.* to libpurecool.* in __init__.py, climate.py, fan.py, sensor.py and vacuum.py, and the requirements files (requirements_all.txt, requirements_test_all.txt, and gen_requirements_all.py) were updated accordingly. For the fan platform, a significant refactor introduced two distinct entity types:\n- DysonPureCoolLinkDevice for legacy Pure Cool Link devices (as before, but using libpurecool)\n- DysonPureCoolDevice for 2018 Pure Cool devices (TP04/DP04), using the new V2 state class DysonPureCoolV2State and new API methods like enable_auto_mode, enable_frontal_direction, enable_sleep_timer, etc.\n\nThe fan platform gained multiple new features for 2018 models:\n- Mapping generic Home Assistant speeds (low/medium/high) to Dyson FanSpeed levels for the new devices.\n- A 'dyson speed' concept for setting exact numeric speeds 1–10 via a dedicated service.\n- Additional attributes and services exposed on the fan entity for night mode, auto mode, oscillation angle (low/high), flow direction (front), sleep timer, and HEPA/carbon filter life.\n\nCustom Dyson services were previously defined under the global fan.services.yaml using prefixed names (dyson_set_night_mode, etc.). These were moved into a new dyson/services.yaml file and renamed to simpler, integration-local names: set_night_mode, set_auto_mode, set_angle, set_flow_direction_front, set_timer, and set_speed. The fan platform registers these services only when appropriate (e.g., extended services only if at least one DysonPureCool device exists). The code centralizes the service handling into a single service_handle function that looks up the target fan entity by entity_id and calls the corresponding method (set_night_mode, set_auto_mode, set_angle, etc.).\n\nA subtle bug risk around duplicate entities was addressed. Originally, the fan platform attempted to avoid duplicates by checking existing entity names when adding new Dyson fan devices. With mixed device types (Pure Cool Link and Pure Cool 2018) or discovery + manual configuration, different entities might share names but refer to the same physical device. The fix was to track already-added devices by serial number, not by name. DysonPureCoolDevice exposes a device_serial property, and setup_platform now builds a list of existing device.serial values and skips devices whose serial is already present.\n\nThe tests were heavily updated to reflect the new library, the new device types, and the new async integration pattern. All test imports were updated to use libpurecool instead of libpurecoollink. New tests were added for DysonPureCoolDevice: verifying turn_on/turn_off, speed mapping, setting exact Dyson speeds, oscillation, night/auto mode, angle, flow direction, timer, and state attributes including HEPA and carbon filter life. Tests use asynctest to patch DysonAccount.login/devices and async_setup_component to initialize the integration. Several assertions were corrected to use call_count rather than relying on truthiness of mock attributes and to use == instead of Python 'is' for string equality. A dedicated test ensures that reloading the fan platform (e.g., via discovery) does not create duplicate Dyson fan entities for the same physical device.\n\nOverall, this PR modernized the Dyson integration to support new hardware, improved the separation of concerns for Dyson-specific services, moved filter-life reporting into a more appropriate entity (fan instead of sensor), and hardened the component against duplicate entity creation. All related tests were updated and extended to verify the new behaviors.",
        "semantic_memory": "Several generalizable patterns emerge from this work:\n\n1. **Library and API Upgrades for Device Integrations**\n   - When a vendor releases new hardware using an updated API, it is often cleaner to switch to or fork a library that supports both old and new APIs rather than bolting new behavior into an outdated library. This PR replaces libpurecoollink with libpurecool across the integration to unify support for both generations of devices.\n   - All imports referencing the old library need to be systematically updated, and requirement pins must be changed in both runtime and test requirement files, as well as any tooling scripts (e.g., script/gen_requirements_all.py).\n\n2. **Supporting Multiple Device Generations in One Integration**\n   - Use distinct entity classes per device generation (e.g., DysonPureCoolLinkDevice vs DysonPureCoolDevice), each encapsulating the specifics of the underlying API and state model. This keeps per-generation logic local and reduces branching in the code.\n   - Dynamically detect device types using isinstance checks against the appropriate library classes, and create the correct entity subclass. This pattern allows a single platform module to manage a heterogeneous set of devices cleanly.\n\n3. **Avoiding Duplicate Entities**\n   - Name-based deduplication is brittle: different configs or discovery methods can produce entities with the same name for the same physical device, or conversely distinct devices with the same name. Unique hardware identifiers such as serial numbers are more reliable dedup keys.\n   - Keep an internal list of identifiers (e.g., device.serial) for entities already added and consult it when creating new entities. Expose a property like device_serial on entities if necessary for tests or introspection.\n\n4. **Component-Scoped vs Global Services**\n   - Integration-specific services are better declared under the corresponding integration’s services.yaml (homeassistant/components/dyson/services.yaml) instead of under a shared domain (e.g., fan/services.yaml). This avoids polluting global namespaces and better encapsulates integration behavior.\n   - Use concise, domain-scoped service names (set_night_mode) rather than prefixed names (dyson_set_night_mode). The integration’s domain already disambiguates them.\n   - Condition registration of advanced services on the presence of devices that can actually handle them (e.g., only register set_angle, set_speed for models that support those features).\n\n5. **Mapping Generic Home Assistant Concepts to Vendor-Specific APIs**\n   - For YAML/GUI users, maintain simple, generic concepts (e.g., fan speeds: low, medium, high) while mapping them to the richer vendor-specific range (Dyson FanSpeed.FAN_SPEED_1–10). This provides a better UX while still exposing full control via advanced attributes or services where needed.\n   - When a device supports both discrete presets and a numeric range, having both a generic speed and a device-specific speed (dyson_speed) attribute/service is a flexible pattern.\n\n6. **Entity Attribute Placement & Modeling**\n   - Attributes like HEPA and carbon filter life belong to the device entity closest to the physical component they describe. For Dyson fans, that is the fan entity, not a standalone sensor, so moving those attributes to the fan is semantically clearer.\n   - When an integration exposes extended features, capture them as standard entity attributes where possible, and as additional properties in device_state_attributes otherwise.\n\n7. **Testing HA Integrations with Async and Mocks**\n   - Modern Home Assistant integrations are async-first. Tests should use async_setup_component or async_* APIs, along with asynctest for mocking asynchronous behavior.\n   - Instead of testing that a mock was “called” using truthy checks, use call_count or assert_called_with for precise expectations. This avoids false positives and is more robust to refactors.\n   - For integrations that react to device state pushed via callbacks, tests can simulate a state update by constructing a library state object from sample JSON, invoking the registered callback, and then verifying the entity’s HA state and attributes.\n\n8. **Consistent Import and State Handling**\n   - All components that rely on a shared library must consistently import from the updated namespace after a library change; missing one (e.g., in tests) leads to import errors or confusing failures.\n   - When dealing with vendor APIs that represent numeric values as zero-padded strings (\"0090\"), it is important to normalize these to integers for HA attributes so that users and automations work with numeric values.\n\nThese patterns apply broadly to any IoT or device integration in a larger framework: handling multi-generation devices, structuring services, guarding against duplicate entities, cleanly mapping between vendor-specific APIs and platform-agnostic concepts, and maintaining a strong test suite during library upgrades.",
        "procedural_memory": [
            "How to add support for a new device generation and update a Home Assistant integration.",
            "Step 1: Identify the new device API requirements.",
            "Determine whether the existing library supports the new hardware/API. If not, either extend it via a PR or use/maintain a fork that supports both legacy and new devices. Ensure the new library exposes clear classes and state models for the new devices.",
            "Step 2: Update library dependencies.",
            "Pin the new library version in the integration’s REQUIREMENTS and in any global requirements files (e.g., requirements_all.txt, requirements_test_all.txt). Update any tooling scripts that list the library name (e.g., script/gen_requirements_all.py).",
            "Step 3: Update imports across the integration.",
            "Search for all imports from the old library (e.g., libpurecoollink.*) and replace them with imports from the new library namespace (libpurecool.*). This includes component modules (fan, climate, sensor, vacuum) and all tests.",
            "Step 4: Introduce new entity classes for new device types.",
            "Define new entity subclasses specifically for the new device generation (e.g., DysonPureCoolDevice) that encapsulate interactions with the new API and state classes (DysonPureCoolV2State). Keep existing entity classes for legacy devices but update them to use the new library.",
            "Step 5: Detect device types and create appropriate entities.",
            "In the platform’s setup_platform, iterate over the devices provided by the parent integration and use isinstance checks against the new library’s classes (DysonPureCool, DysonPureCoolLink, etc.) to instantiate the correct Home Assistant entity class for each device.",
            "Step 6: Prevent duplicate entities using stable identifiers.",
            "Maintain a list of already-added devices keyed by a stable identifier such as device.serial rather than the human-readable name. Skip creating an entity if its serial is already present. Expose a property like device_serial if needed for debugging or tests.",
            "Step 7: Design and register component-scoped services.",
            "Move integration-specific services from generic domains (e.g., fan/services.yaml) into the integration’s own services.yaml (dyson/services.yaml). Rename services to simple verbs (set_night_mode, set_auto_mode, etc.). Implement a service handler that looks up the target entity by entity_id and calls methods like set_night_mode or set_angle. Register only the services that make sense for the devices detected (e.g., angle, precise speed only for the new models).",
            "Step 8: Map generic HA concepts to vendor-specific features.",
            "Implement mappings from Home Assistant’s SPEED_LOW/MEDIUM/HIGH to the vendor’s discrete speed levels. If the hardware supports exact numeric speeds, add a dedicated attribute and service (e.g., dyson_speed and set_speed) to expose that power users but keep the simple speed interface for most users.",
            "Step 9: Decide where to expose additional attributes.",
            "If new state fields (like HEPA and carbon filter life) conceptually belong to the fan, surface them as properties on the fan entity and include them in device_state_attributes. Avoid scattering related attributes across unrelated sensors unless there is a compelling reason.",
            "Step 10: Update and extend tests.",
            "Refactor existing tests to use the new library imports. Add new tests for the new entity class and behaviors: service interactions (turn_on/off, change speed, angle, modes), attribute values, and state updates. Use async_setup_component for integration setup and asynctest for mocking asynchronous library calls.",
            "Step 11: Test service behavior precisely.",
            "For each service, write tests that call the service with matching and non-matching entity_ids, then verify via mock.call_count and assert_called_with that the underlying device methods are invoked exactly as expected. Avoid vague truthiness checks on mocks.",
            "Step 12: Simulate push state updates.",
            "For devices with push-based updates, create library state objects from sample JSON payloads and invoke the message listener callback registered by the integration. After awaiting hass.async_block_till_done(), assert that the HA entity’s state and attributes reflect the new device state correctly.",
            "Step 13: Verify no duplicate entities on rediscovery.",
            "Simulate both initial integration setup and subsequent platform discovery or reload (e.g., via discovery.load_platform). Then inspect hass.data[DOMAIN].entities to ensure only one entity per physical device exists (e.g., matching by platform_name and device_serial).",
            "Step 14: Run the full test suite and linting.",
            "Run tox or the project’s test runner to ensure all tests, including the new asynchronous ones, pass. Fix lint issues such as line length, import ordering, and comparisons (using == instead of is for strings). Only then consider the integration update complete."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant xiaomi_miio Roborock vacuum integration updated its fan speed nomenclature to match the Xiaomi app (v5.6.34). The FAN_SPEEDS mapping changed from Quiet/Balanced/Turbo/Max to Silent/Standard/Medium/Turbo with the same underlying numeric values. This is a breaking change for any automations that referenced the old string fan speed names.",
        "keywords": [
            "Roborock",
            "Xiaomi",
            "xiaomi_miio",
            "vacuum",
            "fan speed",
            "FAN_SPEEDS",
            "nomenclature change",
            "breaking change",
            "automation compatibility",
            "Home Assistant"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant integration for Xiaomi/Roborock vacuums (xiaomi_miio) exposed fan speed presets using older names: `Quiet`, `Balanced`, `Turbo`, and `Max`. Xiaomi's official app (version 5.6.34) updated its UI nomenclature for these speeds, renaming them to `Silent`, `Standard`, `Medium`, and `Turbo` respectively, while retaining the same underlying numeric power levels. This mismatch led to confusion for users who expected the Home Assistant presets to match the app.\n\nTo resolve this, the FAN_SPEEDS mapping in `homeassistant/components/xiaomi_miio/vacuum.py` was updated from:\n\n- `{\"Quiet\": 38, \"Balanced\": 60, \"Turbo\": 77, \"Max\": 90, \"Gentle\": 105}`\n\nto:\n\n- `{\"Silent\": 38, \"Standard\": 60, \"Medium\": 77, \"Turbo\": 90, \"Gentle\": 105}`\n\nThis aligned the integration with the Xiaomi app nomenclature. However, it introduced a **breaking change**: any existing automations or scripts that referenced the old fan speed strings (e.g., `Quiet`, `Balanced`, `Turbo`, `Max`) would cease to work until users updated them to the new names. Reviewers explicitly requested that the breaking change be clearly documented, including a mapping:\n\n- `Quiet -> Silent`\n- `Balanced -> Standard`\n- `Turbo -> Medium`\n- `Max -> Turbo`\n\nThe author also attempted to update tests and documentation accordingly. During the process, the branch became polluted with unrelated commits (e.g., Alexa input_number support, Tesla config flow, Plex/Freebox icons), and rebasing proved problematic. The author eventually abandoned this branch and opened a clean PR with just the intended change. The core functional fix, however, is the renaming and remapping of FAN_SPEEDS for Roborock vacuums.",
        "semantic_memory": "Several generalizable lessons arise from this fix:\n\n1. **String-based enums create brittle external contracts**: When integrations expose string constants (like fan speed names) that users embed in automations and scripts, renaming those constants is a breaking change, even if the underlying numeric or logical behavior remains the same.\n\n2. **Vendor UI nomenclature vs. integration stability**: Device vendors may change UI labels while keeping protocol-level semantics identical. Integrations must decide whether to track these UI changes for consistency or favor backward compatibility. If they follow the vendor UI, they must treat any string changes as a breaking change and communicate clearly to users.\n\n3. **Explicit migration paths**: When renaming options, it's valuable to provide a clear mapping from old to new values (e.g., Quiet->Silent) so users can quickly update automations. Where possible, code-level aliases or deprecation paths can reduce friction (e.g., accepting both old and new names for a release cycle).\n\n4. **Tests and documentation must mirror public contracts**: Tests that assert specific fan speed labels and documentation that instruct users to use certain strings must be updated whenever those strings change. Otherwise, tests will fail or docs will mislead users.\n\n5. **PR hygiene and branch management**: Allowing a feature branch to accumulate unrelated commits (from rebases or merges) makes review and CI harder. In such cases, it's often cleaner to create a new branch with only the intended changes and open a fresh PR.\n\n6. **Communicating breaking changes in home automation systems**: For systems where user configuration is heavily string-based (YAML, templates, automations), minor-looking label changes can have large user impact. Calling these out as breaking changes in release notes and docs is essential.",
        "procedural_memory": [
            "When device/vendor UI nomenclature changes, or when you suspect an integration's exposed options are out of sync with the vendor app, follow these steps:",
            "Step 1: Identify the mismatch\n- Compare the options (e.g., fan speeds) exposed in the integration with those shown in the device vendor's official app or documentation.\n- Confirm whether the underlying protocol values (e.g., numeric power levels, API codes) are unchanged and only the labels differ.",
            "Step 2: Locate the mapping in code\n- Search the integration code for the enum or mapping that defines the user-facing names (in this case, the FAN_SPEEDS dictionary in `xiaomi_miio/vacuum.py`).\n- Verify that the mapping keys are the strings surfaced to users in states, services, and documentation.",
            "Step 3: Design the new mapping and plan compatibility\n- Decide the new names and ensure they align with the vendor UI (e.g., `Silent`, `Standard`, `Medium`, `Turbo`).\n- Map each old name to the new name and confirm that each new name still corresponds to the correct numeric value.\n- Decide whether to provide backward compatibility:\n  - Ideal: temporarily support both old and new names (aliases), logging deprecation warnings.\n  - If not possible/practical: treat this as a breaking change and plan communication accordingly.",
            "Step 4: Implement the nomenclature change\n- Update the enum/mapping definitions (e.g., change FAN_SPEEDS keys and any dependent logic).\n- If you choose to support aliases, implement a normalization layer that accepts both old and new strings and maps them to canonical values.\n- Ensure that state reporting and service schemas now expose the new names.",
            "Step 5: Update tests\n- Locate tests that assert on the old strings (e.g., fan speed lists, service calls, or snapshots).\n- Update them to expect the new names, including any new mapping behavior.\n- Add tests that verify that the mapping from names to underlying values is still correct.",
            "Step 6: Update documentation and breaking change notes\n- Update user documentation (integration pages, examples) to reference the new names.\n- Add a clear breaking change note with explicit old->new value mappings (e.g., Quiet->Silent, Balanced->Standard, Turbo->Medium, Max->Turbo).\n- If the platform uses a changelog or release notes system, ensure the change is highlighted there.",
            "Step 7: Verify automations impact\n- Locally or in a staging environment, inspect existing automations and scripts that refer to the old values.\n- Validate that they fail or behave differently after the change, confirming the need for user migration.\n- Optionally, provide guidance or tooling (e.g., example search/replace patterns) for users to update their configurations.",
            "Step 8: Ensure PR cleanliness and CI health\n- Before opening or updating the PR, verify that the branch contains only relevant commits (rebase or create a new branch if needed).\n- Run the test suite to confirm all updated tests pass.\n- If accidental unrelated commits are present and rebasing is messy, create a fresh branch with just the intended changes and open a new PR.",
            "Step 9: Post-merge monitoring\n- After release, monitor issues and forums for user confusion or regressions.\n- If many users struggle with the breaking change, consider adding temporary compatibility aliases in a follow-up release, if feasible."
        ]
    }
}
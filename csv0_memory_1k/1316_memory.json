{
    "search_index": {
        "description_for_embedding": "Runtime behavior changed with Qt 5.15 causing certain Qt button clicks in napari to stop emitting signals correctly, even though tests passed. The immediate mitigation was to pin PyQt5 and PySide2 versions to be >= QT_MIN_VERSION and < 5.15 in setup.py to avoid Qt 5.15 until proper fixes and tests are added.",
        "keywords": [
            "Qt 5.15",
            "PyQt5",
            "PySide2",
            "dependency pinning",
            "setup.py",
            "GUI regression",
            "Qt signals",
            "napari",
            "version constraint",
            "runtime bug despite passing tests"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, upgrading to Qt 5.15 (via PyQt5/PySide2) introduced a subtle regression in napari: a toolbar button (e.g. the 'new points' layer button) stopped triggering its action when physically clicked in the UI, even though calling .click() programmatically still worked. This meant the Qt signal/slot machinery behaved differently in the new Qt version. Existing tests, including napari/_qt/_tests/test_qt_buttons.py::test_push_button, did not fail because they relied on programmatic clicks or did not accurately simulate a real user click at the correct screen position. As a result, the regression was not caught by CI and only appeared in real usage. Since understanding and fixing the underlying Qt 5.15 behavioral change requires more investigation and more sophisticated GUI testing (potentially mocking real mouse clicks), the maintainers decided on a conservative mitigation: pin the Qt Python bindings to earlier versions. In setup.py, the requirements lines were changed from 'PyQt5>=QT_MIN_VERSION' and 'PySide2>=QT_MIN_VERSION' to use f-strings with upper bounds: 'PyQt5>={QT_MIN_VERSION},<5.15' and 'PySide2>={QT_MIN_VERSION},<5.15'. This prevents users from installing the problematic Qt 5.15 while keeping everything else the same. The discussion also highlighted that, once the underlying issue is fixed on napari's side, it might not matter whether the constraint is '<5.15' or '!=5.15', and that more robust tests should eventually be added to catch this class of GUI regressions.",
        "semantic_memory": "When a major framework or GUI library releases a new minor/major version (e.g. Qt 5.15), it can introduce subtle behavior changes that don't immediately manifest as test failures. GUI regressions are especially prone to slipping through if tests only trigger actions programmatically instead of simulating real user interactions (mouse clicks, pointer positions, focus, etc.). In such cases, the safest short-term response is often to pin dependency versions to a known good range, especially in widely used libraries and applications, while a proper fix is investigated. This pinning is done by adding an upper bound to the version specifier (e.g. '<5.15') in dependency declarations (setup.py, pyproject.toml, requirements.txt). Deciding between '<X' and '!=X' matters: '<X' blocks that version and any future minor/patch releases at or above X, while '!=X' blocks only a specific version; if the downstream project plans to fix the issue internally, '!=X' might be sufficient, but when the impact is unknown or widespread, '<X' can be safer. Additionally, tests that rely only on programmatic action invocation may not capture real-world GUI behavior changes. For a robust test suite around GUI elements, it's important to simulate genuine user input events (mouse events, keyboard events, widget focus) instead of calling widget methods directly. This combination of careful dependency management and realistic interaction tests improves resilience to upstream framework changes.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Detect the regression.\nObserve unexpected behavior after upgrading a GUI framework or major dependency (e.g., user clicks on a button no longer trigger the expected action, while tests still pass). Verify that rolling back to a previous dependency version restores correct behavior.",
            "Step 2: Correlate with dependency versions.\nIdentify which packages changed recently (PyQt5, PySide2, Qt bindings, etc.). Use tools like pip freeze, git history, or lockfiles to compare working and broken environments. Narrow down to the smallest version change that correlates with the regression (e.g. Qt 5.14.x working, Qt 5.15.x broken).",
            "Step 3: Reproduce and characterize the bug.\nCreate a minimal scenario that reproduces the issue. For GUI issues, test both programmatic interactions (calling .click(), .trigger(), etc.) and real user-like events (mousePressEvent, mouseReleaseEvent, QTest.mouseClick, etc.) to see where the behavior diverges. Confirm that the bug appears only on specific dependency versions.",
            "Step 4: Check and enhance tests.\nInspect existing tests that should cover the affected functionality (e.g., button tests). Determine if they only use programmatic interactions. If so, design new tests that simulate real user interaction using the testing tools your GUI framework provides (e.g., QTest.mouseClick for Qt). This ensures future upstream changes will be caught.",
            "Step 5: Apply a conservative temporary fix via version pinning.\nIf the root cause is not yet understood or is expensive to fix, and the new dependency version is breaking important UX behavior, modify your dependency specifications to exclude the problematic versions. For setup.py or similar:\n- Replace unbounded lower constraints, e.g. 'PyQt5>=QT_MIN_VERSION', with a bounded range, e.g. 'PyQt5>={QT_MIN_VERSION},<5.15'.\n- Do the same for related bindings like 'PySide2>={QT_MIN_VERSION},<5.15'.\nCommit these changes so users avoid installing the problematic version by default.",
            "Step 6: Decide on '<X' vs '!=X'.\nIf you are confident that only one specific release is broken and the next minor/patch will likely be safe, use '!=5.15.0' to skip just that version. If the issues are not fully understood, or you want to block the entire range until you explicitly re-validate, use '<5.15' to avoid all 5.15+ versions. Document this rationale in the code or PR discussion.",
            "Step 7: Investigate the underlying framework behavior change.\nWith the pin in place, take time to understand the underlying change in the GUI framework: review upstream release notes, bug trackers, and migration guides. Compare event handling, signal/slot connections, or API behavior between working and broken versions. Implement code changes in your application to be compatible with the new behavior.",
            "Step 8: Add robust regression tests.\nOnce the bug is understood or fixed, add or update tests to explicitly cover the regression scenario using realistic interactions. For Qt, this often means using QTest to generate mouse events at precise widget coordinates rather than only calling .click(). Ensure that tests fail on the broken dependency version and pass on the fixed one.",
            "Step 9: Relax the version pin.\nAfter verifying that your application works correctly with the new dependency version and that tests are robust, update the dependency constraints to allow the new versions again (e.g., change '<5.15' to '<5.16' or remove the upper bound). Communicate this in release notes so users know when newer versions are supported.",
            "Step 10: Monitor and iterate.\nKeep an eye on upstream issues and user reports when major framework versions change. Adjust pins and tests as necessary, and treat dependency upgrades as events requiring targeted smoke tests for critical user interaction paths."
        ]
    }
}
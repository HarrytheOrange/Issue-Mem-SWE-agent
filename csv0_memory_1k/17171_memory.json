{
    "search_index": {
        "description_for_embedding": "Home Assistant Insteon entities could not be renamed via the new entity registry because they lacked a stable unique_id. The fix adds a proper unique_id property to InsteonEntity, derived from the underlying Insteon device ID and group, instead of using the display name, enabling registry-based renames.",
        "keywords": [
            "Home Assistant",
            "Insteon",
            "entity registry",
            "entity rename",
            "unique_id",
            "entity_id",
            "integration bug",
            "device id",
            "group id",
            "registry-based configuration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant users wanted to use the new entity registry rename functionality for Insteon entities but could not, because the Insteon integration did not provide a proper unique_id for its entities. The InsteonEntity class only exposed a name property, which was used for the entity_id, but there was no stable unique_id for the registry to track the entity independently of the display name. Initially, a patch added a unique_id property that simply returned self.name. This would have allowed the registry to see a unique_id but created a coupling between the human-readable name and the internal identity, making renames fragile (changing the name would change the unique_id). The follow-up patch corrected this by deriving unique_id from the actual Insteon device state: if the group is 0x01, unique_id is the device’s base ID; for other groups, unique_id is constructed as '<device_id>_<group>'. This ensures a stable, deterministic unique_id per physical device/group, while allowing the user-facing name to be changed freely in the registry. After this change, the Insteon integration became compatible with the new entity registry rename features.",
        "semantic_memory": "When integrating devices with systems that maintain an entity registry or a configuration database, each entity must expose a stable, immutable unique identifier separate from any human-readable name or label. Using the display name or entity_id as the unique_id is a design mistake because names are intended to be user-changeable, whereas unique_ids must stay consistent over time to allow renames, migrations, and configuration persistence. For protocol-based devices like Insteon, Zigbee, or Z-Wave, a good unique_id is often derived from a device’s hardware address (e.g., device ID, MAC address, or node ID) combined with a sub-identifier such as a channel, group, endpoint, or feature index. This pattern lets the platform reliably associate stored configuration (like renamed entity_ids, UI preferences, or automations) with the underlying device, even if the name changes or the entity is reloaded. In general, stable identifiers should be based on hardware or protocol-level IDs, not user-facing labels.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify registry or configuration symptoms. Look for reports that entities from a particular integration cannot be renamed, lose their renamed names after restart, or do not appear correctly in the entity registry. Confirm by attempting a rename and checking whether it persists.",
            "Step 2: Inspect the integration's entity implementation. Open the entity class for the problematic integration (e.g., InsteonEntity) and check whether it defines a unique_id property or equivalent hook required by the host platform’s registry mechanism.",
            "Step 3: Verify separation between name and unique_id. If unique_id is missing or simply returns the entity's name or entity_id, recognize this as a design flaw. Names should be user-facing and mutable, while unique_id must be stable and derived from device-level identifiers.",
            "Step 4: Determine appropriate identifier components. For the device/integration in question, locate a stable hardware or protocol-level identifier (e.g., device ID, MAC address, node ID) and any necessary sub-identifiers (e.g., group, channel, endpoint, feature index) to distinguish multiple entities per device.",
            "Step 5: Implement a deterministic unique_id property. Add or modify the unique_id property to build a string from those stable components. For example, use just device_id for the primary entity, and for grouped or multi-channel entities use a pattern like f\"{device_id}_{group}\" or f\"{device_id}_{endpoint}\". Ensure this format cannot collide across entities.",
            "Step 6: Keep name independent and user-facing. Confirm that the name property remains independent from unique_id. It can be derived from friendly device information or user configuration, but must not affect unique_id. Avoid using name for any persistence or identity logic.",
            "Step 7: Test with the registry. Restart the platform and verify that entities now appear with a unique_id in the entity registry. Perform rename operations via the UI or configuration tools and ensure that:\n- The renamed entity_id persists across restarts.\n- The unique_id remains constant and unchanged by renames.\n- No duplicate conflicts are introduced.",
            "Step 8: Regression and compatibility checks. Ensure that existing entities continue to map to the same devices after the change. If the integration previously had implicit identifiers, consider migration logic or documentation for users to avoid duplicate entities.",
            "Step 9: Add tests or documentation. If the project has testing infrastructure, add tests asserting that entities expose a non-empty unique_id derived from device identifiers, and that name changes do not alter unique_id. Optionally document the unique_id scheme for maintainers."
        ]
    }
}
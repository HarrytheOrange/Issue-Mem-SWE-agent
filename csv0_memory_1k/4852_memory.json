{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant device_tracker where router-based presence updates were clearing GPS coordinates provided by GPS trackers. Introduces a source_type attribute (gps vs router), has routers auto-fill Home zone coordinates, uses GPS coordinates only when source_type=gps for zone resolution, and clears router-provided coordinates when the device becomes stale. Ensures map/camera views keep meaningful coordinates while at home without breaking router-based staleness logic.",
        "keywords": [
            "home-assistant",
            "device_tracker",
            "router tracker",
            "GPS tracker",
            "source_type",
            "gps vs router",
            "stale device tracking",
            "zone home coordinates",
            "location clearing bug",
            "map camera wrong position"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant users noticed that when a device was tracked both by a GPS-based tracker (e.g., GPSLogger, OwnTracks) and a router-based tracker, the GPS coordinates would be wiped whenever the router reported the device without GPS information. This caused undesirable behavior in features like the Google Maps camera: when the device was home via router detection, the map would point to nowhere (no coordinates) or a default location instead of a meaningful last GPS fix or a precise home coordinate.\n\nInitial attempts tried to preserve GPS coordinates by not clearing them when no GPS was reported and by adding a gps_updated timestamp to distinguish fresh vs stale GPS data. Reviewers, however, pointed out that this effectively 'merged' states from different trackers and disabled router-based staleness checks, which were by design. Routers work by seen/not-seen intervals and should still be able to mark a device as not_home independently of GPS trackers.\n\nThe final solution introduced a new concept: source_type. Two source types were defined: SOURCE_TYPE_GPS ('gps') and SOURCE_TYPE_ROUTER ('router'). The device_tracker.see/async_see APIs were extended with a source_type parameter defaulting to gps. The Device entity gained a source_type field and began exposing it as a state attribute.\n\nFor router-based trackers, the periodic scan function (async_device_tracker_scan) now calls async_see with source_type=router and, when a Home zone is defined, automatically injects GPS coordinates equal to the Home zone latitude/longitude with gps_accuracy=0. That way, router-tracked devices at home expose a meaningful lat/lon for UI components (e.g., map camera) without pretending this came from a GPS sensor.\n\nThe Device.async_update logic was updated so that GPS coordinates are used for zone resolution only when source_type == SOURCE_TYPE_GPS. For router updates, the state is determined by router staleness logic (consider_home) rather than by zone lookups on coordinates. Additionally, when a device becomes stale (stale() is true), the code explicitly sets self._state = STATE_NOT_HOME and clears self.gps so that router-provided home coordinates are not retained after the device is considered away.\n\nDevice.async_seen was adjusted to reset self.gps to None before applying any incoming gps value, and to parse and set gps and gps_accuracy only when valid gps data is provided. If parsing fails, gps is set to None and gps_accuracy is reset to 0 with a warning logged.\n\nA comprehensive test, test_see_passive_zone_state, was added to verify the new behavior. It:\n- Sets up a Home zone at latitude=1, longitude=2.\n- Simulates a router scanner reporting a device dev1 at home (come_home).\n- Sets up the device_tracker component with the test platform and a consider_home of 59 seconds.\n- Asserts that device_tracker.dev1 has state 'home', latitude=1, longitude=2, gps_accuracy=0, and source_type='router'.\n- Simulates the device leaving home (leave_home) and advances time beyond consider_home.\n- Asserts that device_tracker.dev1 becomes 'not_home' and that latitude, longitude, and gps_accuracy are now None, while source_type remains 'router'.\n\nAlong the way, some experimental code (gps_updated attribute) and a redundant test were removed. There was also a short-lived change commenting out Adafruit_BBIO in requirements_all.txt, which was later reverted to keep the dependency intact. The main functional outcome is a clear separation between GPS-based and router-based tracking, preserving useful coordinates at home without corrupting the router's staleness behavior.",
        "semantic_memory": "This case illustrates several generalizable lessons about multi-source presence tracking and attribute management in stateful systems:\n\n1. **Separate source semantics to avoid state merging pitfalls**\n   When multiple subsystems report the \"same\" entity's state (e.g., GPS tracker vs router tracker), treating their data as interchangeable can break invariants. Instead, explicitly represent the source of the data (source_type= gps, router, bluetooth, etc.) and use that to control how attributes and state are interpreted. This prevents accidental merging of incompatible semantics, such as using home-router sightings to override GPS-based location logic.\n\n2. **Do not over-interpret or reuse stale attributes across sources**\n   Reusing old attributes (like GPS coordinates) when new events lack those attributes can lead to subtle bugs and stale data being presented as current. In this case, keeping GPS coordinates that didn't come from the router would have disabled the router's staleness logic and presented misleading locations. A better approach is to either:\n   - derive appropriate coordinates for the new source (e.g., set Home zone coordinates for routers), or\n   - explicitly clear coordinates when they are no longer valid (e.g., on staleness).\n\n3. **UI-friendly attributes should reflect trustworthy semantics**\n   It's tempting to keep GPS coordinates around solely for UI purposes (e.g., a map camera), but the data must still be semantically correct. The solution here was to give routers valid coordinates by mapping them to the Home zone, and to encode that this is router-sourced via source_type, so other logic can treat it differently from true GPS readings.\n\n4. **Staleness and presence logic must consider the data source**\n   Presence detection strategies differ by source: routers use last_seen with a configurable consider_home interval, while push-based GPS trackers update on movement. Applying a single staleness rule irrespective of source can cause incorrect behavior. It's better to keep the source type explicit and tailor staleness behavior accordingly (e.g., only use coordinates for zone resolution when source_type=gps, but always apply consider_home to router sightings).\n\n5. **State transitions should reset dependent attributes**\n   When an entity changes from a meaningful state to an 'unknown' or 'not_home' state via staleness or error, associated attributes that imply a specific location or quality (lat/lon, gps_accuracy) should also be reset. Otherwise, stale attributes may mislead consumers. This fix explicitly clears GPS attributes when router-based devices become stale.\n\n6. **Tests should model temporal behavior and multiple components**\n   Bugs like this often involve time (stale vs fresh) and the interaction of multiple subsystems (device_tracker, zone, scanner). The regression test here:\n   - manipulates dt_util.utcnow via patching,\n   - sets up zones and scanners,\n   - simulates come_home/leave_home events over time,\n   - and asserts both state and attribute changes.\n   This structure is a good pattern for verifying presence-tracking logic that depends on time and composite sources.\n\n7. **APIs should evolve compatibly with sensible defaults**\n   Extending the device_tracker.see/async_see API with a source_type parameter but defaulting it to 'gps' means existing GPS-based integrations continue to work without modification. New or router-based integrations can opt into the richer semantics by passing the appropriate source_type.\n\nOverall, the key pattern is: when many heterogeneous data sources contribute to a unified model (like a device's presence and location), model the sources explicitly, control how their data is combined, and align attribute lifecycles with state transitions and staleness rules.",
        "procedural_memory": [
            "When diagnosing issues where device presence or location seems incorrect in a multi-tracker environment (e.g., router + GPS), start by identifying how each tracker reports state and how their data is combined.",
            "Step 1: Reproduce and observe the incorrect behavior",
            "1. Enable detailed logging for the tracking subsystem (e.g., Home Assistant's device_tracker) and relevant components (router platform, GPS platform, zone).",
            "2. Reproduce the scenario: track a device via both a GPS-based tracker and a router-based tracker, then observe what happens when the router reports the device at home without GPS and when it later becomes stale.",
            "3. Inspect the final entity state and attributes (lat/lon, gps_accuracy, any custom attributes) to see which values are being cleared, retained, or incorrectly inferred.",
            "4. Note whether staleness logic (e.g., consider_home intervals) is still being applied or appears to be bypassed.",
            "Step 2: Identify where state from different sources is being merged",
            "1. Locate the central code path that processes tracker updates (e.g., a see/async_see method on a shared manager class).",
            "2. Check if this method resets attributes like gps or gps_accuracy unconditionally on each update, regardless of source.",
            "3. Look at any logic that uses past attributes (e.g., previous gps coordinates) when new updates lack them; flag this as potential state-merging behavior.",
            "4. Inspect where the final entity state is derived (e.g., async_update) and see whether it uses coordinates, location_name, or last_seen and how it treats missing vs stale data.",
            "Step 3: Introduce an explicit notion of data source",
            "1. Define an enumeration or constants for source types relevant to your domain (e.g., SOURCE_TYPE_GPS, SOURCE_TYPE_ROUTER, SOURCE_TYPE_BLUETOOTH).",
            "2. Extend the update API (e.g., see/async_see) to accept a source_type parameter, defaulting to a sensible value that preserves existing behavior (often 'gps').",
            "3. Store source_type on the entity representing the device, and expose it as a state attribute so both backend and frontend can reason about it.",
            "Step 4: Adjust logic based on source_type",
            "1. In the code that derives the entity's state (e.g., async_update), gate location-based state resolution (zone lookups by GPS) on source_type, e.g., only using GPS coordinates when source_type == SOURCE_TYPE_GPS.",
            "2. For router-based trackers, keep using last_seen + consider_home-style staleness logic to determine 'home' vs 'not_home', and avoid misusing router-derived coordinates as if they were continuous GPS fixes.",
            "3. If you need UI-friendly coordinates for non-GPS sources (e.g., routers), derive them from known static information such as the Home zone and set gps_accuracy appropriately (e.g., 0 or a sentinel value).",
            "Step 5: Manage attribute lifecycle on state transitions and staleness",
            "1. In the entity's update logic, when a device becomes stale (e.g., stale() is true), explicitly clear location attributes like gps, latitude, longitude, and gps_accuracy if they are no longer meaningful.",
            "2. When processing an update (async_seen), consider resetting gps to None before applying new gps data, so that invalid or missing gps does not inadvertently keep old coordinates.",
            "3. When GPS parsing fails due to bad data (ValueError, TypeError, IndexError), catch the error, reset gps and gps_accuracy to neutral values, and log a warning with the device id and offending data.",
            "Step 6: Update scanner logic to pass the correct source_type and coordinates",
            "1. For router-based scanners, ensure that calls into the central update API pass source_type=SOURCE_TYPE_ROUTER.",
            "2. When a Home (or relevant) zone exists, compute coordinates from the zone (lat, lon) and set them as the gps parameter for router updates, with gps_accuracy=0 or another configured value that distinguishes them from real GPS accuracy.",
            "3. Avoid injecting coordinates when you don't have a reliable zone; in that case, let gps remain None.",
            "Step 7: Add regression tests covering time, sources, and state transitions",
            "1. Create tests that set up zones and trackers (router and GPS) and simulate their events in sequence.",
            "2. Patch the system clock or time utilities (e.g., dt_util.utcnow) to control time progression and test staleness behavior deterministically.",
            "3. In tests, assert not only on the logical state ('home', 'not_home', zone name) but also on attributes like latitude, longitude, gps_accuracy, and source_type before and after transitions (e.g., come_home, leave_home, staleness).",
            "4. Use test utilities like assert_setup_component, fire_time_changed, and mock scanners to simulate real-world scenarios without relying on actual network devices.",
            "Step 8: Verify compatibility and document the new behavior",
            "1. Ensure existing integrations that call the update API without source_type continue to behave as before due to the default (e.g., gps).",
            "2. Update documentation or examples to show how to specify source_type in new trackers and how UI components can depend on source_type.",
            "3. Monitor logs and user feedback for cases where source_type may need to be extended (e.g., adding bluetooth or manual sources) and apply the same pattern."
        ]
    }
}
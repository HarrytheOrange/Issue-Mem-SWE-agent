{
    "search_index": {
        "description_for_embedding": "Fix for missing YAML module at runtime caused by incorrect dependency name and missing requirement entry. The package name was corrected from 'pyaml' to 'pyyaml' and added to requirements.txt to ensure the YAML module is installed with the project.",
        "keywords": [
            "missing yaml module",
            "pyyaml",
            "pyaml typo",
            "dependency issue",
            "requirements.txt",
            "import error",
            "python packaging",
            "runtime error",
            "module not found"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the project relied on a YAML parsing library but the correct Python package was not being installed. A previous commit used the wrong package name ('pyaml' instead of 'pyyaml'), leading to a missing module error at runtime (e.g., ModuleNotFoundError or ImportError for yaml). A contributor (hnq90) identified that the correct package name on PyPI is 'pyyaml' and not 'pyaml'. The fix was to add the correct dependency line 'pyyaml==3.11' to requirements.txt, thereby ensuring that the YAML module is installed whenever the project dependencies are installed. This resolved the missing yaml module error and corrected the spelling mistake in the dependency specification.",
        "semantic_memory": "When a Python application fails with a 'module not found' or 'ImportError' for a third-party library, one common cause is a mismatch between the import name and the package name declared in dependency management files (requirements.txt, setup.py, pyproject.toml). YAML support in Python is commonly provided by the 'pyyaml' package, not 'pyaml', so using the wrong package name prevents the correct module from being installed. In general, dependency specifications must match the exact package name on the package index (e.g., PyPI). Failing to do so leads to runtime import errors even if the code itself is syntactically correct. Always verify the exact package identifier and pin to a known-good version when appropriate. Also, ensuring that all required packages are listed in requirements files is essential for reproducible environments and CI reliability.",
        "procedural_memory": [
            "Step 1: Reproduce the error by running the application or tests and capture the exact exception (e.g., ModuleNotFoundError: No module named 'yaml').",
            "Step 2: Identify which library provides the missing module. For YAML parsing in Python, search for the canonical package (e.g., search 'python yaml pypi' and confirm 'pyyaml' as the correct package).",
            "Step 3: Check the project's dependency files (requirements.txt, setup.py, pyproject.toml, Pipfile, etc.) to see if the corresponding package is listed.",
            "Step 4: Verify that the package name in the dependency file exactly matches the name on PyPI or the relevant package index (e.g., 'pyyaml' vs 'pyaml'). Correct any spelling mistakes or name mismatches.",
            "Step 5: If the dependency is missing entirely, add it with an appropriate pinned version (for example, add 'pyyaml==3.11' to requirements.txt).",
            "Step 6: Reinstall dependencies (e.g., 'pip install -r requirements.txt') or recreate the virtual environment to ensure the new package is installed.",
            "Step 7: Rerun the application or tests to confirm that the missing module error is resolved and that no new dependency conflicts appear.",
            "Step 8: Optionally, add a simple import test or minimal unit test that imports the dependency (e.g., 'import yaml') to catch similar missing dependency issues early in CI.",
            "Step 9: Document the correct package name and purpose in the project (e.g., in README or comments) if there is a known confusion between similar package names.",
            "Step 10: Review recent commits that touched dependency files when such errors arise to quickly identify accidental typos or removed dependencies."
        ]
    }
}
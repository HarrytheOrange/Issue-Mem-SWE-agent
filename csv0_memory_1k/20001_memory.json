{
    "search_index": {
        "description_for_embedding": "Fixes Google Assistant climate trait integration with Home Assistant by correctly handling on/off commands via ThermostatSetMode, and by mapping Google 'auto' vs 'heatcool' modes based on whether the climate device supports temperature ranges or single setpoints. Normalizes temperature ranges for devices without ranges and improves sync between GA and HA climate capabilities.",
        "keywords": [
            "google assistant",
            "climate trait",
            "Home Assistant",
            "ThermostatSetMode",
            "on/off handling",
            "auto mode",
            "heatcool mode",
            "temperature range vs single setpoint",
            "HVAC modes mapping",
            "capability flags",
            "integration bugfix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request addresses multiple misalignments between Google Assistant (GA) and Home Assistant (HA) for climate devices. GA assumes certain thermostat behaviors that don’t always match HA’s more flexible climate model.\n\nObserved issues:\n1. When a user says \"Hey Google, turn on <device>\", GA sends a ThermostatSetMode command with mode = 'on'. The existing HA integration tried to interpret this as a mode change instead of a simple power toggle, which could fail or behave incorrectly if the device’s HVAC modes didn’t include 'on'. The same problem existed for 'off'.\n2. GA has two conceptual 'auto' modes: 'auto' (single target temperature) and 'heatcool' (temperature range: low/high). HA climate entities may implement 'auto' without a temperature range or with one, and previous mapping (always using GA 'heatcool' for HA 'auto' as introduced by #18645) did not correctly represent devices that support only a single temperature setpoint.\n3. For devices that have an 'auto' mode but no temperature range, GA would still send a temperature range (low/high) when the user changed the temperature via the Google UI. HA did not handle this mismatch gracefully: GA wanted a range, but the device only supported a single temperature value.\n\nCause:\nThe root cause was a rigid mapping between GA thermostat modes and HA climate modes that ignored the device’s feature/support flags (e.g., whether it supports temperature ranges vs single setpoints, or supports an explicit turn_on/turn_off service). GA’s higher-level assumptions about thermostat behavior were being forced onto devices whose capabilities did not match those assumptions.\n\nFix implemented:\n1. Improved on/off handling: When GA sends ThermostatSetMode with mode 'on' or 'off', HA now interprets this as a power toggle and calls the climate entity’s turn_on/turn_off services instead of trying to set an HVAC operation mode to 'on'/'off'. This matches GA’s intent and respects HA’s power controls.\n2. Better auto vs heatcool mapping: The integration now inspects the climate entity’s supported features/flags to decide whether to expose the device to GA as 'auto' (single setpoint) or 'heatcool' (range). \n   - If the device supports a temperature range, HA exposes/uses GA 'heatcool'.\n   - If the device only supports a single target temperature in auto-like behavior, HA exposes/uses GA 'auto'.\n3. Normalization of ranges for non-range devices: For devices that do not truly support ranges but receive a range from GA, HA now treats that range intelligently:\n   - When reporting the current settings, HA returns a range with low == high for single-setpoint devices so GA’s UI remains consistent.\n   - When receiving a range from GA for a single-setpoint device, HA converts it to a single value (e.g., averaging the low and high) before forwarding it to the underlying climate component.\n4. Additional tests: The author added specific test cases for the on/off behavior and adjusted existing climate integration tests to cover the new auto/heatcool and temperature handling logic.\n\nThis PR is marked WIP as the author realized more nuanced differences between GA 'auto' and 'heatcool' and began restructuring the climate trait integration accordingly. It directly targets pain points referenced in issues #20105, #19815, #18515, and #17559, all revolving around mismatches between GA’s thermostat model and HA’s climate entities.",
        "semantic_memory": "This fix illustrates a common integration design pattern: cloud assistant platforms (like Google Assistant) use simplified, opinionated device models that often do not match the richness or flexibility of local home automation platforms (like Home Assistant). Attempting a one-to-one mapping without considering device-specific capability flags and feature sets leads to confusing or broken behavior.\n\nGeneralizable insights:\n1. Do not hard-code semantic mappings without consulting capabilities: When integrating two systems that both describe device modes (e.g., 'auto', 'heatcool'), rely on capability/support flags (e.g., supports temperature range vs single setpoint, supports on/off service) to decide how to map modes instead of assuming a fixed mapping.\n2. Distinguish power control from mode control: \"On\" and \"off\" are often power state concepts, not HVAC modes. When an upstream system sends 'on'/'off' via a thermostat mode API (e.g., ThermostatSetMode), the integration should route to power services (turn_on/turn_off) rather than trying to create or use artificial HVAC modes that match those strings.\n3. Normalize data shapes for mismatched capabilities: When a controlling system only supports ranges (low/high) but the device only supports a single value, choose a stable normalization strategy:\n   - When reporting device state back to the controller, represent single values as a degenerate range (low == high) so the controller’s UI and logic remain consistent.\n   - When receiving a range for a single-value device, convert it to a single representative value (like the average or high/low depending on semantics) before passing it on.\n4. Recognize nuanced mode variants in external APIs: GA’s 'auto' and 'heatcool' are not just labels; they encode different assumptions about temperature control (single vs range). The integration must use these nuanced variants appropriately to avoid confusing the user and misrepresenting the device’s capabilities.\n5. Use tests to pin down behavior at integration boundaries: For assistant integrations, end-to-end style tests (e.g., simulating ThermostatSetMode commands) are invaluable for preventing regressions and clarifying exactly how commands should be translated into local actions.\n\nOverall, the best practice is to treat cloud assistant models as a lossy projection of local device capabilities. The adapter layer must dynamically map based on features, normalize incompatible data shapes, and separate orthogonal concepts like power vs mode.",
        "procedural_memory": [
            "When diagnosing issues between a voice assistant (like Google Assistant) and a local climate integration (like Home Assistant), start by understanding what commands the assistant actually sends (payloads, modes, ranges) and how your adapter interprets them.",
            "Step 1: Capture and inspect the assistant commands.\n- Enable debug logging for the assistant integration.\n- Trigger the problematic commands (e.g., \"turn on thermostat\", \"set thermostat to auto\", \"set temperature to 72\" from GA).\n- Record the actual payloads (e.g., ThermostatSetMode with mode 'on', or temperature ranges in 'heatcool').",
            "Step 2: Distinguish power vs mode semantics.\n- Identify whether the upstream system uses the same endpoint to express both power and mode (e.g., 'on'/'off' being sent via a mode field).\n- In your adapter, map 'on'/'off' to power-related services (turn_on/turn_off) instead of HVAC operation modes whenever the underlying device uses separate power controls.",
            "Step 3: Inspect device capabilities and support flags.\n- For each climate entity, inspect feature flags: does it support temperature ranges (min/max), only single target temperature, or both? Does it support specific modes (heat, cool, auto, off, etc.)?\n- Expose and map assistant capabilities (e.g., GA 'auto', 'heatcool') based on these flags rather than hard-coded assumptions.",
            "Step 4: Define a mapping strategy between assistant modes and device modes.\n- If the device supports temperature ranges in auto-like mode, map to GA 'heatcool'.\n- If the device only supports a single setpoint in auto-like mode, map to GA 'auto'.\n- For modes not supported by the device, either omit them from the assistant’s exposed capabilities or provide a sensible fallback that doesn’t mislead the user.",
            "Step 5: Normalize temperature shapes for mismatched capabilities.\n- For devices that only support a single target temperature but receive a range (low/high) from the assistant:\n  - Decide how to convert a range into a single value (e.g., average of low and high, or pick high/low according to heating vs cooling semantics).\n  - Implement this conversion when processing incoming assistant commands.\n- For reporting state back to the assistant:\n  - If the assistant expects a range but the device only has a single value, return low == high == current setpoint so the UI behaves correctly.",
            "Step 6: Update state reporting to reflect real capabilities.\n- When syncing/exposing the device to the assistant, report the correct modes and whether it supports heatcool vs auto.\n- Ensure that the capabilities (traits, attributes) advertised to the assistant match the actual HA climate entity features.",
            "Step 7: Add integration tests.\n- Write tests that simulate assistant commands and assert the adapter calls the correct HA services:\n  - ThermostatSetMode('on') -> climate.turn_on\n  - ThermostatSetMode('off') -> climate.turn_off\n  - heatcool mode with ranges -> climate set temperature range when supported.\n  - auto mode with single temperature -> climate set temperature single value.\n- Include tests for devices both with and without temperature ranges to ensure mappings are correct across variants.",
            "Step 8: Validate against real devices and edge cases.\n- Test with devices that have unusual modes or partial support (e.g., heat only, cool only, auto without range).\n- Confirm that GA’s UI displays the modes and temperatures sensibly and that commands behave as expected.",
            "Step 9: Document the mapping rules.\n- Document how GA modes ('off', 'heat', 'cool', 'heatcool', 'auto') map to your platform’s climate modes and services.\n- Include notes on how single vs range temperatures are handled so future maintainers can reason about and extend the integration without reintroducing bugs."
        ]
    }
}
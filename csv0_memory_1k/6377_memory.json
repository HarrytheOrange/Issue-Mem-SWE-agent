{
    "search_index": {
        "description_for_embedding": "Home Assistant Z-Wave integration: added two refresh services (refresh_entity and refresh_node) and implemented a thread-safe mechanism using the dispatcher signal bus instead of directly storing entity references in hass.data. Entities subscribe to per-entity refresh signals and, when triggered, refresh their dependent Z-Wave values or whole node info.",
        "keywords": [
            "Home Assistant",
            "Z-Wave",
            "zwave",
            "refresh_entity",
            "refresh_node",
            "SERVICE_REFRESH_ENTITY",
            "SERVICE_REFRESH_NODE",
            "dispatcher",
            "async_dispatcher_send",
            "async_dispatcher_connect",
            "thread safety",
            "entity refresh",
            "node refresh",
            "services.yaml",
            "NETWORK.nodes",
            "refresh_info",
            "refresh_value"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set for Home Assistant's Z-Wave integration, support was added for two new services: `zwave.refresh_entity` and `zwave.refresh_node`. The initial implementation registered a `refresh_entity` service that looked up the target entity directly from `hass.data[DATA_ZWAVE_DICT]` and called `entity.refresh_from_network()`. Reviewers raised a concern about thread safety because this approach could involve manipulating Z-Wave network state outside of the Z-Wave worker thread and relied on storing entities in a global dict. To address this, the implementation was refactored to use Home Assistant's dispatcher. A signal format `SIGNAL_REFRESH_ENTITY_FORMAT = 'zwave_refresh_entity_{}'` was introduced. The service handler `async_refresh_entity` now simply sends a signal via `async_dispatcher_send(hass, SIGNAL_REFRESH_ENTITY_FORMAT.format(entity_id))` instead of directly touching the entity. Each Z-Wave entity, in its `async_added_to_hass` hook, subscribes to its own refresh signal with `async_dispatcher_connect` and binds the callback to `self.refresh_from_network`. When the service is called, the dispatcher calls `refresh_from_network` on the correct entity in the right context, where it refreshes either the whole node (`node.refresh_info()`) or specific Z-Wave values (`node.refresh_value(value_id)`) based on dependent value IDs. Additionally, a `refresh_node` service was added that takes a `node_id`, looks up the node from `NETWORK.nodes[node_id]`, and calls `node.refresh_info()`. Corresponding service schemas were added: `REFRESH_ENTITY_SCHEMA` in code and entries for `refresh_entity` and `refresh_node` in `homeassistant/components/zwave/services.yaml`. Finally, the dispatcher signal name was updated to include a 'zwave_' prefix to avoid collisions.",
        "semantic_memory": "When adding or modifying Home Assistant services that interact with long‑running integrations (like Z-Wave), it is important to respect thread boundaries and avoid directly storing or mutating entities from arbitrary service callbacks. Service handlers should generally be lightweight and only trigger actions indirectly via Home Assistant's dispatcher or other async-safe mechanisms. The dispatcher pattern—where each entity subscribes to a per-entity or per-domain signal and the service publishes those signals—is a robust way to decouple external triggers (service calls) from internal entity operations. This ensures that operations like refreshing device state (`refresh_info`, `refresh_value`) happen in the correct execution context and don't rely on global mutable state such as `hass.data` dictionaries containing entity instances. Additionally, providing a dedicated `services.yaml` entry and proper voluptuous schemas for services makes them discoverable in the UI and enforces validated input (`entity_id`, `node_id`, etc.). Using clear, namespaced signal names (e.g., `zwave_refresh_entity_{entity_id}`) avoids signal collisions across domains.",
        "procedural_memory": [
            "How to safely add a refresh service for entities in Home Assistant, especially for integrations like Z-Wave:",
            "Step 1: Define new service constants and schemas.",
            " - Add service name constants to the integration's const module (e.g., `SERVICE_REFRESH_ENTITY`, `SERVICE_REFRESH_NODE`).",
            " - Define voluptuous schemas for each service specifying required fields: e.g., `REFRESH_ENTITY_SCHEMA` requires `ATTR_ENTITY_ID`, `NODE_SERVICE_SCHEMA` requires `ATTR_NODE_ID`.",
            "",
            "Step 2: Implement a dispatcher-based signaling pattern instead of direct entity access.",
            " - Choose a namespaced signal name pattern to avoid collisions, e.g., `SIGNAL_REFRESH_ENTITY_FORMAT = 'zwave_refresh_entity_{}'`.",
            " - In the service handler for refreshing an entity, do NOT retrieve entity instances from `hass.data` or other global structures.",
            " - Instead, implement an async service handler like:",
            "   ```python",
            "   @asyncio.coroutine",
            "   def async_refresh_entity(service):",
            "       entity_id = service.data.get(ATTR_ENTITY_ID)",
            "       async_dispatcher_send(hass, SIGNAL_REFRESH_ENTITY_FORMAT.format(entity_id))",
            "   ```",
            " - This keeps the service handler thread-safe and decoupled.",
            "",
            "Step 3: Register the new services with Home Assistant.",
            " - In the integration's setup/start code, register services using `hass.services.register`.",
            " - Associate each service with its description (from `services.yaml`) and the appropriate schema.",
            "   ```python",
            "   hass.services.register(DOMAIN, const.SERVICE_REFRESH_ENTITY, async_refresh_entity, descriptions[const.SERVICE_REFRESH_ENTITY], schema=REFRESH_ENTITY_SCHEMA)",
            "   ```",
            " - Implement `refresh_node` similarly, but directly operating on the underlying network object if that is safe from the current context (e.g., `node = NETWORK.nodes[node_id]; node.refresh_info()`).",
            "",
            "Step 4: Make entities subscribe to dispatcher signals in their lifecycle hooks.",
            " - In the entity class, implement `async_added_to_hass` to connect to the dispatcher:",
            "   ```python",
            "   @asyncio.coroutine",
            "   def async_added_to_hass(self):",
            "       async_dispatcher_connect(",
            "           self.hass,",
            "           SIGNAL_REFRESH_ENTITY_FORMAT.format(self.entity_id),",
            "           self.refresh_from_network",
            "       )",
            "   ```",
            " - This ensures that when a signal for this entity ID is fired, `refresh_from_network` is invoked in the entity's correct execution context.",
            "",
            "Step 5: Implement the actual refresh logic on the entity.",
            " - Provide a method (e.g., `refresh_from_network`) on the entity that knows how to refresh its underlying device state.",
            " - Optionally, have a helper like `_get_dependent_value_ids` or `dependent_value_ids()` that returns the Z-Wave value IDs the entity depends on.",
            " - In `refresh_from_network`, use these IDs to call underlying network APIs safely:",
            "   ```python",
            "   def refresh_from_network(self):",
            "       dependent_ids = self._get_dependent_value_ids()",
            "       if dependent_ids is None:",
            "           self._value.node.refresh_info()",
            "           return",
            "       for value_id in dependent_ids + [self._value.value_id]:",
            "           self._value.node.refresh_value(value_id)",
            "   ```",
            "",
            "Step 6: Document services in services.yaml.",
            " - Add entries for the new services in `components/<domain>/services.yaml` with descriptions, fields, and examples.",
            " - Ensure the field names and types in `services.yaml` match the code-level schemas (e.g., `entity_id` vs `node_id`).",
            "",
            "Step 7: Verify thread safety and behavior.",
            " - Confirm that the service handlers do not directly touch entity internals or the network from non-designated threads.",
            " - Ensure dispatcher callbacks execute where the integration expects (usually within the event loop associated with Home Assistant).",
            " - Run existing test suites (`tox`) and, if necessary, add tests to cover the new services and signaling behavior.",
            "",
            "Step 8: General pattern for similar future features.",
            " - Whenever a new service needs to cause an action on specific entities or devices, prefer signaling via dispatcher over global entity lookup, especially in async/threaded integrations.",
            " - Use per-entity or per-group signal patterns and subscribe in `async_added_to_hass`/`async_will_remove_from_hass` for clean lifecycle management."
        ]
    }
}
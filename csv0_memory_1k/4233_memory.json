{
    "search_index": {
        "description_for_embedding": "Added a new Home Assistant light platform `mqtt_template` that lets users fully customize MQTT payloads using Jinja2 templates. The component subscribes to a state topic, parses state/brightness/RGB from incoming payloads via templates, and publishes commands built from templates on a command topic. It supports optimistic mode when no state topic or state template is defined, and handles optional features (brightness, RGB, flash, transition). Comprehensive tests verify MQTT message formatting, state updates, optimistic behavior, flash/transition handling, and robustness against invalid payload values.",
        "keywords": [
            "mqtt_template",
            "Home Assistant",
            "light component",
            "MQTT",
            "template",
            "Jinja2",
            "render_with_possible_json_value",
            "state_topic",
            "command_topic",
            "optimistic mode",
            "brightness",
            "rgb_color",
            "flash",
            "transition",
            "payload parsing",
            "invalid values",
            "unit tests",
            "mock_mqtt_component"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced the `mqtt_template` light platform for Home Assistant, allowing users to define fully custom MQTT payloads with Jinja2 templates. The core idea is to separate topics from templates: one set for MQTT topics (`state_topic`, `command_topic`) and another for templates that parse or generate payloads (`command_on_template`, `command_off_template`, `state_template`, `brightness_template`, `red_template`, `green_template`, `blue_template`).\n\nIn the implementation, the `MqttTemplate` class extends `Light`. During initialization, it stores the provided topics and templates, attaches the `hass` instance to each non-`None` template, and determines if the entity should operate in optimistic mode. Optimistic mode is enabled when either no `state_topic` or no `state_template` is provided, meaning the component assumes state based on outgoing commands instead of relying on feedback from the broker.\n\nThe component subscribes to the configured `state_topic` using a `state_received` callback. This callback uses `render_with_possible_json_value(payload)` on the relevant templates to extract:\n- `state` (must resolve to `on` or `off`),\n- `brightness` (integer 0–255 if brightness template is configured),\n- `rgb_color` (three integers for R, G, B if all color templates are configured).\n\nIf the parsed state is not `STATE_ON` or `STATE_OFF`, a warning is logged and the previous state is preserved. Similarly, invalid brightness or color values (non-integer) are caught with `ValueError` and ignored with warnings, leaving existing attributes unchanged. After updating any valid attributes, `update_ha_state()` is called to synchronize with Home Assistant.\n\nFor command publishing, `turn_on` and `turn_off` construct a `values` dictionary (including keys like `state`, `brightness`, `red`, `green`, `blue`, `flash`, and `transition` when provided). These values are fed into the respective Jinja2 templates (`command_on_template` or `command_off_template`) to render the payload string. The payload is then published over MQTT using `mqtt.publish` with the configured QoS and retain flags. In optimistic mode, `turn_on` and `turn_off` immediately update the local state (`_state`, `_brightness`, `_rgb`) and call `update_ha_state()` without waiting for an MQTT feedback message.\n\nThe PR also adds PEP257-compliant docstrings to the entity’s properties and methods (e.g., `brightness`, `rgb_color`, `should_poll`, `name`, `is_on`, `assumed_state`, `turn_on`, `turn_off`) and fixes line-length issues (E501) by breaking long template strings across lines.\n\nExtensive tests in `tests/components/light/test_mqtt_template.py` validate the behavior:\n- `test_setup_fails` ensures setup fails when required config keys (e.g. `command_topic`) are missing.\n- `test_state_change_via_topic` verifies that state changes via MQTT messages when only `state_template` is defined; brightness and RGB remain `None` when no templates are configured.\n- `test_state_brightness_color_change_via_topic` confirms parsing of state, brightness, and color from a composite payload like `on,255,255-255-255` and subsequent updates as different partial payloads arrive.\n- `test_optimistic` checks behavior when no `state_topic` is configured: the component is marked as assumed state, outgoing command payloads are properly formatted (e.g. `on,,--` or `on,50,75-75-75`), and the entity’s state, brightness, and color are updated immediately based on the call parameters.\n- `test_flash` ensures that flash parameters (`flash='short'`/`'long'`) are inserted into the command payload via the template `on,{{ flash }}`.\n- `test_transition` verifies that `transition` values passed to `turn_on`/`turn_off` are correctly inserted into payloads (`on,10`, `off,4`) via templates.\n- `test_invalid_values` confirms that bad state (`offf`), bad brightness (`on,off,255-255-255`), and bad color values (`on,255,a-b-c`) do not corrupt the existing internal state; the component preserves the last known valid brightness and color.\n\nThe PR also adds missing docstrings for `setUp` and `tearDown` in the tests, complying with the project’s PEP257 and pydocstyle enforcement. The discussion around `render_with_possible_json_value(payload)` noted message length concerns but did not lead to code changes.",
        "semantic_memory": "This change illustrates several generalizable patterns for designing MQTT-based, template-driven components and ensuring their robustness:\n\n1. **Template-driven payload mapping**\n   - Instead of tightly coupling the component to a fixed payload format, use templates to map between internal state and MQTT payload strings. Jinja2 templates with named variables (e.g., `{{ brightness }}`, `{{ red }}`) make the interface flexible and user-configurable.\n   - Separate templates for state, brightness, and color allow partial updates and ensure that components can operate even when some features (e.g., brightness or RGB) are unsupported or omitted.\n\n2. **Optimistic mode for write-only integrations**\n   - Many devices do not provide a state feedback channel. An `optimistic` mode lets the integration assume that commands succeed, updating internal state immediately and marking the entity as `assumed_state` for the UI.\n   - Optimistic mode can be inferred (and defaulted) when critical feedback configuration (like `state_topic` or `state_template`) is missing. This avoids misconfigurations where a device would otherwise never appear to change state.\n\n3. **Graceful handling of invalid external data**\n   - External MQTT payloads may be malformed or out-of-spec. The component should:\n     - Attempt to parse values (e.g., using templates and `int()` conversion),\n     - Catch parsing errors (`ValueError`),\n     - Log warnings for observability,\n     - Maintain existing internal state if new data is invalid instead of applying partial, corrupt updates.\n   - This defensive design prevents a single bad message from degrading the user experience or breaking automations.\n\n4. **Optional feature support via configuration**\n   - Use the presence or absence of templates to determine which features are active:\n     - If `brightness_template` exists, initialize brightness to a default and expose it as supported.\n     - If all `red_template`, `green_template`, and `blue_template` exist, expose RGB support and maintain an RGB tuple; otherwise, treat the device as not supporting color.\n   - This pattern allows a single implementation to cover a range of device capabilities without separate code paths for each.\n\n5. **Clear separation of concerns (topics vs. templates)**\n   - Keep MQTT topics (`state_topic`, `command_topic`) and payload structure (templates) separate. This makes it easier for users to integrate with existing devices that have fixed topics but arbitrary payload structures.\n   - It also makes unit tests simpler, as you can assert on simple strings (`'on,50,75-75-75'`) instead of coupling tests to a rigid schema.\n\n6. **Testing MQTT integrations with mocks**\n   - Use test utilities like `mock_mqtt_component` to intercept MQTT publishes and `fire_mqtt_message` to simulate incoming messages. This allows full behavioral testing of the component without a real broker.\n   - Assert not only on state changes in the entity but also on the exact MQTT topic, payload, QoS, and retain flags being published.\n   - Test both valid and invalid payloads to ensure robustness of parsing and state update logic.\n\n7. **Compliance with style and documentation standards**\n   - For libraries and frameworks where docstrings are enforced (via tools like pydocstyle), even overridden methods should have minimal but clear docstrings explaining their behavior.\n   - PEP8/PEP257 compliance helps keep contributions maintainable and consistent across a large code base.\n\nOverall, this PR demonstrates how to implement a flexible, user-configurable integration for heterogeneous MQTT devices, including robust parsing, optimistic operation, and thorough testing.",
        "procedural_memory": [
            "Step-by-step instructions on how to design, debug, or extend a template-based MQTT light (or similar component):",
            "Step 1: Identify required and optional features",
            "Determine what aspects of the device you need to control or monitor (e.g., on/off state, brightness, RGB color, flash, transition). Mark required MQTT options (like command topic) and optional ones (like state topic, brightness templates, etc.).",
            "Step 2: Define configuration schema",
            "Use a schema (e.g., via voluptuous) to validate configuration:\n- Required: command_topic, command_on_template, command_off_template.\n- Optional: state_topic, state_template, brightness_template, red_template, green_template, blue_template, qos, retain, optimistic.\nValidate topics using MQTT-specific validators and templates via a template type.",
            "Step 3: Initialize component state and capabilities",
            "In the entity's `__init__`:\n- Store the `hass`, topics, templates, QoS, and retain.\n- Assign `hass` to each template (e.g., `tpl.hass = hass`).\n- Decide whether to use optimistic mode: enable it when there is no `state_topic` or no `state_template`, or when explicitly configured.\n- Initialize internal state variables based on templates:\n  - `_state` defaults to `False` (off).\n  - `_brightness` defaults to `255` if a brightness template exists; otherwise `None`.\n  - `_rgb` defaults to `[0, 0, 0]` if all three color templates exist; otherwise `None`.",
            "Step 4: Subscribe to MQTT state topic (if available)",
            "If a `state_topic` is configured, subscribe and define a callback:\n- In the callback, use `template.render_with_possible_json_value(payload)` for each relevant template.\n- Try to parse:\n  - State: map to `STATE_ON` or `STATE_OFF` and update `_state`. If unrecognized, log a warning and leave state unchanged.\n  - Brightness: `int(parsed_value)` when brightness is supported. On `ValueError`, log a warning and keep existing brightness.\n  - RGB: parse each of red, green, blue as `int()`. On any `ValueError`, log a warning and keep existing color.\n- After applying valid updates, call `update_ha_state()`.",
            "Step 5: Implement command publishing (`turn_on` and `turn_off`)",
            "In `turn_on`:\n- Build a `values` dict starting with `{'state': True}`.\n- If `brightness` in kwargs, add to `values` and, in optimistic mode, update `_brightness`.\n- If `rgb_color` in kwargs, unpack into `values['red']`, `values['green']`, `values['blue']` and update `_rgb` in optimistic mode.\n- If `flash` in kwargs, add `values['flash'] = kwargs['flash']`.\n- If `transition` in kwargs, add `values['transition'] = kwargs['transition']`.\n- Render the payload using `command_on_template.render(**values)`.\n- Use `mqtt.publish(hass, command_topic, payload, qos, retain)`.\n- In optimistic mode, set `_state = True` and call `update_ha_state()`.\n\nIn `turn_off`:\n- Build `values = {'state': False}`.\n- Add `transition` if provided.\n- Render using `command_off_template.render(**values)`.\n- Publish via MQTT, and in optimistic mode set `_state = False` and call `update_ha_state()`.",
            "Step 6: Expose properties and flags correctly",
            "Implement properties for:\n- `brightness` → return `_brightness`.\n- `rgb_color` → return `_rgb`.\n- `should_poll` → return `False` (MQTT is push-based).\n- `name` → return configured name.\n- `is_on` → return `_state`.\n- `assumed_state` → return `True` when in optimistic mode.\nProvide concise docstrings to satisfy code style tools (e.g., pydocstyle).",
            "Step 7: Write unit tests with mocked MQTT",
            "Use utilities like `mock_mqtt_component` and `fire_mqtt_message` to fully test behavior without a real broker:\n- Test setup failures when required configuration (like `command_topic`) is missing.\n- Test initial state and attributes when only basic templates are defined.\n- Test full state parsing:\n  - Simulate messages like `on,255,255-255-255` and assert state, brightness, and RGB.\n  - Verify transitions from on to off via messages like `off`.\n- Test optimistic mode by omitting `state_topic`/`state_template` and asserting:\n  - `ATTR_ASSUMED_STATE` is true.\n  - The last MQTT publish call contains the expected topic, payload, QoS, and retain values.\n  - The entity’s internal state updates immediately after `turn_on`/`turn_off`.",
            "Step 8: Test special features and edge cases",
            "Add tests for:\n- Flash: configure templates like `'on,{{ flash }}'` and assert payloads `on,short` and `on,long` when calling `turn_on(..., flash='short/long')`.\n- Transition: use templates `on,{{ transition }}` and `off,{{ transition|d }}` and assert payloads like `on,10` and `off,4`.\n- Invalid values: simulate malformed states (`offf`), brightness (`on,off,255-255-255`), and RGB (`on,255,a-b-c`); assert that internal state is not corrupted and previous valid values remain.",
            "Step 9: Log and handle errors gracefully",
            "Ensure that all parsing failures log warnings but do not raise exceptions that would break the component. This makes it easier to diagnose misconfigurations or device-side issues via logs while keeping the system stable.",
            "Step 10: Maintain style and documentation",
            "Run code style and docstyle tools (flake8, pydocstyle, etc.) to ensure:\n- All methods (including overridden ones) have appropriate docstrings.\n- Long lines (especially complex template strings) are broken up to respect line length limits.\nThis prevents CI failures on style and keeps the code base consistent."
        ]
    }
}
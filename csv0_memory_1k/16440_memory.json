{
    "search_index": {
        "description_for_embedding": "Home Assistant AsusWrt device tracker: an attempted fix removed ARP and DNS leases based discovery methods in favor of `ip neigh`, which would have broken support for routers that rely on those commands. Discussion concluded that parse errors from some commands are expected across heterogeneous AsusWrt firmware and should be handled gracefully rather than removing methods.",
        "keywords": [
            "home-assistant",
            "asuswrt",
            "device_tracker",
            "arp",
            "dnsmasq.leases",
            "ip neigh",
            "wl command",
            "parsing errors",
            "multi-router support",
            "fallback discovery methods",
            "breaking change",
            "network device tracking"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, a contributor tried to improve the Home Assistant AsusWrt device_tracker integration by removing two code paths: one that parsed `arp -n` output (`_get_arp`) and one that read `/var/lib/misc/dnsmasq.leases` (`_get_leases`). They believed these functions 'added no value' and might be causing presence detection issues, and they preferred using `ip neigh` as the primary source of truth. The patch deleted the ARP and leases regexes and their use in `get_asuswrt_data`, and then trimmed tests that referenced `_get_arp`, `_get_leases`, and `_parse_lines` for ARP.\n\nAnother user reported that on their Asus router (RT-AC53), the `wl` command does not exist, so the router depends on other methods (like ARP or leases) to discover clients. They explained that AsusWrt firmware seems to have multiple different mechanisms for obtaining the device list, and that parse failures are expected for some commands on some devices. Thus, removing ARP and leases would break routers that rely on those methods.\n\nFurther discussion clarified that the 'errors' motivating the PR were debug-level parse warnings such as \"Could not parse row: ? (192.168.1.129) at <incomplete> on br0\" from `arp` parsing. These were not fatal exceptions and were intentionally tolerated because some AsusWrt variants format output differently. The apparent 'stops working' behavior was not clearly tied to a real unhandled error.\n\nThe reviewer and maintainer pointed out that, because AsusWrt command support varies widely, the integration intentionally tries several different commands (`wl`, `arp`, `ip neigh`, leases, etc.) and merges results. Removing any of these without strong evidence breaks environments where that command is the only working one. They suggested a better approach: keep all methods, improve per-method error handling, and possibly disable a method dynamically if it repeatedly fails, instead of deleting it.\n\nGiven the risk of breaking existing setups, the maintainer closed the PR unmerged, stating it would break environments. The conclusion was that the fix should focus on resilience and error handling across multiple discovery methods rather than removal of 'noisy' commands.",
        "semantic_memory": "When integrating with heterogeneous router firmwares (or any external systems with multiple variants), different devices may expose overlapping but non-identical interfaces or commands. A method that appears redundant or noisy on one device (e.g., producing parse warnings) may be critical on another device where a different method is absent.\n\nKey points:\n- Multi-backend device integrations often need several discovery strategies (e.g., `wl`, `arp`, `ip neigh`, DHCP leases). Removing one can silently break a subset of users whose hardware only supports that method.\n- Parsing errors for some commands can be expected and benign. A robust integration should treat them as soft failures, log at debug level, and continue using other data sources rather than failing the entire process.\n- Integration logic should isolate failures per method: if `arp` parsing fails, that should not cause the complete device update to fail; it should just omit ARP-derived data for that run.\n- Instead of removing methods that appear problematic, design adaptive behavior: detect when a command is unsupported or consistently malformed on a given device and, for that runtime, skip or de-prioritize that method while keeping it available for other devices.\n- Test suites should reflect real behavior, including multiple data sources and fallbacks. Changing tests just to satisfy a narrower implementation that drops legitimate functionality is a warning sign of a breaking change.\n\nGeneralizable best practice: In cross-device integrations, favor additive, fault-tolerant probing of multiple information sources and per-source error isolation over destructive simplifications that remove fallback paths based on limited testing.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving multiple discovery methods in a heterogeneous device integration:",
            "Step 1: Confirm the actual failure mode.\n- Check logs for exceptions vs. debug-level warnings. Distinguish between harmless parse/log messages and real unhandled errors that break the update loop.\n- Verify whether the integration truly 'stops working' (e.g., no updates, tracebacks) or whether it's merely less accurate or noisy.\n",
            "Step 2: Inventory all discovery methods used.\n- List every command or API used (e.g., `wl assoclist`, `arp -n`, `ip neigh`, DHCP/leases files).\n- For each, understand which devices/firmware versions support it and what data fields it contributes (MAC, IP, hostname, status).",
            "Step 3: Reproduce behavior on the target device.\n- Manually run the commands on the router (via SSH/Telnet) to see:\n  - Which commands exist (`which wl`, `arp -n`, `ip neigh`).\n  - What the raw output looks like.\n- Compare the actual output against the regex/parsers in the integration to see why parse warnings occur.",
            "Step 4: Decide if parse errors are acceptable or fatal.\n- If some lines can't be parsed but others can, treat this as partial success, not a global failure.\n- Ensure parsers return partial results instead of raising exceptions when encountering unexpected formats.",
            "Step 5: Isolate failures per method.\n- Wrap each method (e.g., `_get_wl`, `_get_arp`, `_get_leases`, `_get_neigh`) in try/except so that a failure in one method returns an empty dict and logs a warning, rather than propagating an exception.\n- In the aggregator (e.g., `get_asuswrt_data`), merge results from all methods that succeeded; do not let one failure abort the whole device update.",
            "Step 6: Add adaptive disabling of consistently failing methods (optional but robust).\n- Track per-method success/failure over time (e.g., in-memory counters).\n- If a given command consistently fails (e.g., always raises or returns completely unparsable output), mark that method as disabled for the rest of the session.\n- Log an info-level message indicating that the method was disabled for this device, so users understand the behavior.",
            "Step 7: Avoid removing discovery methods without cross-device validation.\n- Before deleting a method (like ARP or leases), verify:\n  - That it's not the only working method on some device types.\n  - That there are replacement methods that provide equivalent data on all supported devices.\n- If such verification is not possible (e.g., due to lack of hardware diversity), prefer leaving the method in place and improving its error handling.",
            "Step 8: Adjust tests to cover the multi-method behavior.\n- Keep tests that validate all discovery methods and their combination in `get_asuswrt_data`.\n- Add tests for:\n  - A method returning unparsable output but not crashing.\n  - A method being missing on a device (simulated by mocking an error or empty output).\n  - Merging data from multiple partial sources (e.g., MAC from `wl`, IP from `neigh`, hostname from leases).",
            "Step 9: Communicate behavior expectations clearly.\n- Document that some debug-level parse warnings are expected on certain routers.\n- Explain that the integration tries several methods and that the set of commands supported depends on router model/firmware.",
            "Step 10: Only then consider refactoring or simplification.\n- Once per-method error handling and adaptive behavior are solid, profile the integration.\n- If a method is truly unused and unsupported across all known devices (with evidence), only then consider deprecating and removing it in a controlled, backwards-compatible way."
        ]
    }
}
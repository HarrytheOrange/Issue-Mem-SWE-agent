{
    "search_index": {
        "description_for_embedding": "Refactor Home Assistant core and remote startup to be fully async-safe: move initialization from start() into async_start(), avoid event-loop-dependent work in constructors, make ServiceRegistry registration lazy, improve async test fixture, and lazily initialize aiohttp ClientSession with proper shutdown.",
        "keywords": [
            "async initialization",
            "HomeAssistant.start",
            "async_start",
            "ServiceRegistry",
            "EVENT_CALL_SERVICE listener",
            "aiohttp.ClientSession lazy init",
            "thread-safe event loop usage",
            "test fixture async_test_home_assistant",
            "ThreadPoolExecutor",
            "core loop exception handler"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set is part of a broader effort to make Home Assistant initialization fully asynchronous and event-loop-safe.\n\nOriginally, HomeAssistant.start() handled both event loop management and core initialization synchronously. It registered services, signal handlers, and ran the loop, mixing responsibilities and making the startup sequence harder to manage and test. Additionally, some components did work in constructors that assumed an active event loop (e.g., ServiceRegistry listening to EVENT_CALL_SERVICE on init, and aiohttp.ClientSession being created eagerly in constructors). The async test fixture also faked async behavior by creating HomeAssistant in a thread executor instead of truly using the event loop.\n\nThe fixes are:\n\n1. **Core async startup refactor**\n   - HomeAssistant.start() is reduced to managing the event loop lifecycle: it schedules hass.async_start() via loop.create_task(), then runs loop.run_forever(), catching KeyboardInterrupt to trigger a clean async stop handler, and finally closes the loop.\n   - The new async_start() coroutine now finalizes startup inside the event loop: sets CoreState.starting, registers the homeassistant.stop and homeassistant.restart services, and attaches OS signal handlers (SIGTERM/SIGHUP) that call async stop/restart handlers. The loop's _thread_ident is set and an async timer is created. This separates sync entry point from async initialization logic.\n   - Dedicated @callback handlers _async_stop_handler and _async_restart_handler are added to encapsulate stop/restart behavior (set exit_code and schedule async_stop).\n   - The core loop exception handler (_async_exception_handler) is annotated as a callback to clarify it runs in the loop context.\n\n2. **ServiceRegistry async-safe constructor**\n   - Previously, ServiceRegistry.__init__ registered an EVENT_CALL_SERVICE listener via run_callback_threadsafe on the loop during construction. This tied construction to the loop thread and made the constructor implicitly async-dependent.\n   - The fix removes this side-effect from __init__ and introduces a self._async_unsub_call_event attribute initialized to None.\n   - In async_register(), after adding the service, the ServiceRegistry checks if _async_unsub_call_event is None; if so, it lazily subscribes to EVENT_CALL_SERVICE via bus.async_listen and stores the unsubscribe callback. This makes the constructor safe to call without having to jump threads or rely on an already running loop; the listener is created only when first needed.\n\n3. **Remote Home Assistant constructor improvements**\n   - The Remote HomeAssistant equivalent now sets up an executor (ThreadPoolExecutor), assigns it as the loop's default executor, and sets a loop exception handler (self._async_exception_handler), mirroring core behavior.\n   - It creates a worker pool, bus, services, state machine, and config, then sets state to not_running and attaches a local API object to config.api.\n   - Web session creation is deferred (see next point) instead of eagerly creating aiohttp.ClientSession in the constructor.\n\n4. **Lazy initialization and proper cleanup of aiohttp.ClientSession**\n   - HomeAssistant previously created an aiohttp.ClientSession eagerly in __init__, which is risky if the event loop is not fully configured or if the instance is used in different loop contexts.\n   - The fix introduces a private _websession attribute set to None and a websession property. On first access, the property lazily creates an aiohttp.ClientSession bound to self.loop and caches it.\n   - In async_stop(), if _websession is not None, it is closed via `yield from self._websession.close()` before marking the state as not_running and stopping the loop. This ensures proper resource cleanup.\n   - Remote HomeAssistant follows the same pattern: _websession is introduced in place of an eagerly-created ClientSession.\n\n5. **Async test fixture made truly async-safe**\n   - The test helper async_test_home_assistant(loop) previously wrapped HomeAssistant construction inside loop.run_in_executor(None, get_hass), along with some configuration. The function get_hass created HomeAssistant in a worker thread to work around async-unfriendly constructors.\n   - With constructors made async-safe, the fixture now constructs HomeAssistant directly in the test's event loop thread. It sets config fields (location_name, config_dir, latitude, longitude, elevation, time zone, units, skip_pip) synchronously.\n   - Only loader.prepare(hass), which may be blocking, is still run in an executor using loop.run_in_executor to avoid blocking the event loop. HomeAssistant.state is set to running after preparation.\n\n6. **Misc. cleanup**\n   - Signal handler registration and service registration code was simplified to use the new _async_stop_handler and _async_restart_handler, avoiding duplicated logic and callback definitions.\n   - Some coroutine and thread-safe calls (e.g., run_coroutine_threadsafe(sleep_wait(), self.loop).result()) were cleaned up cosmetically for readability.\n\nOverall, this PR makes Home Assistant's startup, service registration, and HTTP session usage more consistent with asynchronous best practices, separating synchronous loop management from in-loop async initialization, avoiding event-loop-heavy work in constructors, and making the test infrastructure match the async reality of the core.",
        "semantic_memory": "Generalizable lessons from this change revolve around designing async systems, especially in Python with asyncio:\n\n1. **Separate sync entry points from async initialization**\n   - Use a thin synchronous wrapper (e.g., start()) to set up and run the event loop and schedule an async initialization coroutine (e.g., async_start()). This makes it clearer where blocking vs. async logic lives and simplifies testing.\n\n2. **Avoid event-loop-dependent work in constructors**\n   - Constructors should not assume they run in a particular thread or with a running event loop. Instead of performing loop-bound calls (like listening to events or scheduling coroutines) in __init__, defer that work to async methods or lazy initialization triggered on first use (e.g., in async_register or property access).\n   - This avoids subtle cross-thread issues and makes objects easier to construct in tests, workers, or before the loop is fully configured.\n\n3. **Lazy initialization of async resources**\n   - Expensive or event-loop-bound resources (e.g., aiohttp.ClientSession, long-lived network connections) should be lazily created on demand in properties or dedicated async init functions. This gives better control over lifecycle, reduces startup cost, and avoids initializing resources that may never be used.\n   - Pair lazy creation with explicit cleanup (e.g., closing the ClientSession in async_stop()) to prevent leaks.\n\n4. **Use executors for blocking or CPU-bound work**\n   - Any operations that can block (file IO, heavy computation, module preparation) should be moved to an executor using loop.run_in_executor. Tests and runtime code alike benefit from keeping the event loop responsive.\n\n5. **Centralize stop/restart logic**\n   - All mechanisms that trigger shutdown or restart (services, signals, keyboard interrupts) should route through a small number of unified handlers. These handlers can set exit codes and schedule a clean async shutdown, avoiding duplicated logic and inconsistent behavior.\n\n6. **Register event listeners lazily and idempotently**\n   - When a service registry or similar component needs to listen to a bus, delay subscribing until a first use, and track the unsubscribe callback so you only subscribe once. This keeps initialization cheap and avoids unnecessary listeners when the feature is not used.\n\n7. **Async test fixtures should mirror production behavior**\n   - Tests should not rely on special threading tricks to construct core objects if production code is event-loop-based. Instead, fix the constructors to be async-safe, and then construct objects directly in the loop thread. Use executors only for actual blocking work.\n\n8. **Consistent exception handling in the event loop**\n   - Set a default exception handler on the loop that logs context and exceptions, both for the main app and remote clients, so unexpected errors are centralized and observable.\n\nThese practices lead to more predictable, testable, and robust async applications.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar async initialization and lifecycle issues in an asyncio-based application.",
            "Step 1: Identify async-unsafe constructors and side effects\n- Search for __init__ methods that:\n  - Call event bus listen/subscribe functions.\n  - Create async resources (e.g., aiohttp.ClientSession) tied to a loop.\n  - Use run_until_complete, run_coroutine_threadsafe, or other loop-affecting operations.\n- These are candidates for refactor because they couple object construction to the loop thread and runtime state.",
            "Step 2: Move core initialization into an async method\n- Create an async initialization method (e.g., async_start or async_init) on the main application object.\n- Move event-bus registrations, service registrations, timer setup, and signal handlers from the synchronous start() or constructor into this async method.\n- Ensure the method only runs inside the event loop (scheduled via loop.create_task or awaited from an async main).",
            "Step 3: Simplify the synchronous entry point\n- Refactor the sync start() to:\n  - Obtain or create the event loop.\n  - Schedule the async initializer (loop.create_task(self.async_start())).\n  - Call loop.run_forever() to drive the application.\n  - Catch KeyboardInterrupt and other stop conditions, and use loop.call_soon to schedule a clean async stop handler.\n  - Close the loop in a finally block to ensure cleanup.",
            "Step 4: Centralize stop and restart logic\n- Implement dedicated callback methods for stopping and restarting (e.g., _async_stop_handler, _async_restart_handler):\n  - These should set an exit_code and schedule an async_stop coroutine that cleans up resources.\n- Use these handlers for:\n  - OS signals (SIGTERM, SIGHUP).\n  - Application-level services (homeassistant.stop, homeassistant.restart).\n  - KeyboardInterrupt handling in start().\n- This ensures all shutdown paths behave consistently.",
            "Step 5: Make event-driven components lazily subscribe to the bus\n- For registries or managers that need event subscriptions (like a ServiceRegistry):\n  - In __init__, only store references to bus and loop; do not subscribe yet.\n  - Add a field (e.g., _async_unsub_call_event = None) to track subscription state.\n  - In an async method that is guaranteed to be called in the loop (such as async_register), check the field:\n    - If None, call bus.async_listen to subscribe and store the unsubscribe callback.\n  - This avoids cross-thread/event-loop calls in the constructor.",
            "Step 6: Lazily initialize async resources like HTTP sessions\n- Replace eager creation of aiohttp.ClientSession or similar resources in __init__ with a lazy property:\n  - Initialize a private attribute (e.g., self._websession = None).\n  - Implement a @property def websession: that:\n    - If self._websession is None, creates aiohttp.ClientSession(loop=self.loop) and stores it.\n    - Returns self._websession.\n- In your shutdown coroutine (async_stop or equivalent):\n  - If self._websession is not None, await self._websession.close().\n  - Set the attribute to None if necessary.\n- This ensures the resource is only created when needed and is properly closed.",
            "Step 7: Use executors for blocking operations, including in tests\n- Audit code that runs during startup or fixture setup for blocking calls (disk IO, network IO, heavy computations, module loading).\n- Offload these calls to an executor using loop.run_in_executor:\n  - Example: yield from loop.run_in_executor(None, loader.prepare, hass).\n- Keep the remaining setup logic running directly in the event loop thread.",
            "Step 8: Make async test fixtures reflect real async behavior\n- Update async test helpers to:\n  - Create core objects (e.g., HomeAssistant) directly in the event loop thread.\n  - Configure basic properties synchronously (config_dir, location, timezone, etc.).\n  - Only use run_in_executor for truly blocking work.\n- Avoid constructing core objects via run_in_executor or background threads solely to work around async-unsafe constructors.",
            "Step 9: Set and reuse a global loop exception handler\n- Implement an exception handler function that logs context and exceptions.\n- Set it on the event loop using loop.set_exception_handler.\n- For any components that create their own loops or run in a remote environment, apply the same handler to ensure consistent logging.",
            "Step 10: Validate behavior with tests and runtime checks\n- Add or update tests to:\n  - Ensure async_test_home_assistant (or equivalent fixtures) can create and use HomeAssistant without thread workarounds.\n  - Verify that services are correctly registered and that EVENT_CALL_SERVICE triggers the intended service callbacks after lazy subscription.\n  - Confirm that shutdown closes the HTTP session, stops worker pools, and stops the loop.\n- Run the test suite and exercise start/stop/restart flows manually to verify that signals, keyboard interrupts, and service-based shutdown all behave correctly."
        ]
    }
}
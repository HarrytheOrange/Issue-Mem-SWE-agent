{
    "search_index": {
        "description_for_embedding": "Refactor Home Assistant cloud preferences into a dedicated CloudPreferences class and add a new persisted google_allow_unlock preference that controls whether Google Assistant is allowed to unlock locks. Update WebSocket API and IoT handlers to use centralized cloud prefs and maintain backward compatibility for existing users.",
        "keywords": [
            "homeassistant.components.cloud",
            "cloud preferences",
            "CloudPreferences",
            "google_allow_unlock",
            "Google Assistant unlock",
            "Alexa enabled",
            "Google enabled",
            "websocket update_prefs",
            "persistent settings",
            "backwards compatibility",
            "iot handler",
            "feature flag"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the cloud integration for Home Assistant was refactored to centralize user preferences and add a new setting that controls whether Google Assistant may unlock locks. Previously, Alexa and Google enablement flags were stored directly via a generic storage Store in the cloud component (__init__.py), and Googleâ€™s `allow_unlock` was passed from the Google Assistant YAML configuration. The PR introduces a dedicated `CloudPreferences` class in `homeassistant/components/cloud/prefs.py`, which encapsulates all persistent cloud-related preferences: `alexa_enabled`, `google_enabled`, and the new `google_allow_unlock` flag. These preference keys were moved to constants (`PREF_ENABLE_ALEXA`, `PREF_ENABLE_GOOGLE`, `PREF_GOOGLE_ALLOW_UNLOCK`) in `cloud.const`.\n\nThe cloud component now instantiates `self.prefs = CloudPreferences(hass)` and calls `await self.prefs.async_initialize(not info)` in `async_start`. Initialization reads from storage; if no stored prefs exist (i.e., first run / backward compatibility case), it sets `alexa_enabled` and `google_enabled` based on whether the user is already logged in and defaults `google_allow_unlock` to False. The older inline storage logic and `Cloud.update_preferences` method were removed; instead, `CloudPreferences.async_update` is used throughout.\n\nThe WebSocket API for updating cloud preferences (`cloud/update_prefs`) was updated so that the schema and payload keys use the constants from `cloud.const`, and it now supports updating `google_allow_unlock` in addition to `alexa_enabled` and `google_enabled`. The response from the account status endpoint was also changed: instead of returning individual top-level booleans like `alexa_enabled` and `google_enabled`, it returns a `prefs` dictionary containing all preferences, including the new unlock flag.\n\nIoT handlers were updated to read preferences from `cloud.prefs` instead of from attributes directly on the cloud object. Alexa handling now checks `cloud.prefs.alexa_enabled`, and Google Actions handling checks `cloud.prefs.google_enabled`. When building the Google Assistant config, the `allow_unlock` parameter now comes from `cloud.prefs.google_allow_unlock` instead of a YAML config option. Tests were adjusted accordingly to mock `cloud.prefs._prefs`, verify the new `prefs` structure in account data, and ensure that the WebSocket preference update correctly flips all three flags including `google_allow_unlock`.\n\nOverall, the incident was not a runtime bug but a structural improvement: adding a new security-sensitive preference (Google unlock) required a more robust, centralized, and extensible preferences mechanism for the cloud integration, and the PR implemented this by introducing a dedicated preferences module, constant keys, async initialization, and consistent usage across the HTTP, WebSocket, and IoT layers.",
        "semantic_memory": "This change illustrates several generalizable patterns about managing user preferences and feature flags in a complex, asynchronous system:\n\n1. **Centralize preference management**: Instead of scattering preference reads/writes across the codebase, encapsulate them in a dedicated class (here, `CloudPreferences`) or module. This improves coherence, makes it easier to add new preferences, and reduces the risk of inconsistent behavior or duplication.\n\n2. **Use stable constant keys for persisted data**: Preference keys that are persisted to disk or sent over APIs should be defined as constants in a shared `const` module. This reduces typos, eases refactoring, and makes the set of user-facing preferences discoverable and self-documenting.\n\n3. **Backwards compatibility for new preferences**: When introducing new stored preferences in a production system, the code must handle the absence of data gracefully. This PR loads existing preferences and, if none exist (first run or older installation), seeds them with defaults inferred from existing state (e.g., whether the user is already logged in) and secure defaults for new flags (e.g., `google_allow_unlock` defaults to `False`). This avoids breaking existing installations and ensures safe behavior for new security-relevant settings.\n\n4. **Async initialization of configuration/state**: In async frameworks, objects that depend on I/O-backed state (e.g., disk storage) should have an explicit asynchronous initialization step (`async_initialize`) separate from `__init__`. This keeps constructors fast and synchronous while still allowing components to reliably access initialized state later in their lifecycle.\n\n5. **Expose preferences as a single structured object over APIs**: Instead of exposing many top-level booleans or individual fields across the HTTP/WebSocket boundary, returning a `prefs` dictionary makes the API more extensible. New preference fields can be added without changing the API shape dramatically, and clients can opt-in to new keys when they appear.\n\n6. **Security-sensitive features should be explicitly controlled**: Features like allowing voice assistants to unlock doors should be guarded by explicit, user-controlled flags with safe defaults. Moving `allow_unlock` into a persistent cloud preference of its own ensures consistent behavior and makes it clear that this is a distinct security setting that can be toggled centrally.\n\n7. **Tests should reflect and enforce the new abstraction**: When refactoring preferences into a dedicated class, tests must be updated to manipulate and assert against that abstraction (e.g., `cloud.prefs._prefs`) rather than old internal fields. This not only ensures functional correctness but also prevents regressions where code bypasses the new abstraction.",
        "procedural_memory": [
            "When adding or refactoring persistent preferences or feature flags in an asynchronous service, follow a structured approach:",
            "Step 1: Identify scattered preference logic",
            "Search for all locations where related preferences or flags are read and written (e.g., `cloud.STORAGE_ENABLE_ALEXA`, `cloud.STORAGE_ENABLE_GOOGLE`, or direct calls to storage APIs). Document those usages and their intended semantics (default values, when they are set, and how they are used).",
            "Step 2: Introduce a dedicated preferences abstraction",
            "Create a dedicated module (e.g., `prefs.py`) and a class (e.g., `CloudPreferences`) responsible for managing these preferences. The class should encapsulate:\n- the storage backend (e.g., `hass.helpers.storage.Store`),\n- an internal in-memory representation (e.g., `self._prefs`),\n- asynchronous initialization logic to load from disk,\n- an async update method that applies changes and persists them,\n- and property accessors for each preference for convenient, type-safe access.",
            "Step 3: Define and centralize preference keys and defaults",
            "Add constant keys for all preferences in a `const` module (e.g., `PREF_ENABLE_ALEXA`, `PREF_ENABLE_GOOGLE`, `PREF_GOOGLE_ALLOW_UNLOCK`). In the preferences class, define the default values for each preference, especially for new security-sensitive options, and use these defaults when no stored data is present.",
            "Step 4: Implement asynchronous initialization with backward compatibility",
            "In `async_initialize`, load existing preferences from storage. If no preferences are stored (first run or upgrade from older versions):\n- Derive sensible defaults based on existing state (e.g., already logged-in users keep their features enabled).\n- For new sensitive flags, default to the safe option (e.g., `google_allow_unlock = False`).\n- Store the resulting defaults in `self._prefs` so the rest of the system can rely on their presence.",
            "Step 5: Replace direct access with the new preferences interface",
            "Refactor all call sites to use the preferences abstraction:\n- Replace direct fields like `cloud.alexa_enabled` or local storage dictionaries with properties such as `cloud.prefs.alexa_enabled`.\n- In logic that checks whether features are enabled (Alexa/Google handlers, configuration building), read from the preferences class.\n- Update places that previously wrote preferences (e.g., WebSocket handlers) to call `CloudPreferences.async_update` instead of manipulating raw storage.",
            "Step 6: Update API schemas and payloads",
            "If preferences are exposed or modified over HTTP/WebSocket:\n- Update the input schema to use the centralized constant keys.\n- Add any new preferences (e.g., `google_allow_unlock`) as optional fields.\n- Adjust the response payload to return a structured `prefs` object rather than multiple scattered top-level fields. Ensure old clients can tolerate the new shape or provide transitional support if necessary.",
            "Step 7: Wire preferences into component lifecycle",
            "In the main component setup/entrypoint (e.g., `Cloud.async_start`), ensure `async_initialize` is awaited before any code relies on the preferences. Pass any necessary context (e.g., `logged_in` boolean) so initialization can choose proper defaults. Avoid doing I/O in the constructor; use an explicit initialization step instead.",
            "Step 8: Adjust tests to use the new abstraction",
            "Update unit tests and fixtures to:\n- Construct or patch `CloudPreferences` instances, populating `prefs._prefs` instead of older fields.\n- Assert against `cloud.prefs.as_dict()` or specific properties rather than legacy storage keys on the cloud object.\n- Add new tests that verify that: (a) default preferences are set correctly when no storage exists, (b) the WebSocket/API endpoints correctly update stored preferences including the new ones, and (c) feature behavior (like enabling/disabling Alexa or Google Actions, and allowing unlock) respects the new flags.",
            "Step 9: Verify behavior and migration",
            "Run the test suite and manually validate that:\n- Existing installations keep their behavior (e.g., Alexa/Google still enabled where they were enabled before),\n- New installations get safe defaults (e.g., Google unlock disabled),\n- The UI or frontend can read and update the `prefs` object and that those changes are immediately reflected in the runtime behavior of the system (e.g., disabling Google prevents Google IoT handling).",
            "Step 10: Document or communicate the new preference",
            "Even if not in this PR, ensure there is clear documentation or release notes indicating the new preference (e.g., `google_allow_unlock`), its default behavior, and how users can change it (e.g., via the cloud settings UI or API), especially for security-sensitive options like remote unlock."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor of the Home Assistant Freebox integration: migrate to config entries with a guided config flow and link step, centralize API access through a FreeboxRouter coordinator, add temperature and connection sensors, change device tracking to entity-based router tracking with dispatcher-driven updates, store auth tokens per-host under .storage, support multiple Freebox routers, and properly handle connection failures via ConfigEntryNotReady.",
        "keywords": [
            "Home Assistant",
            "Freebox",
            "config_flow",
            "config entries",
            "aiofreepybox",
            "device_tracker",
            "sensor",
            "router coordinator",
            "dispatcher",
            "async_setup_entry",
            "ConfigEntryNotReady",
            "multiple hubs",
            "token storage",
            "temperature sensors",
            "connection speed sensors"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the Freebox integration for Home Assistant was refactored from an old-style, YAML-and-platform-setup design into a modern, config-entry-based integration with a coordinated data model.\n\nOriginally, the integration used a single global Freepybox client (hass.data[\"freebox\"]), manual platform loading (async_load_platform), and simple download/upload speed sensors plus device_tracker support. Auth tokens were stored in a flat freebox.conf at the config root. There was no config flow; setup relied on YAML or mDNS discovery, and device_tracker logic was based on a custom DeviceScanner.\n\nThe refactor introduced several key changes:\n\n1. Config Flow & Setup\n- Added a config_flow for the Freebox integration, with a two-step process:\n  - user step: the user inputs host and port.\n  - link step: Home Assistant prompts the user to press the validation button on the Freebox to authorize the app. This step calls Freepybox.open(), then performs permission checks (system.get_config and lan.get_hosts_list). Different error conditions are handled:\n    - AuthorizationError => 'register_failed'.\n    - HttpRequestError => 'connection_failed'.\n    - Any other exception => 'unknown'.\n- The flow uses config entry unique_id set to the host to prevent duplicate configuration. Import and discovery sources reuse the same logic.\n- Strings and translations were added for the new steps and errors.\n\n2. Central Router Coordinator (FreeboxRouter)\n- Introduced a FreeboxRouter class to centralize all Freebox I/O and polling:\n  - Stores host, port, and obtains an aiofreepybox.Freepybox instance via a helper (get_api).\n  - get_api stores the token file under .storage/freebox/<slug-host>.conf using pathlib, enabling multiple Freebox routers without auth conflicts.\n  - On setup(), it opens the API connection; failure raises ConfigEntryNotReady (wrapping HttpRequestError), so HA can retry later.\n  - Fetches router system config once to populate name, MAC, firmware version, and builds a consistent device_info object.\n  - Maintains:\n    - devices: mapping MAC -> raw device dict enriched (router itself is injected as a pseudo-device with host_type 'router').\n    - sensors_temperature: mapping human-readable sensor name -> temperature value.\n    - sensors_connection: mapping connection keys (rate_up, rate_down, etc.) -> raw values.\n  - Has update_all() scheduled every 30 seconds via async_track_time_interval, which calls update_sensors() first then update_devices(). This ensures sensors and device trackers get up-to-date data.\n  - Signals changes via per-entry dispatcher signals (signal_device_new, signal_device_update, signal_sensor_update), so platforms can subscribe and update only when data changes.\n  - Exposes wifi and system methods for the switch platform and sensor setup.\n\n3. Device Tracker Refactor\n- The old DeviceScanner-based device_tracker implementation was removed.\n- Added a config_entry-based device_tracker platform:\n  - async_setup_entry uses the router from hass.data[DOMAIN][entry.unique_id] and a tracked set of MAC addresses.\n  - It registers callbacks on router.signal_device_new to add new entities and router.signal_device_update to refresh existing ones.\n  - FreeboxDevice became a ScannerEntity subclass:\n    - unique_id is the MAC address.\n    - name is derived from primary_name, with a fallback to DEFAULT_DEVICE_NAME ('Unknown device') if the name is blank or whitespace.\n    - is_connected is derived from the device's 'active' boolean.\n    - device_state_attributes are populated with timestamps (last_time_reachable, last_time_activity) where available, but the 'active' and 'reachable' flags are not redundantly duplicated in attributes anymore.\n    - device_info includes connections (MAC) and the vendor name.\n    - Icon is derived from host_type using a central DEVICE_ICONS mapping.\n  - Entities are non-polling and update via dispatcher; async_on_demand_update triggers state refresh on each router update signal.\n\n4. Sensor Refactor & Temperature Sensors\n- The sensor platform was rewritten to rely on the FreeboxRouter's sensor state instead of making its own API calls.\n- In the router:\n  - update_sensors() calls system.get_config() and connection.get_status().\n  - For each temperature sensor in syst_datas['sensors'], it stores the current sensor value keyed by the sensor's name in sensors_temperature.\n  - For each key in CONNECTION_SENSORS (rate_down, rate_up), it stores the raw value in sensors_connection.\n  - Router attributes (for the router device) include IPv4/IPv6, connection type, uptime, firmware version, and serial.\n- In the sensor platform:\n  - async_setup_entry uses the router's sensor mappings to create FreeboxSensor entities:\n    - Temperature sensors: keyed by the sensor name; uses TEMPERATURE_SENSOR_TEMPLATE and a name like 'Freebox <sensor name>'.\n    - Connection sensors: keyed by the connection keys and using CONNECTION_SENSORS definitions for name/icon/unit.\n  - FreeboxSensor objects rely on router.sensors[...] for their current value and apply unit-specific transformations (KB/s to kB/s). They are non-polling and update via router.signal_sensor_update.\n\n5. WiFi Switch Improvements\n- The switch platform now uses the router and config entries:\n  - FreeboxWifiSwitch holds the router, unique_id as '<router MAC> Freebox WiFi', and uses router.wifi.get_global_config()/set_global_config() to read and control WiFi state.\n  - Errors due to insufficient permissions (InsufficientPermissionsError) are logged with guidance to the documentation.\n  - It exposes the router's device_info for proper device registry grouping.\n\n6. Multiple Freebox Routers & YAML Migration\n- YAML config support was kept but adjusted to allow multiple Freebox routers:\n  - CONFIG_SCHEMA is now a list of FREEBOX_SCHEMA entries under 'freebox'.\n  - async_setup iterates over each YAML-defined router and starts a config flow via SOURCE_IMPORT for each (host, port) pair.\n- Discovery via mDNS uses SOURCE_DISCOVERY.\n- The config flow uses the host as the config entry unique_id, which ensures duplicates are rejected no matter the source (user, import, discovery).\n\n7. Token Storage & .coveragerc\n- Tokens are now stored per-host under .storage/freebox/<slugified-host>.conf, instead of a single freebox.conf at the config root. This prevents collisions when multiple routers are configured.\n- .coveragerc was updated to include the new router.py and other Freebox module files in coverage omissions where appropriate.\n\n8. Testing\n- Added test_config_flow.py with pytest and asynctest.CoroutineMock to cover:\n  - user, import, discovery flows.\n  - the link step, including success and failures from AuthorizationError, HttpRequestError, and InvalidTokenError.\n  - preventing duplicates based on unique_id.\n- A conftest fixture mocks pathlib.Path interactions for the tests.\n\nOverall, this PR modernized the Freebox integration to meet Home Assistant's silver/gold integration quality standards: config entries, proper discovery, unique IDs, device info, non-blocking I/O, coordinated updates, better error handling, multiple hub support, and more detailed sensors.",
        "semantic_memory": "This refactor embodies several generalizable patterns for building robust integrations in an async, config-entry-based platform like Home Assistant:\n\n1. Centralized Coordinator Object\n- Create a dedicated coordinator object (e.g., FreeboxRouter) per physical device/hub to own all API clients, connection details, and polling logic.\n- Expose structured data (devices, sensors, attributes) from this coordinator rather than having each platform call the API directly.\n- Schedule a single periodic update (using async_track_time_interval) and fan-out updates to entities via dispatcher signals. This reduces redundant I/O and keeps entity code simple.\n\n2. Robust Config Flow With Explicit Link Step\n- Use a multi-step config flow when device authorization requires user interaction, separating data input (host, port) from authorization (pressing a button on the device).\n- In the link step, perform both connectivity and permission checks; fail fast if credentials or permissions are insufficient.\n- Use precise exception handling (AuthorizationError, HttpRequestError, etc.) and map them to user-friendly error messages.\n- Use unique_id in config entries to avoid duplicate configurations, regardless of input source.\n\n3. Per-Host Token Storage Using .storage\n- For integrations that need long-lived tokens, store tokens per device/host using a structured namespace under the platform's storage key (e.g., .storage/freebox/slug(host).conf).\n- Avoid a single global token file; this enables multiple devices of the same type without cross-contamination of credentials.\n\n4. Device and Sensor Modeling\n- Represent router-level properties and attached devices in a uniform way:\n  - Treat the hub/router itself as a device in the device registry with a special host_type and attributes (IPv4, IPv6, uptime, firmware, serial).\n  - For child devices, normalize names (e.g., strip whitespace, default to 'Unknown device') and set unique IDs based on stable identifiers such as MAC addresses.\n- For sensors, store both metadata (name, unit, icon, device_class) and current value in the coordinator, letting entities focus only on presentation and transformation (e.g., unit conversion).\n\n5. Dispatcher-Driven, Non-Polling Entities\n- Prefer non-polling entities that subscribe to coordinator signals over per-entity polling. This is especially important for integrations with many entities (device trackers, sensors) to avoid overwhelming the device.\n- Use two types of signals when necessary: one for new entities (signal_device_new) and one for data updates (signal_device_update / signal_sensor_update).\n\n6. Handling Connection Failures in async_setup_entry\n- In async_setup_entry, encapsulate connection-opening logic and raise ConfigEntryNotReady if the external device is temporarily unavailable (e.g., HttpRequestError). This lets the platform retry instead of failing permanently.\n- Keep async_setup_entry thin; delegate connection management to the coordinator.\n\n7. YAML Migration to Config Entries\n- Even when migrating to config entries, keep old YAML support by wrapping it with calls to async_init(SOURCE_IMPORT) and allowing multiple entries via a list-based schema.\n- This provides a smooth migration path while aligning with the modern configuration model.\n\n8. Testing Asynchronous Flows and External APIs\n- Use CoroutineMock (or equivalent) to mock async calls like open(), system.get_config(), lan.get_hosts_list(), and connection.get_status().\n- Test each config flow path: initial form, successful link, and various error scenarios.\n- Mock filesystem/path interaction when the integration writes to .storage, so tests remain isolated from the real filesystem.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues or implement similar patterns in other integrations:",
            "Step 1: Introduce a coordinator object per device/hub",
            "- Define a class (e.g., MyDeviceCoordinator) that holds the API client, connection configuration, and state (devices, sensors, attributes).",
            "- In async_setup_entry, instantiate this coordinator, call its setup() method, and store it under hass.data[DOMAIN][entry.unique_id].",
            "- Let the coordinator schedule periodic updates and expose per-entry dispatcher signals for updates and new entities.",
            "",
            "Step 2: Migrate to config entries and config flows",
            "- Create a config_flow.py implementing ConfigFlow with a user step and any additional steps required (e.g., link/authorize).",
            "- In async_step_user, collect required fields (host, port, credentials) and set unique_id based on a stable identifier (host, MAC, serial).",
            "- Implement async_step_link if the device requires a physical or secondary authorization, using a temporary API client to test connectivity and permissions.",
            "- Translate API/transport exceptions into user-friendly error messages via the translations system.",
            "- Provide async_step_import and/or async_step_discovery to reuse core logic for other sources (YAML import, discovery).",
            "",
            "Step 3: Centralize token/file-based auth",
            "- Define a stable storage namespace under .storage/<domain>/, e.g., .storage/freebox/<slugified-host>.conf or a JSON file.",
            "- Implement a helper (e.g., get_api(hass, host)) to:\n  - Create the storage directory if missing.\n  - Construct the token file path for the given host.\n  - Return the configured API client using this token file.",
            "- Use this helper in both the config flow (for link step) and the coordinator.",
            "",
            "Step 4: Convert platform code to use the coordinator",
            "- Replace direct API calls in sensor/device_tracker/switch platforms with reads from the coordinator state (coordinator.devices, coordinator.sensors, etc.).",
            "- In async_setup_entry for each platform, grab the coordinator from hass.data and build entities from the coordinator's data structures.",
            "- Use dispatcher signals from the coordinator to handle updates:\n  - For sensors, subscribe to a signal_sensor_update and, on callback, schedule entity state updates.\n  - For device trackers, subscribe to both a 'new devices' signal to add new entities and an 'update' signal to refresh state.",
            "",
            "Step 5: Design entities as non-polling, dispatcher-driven",
            "- Set should_poll = False on entities that rely on the coordinator to push updates.",
            "- Implement an async_on_demand_update or similar callback that calls async_schedule_update_ha_state(True) when the coordinator signals new data.",
            "- Ensure that the coordinatorâ€™s update methods call async_dispatcher_send with appropriate signals.",
            "",
            "Step 6: Handle multiple device instances cleanly",
            "- In the integration config schema, allow a list of device configs (e.g., a list of Freebox routers).",
            "- For YAML configs, iterate over each entry and call hass.config_entries.flow.async_init(DOMAIN, context={'source': SOURCE_IMPORT}, data=<entry>).",
            "- Use unique_id in config entries to detect and abort duplicates from any source (user/import/discovery).",
            "",
            "Step 7: Handle connection failures with ConfigEntryNotReady",
            "- In the coordinator.setup() or async_setup_entry, catch connection-related exceptions (e.g., HttpRequestError).",
            "- Log the exception with context (host, port) and raise ConfigEntryNotReady to signal HA that the integration should be retried later.",
            "- Avoid returning False from async_setup_entry for transient network errors; that implies a non-retryable failure.",
            "",
            "Step 8: Write focused tests for config flow and coordinator",
            "- Use pytest fixtures and CoroutineMock to simulate successful API calls and different error cases.",
            "- For config flow tests, assert:\n  - The correct form 'step_id' is shown for user/import/discovery sources.\n  - Unique_id-based duplication is handled correctly (abort with reason 'already_configured').\n  - Each error branch in async_step_link is exercised.\n  - Successful linking produces a config entry with the expected title, data, and unique_id.",
            "- If the integration writes to the filesystem, mock pathlib.Path (or equivalent) to avoid touching the real disk.",
            "",
            "Step 9: Expose rich device and router entities",
            "- Register the hub/router as a device with proper identifiers, connections, manufacturer, name, firmware_version, and other attributes.",
            "- For child devices (e.g., host devices on a router), use stable identifiers (MAC) as unique IDs and provide vendor_name, last activity timestamps, and meaningful icons based on type.",
            "- Normalize device names, providing sensible defaults when names are missing or blank."
        ]
    }
}
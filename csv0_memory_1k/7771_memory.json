{
    "search_index": {
        "description_for_embedding": "Fixes multiple issues in Home Assistant's telegram_bot / notify.telegram integration: prevents double template rendering, allows templating in url/file/caption/latitude/longitude, reliably loads HA camera snapshots with retry logic and HTTP Basic/Digest auth, correctly sends files to multiple chat targets by reusing an in-memory buffer, improves inline keyboard YAML syntax handling, and corrects chat_id handling for callback queries and message edit services.",
        "keywords": [
            "home-assistant",
            "telegram_bot",
            "notify.telegram",
            "template rendering",
            "jinja2 template",
            "camera snapshot",
            "HTTP 500 retry",
            "HTTPDigestAuth",
            "HTTPBasicAuth",
            "inline keyboard",
            "multiple chat targets",
            "allowed_chat_ids",
            "callback_query",
            "chat_id validation",
            "file upload",
            "ByteIO reuse",
            "services.yaml schema"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, several regressions and missing features were discovered in the Home Assistant telegram_bot / notify.telegram integration after versions 0.45 and 0.45.1.\n\nObservations / Problems:\n1. Messages coming from notify.telegram caused templates to be rendered twice. Some fields were already plain strings when entering the telegram_bot service layer but were treated as templates again, leading to errors or unexpected output.\n2. Callback queries from inline keyboards could lack a top-level 'chat' object. The existing code assumed 'chat' was always present and enforced allowed_chat_ids on both 'from.id' and 'chat.id', causing KeyErrors or improperly rejecting valid callback queries.\n3. Inline keyboard syntax in YAML was cumbersome. Only a specific list-of-tuples structure or a simple comma-separated command string was supported, making configuration less user-friendly.\n4. Sending a file (photo/document) to multiple Telegram chats was broken. The previous implementation loaded the file once before looping over targets, and then reused the same stream for each send. Telegram's API consumes the stream, so subsequent sends saw EOF, causing failures. A later attempt to move load_data into the per-target loop introduced unnecessary repeated downloads.\n5. Camera snapshots from Home Assistant cameras (especially some generic IP cams) often returned HTTP 500 on the first few requests. The telegram_bot integration tried only once and silently failed to send images.\n6. The integration did not support templating for many useful fields (url, file, caption, latitude, longitude), so users couldn't leverage Home Assistant’s templating system for dynamic values in those parameters.\n7. The integration lacked support for HTTP digest authentication when fetching media from URLs that required it; only unauthenticated or basic authentication flows were effectively supported.\n8. Validation and normalization of chat_id targets had edge cases: editing messages or addressing a single chat_id as an integer could fail because the helper assumed an iterable target. Additionally, filtering of allowed targets was overly complex.\n\nCauses:\n- The template rendering helper assumed all non-strings were template objects and all strings needed rendering, leading to double rendering for already-rendered strings while missing correct type checks.\n- The message parsing logic assumed the presence of 'chat' in every incoming Telegram update. Callback queries can originate from inline keyboards where 'chat' may be absent or structured differently.\n- Inline keyboard construction logic only handled limited patterns (list of tuples or simple '/cmd' strings) and didn’t support the more expressive 'Label:/cmd' syntax mentioned in documentation.\n- File sending logic did not account for the fact that file-like objects are consumed by the Telegram client; reusing the same file object across multiple sends without resetting or cloning the buffer caused failures.\n- The HTTP request helper for loading photos/documents performed a single request with no retry or handling for camera endpoints that transiently return HTTP 500 or empty content.\n- Service schemas defined url, file, caption, latitude, and longitude as simple strings/floats rather than cv.template, preventing the templating engine from being applied at the schema level.\n- No parameter existed in the service schema to select HTTP digest authentication; and requests.get used raw (username, password) tuples, not HTTPDigestAuth, making it impossible to handle digest-only endpoints.\n- chat_id normalization did not handle the case where target was a single integer and not a list, and allowed_chat_ids filtering was more complicated than necessary.\n\nFixes / Changes:\n1. Template rendering:\n   - Introduced a helper _render_template_attr that checks if an attribute value is already a primitive (float, int, str). If so, it is passed through unchanged.\n   - If it is a Template object, hass is attached and async_render() is called inside a try/except block that catches TemplateError. In case of error, a log entry is produced and the raw template string is used instead of failing.\n   - Extended template rendering to additional attributes: ATTR_URL, ATTR_FILE, ATTR_CAPTION, ATTR_LONGITUDE, and ATTR_LATITUDE.\n   - Updated service schemas to use cv.template for url, file, caption (in send_photo/send_document), caption (edit_caption), longitude, and latitude (send_location), and message (answer_callback_query message).\n\n2. Callback queries and allowed_chat_ids:\n   - Modified _get_message_data to handle messages that do not include a 'chat' key. It now checks 'from.id' against allowed_chat_ids, and only additionally checks 'chat.id' if 'chat' exists in the payload.\n   - The returned data dictionary always includes ATTR_USER_ID, ATTR_FROM_FIRST, ATTR_FROM_LAST, and includes ATTR_CHAT_ID only if 'chat' is present.\n\n3. Inline keyboard improvements:\n   - Replaced the older _make_row_of_kb with _make_row_inline_keyboard (or _extract_inline_keyboard_buttons in earlier commits) that handles three forms:\n     * A list of tuples: [(text_b1, callback_data1), (text_b2, callback_data2), ...]\n     * A string of comma-separated commands: '/cmd1, /cmd2, /cmd3' (labels derived from uppercased command names without the leading '/')\n     * A string of comma-separated 'label:/cmd' pairs: 'Text1:/cmd1, Text2:/cmd2'\n   - InlineKeyboardMarkup is built from a list of rows, each produced by this helper.\n   - The service documentation example in services.yaml was updated to show the new 'Text button:/command' syntax as a recommended option.\n\n4. Sending files to multiple targets:\n   - Introduced load_data(url=None, filepath=None, ...) to avoid using 'file' as a variable name and to clarify that local files are specified by path.\n   - send_file() now calls load_data once to get a file-like object (file_content). If it succeeds, the code iterates over all target chat_ids and, for each, wraps file_content.read() in a new io.BytesIO instance and sends that as the file payload.\n   - After each send, file_content.seek(0) is called to reset the underlying buffer for the next target.\n   - If load_data returns None, an explicit error is logged indicating that the file could not be sent with the given kwargs.\n\n5. Reliable camera snapshot loading with retries:\n   - Enhanced load_data to implement retry logic when loading from a URL. The function now:\n     * Creates a requests.get parameter dict with timeout and optional auth.\n     * Tries up to num_retries (default 5) times.\n     * Logs warnings on non-OK HTTP status codes and on empty response content.\n     * Returns a BytesIO object when a non-empty body is retrieved.\n     * Logs a final warning if it cannot load any data after all retries.\n   - Exceptions (OSError, TypeError) are caught and logged, returning None instead of raising.\n   - This specifically addresses the issue where HA camera endpoints (especially generic ones) return HTTP 500 or empty bodies on first attempts.\n\n6. HTTP Basic / Digest authentication support:\n   - Added ATTR_AUTHENTICATION to the file sending schema, and accepts a string that can be compared to HTTP_DIGEST_AUTHENTICATION (from homeassistant.const).\n   - In load_data, when username/password are provided and authentication == HTTP_DIGEST_AUTHENTICATION, HTTPDigestAuth is used; otherwise, HTTPBasicAuth is used.\n   - Updated send_file to pass through the 'authentication' parameter from kwargs to load_data.\n\n7. Target chat_id handling and validation:\n   - Simplified _get_target_chat_ids:\n     * If target is not None, and is a single integer, it's wrapped into a list.\n     * The method filters target values against allowed_chat_ids.\n     * If valid chat_ids remain, it returns them; otherwise it logs a warning that targets are unallowed and falls back to the default user.\n   - This ensures single-int targets work correctly, including for edit-message services, and avoids type errors from assuming iterables.\n\nOverall, these changes fix the bugs reported in issues like \"Location information not being sent\", \"Cannot send specific jpg via telegram-bot\", and \"Telegram does not send photo if URL requires HttpDigestAuth\", while also making configuration more flexible and robust.",
        "semantic_memory": "This case highlights multiple generalizable patterns for building robust integrations between a home automation platform and a third-party messaging API.\n\n1. Template handling and double rendering:\n   - When a system uses template objects (e.g., Jinja2) in configuration, the boundary between 'template' and 'plain string' must be carefully maintained. Only objects that are known to be templates should be rendered; plain strings should be passed through unchanged.\n   - A safe pattern is: 'if isinstance(value, Template): render it; if it’s a primitive (str/int/float) treat it as final'.\n   - Always catch template rendering errors and fall back gracefully (e.g., using the raw template string) instead of letting an exception break the service call.\n   - Schema-level validation (e.g., declaring cv.template instead of cv.string) makes it easier to systematically handle templated fields.\n\n2. Handling partial / variant payloads from external APIs:\n   - External APIs like Telegram can deliver different event formats for different update types (messages vs callback queries). Code must handle optional fields and not assume uniform structure.\n   - Access to nested fields (like 'chat.id') must be guarded by existence checks to avoid KeyError and to behave correctly when some data is legitimately absent.\n   - Access control (allowed_chat_ids) may need to consider different identifiers ('from.id' vs 'chat.id') depending on the type of update.\n\n3. Reusing I/O buffers for multi-target sends:\n   - When sending the same binary payload to multiple recipients via an API that consumes a stream, you cannot reuse the same open stream without resetting or cloning it.\n   - A common pattern is to either:\n     * Read the file once into memory (e.g., BytesIO) and create new BytesIO objects per send, resetting the underlying buffer as needed, or\n     * Reopen the file from disk for each send.\n   - Using a single in-memory buffer that is reset between sends is an efficient and robust approach for moderate file sizes.\n\n4. Robust HTTP fetching with retry logic:\n   - External devices such as IP cameras can be flaky, returning transient HTTP 500 or empty content. Integrations should implement retry logic with sensible limits.\n   - Retry loops should:\n     * Centralize request parameters (timeout, auth) outside the loop.\n     * Log when non-success status codes or empty content occur so that operators can diagnose device issues.\n     * Fail cleanly after a maximum number of retries instead of hanging or flooding.\n\n5. Authentication abstraction:\n   - When supporting multiple authentication methods (e.g., Basic and Digest), don’t hard-code a single approach. Instead, accept a parameter (like 'authentication') and choose the appropriate auth handler (HTTPBasicAuth vs HTTPDigestAuth) at runtime.\n   - Keep authentication selection close to the HTTP client call, but expose the configuration in the user-facing schema so that end users can choose without code changes.\n\n6. Configurable inline UI elements:\n   - For chatbots, building inline keyboards from configuration is common. A flexible parser that accepts multiple forms (simple command strings, label-command pairs, or explicit tuples) significantly improves usability.\n   - Use a clear, documented mapping from human-friendly syntax (\"Text:/cmd\") to the underlying API objects (InlineKeyboardButton with label and callback_data).\n\n7. Normalizing input types for IDs and targets:\n   - Services that accept identifiers (like chat_ids) should normalize different forms (single int, list of ints, maybe strings) into a uniform internal representation.\n   - After normalization, apply validation (e.g., check against allowed IDs) and maintain a safe fallback (e.g., default user) if validation fails.\n\n8. Naming and readability:\n   - Avoid shadowing built-in names like 'file', which makes code harder to reason about and can cause subtle issues. Use descriptive names like 'filepath' or 'file_content' instead.\n\nTogether, these patterns demonstrate how to harden an integration: clearly separate templating concerns, robustly parse and validate external API payloads, make HTTP access resilient and pluggable (auth and retries), and normalize user inputs early.",
        "procedural_memory": [
            "When debugging and fixing issues in a messaging integration that handles templated data, external HTTP media loads, and multiple recipients, follow these steps:",
            "Step 1: Identify the failing paths and data types.",
            "- Reproduce the problem using the documented configurations (e.g., sending location, photo, or document to multiple targets).",
            "- Log incoming service data and external API payloads to see the actual structure (e.g., message vs callback_query, presence/absence of 'chat' field).",
            "- Confirm whether fields like url, file, caption, latitude, longitude are intended to support templating and whether they are declared as such in the schema.",
            "Step 2: Fix template rendering behavior.",
            "- Check how templated fields are declared in your validation/schema: change cv.string / float / int fields that should be templates to cv.template.",
            "- Introduce a helper function for rendering attributes that:",
            "  - Treats plain primitives (str, int, float) as already-rendered and returns them unchanged.",
            "  - Detects template objects, attaches the runtime context (e.g., hass), and calls their render/async_render method.",
            "  - Catches template rendering errors and logs them, falling back to the raw template string instead of raising.",
            "- Apply this helper uniformly to all templatable attributes (message, title, url, file, caption, longitude, latitude, etc.) at the entry point of the service.",
            "Step 3: Harden payload parsing for external updates (e.g., Telegram updates).",
            "- Inspect the variety of update types you receive (regular messages, callback queries, etc.) and determine which fields are optional.",
            "- Update your parsing logic to guard against missing keys, e.g.:",
            "  - Check `if 'chat' in msg_data` before accessing msg_data['chat']['id'].",
            "  - Build your internal data dict with mandatory fields (like user id, names) and add optional fields (chat_id) only when present.",
            "- Adjust access control so that allowed IDs are validated correctly even if some fields are optional (e.g., validate 'from.id', and 'chat.id' only when available).",
            "Step 4: Normalize and validate target identifiers.",
            "- Implement a helper to normalize target IDs:",
            "  - If target is None, fallback to a default recipient.",
            "  - If target is a single int, wrap it in a list.",
            "  - If target is iterable, normalize and filter it against allowed IDs.",
            "  - Log a warning when none of the provided targets are allowed and default to a safe fallback.",
            "- Use this helper consistently across send/edit services to avoid type-related bugs.",
            "Step 5: Correct multi-target file sending behavior.",
            "- Recognize that file-like objects are consumed by the sending client; re-sending them as-is will fail unless you reset or duplicate the buffer.",
            "- Implement a function (e.g., load_data) that returns a file-like object either from a URL (BytesIO) or a local path (open(filepath, 'rb')). Avoid using 'file' as a variable name.",
            "- In your send_file function:",
            "  - Call load_data once to get file_content.",
            "  - If file_content is None, log an error and abort gracefully.",
            "  - For each chat_id in normalized targets:",
            "    - Wrap file_content.read() in a new BytesIO and pass that to the messaging API.",
            "    - After each send, call file_content.seek(0) to reset the buffer.",
            "- This ensures that the same media can be sent to multiple recipients reliably without repeated downloads.",
            "Step 6: Implement robust HTTP fetching with retries and authentication.",
            "- Encapsulate HTTP fetching logic (e.g., for camera snapshots) in a dedicated function that:",
            "  - Accepts url, username, password, and an authentication mode (e.g., basic vs digest).",
            "  - Builds a requests.get parameter dict, including timeout and auth set as either HTTPBasicAuth or HTTPDigestAuth based on the authentication mode.",
            "  - Loops up to a limited num_retries, logging warnings on non-OK status codes and empty content.",
            "  - Returns a BytesIO object if a non-empty response is obtained; otherwise, logs a final warning and returns None.",
            "  - Catches filesystem/network-related exceptions and logs them.",
            "- Expose an 'authentication' option in the service schema and pass it down to the HTTP helper so users can choose between basic and digest.",
            "Step 7: Improve inline keyboard configuration parsing.",
            "- Decide on user-friendly syntax for inline keyboards (e.g., '/cmd1, /cmd2' and 'Label1:/cmd1, Label2:/cmd2') and document it.",
            "- Implement a parser that:",
            "  - If the row is a string, splits by commas; for each segment:",
            "    - If it contains ':/', treat it as 'label:/command'.",
            "    - Otherwise, treat it as '/command' with a label derived from the command name.",
            "  - If the row is a list of tuples, directly convert each tuple to an inline button.",
            "- Use this parser to build the InlineKeyboardMarkup object for messages.",
            "Step 8: Validate with integration-level tests and logging.",
            "- Exercise all affected use cases: templated locations, HA camera snapshots, file/document sending to multiple chats, callback queries from inline keyboards, and message editing.",
            "- Use debug-level logging around key operations (template rendering, URL fetch, target selection, file sending) to verify that data flows as expected and to aid future diagnosis.",
            "- Once verified, keep critical warnings and error logs to help users diagnose configuration and device issues in production."
        ]
    }
}
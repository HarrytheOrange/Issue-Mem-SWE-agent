{
    "search_index": {
        "description_for_embedding": "Home Assistant HomeKit integration: add support for binary_sensor and device_tracker entities by mapping their device_class to appropriate HomeKit Binary Sensor services (CarbonDioxideSensor, CarbonMonoxideSensor, LeakSensor, MotionSensor, OccupancySensor, ContactSensor, SmokeSensor). Defaults to OccupancySensor when no device_class is matched. Includes new constants, a generic BinarySensor accessory class, and comprehensive tests for service/characteristic assignment and state-to-detected mapping.",
        "keywords": [
            "Home Assistant",
            "HomeKit",
            "binary_sensor",
            "device_tracker",
            "BinarySensor accessory",
            "device_class mapping",
            "ContactSensor",
            "MotionSensor",
            "OccupancySensor",
            "LeakSensor",
            "SmokeSensor",
            "CarbonDioxideSensor",
            "CarbonMonoxideSensor",
            "ATTR_DEVICE_CLASS",
            "STATE_ON",
            "STATE_HOME",
            "homeassistant.components.homekit.type_sensors",
            "homeassistant.components.homekit.const",
            "get_accessory"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant HomeKit integration lacked support for exposing binary_sensor and device_tracker entities as HomeKit accessories. Users wanted binary sensors (e.g., doors, motion, smoke, leaks) and presence tracking to appear correctly in HomeKit without needing manual templates.\n\nThe fix introduced a new generic BinarySensor HomeKit accessory type and wired it into the accessory factory. In homeassistant/components/homekit/__init__.py, get_accessory was updated so that entities in the 'binary_sensor' or 'device_tracker' domains are logged and instantiated using the TYPES['BinarySensor'] class.\n\nIn homeassistant/components/homekit/const.py, the developer added new HomeKit service and characteristic constants: services for CarbonDioxideSensor, CarbonMonoxideSensor, ContactSensor, LeakSensor, MotionSensor, OccupancySensor, and SmokeSensor, and corresponding characteristics like CarbonDioxideDetected, CarbonMonoxideDetected, ContactSensorState, LeakDetected, MotionDetected, OccupancyDetected, and SmokeDetected. They also defined device_class string constants (co2, gas, moisture, motion, occupancy, opening, smoke) so that device classes could be mapped robustly.\n\nIn homeassistant/components/homekit/type_sensors.py a BINARY_SENSOR_SERVICE_MAP dictionary was introduced, mapping each binary_sensor device_class to a specific pair of HomeKit (service, characteristic). For example:\n- co2 -> (CarbonDioxideSensor, CarbonDioxideDetected)\n- gas -> (CarbonMonoxideSensor, CarbonMonoxideDetected)\n- moisture -> (LeakSensor, LeakDetected)\n- motion -> (MotionSensor, MotionDetected)\n- occupancy -> (OccupancySensor, OccupancyDetected)\n- opening -> (ContactSensor, ContactSensorState)\n- smoke -> (SmokeSensor, SmokeDetected)\n\nA new @TYPES.register('BinarySensor') class BinarySensor(HomeAccessory) was implemented. During __init__, it fetches the entity's device_class from hass.states, looks it up in BINARY_SENSOR_SERVICE_MAP, and if no match is found, defaults to using the occupancy mapping. It then preloads the appropriate HomeKit service and characteristic and initializes char_detected to 0 (not detected).\n\nThe update_state method translates Home Assistant states into the HomeKit boolean detected value: it treats STATE_ON or STATE_HOME as detected = True (1) and anything else (e.g., STATE_OFF, STATE_NOT_HOME) as detected = False (0). This allows both traditional binary_sensors and device_trackers (home/not_home) to function as occupancy-like HomeKit sensors.\n\nTests were added and refined. In tests/components/homekit/test_get_accessories.py, new tests verify that a binary_sensor with device_class 'opening' and a device_tracker entity both route to the BinarySensor type via get_accessory. In tests/components/homekit/test_type_sensors.py, the test suite was extended to:\n- Confirm TemperatureSensor and HumiditySensor behavior still works.\n- Test the BinarySensor behavior for a specific 'opening' device: verify initial category, AID, and that char_detected toggles correctly for STATE_ON/OFF/HOME/NOT_HOME.\n- Add a separate test to iterate over all entries in BINARY_SENSOR_SERVICE_MAP and assert that, for each device_class, the BinarySensor accessory uses the expected HomeKit service and characteristic names.\n\nOver a couple of commits, the tests were refactored to respect style guidelines (line length, indentation) and split into more focused tests to improve speed while increasing coverage. The final result is that binary_sensor and device_tracker entities are now automatically exposed to HomeKit as appropriate Binary Sensor accessories with sensible defaults and robust test coverage.",
        "semantic_memory": "This change illustrates a general pattern for integrating a heterogeneous home automation platform with a structured external API like HomeKit:\n\n1. **Centralized type mapping based on metadata**: When a platform has a generic domain (e.g., `binary_sensor`) but supports device subclasses via attributes like `device_class`, the integration should centralize the mapping from those internal classes to external types. Here, BINARY_SENSOR_SERVICE_MAP maps Home Assistant device_class values to HomeKit service and characteristic tuples.\n\n2. **Graceful default behavior**: Not all entities will have a specific device_class. Providing a sensible default (here, defaulting to an OccupancySensor mapping) ensures that entities like generic binary_sensors or device_trackers still appear usefully in the external system without complex user configuration.\n\n3. **Single generic adapter class per domain**: Instead of creating multiple accessory classes for every binary sensor subtype, a single BinarySensor accessory is parameterized with the correct HomeKit service/characteristic based on device_class. This reduces code duplication and makes future extension as simple as adding to the mapping.\n\n4. **State normalization**: Integrations often need to map multiple internal states onto a simpler external representation. Here, home-assistant states like STATE_ON and STATE_HOME are considered equivalent for HomeKit’s boolean `Detected` characteristics, while STATE_OFF and STATE_NOT_HOME map to not detected. This is an example of normalizing rich internal state into a simplified API contract.\n\n5. **Robust testing across mappings**: When a mapping table is central to behavior, tests should iterate over its entries and assert that each mapping produces the correct external service and characteristic. This ensures future edits to the mapping or constants don’t silently break integrations.\n\n6. **Separation of concerns in tests**: Splitting tests into (a) behavior/state-change tests and (b) mapping/configuration tests leads to faster, clearer test suites and easier debugging.\n\n7. **Use of constant definitions**: Defining device_class strings and HomeKit service/characteristic names as constants in a shared module avoids magic strings and keeps mapping logic maintainable and searchable.\n\nOverall, the change demonstrates best practices for extending an integration layer: use metadata-driven dispatch, establish defaults, normalize state semantics, and cover mapping logic comprehensively with tests.",
        "procedural_memory": [
            "When an entity type in a home automation platform is not showing up correctly in an external integration (e.g., HomeKit), systematically add support using a mapping-based approach.",
            "Step 1: Identify the missing domains and their metadata.\n- Determine which domains (e.g., `binary_sensor`, `device_tracker`) are not currently handled in the integration.\n- Inspect the entities' attributes (such as `ATTR_DEVICE_CLASS`) to see how they classify subtypes.",
            "Step 2: Update the accessory factory/dispatch logic.\n- Locate the central place where entities are mapped to integration-specific types (e.g., `get_accessory` in the HomeKit component).\n- Add conditional branches for the new domains (e.g., `elif state.domain == 'binary_sensor' or state.domain == 'device_tracker':`).\n- Ensure the branch returns a generic adapter/accessory class that can handle multiple subtypes (e.g., `TYPES['BinarySensor']`).",
            "Step 3: Define external service and characteristic constants.\n- In a shared constants module, add definitions for any new external services and characteristics you need (e.g., `SERV_CONTACT_SENSOR`, `CHAR_CONTACT_SENSOR_STATE`, etc.).\n- If using internal device classification, also define those device_class string constants (`DEVICE_CLASS_MOTION`, `DEVICE_CLASS_SMOKE`, etc.) for reuse and to avoid magic strings.",
            "Step 4: Implement a mapping from internal device classes to external types.\n- Create a dictionary (e.g., `BINARY_SENSOR_SERVICE_MAP`) mapping each internal device_class to a tuple of (service, characteristic) used by the external system.\n- Example: `{DEVICE_CLASS_MOTION: (SERV_MOTION_SENSOR, CHAR_MOTION_DETECTED), ...}`.\n- Decide on a default mapping for unknown or missing device_class values (e.g., map to OccupancySensor or another reasonable generic type).",
            "Step 5: Implement or extend the generic accessory/adapter class.\n- Create or modify a generic class (e.g., `BinarySensor(HomeAccessory)`) that:\n  - Reads the entity’s `ATTR_DEVICE_CLASS` from `hass.states.get(entity_id).attributes`.\n  - Looks up the appropriate (service, characteristic) in the mapping, falling back to the default when not found.\n  - Calls the helper to preload the chosen service (`add_preload_service(self, service_name)`).\n  - Stores the primary characteristic (e.g., `char_detected`) and initializes it to an appropriate default (typically 0 for not detected).",
            "Step 6: Normalize internal states to external characteristic values.\n- Implement `update_state` to translate internal state strings to the external characteristic format.\n- For binary-like sensors, decide which internal states correspond to `True` vs `False` (e.g., treat `STATE_ON` and `STATE_HOME` as detected, and `STATE_OFF` and `STATE_NOT_HOME` as not detected).\n- Handle `new_state is None` defensively by early return to avoid errors on removal or startup.",
            "Step 7: Write tests for accessory creation and state mapping.\n- In tests for the factory (e.g., `test_get_accessories.py`):\n  - Patch the TYPES registry to a mock class for the new accessory type.\n  - Create a fake State object for each new domain (`binary_sensor`, `device_tracker`) and assert that `get_accessory` instantiates the correct type.\n- In tests for the accessory (e.g., `test_type_sensors.py`):\n  - Initialize the Home Assistant test instance and set an initial state with the correct `ATTR_DEVICE_CLASS`.\n  - Instantiate the accessory and call `run()` if needed.\n  - Assert AID, category, and initial characteristic values.\n  - Change the entity’s state through the various expected values (on/off/home/not_home) and assert that the characteristic toggles as expected.",
            "Step 8: Test the mapping table comprehensively.\n- Create a dedicated test that iterates over all entries in your device_class-to-service map (e.g., `for device_class, (service, char) in BINARY_SENSOR_SERVICE_MAP.items():`).\n- For each entry:\n  - Set a test entity’s state with that device_class.\n  - Instantiate the accessory.\n  - Assert that `acc.get_service(service).display_name == service` and `acc.char_detected.display_name == char`.\n- This protects against regressions if constants or mappings change.",
            "Step 9: Clean up and optimize tests.\n- Ensure tests follow style guidelines (line length, indentation).\n- Split large tests into smaller ones focusing separately on behavior (state changes) and configuration (mapping correctness) to improve speed and maintainability.",
            "Step 10: Run the full test suite and linters.\n- Execute the targeted tests (e.g., `tox -e py36 -- tests/components/homekit/test_type_sensors.py` and `tests/components/homekit/test_get_accessories.py`).\n- Run the project’s linting and formatting tools.\n- Only merge changes once all tests and lint checks pass, ensuring the integration behaves correctly for all supported device classes."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant history_stats sensor was incorrectly reporting an initial value of 0 on startup and after restart, causing a spurious 0 data point in history graphs. The fix initializes internal value/count to None instead of 0 and returns STATE_UNKNOWN (None) until the first real computation, and avoids exposing attributes before a valid value exists.",
        "keywords": [
            "home-assistant",
            "history_stats",
            "sensor",
            "initial state",
            "restart issue",
            "spurious zero",
            "STATE_UNKNOWN",
            "time series graph",
            "entity history",
            "uninitialized value"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant history_stats sensor component always initialized its internal metrics (value and count) to 0. On system startup or restart, before any history-based computation was performed, the entity would publish a state of '0'. This produced an extra 0 data point at the beginning of the time series, which distorted graphs and analytics, especially when the actual computed value should have been a non-zero duration or count.\n\nThe root cause was that the sensor exposed an initial numeric state (0) even though no calculation had been done; the code path treated the default as a valid measurement rather than 'no data yet'. When Home Assistant restarted, the sensor wrote this 0 state right before writing the real computed value, leading to a fake drop to 0 in the graph.\n\nThe fix changed the initialization and state handling in `HistoryStatsSensor`:\n- `self.value` and `self.count` are initialized to `None` instead of `0`.\n- The `state` property now returns `None` (which Home Assistant maps to `STATE_UNKNOWN`) if `value` or `count` is `None`, ensuring no misleading 0 appears before the first real computation.\n- The `device_state_attributes` property returns an empty dict if `value` is `None`, so no misleading attributes are exposed.\n\nTests were updated accordingly:\n- The setup test now asserts the initial state is `STATE_UNKNOWN` instead of `'0'`.\n- In the measure test, the sensor case that previously returned 0 now returns `None`, matching the new semantics of 'no data yet' instead of 'zero value'.\n\nThis resolved the issue where history graphs showed a spurious 0 point at restart (linked to issue #12629).",
        "semantic_memory": "This fix highlights an important pattern in stateful, time-series, or history-based systems: uninitialized or not-yet-computed values must be clearly distinguished from legitimate zero values.\n\nKey principles:\n1. **Use explicit 'unknown' states for uninitialized metrics**: Initializing numeric fields to 0 can cause downstream consumers (graphs, logs, alerts) to interpret them as valid measurements. Instead, use `None`, `null`, or a framework-specific 'unknown' sentinel (e.g., Home Assistant's `STATE_UNKNOWN`) until the first valid computation.\n\n2. **Prevent premature exposure of attributes**: If a main value is not yet computed, attributes derived from that value (e.g., formatted durations, counts) should not be exposed. Returning an empty attribute dict (or analogous behavior) avoids inconsistent or misleading UI/state.\n\n3. **Separate 'no data' vs 'zero data'**: In statistics and monitoring, '0' is a meaningful value (e.g., 0 seconds on, 0 events). Conflating 'no data yet' with '0' corrupts graphs, triggers false alarms, and confuses users. A distinct 'unknown/unavailable' state improves correctness and UX.\n\n4. **Tests should encode initialization semantics**: Unit tests should explicitly assert the initial state of components, especially for sensors and time-series producers. If a system's contract is that a sensor starts as 'unknown' until computed, tests must enforce this to prevent regressions.\n\n5. **Restart behavior is part of the API**: When services restart, their entities' initial states and transitions are observable. Design and testing must include restart scenarios to avoid spurious state changes (e.g., brief 0 values, flapping states) that impact history and automations.\n\nThis pattern applies broadly to metrics collectors, monitoring agents, IoT sensors, and any component that exposes derived or historical values.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and observe the symptom\n- Restart the service or application (e.g., Home Assistant) and monitor the affected sensor/entity.\n- Inspect graphs or logs for sudden 0 values or other default primitives immediately after startup.\n- Confirm whether the extra data point only appears around restarts or also during normal operation.",
            "Step 2: Inspect initialization code\n- Locate the class or function that defines the sensor/metric (e.g., `HistoryStatsSensor`).\n- Check how internal state variables (e.g., `value`, `count`, `total`, `duration`) are initialized.\n- Look for default values like 0, empty string, or false that might be used before any real computation.",
            "Step 3: Trace the state exposure logic\n- Find the property or method that exposes the state to the framework or API (e.g., `state` property in a sensor entity).\n- Determine under what conditions this method is called (on startup, on update callbacks, on timers).\n- Verify if it returns the default-initialized values even when no computation has run yet.",
            "Step 4: Differentiate uninitialized from real zero\n- Decide what the representation for 'no data yet' should be in your system (e.g., `None`, `null`, `NaN`, `STATE_UNKNOWN`, `UNAVAILABLE`).\n- Update internal fields to initialize to this 'unknown' representation instead of a valid numeric or boolean value.\n- For Home Assistant specifically, ensure the `state` property returns `None` initially so the state becomes `STATE_UNKNOWN` in the state machine.",
            "Step 5: Guard attribute and formatting logic\n- Review attribute builders or formatting helpers (e.g., `device_state_attributes`, helper.pretty_duration()).\n- Add guards so they only operate when the main value is present (not None/unknown).\n- If the value is absent, return empty attributes or a safe default representation rather than computing on a null value.",
            "Step 6: Add or update tests to capture behavior\n- Write a test that sets up the component and immediately inspects its state; assert it is 'unknown' (or equivalent), not 0.\n- Add tests for the first computation cycle: after simulating history or measurements, assert that the state transitions from unknown to the correct numeric value.\n- Add regression tests for restart scenarios if your framework allows simulating restarts or reloading components.",
            "Step 7: Verify graph and history behavior\n- After applying the fix, restart the system and inspect graphs/logs again.\n- Confirm that there is no spurious 0 point at startup and that the first data point reflects the first real computation.\n- Check any dependent templates, automations, or clients that rely on the sensor to ensure they handle 'unknown' gracefully.",
            "Step 8: Document and communicate semantics\n- Update documentation to clarify that the sensor/entity will be 'unknown' until a valid value is computed.\n- If relevant, inform users that this is expected behavior and preferable to emitting incorrect zeros.\n- Note this pattern in internal coding guidelines for future sensors and metrics collectors."
        ]
    }
}
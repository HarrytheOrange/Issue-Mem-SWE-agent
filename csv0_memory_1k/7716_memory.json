{
    "search_index": {
        "description_for_embedding": "Fixes a bug where the Jinja2 `random` template filter in Home Assistant cached its result across renders. Introduces a custom context-dependent `random` filter that calls `random.choice` on each render, ensuring a new random value is selected every time the template is rendered. Adds a unit test that patches `random.choice` to confirm the filter is executed per render.",
        "keywords": [
            "template filter caching bug",
            "Jinja2 random filter",
            "Home Assistant template",
            "non-deterministic template output",
            "contextfilter",
            "random.choice",
            "TemplateEnvironment",
            "ENV.filters['random']",
            "test_template.py",
            "mock random.choice",
            "render evaluated each time",
            "deterministic vs nondeterministic filters"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's template system reused Jinja2's built-in `random` filter, which caused random selections to be cached and not reevaluated on subsequent template renders. Users expected `{{ [1, 2] | random }}` to potentially yield different values across renders, but due to Jinja2's internal caching mechanisms for pure filters, the value was chosen once and reused. The fix introduced a custom filter `random_every_time` defined with `@contextfilter` that calls Python's `random.choice(values)` directly. This filter was then registered as the environment's `random` filter via `ENV.filters['random'] = random_every_time`, replacing the default Jinja implementation and making the filter context-dependent so it is not cached. A new test `test_random_every_time` was added: it patches `random.choice` using `@patch.object(random, 'choice')`, renders the template twice (`'{{ [1,2] | random }}'`), first with `random.choice` returning 'foo' and then 'bar', and asserts that the two renders yield 'foo' and 'bar' respectively. This test fails with the old cached behavior and passes after the fix, demonstrating that the random filter runs on every render.",
        "semantic_memory": "Template engines often assume that filters are pure, deterministic functions and may cache their results to improve performance. When non-deterministic operations (randomness, time-based values, external state) are implemented as standard filters without signaling context dependence, caching can lead to unexpected behavior where subsequent renders reuse stale results. In Jinja2, using `@contextfilter` (or more modern `@pass_context`) marks filters as context-aware and can prevent certain caching optimizations, ensuring they run per render or per context. For random-like behavior in templates, the filter should be context-dependent and should call randomness functions (e.g., `random.choice`) at render time, not at import time or during template compilation. Additionally, verification of non-deterministic behavior is best done by controlling the source of randomness via mocking (patching `random.choice`) to turn the behavior into deterministic, testable scenarios. Overriding default library filters globally (e.g., `ENV.filters['random'] = custom_random`) is an effective strategy when you must adapt third-party semantics to the expectations of your application.",
        "procedural_memory": [
            "To diagnose and fix issues where template filters with random or dynamic behavior appear to be cached or not updating between renders:",
            "Step 1: Reproduce the symptom",
            "Render the template multiple times, especially one that uses non-deterministic behavior, such as `{{ [1,2] | random }}`. Confirm that the value does not change across renders even when you expect randomness or other dynamic behavior.",
            "Step 2: Inspect template engine filter behavior",
            "Review the template engine documentation (e.g., Jinja2) for how filters are executed and cached. Identify whether the problematic filter is a built-in and if it assumes purity or can be optimized/cached.",
            "Step 3: Check filter registration and environment configuration",
            "Look at where the template environment is created and filters are registered (e.g., `ENV = TemplateEnvironment(...)`). Check the mapping `ENV.filters` for the filter in question to see if a custom override or the default implementation is used.",
            "Step 4: Decide on context awareness",
            "If the filter performs non-deterministic or context-dependent work (random numbers, timestamps, stateful lookups), implement it as a context-dependent filter. In Jinja2, decorate it with `@contextfilter` (or `@pass_context` in newer versions) so that the engine treats it as context-dependent and avoids reusing cached results inappropriately.",
            "Step 5: Implement a custom filter that performs the random/dynamic work at render time",
            "Define a function such as `@contextfilter def random_every_time(context, values): return random.choice(values)` (or similar logic). Register it by assigning `ENV.filters['random'] = random_every_time` or under the desired filter name, overriding the default filter implementation.",
            "Step 6: Add tests that control the non-determinism",
            "Write a unit test that patches the source of randomness (e.g., using `unittest.mock.patch.object(random, 'choice')`). Render the template multiple times, changing the mocked return value between renders, and assert that the template output changes accordingly. This converts non-deterministic behavior into a deterministic, verifiable test case.",
            "Step 7: Verify old vs new behavior",
            "Run the test suite and make sure the new tests fail with the old implementation and pass with the custom context-dependent filter to confirm the fix is effective and properly captured by tests.",
            "Step 8: Review for broader implications",
            "Scan for other filters in the codebase that may also be non-deterministic (e.g., time-based, external API lookups) and ensure they are implemented as context-aware or otherwise marked so they are not cached unexpectedly.",
            "Step 9: Document semantic changes",
            "If overriding a standard library filter (like Jinja2â€™s `random`), document in your project that the filter semantics differ from the default engine behavior (e.g., random evaluated on each render) so other developers know what to expect."
        ]
    }
}
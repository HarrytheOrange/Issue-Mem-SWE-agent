{
    "search_index": {
        "description_for_embedding": "Home Assistant MQTT binary_sensor gained an off_delay option to better support stateless sensors (e.g., PIR, door bell). Implementation uses a single debounced async timer (async_call_later) to automatically turn the sensor off after N seconds, cancelling any existing timer when a new ON event arrives. Configuration validates off_delay as a non-negative integer number of seconds, and constants are kept local to the integrations instead of in the global const module. Tests were added and fixed to avoid leaving config storage files behind by mocking config entry saving.",
        "keywords": [
            "home-assistant",
            "MQTT binary_sensor",
            "off_delay",
            "stateless sensors",
            "PIR",
            "door sensor",
            "door bell",
            "async_call_later",
            "debounce timer",
            "time-based auto reset",
            "homeassistant.components.binary_sensor.mqtt",
            "rfxtrx",
            "CONF_OFF_DELAY",
            "config validation",
            "tests leaving files behind",
            "config_entries _async_schedule_save mock"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request adds an off_delay property to the Home Assistant MQTT binary_sensor platform to better support stateless sensors such as PIR motion detectors, door sensors, and door bells.\n\nInitially, the author copied an off-delay pattern from the rfxtrx binary_sensor implementation. That original snippet only scheduled an off-delay timer if no timer existed, which meant that repeated ON events during the delay would not extend the off time. After review feedback, the behavior was changed so that each new ON event cancels any existing off-delay timer and schedules a new one, effectively debouncing and extending the off time while motion/events continue.\n\nThe configuration schema for off_delay first accepted a time_period/timedelta, but was later simplified to a non-negative integer number of seconds using `vol.All(vol.Coerce(int), vol.Range(min=0))`. off_delay is stored as a local constant (`CONF_OFF_DELAY = 'off_delay'`) within the MQTT binary_sensor module rather than being promoted to the global `homeassistant.const` namespace, following reviewer advice to avoid over-centralizing constants. The rfxtrx integration similarly defines its own CONF_OFF_DELAY instead of using a global constant.\n\nThe MQTT binary sensor entity was updated to track an internal `_delay_listener` handle. In `state_message_received`, after validating and parsing the payload and template, if the new state is ON and `_off_delay` is set, an `off_delay_listener` callback (decorated with `@callback`) is defined. Before scheduling a new timer via `evt.async_call_later(self.hass, self._off_delay, off_delay_listener)`, any existing `_delay_listener` is called (which cancels the previous timer). When the timer fires, `off_delay_listener` sets `_delay_listener` to None, sets `_state` to False, and calls `async_schedule_update_ha_state()` to propagate the OFF state.\n\nA new test `test_off_delay` was added for the MQTT binary_sensor to verify that: (1) an ON MQTT payload sets the state to ON and fires an event; (2) a second ON payload still leaves the state ON and fires another event; and (3) after advancing time by 30 seconds via `fire_time_changed`, the state becomes OFF and a final state changed event is emitted.\n\nDuring CI, tests started failing due to leftover files under `tests/testing_config/.storage` (`core.config_entries`). Investigation showed that running tests created persistent config entry files. The fix was to mock `self.hass.config_entries._async_schedule_save` in the test setup (`self.hass.config_entries._async_schedule_save = Mock()`), preventing tests from writing to disk and resolving the 'tests are leaving files behind' error.\n\nIn summary, the PR introduced an off_delay-based auto-reset for MQTT binary_sensors with a debounced async timer, refined the config schema, localized constants to integrations, and fixed a test side-effect by mocking out file-saving behavior.",
        "semantic_memory": "This change illustrates several generalizable software development patterns:\n\n1. **Designing off-delay behavior for stateless event sources**\n   - Stateless sensors (like PIR motion detectors, door bells, or buttons) often only emit an ON event without a corresponding OFF. Systems that model them as binary sensors need an automatic off-delay to restore the OFF state after a configured interval.\n   - A practical pattern is: on each ON event, schedule a future OFF state change after `off_delay` seconds. If another ON arrives before the timer fires, cancel and reschedule the timer. This implements a simple extension of the active period while events continue to arrive.\n\n2. **Debounced one-shot timers in async/event-driven systems**\n   - Instead of spawning multiple timers and trying to coordinate them, keep a single timer handle (`_delay_listener`). On each new triggering event:\n     - If a timer exists, cancel it (often by calling the handle returned by the schedule function).\n     - Schedule a new timer and store its handle.\n   - The timer callback should clear the stored handle, update state, and notify observers (e.g., via an async state update method).\n   - Using framework utilities like `async_call_later` or `async_track_point_in_utc_time` centralizes timing logic and ensures correct interaction with the event loop.\n\n3. **Configuration validation and simplicity**\n   - For user-facing configuration, using a simple integer number of seconds (`vol.Coerce(int)` + `vol.Range(min=0)`) can be more straightforward than complex time period objects, particularly when only a simple delay is needed.\n   - Schema libraries (like voluptuous) can enforce constraints (e.g., non-negative values), reducing runtime checks.\n\n4. **Local vs global constants**\n   - Not every commonly used string key needs to live in a global constants module. Over-centralizing configuration keys increases cognitive load and cross-module coupling.\n   - It can be preferable to define configuration constants locally within an integration (e.g., `CONF_OFF_DELAY = 'off_delay'` in the module) when they are only used in a small scope. Promote only widely shared or cross-cutting keys to global constants.\n\n5. **Testing without side effects (no persistent files)**\n   - Automated tests should not leave files or other persistent side effects. When framework components (like config entry managers) perform async saves, they may write files under test directories.\n   - A robust pattern is to mock save methods (e.g., `_async_schedule_save = Mock()`), use temporary directories, or otherwise isolate file I/O so tests are hermetic and CI checks for dirty working trees pass.\n   - If CI reports 'tests are leaving files behind', inspect test configuration paths (like `tests/testing_config`) and mock or redirect the responsible operations.\n\n6. **Using callbacks in async frameworks**\n   - Decorating timer callbacks with `@callback` (or equivalent) marks them as synchronous callbacks safe to run in the event loop without further scheduling overhead.\n   - Inside such callbacks, it's common to update internal state and then invoke a framework-provided 'update my external representation' method, separating internal logic from state broadcasting.\n\nThese patterns apply broadly to any event-driven home automation or IoT platform where devices emit events irregularly, require timed state transitions, and must be tested in an automated, side-effect-free environment.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Understand the stateless sensor requirement.\n- Identify sensors that only emit transient events (e.g., ON when motion is detected) without reliable OFF events.\n- Determine the desired behavior: typically, after an ON event, the sensor should remain logically ON for a certain period (off_delay), then automatically revert to OFF.",
            "Step 2: Add an off_delay configuration option.\n- Define a configuration key local to the integration (unless it needs to be shared widely), e.g., `CONF_OFF_DELAY = 'off_delay'` inside the module.\n- In your configuration schema, add an optional field for off_delay:\n  - For example with voluptuous: `vol.Optional(CONF_OFF_DELAY): vol.All(vol.Coerce(int), vol.Range(min=0))`.\n  - This ensures off_delay is a non-negative integer number of seconds.\n- Pass this config value through your setup function into the entity or component class and store it as an instance attribute (e.g., `self._off_delay`).",
            "Step 3: Implement a debounced off-delay timer.\n- Add an attribute to your entity to hold the timer handle, e.g., `self._delay_listener = None` in `__init__`.\n- In the logic that processes incoming state/events (e.g., MQTT message handler):\n  1. Parse and validate the new state (handle templates, payload_on/off, etc.).\n  2. If the new state is ON and `self._off_delay` is not None:\n     - Define a callback function (e.g., `off_delay_listener(now)`) that:\n       - Sets `self._delay_listener = None`.\n       - Sets `self._state = False` (or equivalent OFF value).\n       - Calls the framework method to update external state, e.g., `self.async_schedule_update_ha_state()`.\n     - If `self._delay_listener` is not None, call it to cancel the previously scheduled timer.\n     - Schedule a new timer using the framework utility, e.g., `self._delay_listener = evt.async_call_later(self.hass, self._off_delay, off_delay_listener)`.\n  3. After handling the timer logic, call your typical state update method for the current event (for the immediate ON state).\n- Ensure the timer callback is marked appropriately for your framework (e.g., with `@callback` in Home Assistant) so it is executed efficiently in the event loop.",
            "Step 4: Write tests for off_delay behavior.\n- Set up the integration in a test environment (e.g., create a test Home Assistant instance and configure the binary_sensor with off_delay).\n- Subscribe to state change events so you can count and inspect them.\n- Test sequence:\n  1. Send an ON event (e.g., via a mocked MQTT message). Assert the sensor state becomes ON and a state-changed event is emitted.\n  2. Send another ON event before the delay expires. Assert the sensor remains ON and another state-changed event is emitted.\n  3. Advance time by more than off_delay (use a test helper like `fire_time_changed` or equivalent). Assert the sensor state becomes OFF and a final state-changed event is emitted.\n- Optionally add tests that send multiple ON events in quick succession to ensure only one OFF transition occurs after the last ON.",
            "Step 5: Prevent tests from leaving persistent files.\n- If CI reports errors like 'Tests are leaving files behind' or you notice leftover files in test directories (e.g., `tests/testing_config/.storage/core.config_entries`), determine which component is writing them.\n- Common culprits include configuration entry managers or other subsystems that schedule saves.\n- In your test setup, mock out file-saving methods, e.g.:\n  - `self.hass.config_entries._async_schedule_save = Mock()`\n- Alternatively, configure the system to use a temporary directory per test run or clean up files in teardown.\n- Re-run tests locally and verify no new untracked files appear in the working tree.",
            "Step 6: Manage constants and module boundaries.\n- Before adding a new global constant (e.g., to a shared const module), evaluate how widely it will be used.\n- If it is only relevant to one or a small set of integrations, define it locally in those modules to keep the global namespace lean.\n- If a constant was prematurely added globally, consider moving it back into the specific integration modules, updating imports accordingly.",
            "Step 7: Review and refine async callback patterns.\n- Ensure that timer callbacks update both the internal state and the external representation through the correct async APIs.\n- Mark callbacks with the appropriate decorator (e.g., `@callback`) when the framework expects it.\n- Confirm that you are using the right scheduling helper for your use case:\n  - `async_call_later` for relative delays in seconds.\n  - `async_track_point_in_utc_time` or similar when scheduling at an absolute time.\n- Verify that you clear the timer handle when the callback executes to avoid stale references and to allow new timers to be scheduled cleanly."
        ]
    }
}
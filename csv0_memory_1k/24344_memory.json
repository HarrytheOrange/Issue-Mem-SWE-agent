{
    "search_index": {
        "description_for_embedding": "Home Assistant ZHA integration gain support for Zigbee DoorLock clusters and door lock entities, including lock/unlock services, state reporting, and tests. The change also refactors the ZHA command wrapper to return the full zigpy result instead of a boolean, and updates lights/switches/locks and their tests to handle the new response format and to be resilient to zigpy schema changes (e.g., Optional types in cluster.request).",
        "keywords": [
            "Home Assistant",
            "ZHA",
            "Zigbee",
            "DoorLock cluster",
            "zha lock entity",
            "lock_state reporting",
            "zigpy Cluster.request",
            "command wrapper",
            "Status.SUCCESS",
            "REPORT_CONFIG_IMMEDIATE",
            "test brittleness",
            "schema change",
            "Optional type",
            "channel registry",
            "ZhaDoorLock",
            "DoorLockChannel"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident the Home Assistant ZHA integration was extended to support Zigbee door locks using the Zigbee DoorLock cluster. Prior to this PR, ZHA did not expose DoorLock clusters as lock entities, so Zigbee locks could not be controlled or monitored via Home Assistant.\n\nThe contributor implemented a new DoorLockChannel in `homeassistant/components/zha/core/channels/closures.py`. This channel listens for and reads the `lock_state` attribute from the Zigbee DoorLock cluster, forwards state updates via the dispatcher (`SIGNAL_ATTR_UPDATED`), and retrieves the initial state during initialization.\n\nThe channel was registered in the ZHA channel registry so that `zcl.clusters.closures.DoorLock` maps to `DoorLockChannel`. In `core/registries.py`, the DoorLock cluster was mapped to the `lock` domain for device-class routing, and report configuration for `lock_state` was added with `REPORT_CONFIG_IMMEDIATE` to get timely state updates.\n\nA new entity class `ZhaDoorLock` was added in `homeassistant/components/zha/lock.py`, subclassing `ZhaEntity` and `LockDevice`. It:\n- hooks into ZHA discovery (`ZHA_DISCOVERY_NEW` for the `lock` domain),\n- binds to the DoorLockChannel via the `DOORLOCK_CHANNEL` key,\n- translates Zigbee `lock_state` values into Home Assistant states using a small mapping (`STATE_LIST` -> `VALUE_TO_STATE`),\n- exposes `is_locked`,\n- implements `async_lock` and `async_unlock` by calling `doorlock_channel.lock_door()` / `unlock_door()` and scheduling state updates, and\n- supports state restoration and explicit refresh.\n\nWhile adding tests for the lock, the team encountered failures caused by changes in zigpy’s DoorLock cluster schema: the `Cluster.request` third parameter (schema) now included an `Optional` type instead of being empty. The original tests asserted the full `call_args` for `Cluster.request`, including the empty args tuple, which became brittle once zigpy changed its internal command schema. To fix this, the tests were updated to only assert the essential parts of the call (e.g., that the first positional argument indicates a cluster-specific command and that the correct command ID, `LOCK_DOOR` or `UNLOCK_DOOR`, is used) instead of the full argument list. This made the tests resilient to underlying API changes discussed by the reviewers.\n\nSeparately, the ZHA command wrapper `decorate_command` in `core/channels/__init__.py` was refactored. Previously, it converted the zigpy command result into a simple boolean (checking `result[1] is Status.SUCCESS` when not already boolean). This abstraction turned out to be too limiting when different clusters or commands might return different result structures, and when the caller needed more detailed information. The wrapper was changed to:\n- return the full `result` from the underlying zigpy call unmodified, and\n- on `DeliveryError` or `Timeout`, log the error and return the exception instance instead of `False`.\n\nBecause of this, entity code that depended on the former boolean behavior (lights, switches, and now locks) had to be updated to interpret the returned result correctly. For example:\n- `zha/light.py` now imports `Status` and checks `isinstance(result, list) and result[1] is Status.SUCCESS` for various commands (on/off, move_to_level_with_on_off, move_to_color_temp, move_to_color) before considering the command successful.\n- `zha/switch.py` similarly checks `result[1] is Status.SUCCESS` for on/off commands.\n- `zha/lock.py` interprets the DoorLock commands as successful if `result` is a list and `result[0] is Status.SUCCESS` (reflecting a slightly different result shape from zigpy for these lock commands).\n\nThe test suite was updated accordingly:\n- Light tests now mock `Cluster.request` to return lists matching the new expectations (e.g., `[sentinel.data, Status.SUCCESS]` or `[0x00, Status.SUCCESS]`).\n- Switch tests likewise return `[0x00, Status.SUCCESS]` for `turn_on` and `[0x01, Status.SUCCESS]` for `turn_off`.\n- Lock tests now mock `Cluster.request` to return `[Status.SUCCESS]` and only assert the first positional arguments of `cluster.request` rather than the entire call structure.\n\nMinor lint fixes were applied (import ordering, unused imports, docstring tweaks) and one test bug was corrected where the unlock scenario incorrectly called the `async_lock` helper.\n\nDuring review, maintainers acknowledged that codecov patch coverage failures could be ignored in this case. The main conceptual takeaway was to make HA’s tests less coupled to zigpy’s internal command schema and to have a more flexible command wrapper that doesn’t discard important information.\n",
        "semantic_memory": "This change illustrates several generalizable lessons around integration code, third-party APIs, and testing strategy:\n\n1. **Resilient Integration with Third-Party Libraries**\n   - When wrapping third-party APIs (like zigpy’s `Cluster.request`), avoid over-simplifying return values unless you fully control or freeze the upstream API. Converting all results to a boolean can make it impossible for callers to react intelligently to different outcomes or payload types. Returning the full result allows future extensions without changing the wrapper interface again.\n   - If an upstream library changes internal details (e.g., its command schema or uses new types like `Optional`), tests that assert too much about the call structure can begin to fail even though behavior is still correct. Tests should generally assert observable behavior and key parameters, not internal or incidental details.\n\n2. **Testing: Assert Only What Matters**\n   - When mocking and asserting calls to a function like `Cluster.request`, it is often sufficient to assert only the critical positional arguments (e.g. whether the command is cluster-specific and the correct command ID) rather than the entire `call_args` including schemas, manufacturer codes, or optional fields. This approach reduces brittleness when underlying libraries evolve.\n   - For complex or evolving APIs, it is preferable to test against a stable abstraction layer (e.g., a `command()` helper or channel-level `lock_door()`/`unlock_door()` methods) instead of low-level primitives like `Cluster.request`.\n\n3. **Error Handling in Asynchronous Command Wrappers**\n   - In async integrations, wrapping commands in a decorator that handles common exceptions (like network or delivery errors) centralizes error handling and logging. Returning the exception object instead of `False` allows the caller to distinguish between different failure modes if needed, or to log richer context.\n   - Callers should treat the result as a structured value (e.g., a list or tuple containing sequence numbers and `Status` codes) and explicitly check conditions like `result[1] is Status.SUCCESS`. This makes it easier to extend behavior in the future (e.g., reacting differently to specific error codes) rather than relying on a simple boolean.\n\n4. **State Mapping Between Protocol and Application Domains**\n   - Many protocols encode state as numerical or enumerated values (e.g., Zigbee DoorLock `lock_state` enums). Integrations should define explicit mappings between these protocol-specific values and platform-level states (`STATE_LOCKED`, `STATE_UNLOCKED`), including handling edge or intermediate values (e.g., 'not fully locked').\n   - Maintaining a small map like `VALUE_TO_STATE` makes it easy to adapt to future spec changes while keeping entity logic clean.\n\n5. **Configuring Attribute Reporting Strategically**\n   - For entities where immediate feedback is important (like locks), using a more aggressive reporting configuration (e.g., `REPORT_CONFIG_IMMEDIATE` for `lock_state`) improves UX and consistency between physical state and Home Assistant state.\n\n6. **Pattern for Adding New Device Types in a Modular Integration**\n   - Adding a new ZHA device type follows a pattern: create a dedicated channel for the cluster, register it in the channel registry, map the cluster to a Home Assistant domain in the integration’s registries, and then implement an entity class that consumes that channel. This pattern keeps protocol-specific details isolated from entity logic.\n\nOverall, the PR highlights best practices for designing stable wrappers around evolving third-party APIs, building robust tests that don’t over-specify implementation details, and structuring integration code around channels and entities to support new device types cleanly.",
        "procedural_memory": [
            "To diagnose and implement support for a new Zigbee cluster-based device type in Home Assistant ZHA (or a similar integration), and to keep the tests robust against upstream API changes, follow these steps:",
            "Step 1: Identify the new cluster and desired domain",
            "- Determine which Zigbee cluster represents the device capability (e.g., `zcl.clusters.closures.DoorLock` for locks).",
            "- Decide which Home Assistant domain the device should belong to (e.g., `lock`, `light`, `switch`).",
            "- Check existing registries or mappings to see how similar clusters are handled.",
            "Step 2: Implement a dedicated channel for the cluster",
            "- Create a new channel class (e.g., `DoorLockChannel`) that inherits from the integration’s generic channel base (e.g., `ZigbeeChannel`).",
            "- Implement:\n  - `async_initialize(self, from_cache)`: read initial attribute values (like `lock_state`) and then call `super().async_initialize(from_cache)`.\n  - `attribute_updated(self, attrid, value)`: translate relevant attribute reports into dispatcher signals, logging them for debug purposes.\n  - `async_update(self)`: fetch the latest attribute value (e.g., using `get_attribute_value('lock_state', from_cache=True)`) and emit appropriate signals.",
            "Step 3: Register the new channel and domain mappings",
            "- In the channel registry, map the cluster ID to the new channel class, e.g.:\n  - `ZIGBEE_CHANNEL_REGISTRY[zcl.clusters.closures.DoorLock.cluster_id] = DoorLockChannel`.",
            "- In the integration’s registries or device-class map:\n  - Map the cluster (or its class) to the target domain (e.g., `LOCK`).\n  - Add attribute reporting configuration for key attributes (e.g., `lock_state`), choosing report config suited to the use case (`REPORT_CONFIG_IMMEDIATE` for locks).",
            "Step 4: Implement the entity class",
            "- Create an entity class that integrates the new channel (e.g., `ZhaDoorLock` extending `ZhaEntity` and `LockDevice`).",
            "- In `__init__`, store a reference to the relevant channel via the integration’s channel map (e.g., `self._doorlock_channel = self.cluster_channels.get(DOORLOCK_CHANNEL)`).",
            "- Implement:\n  - `async_added_to_hass`: subscribe to channel signals via dispatcher (e.g., `SIGNAL_ATTR_UPDATED`) and bind a callback to update entity state.\n  - A state mapping from protocol-specific values to HA states (e.g., a `STATE_LIST` and `VALUE_TO_STATE` dict mapping indices to `STATE_LOCKED` / `STATE_UNLOCKED`).\n  - `is_locked` (or analogous domain methods) based on the mapped state.\n  - Domain-specific actions (`async_lock`, `async_unlock`, etc.) that call channel methods like `lock_door()`/`unlock_door()` and then schedule a state update.\n  - `async_update` and a helper like `async_get_state` to explicitly poll channel attributes when needed.\n  - Optional state restoration using `async_restore_last_state`.",
            "Step 5: Use a robust command wrapper",
            "- If the integration uses a common command wrapper (e.g., `decorate_command`):\n  - Ensure it returns the full underlying result from the third-party library rather than collapsing it to a boolean.\n  - Handle common exceptions (`DeliveryError`, `Timeout`) by logging and returning the exception object.\n  - Avoid embedding assumptions about the shape of the result in the wrapper; let call sites interpret the structure based on context.",
            "Step 6: Update entity command handlers to interpret results correctly",
            "- In each entity method that sends commands (e.g., `async_turn_on`, `async_turn_off`, `async_lock`, `async_unlock`):\n  - Treat the command result as structured data, e.g. a list from zigpy like `[sequence_number, Status.SUCCESS]` or `[Status.SUCCESS]`.\n  - Check for success explicitly: `isinstance(result, list) and result[index] is Status.SUCCESS`.\n  - On failure, log a clear error with the result for troubleshooting, and avoid updating state prematurely.\n  - Keep the success condition as narrow as possible to avoid false positives.",
            "Step 7: Write integration tests with stable expectations",
            "- Create tests that simulate a zigpy device with the relevant clusters using helper functions like `async_init_zigpy_device` and `async_enable_traffic`.",
            "- Verify entity creation and initial state (e.g., initially `STATE_UNAVAILABLE`, becoming `STATE_UNLOCKED` after traffic is enabled).",
            "- Simulate attribute reports (e.g., using `cluster.handle_message(...)` and fabricated attributes) and assert that entity state tracks these updates correctly.",
            "- For service calls (e.g., HA `lock`, `unlock`, `turn_on`, `turn_off`):\n  - Patch or monkeypatch `zigpy.zcl.Cluster.request` to return mock coroutines with realistic structures, like `[sequence, Status.SUCCESS]` or `[Status.SUCCESS]` depending on the cluster.\n  - Assert that the cluster request was invoked with the proper critical parameters (e.g., `call_args[0][0]` indicates cluster-specific, `call_args[0][1]` equals the expected command ID), rather than asserting the entire `call_args` including schema and keyword args.\n  - Confirm that entity state reflects the expected outcome after the service call.",
            "Step 8: Make tests robust to upstream API changes",
            "- If tests start failing due to changes in the third-party library’s internals (like new schema parameters or use of `Optional` types):\n  - Refactor assertions to only depend on stable aspects of the API (e.g., command IDs and high-level behavior) instead of exact argument lists.\n  - Consider mocking a higher-level helper (e.g., a channel `command()` method) rather than the low-level `Cluster.request` to insulate tests from future API changes.\n  - Adjust mock return values to match any new expected structures used by callers (e.g., if handlers now inspect `result[0]` instead of `result[1]`).",
            "Step 9: Run and iterate on tests and linting",
            "- Run the test suite focusing on the relevant modules to ensure behavior is correct.\n  - Fix any linting issues (import order, unused imports, docstring consistency, long lines) early to keep the CI pipeline green.\n  - If coverage tools flag low patch coverage, consider adding targeted tests, but coordinate with maintainers when coverage requirements can be relaxed for structural changes.",
            "Step 10: Document and validate behavior",
            "- Update user-facing documentation to mention the new device support (e.g., ZHA door lock support) and any configuration notes.\n  - Validate on actual hardware if possible to confirm lock/unlock behavior, state transitions, and attribute reporting match expectations."
        ]
    }
}
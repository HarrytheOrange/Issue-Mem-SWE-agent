{
    "search_index": {
        "description_for_embedding": "Home Assistant asuswrt integration updated so its network sensors (upload/download totals and speeds) become optional and configurable. The main asuswrt component now passes an optional list of sensor types via discovery_info to the sensor platform, which conditionally creates only the requested sensor entities. If no sensors are configured, the sensor platform exits early and no sensor entities are created. Fixes included correcting iteration over the config dict, using discovery_info correctly, and handling optional config without defaults.",
        "keywords": [
            "home assistant",
            "homeassistant",
            "asuswrt",
            "asuswrt sensor optional",
            "optional sensors",
            "conditional platform load",
            "discovery_info",
            "async_setup_platform",
            "CONFIG_SCHEMA",
            "voluptuous",
            "device_tracker",
            "upload_speed",
            "download_speed",
            "upload",
            "download",
            "configuration.yaml",
            "integrations",
            "platform configuration bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant asuswrt integration originally always created all four router sensors (upload, download, upload_speed, download_speed) whenever the asuswrt component was configured. Users wanted to make these sensors optional, both to reduce clutter and to allow running only the device_tracker functionality.\n\nTo address this, the developer added a new optional `sensors` configuration key to the `asuswrt` domain in `configuration.yaml`, with allowed values `['upload_speed', 'download_speed', 'download', 'upload']`. The main component (`homeassistant/components/asuswrt.py`) was updated to:\n- Define `CONF_SENSORS` and `SENSOR_TYPES`.\n- Extend the `CONFIG_SCHEMA` with `vol.Optional(CONF_SENSORS): vol.All(cv.ensure_list, [vol.In(SENSOR_TYPES)])` so users can specify a list of desired sensors.\n- Call `async_load_platform('sensor', DOMAIN, config[DOMAIN].get(CONF_SENSORS), config)` instead of always loading sensors with an empty discovery payload.\n\nOn the sensor side (`homeassistant/components/sensor/asuswrt.py`), `async_setup_platform` was modified to:\n- Immediately return if `discovery_info` is `None`, meaning no sensors were requested.\n- Build a list of sensor entities only for those names present in `discovery_info` (a list of sensor identifiers):\n  - `'download'` -> `AsuswrtTotalRXSensor`\n  - `'upload'` -> `AsuswrtTotalTXSensor`\n  - `'download_speed'` -> `AsuswrtRXSensor`\n  - `'upload_speed'` -> `AsuswrtTXSensor`\n- Call `add_entities(devices)` with that filtered list.\n\nWhile implementing this, the developer encountered a couple of subtle bugs:\n- Initially, they iterated `for router in config[DOMAIN]:` and then tried to index `router[CONF_SENSORS]`, but `config[DOMAIN]` is a dict, so `router` was a key string, not a dict. This was corrected by dropping the loop and accessing `config[DOMAIN][CONF_SENSORS]` directly, and later by using `config[DOMAIN].get(CONF_SENSORS)`.\n- In an early version, the check for download speed sensors mistakenly used `if 'download_speed' in devices:` instead of checking `discovery_info`. This would never match and prevented that sensor from being created; it was fixed to `if 'download_speed' in discovery_info:`.\n- The `CONF_SENSORS` schema initially set `default=SENSOR_TYPES`, which would always create all sensors even when the user did not specify them. This was changed to remove the default and use `.get(CONF_SENSORS)` so that omitting the key results in `discovery_info` being `None` and the sensor platform not loading any sensors.\n\nThe final result is that asuswrt sensors are truly optional: if `sensors:` is not specified in the `asuswrt` config, only the device_tracker is set up; if it is specified, only the selected sensors are created. The code passes tests and the reviewer confirmed it could be merged once CI passed.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices for modular integrations and optional subcomponents:\n\n1. **Optional sub-platforms via discovery_info**\n   - In frameworks like Home Assistant that separate a main integration from platform-specific modules (e.g., `sensor`, `device_tracker`), optional behavior can be implemented by controlling calls to `async_load_platform` and passing configuration via `discovery_info`.\n   - The sub-platform's `async_setup_platform` should treat `discovery_info` as the authoritative source of configuration from the main component and early-return when it is `None` or empty.\n\n2. **Using an optional config key instead of implicit defaults**\n   - If a feature is meant to be truly optional, avoid setting a default that implicitly turns it on. In this case, using `default=SENSOR_TYPES` meant sensors were always created even when the user did not request them.\n   - Better is to make the key optional in the schema and use `.get()` without a default so that the absence of the key can be interpreted as \"do not enable this feature\".\n\n3. **Voluptuous schema for controlled lists**\n   - For user-configurable lists of options, schema definitions like `vol.All(cv.ensure_list, [vol.In(ALLOWED_VALUES)])` validate both that the data is a list and that each element is one of the supported values.\n   - This pattern prevents typos and unsupported values from silently breaking behavior.\n\n4. **Conditional entity creation based on configuration**\n   - Rather than always instantiating all possible entities, build a list dynamically from configuration. This reduces resource usage and UI clutter and makes the integration more flexible.\n   - Mapping string keys (e.g., 'download_speed') to entity classes provides a clear, explicit relationship between options and behavior.\n\n5. **Guarding setup functions with minimal checks**\n   - Adding simple guards like `if discovery_info is None: return` avoids unnecessary setup and makes it explicit when a platform is loaded only through the main component's orchestration.\n\n6. **Correct handling of configuration structures**\n   - Configuration objects are often nested dicts. Iterating `for x in config[DOMAIN]` yields keys, not the nested dict itself. Access patterns must reflect the actual structure (e.g., `config[DOMAIN]` vs items) to avoid subtle runtime errors.\n\n7. **Debugging subtle logic errors**\n   - Small mistakes like checking membership in the wrong collection (`'download_speed' in devices` instead of `'download_speed' in discovery_info`) can silently disable parts of functionality. Careful review of containment checks and collection types is required when dynamically building lists of entities or options.",
        "procedural_memory": [
            "How to make subcomponents (e.g., sensors) optional and configurable in a modular integration:",
            "Step 1: Identify the main integration and its sub-platforms",
            "- Locate the main component (e.g., `components/asuswrt.py`) and all associated platform files (e.g., `components/sensor/asuswrt.py`, `components/device_tracker/asuswrt.py`).",
            "- Determine which sub-platform(s) should be optional (e.g., sensors, but not device_tracker).",
            "Step 2: Add an optional configuration key with a constrained list of values",
            "- Introduce a new constant for the key, e.g., `CONF_SENSORS = 'sensors'`, and a list of allowed values, e.g., `SENSOR_TYPES = ['upload_speed', 'download_speed', 'download', 'upload']`.",
            "- In the integration's CONFIG_SCHEMA, add an optional entry:\n  - `vol.Optional(CONF_SENSORS): vol.All(cv.ensure_list, [vol.In(SENSOR_TYPES)])`.\n  - Do NOT specify a default if you truly want the feature to be disabled by default when not present.",
            "Step 3: Read the optional configuration correctly",
            "- In the main integration's `async_setup`, after parsing config, access the optional key with `.get` instead of indexing:\n  - `selected_sensors = config[DOMAIN].get(CONF_SENSORS)`.\n  - If the key is absent, `selected_sensors` will be `None`.",
            "Step 4: Pass configuration into sub-platforms via discovery_info",
            "- When calling `async_load_platform` for the optional sub-platform, pass the configuration as `discovery_info`:\n  - `hass.async_create_task(async_load_platform(hass, 'sensor', DOMAIN, selected_sensors, config))`.",
            "- For always-on platforms (e.g., device_tracker) you can still pass `{}` or omit discovery-based filtering as appropriate.",
            "Step 5: Guard sub-platform setup using discovery_info",
            "- In the sub-platform module’s `async_setup_platform`:\n  - Add `if discovery_info is None: return` at the top.\n  - This ensures that if the main component did not request this platform (no config, or explicitly disabled), no entities are created.",
            "Step 6: Dynamically build entities based on the configuration",
            "- Treat `discovery_info` as the list of selected options.\n  - Initialize an empty list: `devices = []`.\n  - For each supported option, check membership in `discovery_info` and append the corresponding entity class:\n    - `if 'download' in discovery_info: devices.append(AsuswrtTotalRXSensor(api))`\n    - `if 'upload' in discovery_info: devices.append(AsuswrtTotalTXSensor(api))`\n    - `if 'download_speed' in discovery_info: devices.append(AsuswrtRXSensor(api))`\n    - `if 'upload_speed' in discovery_info: devices.append(AsuswrtTXSensor(api))`.\n  - Finally, call `add_entities(devices)`.",
            "Step 7: Avoid common configuration structure mistakes",
            "- Confirm the type of `config[DOMAIN]` (dict vs list). If it’s a dict, `for x in config[DOMAIN]` gives keys, not nested dict objects.\n  - Use dictionary access (`config[DOMAIN][CONF_SENSORS]` or `.get`) rather than treating the top-level domain config as iterable of router instances unless the schema is explicitly a list.",
            "Step 8: Validate and test behavior",
            "- Add or update example configuration to include the new `sensors:` key.\n  - Test scenarios:\n    - No `sensors` key: sensors platform should not set up; only device_tracker present.\n    - `sensors` with a subset of options: only those sensors should appear.\n    - Invalid sensor name in config: config validation should fail via voluptuous.\n  - Run the existing test suite (`tox` in this project) and add targeted tests if possible.",
            "Step 9: Debugging when entities don't appear or won't disable",
            "- If entities appear even when not requested, check for:\n    - A default value in the schema that always enables them.\n    - The sub-platform ignoring `discovery_info` and unconditionally creating entities.\n  - If entities never appear, verify:\n    - That `async_load_platform` is actually called with the correct `discovery_info`.\n    - That the membership checks (e.g., `'download_speed' in discovery_info`) are against the correct collection, not against the list of devices or some other structure.",
            "Step 10: Document the behavior",
            "- Update user-facing docs to show how to enable or disable specific sensors via configuration.\n      - Example:\n        asuswrt:\n          host: <ip-address>\n          sensors:\n            - upload\n            - download\n            - upload_speed\n            - download_speed\n      - Explain that omitting `sensors` disables all asuswrt sensors while keeping device tracking functional."
        ]
    }
}
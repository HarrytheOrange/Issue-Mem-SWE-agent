{
    "search_index": {
        "description_for_embedding": "Home Assistant core change replacing fragile regex-based template entity extraction and template triggers with a robust runtime entity tracking mechanism. Introduces Template.async_render_with_collect and async_track_template_result, refactors bayesian.binary_sensor and universal.media_player to use template result listeners, improves error handling, supports iterators and dynamic templates, and centralizes entity filtering via EntityFilter.",
        "keywords": [
            "Home Assistant",
            "template tracking",
            "Template.async_render_with_collect",
            "async_track_template_result",
            "async_track_template",
            "entity filter",
            "EntityFilter",
            "bayesian.binary_sensor",
            "universal.media_player",
            "automation.template",
            "template sensors",
            "regex removal",
            "dynamic templates",
            "iterator templates",
            "group.closest",
            "TemplateError handling",
            "str_to_bool",
            "non-deterministic templates",
            "wait_template"
        ]
    },
    "agent_memory": {
        "episodic_memory": "Previously, Home Assistant used a hand-written regex to statically extract entity IDs from Jinja2 templates in order to know which state changes should re-evaluate a template (e.g., for automations, template binary sensors, and bayesian sensors). This approach was brittle, duplicated across many call sites, and failed for dynamic or iterator-based templates (e.g., loops over states, filters, or dynamic entity IDs). It also caused difficult-to-debug cases where templates silently didn't re-trigger, or over-triggered on MATCH_ALL.\n\nIn this PR, the author replaced that regex-based mechanism with a runtime entity tracking system. The core idea: while a template is being rendered, the code tracks which entity states and domains are actually accessed. This is implemented via Template.async_render_with_collect, which returns both the render result (or TemplateError) and an EntityFilter describing the entities/domains that influenced the result. Supporting changes include:\n\n- A new EntityFilter class (replacing the old generate_filter-only pattern) that holds include/exclude sets and implements __call__ for entity ID filtering. This unified filter representation is used by template tracking and elsewhere.\n- The Template helper was extended with async_render_with_collect and render_with_collect, which use hass.data[\"template.collect\"] as a per-render collection context. All state access paths (AllStates, DomainStates, TemplateState, TemplateMethods.is_state / state_attr / closest / distance, etc.) were updated to mark which entities or domains were touched.\n- Iterators and length checks over states/states.<domain> (e.g., for state in states.sensor or len(states)) set include_all or include_domains in the EntityFilter, while actual attribute access on individual states adds specific entity_ids.\n- Edge cases like AllStates and DomainStates now validate entity IDs and domains (via valid_entity_id) and raise TemplateError for invalid names instead of silently failing.\n- The closest(...) helper was updated to correctly track group membership and the group entity ID, and tests were added to verify filters when using closest with groups.\n\nOn top of this core tracking, new event helpers were added/refactored:\n\n- async_track_template_result(hass, template, action, variables=None) now registers a state_changed listener that re-renders the template whenever an entity used in the last render changes. It calls the provided action with (event, template, last_result, result), where result can be either the new string output or a TemplateError. It also:\n  - Emits the initial result (or TemplateError) immediately upon registration.\n  - Only calls the listener once when the template starts erroring, and again when it returns to a non-error state.\n  - Optimizes state change handling by only checking entity_filter.include_entities for simple state changes and full filter for lifecycle events.\n  - Returns a TrackTemplateResultInfo info object, which exposes async_remove()/remove() and async_refresh()/refresh(), allowing callers to force a re-evaluation of the template (useful for non-deterministic templates).\n\n- async_track_template(hass, template, action, variables=None) was rewritten to build on async_track_template_result. It interprets the template result as a boolean (via the new util.str_to_bool), triggering the action only on transitions from falsey to truthy. On initial registration, if the template is truthy, it figures out a representative entity_id and state (using the collected EntityFilter) and calls action(entity_id or MATCH_ALL, state, state) to preserve previous semantics for template automations.\n\nSeveral components were updated to use these new APIs:\n\n- bayesian.binary_sensor:\n  - Previously, the bayesian sensor computed its observation dependencies via static entity IDs and template.extract_entities(), which suffered from the same regex problems.\n  - The code now builds two maps: entity_obs (per-entity observations) and template_obs (per-template observations). Entity-based observations still use async_track_state_change; template-based observations use async_track_template_result.\n  - For template observations, the callback receives (event, template, old_result, new_result). It converts new_result to a boolean (using str_to_bool) unless new_result is a TemplateError (which is treated as False), then updates Bayesian observations and recomputes the posterior probability.\n  - current_obs is updated incrementally, probability is recomputed via update_probability, and the entity’s state is updated by async_schedule_update_ha_state. The internal _deviation flag (probability >= threshold) is maintained accordingly.\n  - The entity tracks all TrackTemplateResultInfo instances so that async_update() can force recomputation via info.async_refresh(). This is specifically to support non-deterministic templates (e.g., templates that may change due to external factors not tracked in entity_filter).\n  - Tests were updated: one scenario uses a template observation in place of a state observation; another explicitly mocks Template.async_render to simulate a non-deterministic template and verifies that forcing an update flips the bayesian sensor’s state.\n\n- universal.media_player:\n  - The universal media player supports a state_template to define master_state. Previously it used extract_entities() and manual tracking; now it uses async_track_template_result.\n  - The component stores TrackTemplateResultInfo for the state template, and on dependency updates (tracked via async_track_state_change on child and attribute entities), it calls _refresh_state() and async_schedule_update_ha_state().\n  - _refresh_state() finds the current active child (non-OFF_STATES). async_update() now also calls _refresh_state() and, if a state template is present, calls info.async_refresh() so non-deterministic templates get recomputed.\n  - TemplateError results from template evaluation are logged via _LOGGER.exception and ignored for state purposes.\n\nOther supporting changes:\n\n- helpers/event.py gained extensive documentation on the semantics of async_track_template and async_track_template_result, including argument semantics, TemplateError handling, and registration behavior. Tests were added to cover:\n  - Basic template tracking and change-detection semantics.\n  - Error conditions: syntax errors vs. missing entity states.\n  - Behavior when templates are iterators over states or use selectattr/filter pipelines.\n- homeassistant.util.str_to_bool was introduced and used in rest.binary_sensor.is_on, condition.async_template, and the bayesian component to provide consistent string-to-bool parsing (supporting values like 'true', 'on', 'open', 'yes', numeric string values, etc.).\n- The legacy Template.extract_entities remains for compatibility but is now implemented by calling async_render_with_collect and translating the resulting EntityFilter to either '*' or a set of entities.\n- Template.hasher and __repr__/AllStates/DomainStates were improved for readability and correctness.\n\nOverall, the change makes template-driven behaviors (automations, binary sensors, universal media player) significantly more robust and powerful, especially for dynamic templates that iterate over states or construct entity IDs at runtime. It eliminates the need for the fragile and duplicated regex-based entity extraction and centralizes template tracking logic in one place.",
        "semantic_memory": "This change encapsulates several generalizable patterns and best practices around template evaluation, event-driven triggers, and dependency tracking in asynchronous, stateful systems:\n\n1. **Runtime dependency tracking is more robust than static regex-based parsing**:\n   - Instead of trying to predict which inputs affect a computation by static analysis (e.g., regex over template text), track dependencies at runtime during actual evaluation. This ensures full coverage, works with dynamic constructs (loops, filters, concatenated entity IDs), and reduces maintenance by centralizing logic in shared helpers.\n   - The core pattern: wrap your data access functions (e.g., state getters) so that they record which identifiers are accessed during a computation. Then, store this as a filter used to determine when to recompute.\n\n2. **Use explicit filter objects for dependency sets**:\n   - A dedicated EntityFilter class encapsulating include/exclude domains and entities, and implementing __call__, is cleaner than many ad hoc generate_filter or lambda solutions. It makes filters comparable, serializable, testable, and reusable across components.\n   - Separation of concerns: the filter represents the dependency set; event helpers use it to decide when to re-run templates; components use either the filter or its underlying sets for optimized callbacks.\n\n3. **Separate template result tracking from boolean condition tracking**:\n   - async_track_template_result focuses on any change in template output (including errors), while async_track_template interprets those results as booleans and only triggers on transitions from falsey to truthy.\n   - This layering keeps concerns clear: one helper is about change detection, while another defines the semantics of truth for triggers.\n\n4. **Error-aware monitoring with minimal noise**:\n   - When monitoring computed values, propagate the first error as a distinct result (TemplateError) to listeners, and suppress repeated identical errors until the state becomes valid again. This balances observability with noise control.\n   - Log exceptions clearly and treat errors as non-triggering (e.g., False for conditions), but don’t silently swallow them.\n\n5. **Support non-deterministic computations with explicit refresh hooks**:\n   - Some templates or computed values may depend on inputs not tracked via entity IDs (time, external APIs, random, or hidden side effects). To handle these within an otherwise dependency-based system, expose an explicit refresh() / async_refresh() on the tracker info object and call it when appropriate (e.g., in async_update()).\n   - This pattern acknowledges the limitation of purely dependency-based invalidation and provides a pragmatic escape hatch.\n\n6. **Validate identifiers early and centrally**:\n   - Domain and entity references in templates (states.domain or states.some_entity) are validated via valid_entity_id. Invalid names raise TemplateError, preventing subtle bugs where templates silently refer to non-existent or malformed entities.\n   - Doing validation near the helper layers ensures all template usages benefit without duplicating checks.\n\n7. **Use a scoped collection context (e.g., hass.data) instead of globals for tracking**:\n   - Instead of a module-level global variable to track current entity collection, use hass.data with a well-defined key (e.g., 'template.collect') as a scoped, concurrency-safe context for async operations.\n   - This avoids global-state pitfalls and matches the system’s async model.\n\n8. **Design event helpers with rich return objects instead of raw callables**:\n   - Returning a TrackTemplateResultInfo object (with remove, async_remove, refresh, async_refresh, and template references) is a more flexible API than a bare unsubscribe function. It allows extending behavior (like forced refresh) without breaking existing consumers.\n\n9. **Consistent conversion utilities (e.g., str_to_bool)**:\n   - A shared utility for string-to-boolean conversion avoids subtle inconsistencies across components. Code reuse here also simplifies future updates (e.g., supporting more truthy values).\n\n10. **Tests at both helper and component levels**:\n    - Template behavior is tested in isolation (helpers/template, helpers/event) and also through components (bayesian.binary_sensor, universal.media_player). This ensures the generic mechanisms work, and that they integrate correctly into higher-level features.\n\nThese patterns are broadly applicable to any event-driven, template-driven system where dependencies are dynamic and may be hard to statically analyze: web templating, rules engines, or reactive programming frameworks.",
        "procedural_memory": [
            "When stateful templates or computed fields need to re-evaluate on relevant changes, avoid brittle static parsing. Instead, instrument runtime access paths and track which inputs were actually used, then use that to drive event subscriptions or cache invalidation.",
            "Step 1: Introduce a central filter/collector object for dependencies.",
            "Step 1.1: Define a class (e.g., EntityFilter) that holds include_all, include_domains, include_entities, exclude_domains, exclude_entities and implements __call__(entity_id) → bool, plus useful __repr__/__eq__.",
            "Step 1.2: When you start evaluating a template or computation, create a new filter instance and store it in a per-request or per-context location (e.g., hass.data['template.collect']).",
            "Step 1.3: Wrap all data-access functions that templates call (e.g., state getters, iterators over collections) so they update this filter whenever an entity or domain is touched:\n- When iterating over all states, mark include_all = True.\n- When iterating over a domain (e.g., states.sensor), add that domain to include_domains.\n- When accessing a specific entity’s state or attributes, add its entity_id to include_entities.",
            "Step 1.4: After the template/computation finishes, return both the result and the filter. Clear the collector from the context to avoid leaks.",
            "Step 2: Build a robust template result tracker.",
            "Step 2.1: Implement an async function async_track_template_result(hass, template, action, variables=None) that:\n- Renders the template using async_render_with_collect to obtain (result, entity_filter).\n- Stores the last_result and entity_filter along with an exception flag.\n- Registers an EVENT_STATE_CHANGED listener.\n- On each event, checks whether the changed entity_id is in include_entities or matches the filter (with optimizations for state vs. lifecycle changes).\n- If relevant, re-renders the template and compares the new result with last_result.\n- If the new result is a TemplateError and is the first error since a non-error, call action(event, template, last_result, error).\n- If the new result is non-error and different from last_result, call action(event, template, last_result, result) and update last_result.",
            "Step 2.2: Wrap that behavior in a small info object (e.g., TrackTemplateResultInfo) that stores the template, action, variables, last_result, entity_filter, and the unsubscribe handle. Provide methods:\n- async_remove()/remove() to stop listening.\n- async_refresh()/refresh() to force a re-render and notify if the result changed.\n- __call__ delegating to remove() to maintain backward-compatible behavior where listeners used to be simple callables.",
            "Step 3: Build a boolean-condition tracker on top of result tracking.",
            "Step 3.1: Implement async_track_template(hass, template, action, variables=None) that uses async_track_template_result internally. Its listener should:\n- Treat the result as boolean using a shared str_to_bool utility (considering 'true', 'on', 'open', 'yes', '1' as True etc.).\n- Trigger action(entity_id, old_state, new_state) only when the boolean view transitions from False (or falsy) to True.\n- On first invocation (when last_result is None), if the result is truthy, use async_render_with_collect to determine a representative entity_id and state to pass to the action. Prefer an included entity from include_entities; fall back to scanning all states against the filter; and use MATCH_ALL if none found.",
            "Step 4: Refactor components to use the new trackers.",
            "Step 4.1: For components that previously used template.extract_entities() or regex-based entity listing:\n- Replace that logic with async_track_template_result (or async_track_template if they only care about truthiness).\n- Store the returned TrackTemplateResultInfo objects so they can be refreshed later in async_update() if needed.\n- Update internal bookkeeping to map templates to their observers (e.g., template_obs[Template] → list of observation configs).",
            "Step 4.2: In observation-based components (e.g., bayesian sensors):\n- For each template-based observation, register an async_track_template_result listener.\n- In the callback, interpret the new_result appropriately (convert to bool via str_to_bool, treat TemplateError as False or handled separately), update the current observations, recompute any derived measures (like posterior probability), and schedule updates.",
            "Step 4.3: For components that define a master state through a template (e.g., universal media player):\n- Register async_track_template_result for the state_template.\n- Store the latest template output in a dedicated attribute (e.g., _state_template_result).\n- On dependency or template updates, recompute the derived entity state from this result and from underlying entity children.\n- Implement async_update() to call refresh on the template info object if the template might be non-deterministic.",
            "Step 5: Handle errors consistently.",
            "Step 5.1: Within template tracking, treat stack-level exceptions (TemplateError) as part of the API. Don’t crash the system or silently swallow errors; instead:\n- Log with _LOGGER.exception or _LOGGER.error.\n- Provide the error to listeners (once per continuous error sequence) so they can decide what to do.\n- For boolean conditions, treat errors as False to avoid spurious triggers.",
            "Step 5.2: Validate entity IDs and domains used in template helpers early (e.g., when accessing states.domain.entity). If invalid, raise TemplateError rather than returning STATE_UNKNOWN silently.",
            "Step 6: Update tests to confirm behavior and prevent regressions.",
            "Step 6.1: Add unit tests for:\n- async_render_with_collect producing the correct EntityFilter for simple entity access, domain iteration, full states iteration, and advanced constructs like selectattr + join.\n- async_track_template_result and async_track_template behavior on initial registration, state changes, and error conditions.\n- Components that use the new APIs (bayesian.binary_sensor, universal.media_player, automation templates, template switches/lights/cover/fan) to ensure they respond correctly when templates change or error.\n\nBy following these steps, a developer can incrementally migrate from fragile, static template dependency analysis to a robust, central runtime tracking system that scales to complex templates and remains maintainable over time."
        ]
    }
}
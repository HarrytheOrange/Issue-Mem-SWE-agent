{
    "search_index": {
        "description_for_embedding": "StackStorm change that moves the ChatOps integration pack into contrib so it is shipped and auto-registered, and introduces a Jinja2-based result formatting pipeline (format_result, post_message, post_result workflow, HTTP GET alias, and a notify_hubot rule) integrated with packaging for deb/rpm.",
        "keywords": [
            "StackStorm",
            "chatops pack",
            "Hubot",
            "Jinja2 template",
            "execution result formatting",
            "generic notify trigger",
            "announcement runner",
            "action-chain",
            "ActionAlias result.format",
            "st2.executions.get",
            "packaging deb rpm",
            "/opt/stackstorm/packs",
            "chatops notifications",
            "Hubot adapter"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the StackStorm ChatOps integration pack was moved into the main contrib directory so it can be shipped with the product and auto-registered, giving the team tighter control over where and when it is deployed. A new pack `contrib/chatops` was added with README, icon, actions, workflows, aliases, and rules, and the packaging scripts for both Debian and RPM were updated to copy `contrib/chatops` into `/opt/stackstorm/packs/`.\n\nWithin the new pack, three core actions were defined:\n\n1. `chatops.post_message` (announcement runner) posts messages onto the StackStorm stream for ChatOps consumers, supporting parameters like `channel`, `message`, `user`, and `whisper`.\n2. `chatops.post_result` (action-chain) is a workflow that takes a notification `result` (trigger payload), retrieves the corresponding execution via `st2.executions.get`, formats the execution result, and then posts it to the ChatOps stream.\n3. `chatops.format_result` is a Python action that uses the st2client and Jinja2 to transform an execution object into a human-readable message string.\n\n`format_result.py` initializes a `Client` using `ST2_ACTION_API_URL` and `ST2_ACTION_AUTH_TOKEN` environment variables, sets up a Jinja2 environment with custom test `in`, and loads a default Jinja template from `actions/templates/default.j2`. At runtime, it builds a `context` containing `six` and the `execution`. If the execution context references an `action_alias_ref` with an `id`, it resolves that alias using the st2client. If the alias includes a `result` section and `enabled` is true, it overrides the default template with `alias.result['format']`. The chosen template is rendered with the context and returned as the final message.\n\nThe default Jinja template implements a `serialize` macro that walks nested mappings and formats key/value pairs nicely, handling multi-line strings, and generating specialized output depending on the runner type (`http-request`, `run-python`, `python-script`, `windows-*`, `remote-shell-*`, `local-shell-*`). It shows action ref, status, and execution id, then prints a best-effort summary of the `execution.result` structure.\n\nThe `post_result` action-chain workflow (`actions/workflows/post_result.yaml`) has three steps: (1) `get_execution` calls `st2.executions.get` with `result.execution_id` from the notification trigger and publishes `execution`; (2) `format_result` invokes `chatops.format_result` with that `execution` and publishes `message`; and (3) `post_message` calls `chatops.post_message` with `user`, `channel`, `whisper`, and the formatted `message`.\n\nA simple example alias `contrib/chatops/aliases/http-get.yaml` was added to demonstrate this: the alias `get` maps to `core.http`, accepts `http get {{ url }}` commands, uses an `ack` format of `\"requesting...\"`, and a `result` format that accesses `execution.result.body`.\n\nA notification rule `contrib/chatops/rules/notify_hubot.yaml` named `notify` listens to `core.st2.generic.notifytrigger` and filters on `trigger.route == \"hubot\"`. When matched, it calls `chatops.post_result`, passing the `source_channel`, `user`, and the entire `trigger` as `result`. This connects StackStorm's notification system to the ChatOps pack so Hubot (or other ChatOps consumers) can receive nicely formatted execution results.\n\nLastly, the packaging scripts were updated: `contrib/chatops` is now listed in `contrib/README.md` under shipped contents and added to `st2common/packaging/debian/install` and both `st2common-rhel6.spec` and `st2common.spec` to ensure the pack is copied, permissioned (`chmod -R 775`), and installed with the core product.",
        "semantic_memory": "This change illustrates several reusable patterns for integrating an automation platform with ChatOps and for packaging internal packs as first-class components of a product.\n\nKey generalizable concepts:\n\n1. **Treat ChatOps integration as a core pack**: Moving ChatOps logic into the main contrib packs means it ships with the product and is automatically available in all installations. For any platform that uses packs/modules, critical integration features (like notifications to chat systems) should be packaged and deployed as core bundles, not as optional or external repositories. This provides consistent behavior across environments and simplifies upgrades.\n\n2. **Use a dedicated event flow: trigger → workflow → formatter → transport**: A clean ChatOps pipeline breaks into stages:\n   - A notification trigger is fired (`core.st2.generic.notifytrigger`).\n   - A workflow (`post_result`) orchestrates data retrieval and transformation.\n   - A formatter action (`format_result`) generates a human-readable string from structured execution data.\n   - A transport action (`post_message`) broadcasts the message onto a stream for chat clients.\n   This separation makes it easy to tweak formatting, change transports, or extend workflows without touching the notification rules.\n\n3. **Template-based result formatting with alias-level overrides**: Instead of hard-coding message formats in code, use a template engine (Jinja2 here) with a sensible default template that understands different result shapes by runner type. Allow specific commands (action aliases) to override the default format via a `result.format` field. This offers both global consistency and per-command customization without modifying the formatter code.\n\n4. **Expose runner-specific views of execution results**: Different runners return different structures (`stdout`, `stderr`, `exit_code`, `return_code`, `body`, nested per-host results, etc.). A generic serializer macro combined with specialized branches per runner type allows the same template to handle many result shapes gracefully. This is a robust approach in any system where execution backends vary but need to be presented uniformly to humans.\n\n5. **Using environment-provided API URLs and tokens in actions**: The formatter action grabs `ST2_ACTION_API_URL` and `ST2_ACTION_AUTH_TOKEN` from the environment to instantiate a client inside the action runtime. This pattern decouples the action from static configuration and lets the platform control connectivity and auth via environment variables or runner settings.\n\n6. **Routing notifications by logical routes**: The rule filters on `trigger.route == \"hubot\"`. Using logical `route` values in generic notification triggers allows multiple consumers (Hubot, Slack, email, etc.) to subscribe selectively to events, each with its own rule and workflow, instead of having one monolithic notification handler.\n\n7. **Packaging best practices for built-in packs**: When adding built-in functionality, you must:\n   - Place the pack under the standard contrib location so it is recognized by auto-registration logic.\n   - Update packaging manifests (`.spec` files, deb `install` files) to copy the directory into the expected packs path and set proper permissions.\n   - Document the new pack in any top-level README or index so users know it exists.\n   This ensures the component is deployed and registered in all target environments.\n\nOverall, the fix demonstrates how to design a flexible, template-driven ChatOps notification system that is treated as a core, packaged feature rather than an external, ad-hoc integration.",
        "procedural_memory": [
            "To implement or troubleshoot a ChatOps integration pack that formats and broadcasts execution results, follow these steps:",
            "Step 1: Ensure the pack is treated as a core/contrib pack",
            "- Place the pack (e.g., `chatops`) under the platform’s standard contrib path (for StackStorm, `contrib/chatops`).",
            "- Add a `pack.yaml` with `name`, `description`, `version`, and author information so the system can register the pack.",
            "- Update top-level documentation (e.g., `contrib/README.md`) to list the new pack if other contrib packs are documented there.",
            "",
            "Step 2: Wire the pack into OS packaging",
            "- For Debian packages: update the `install` file (e.g., `st2common/packaging/debian/install`) to copy the pack directory into the runtime packs location, such as:\n  - `contrib/chatops opt/stackstorm/packs/`.",
            "- For RPM packages: modify spec files (e.g., `st2common-rhel6.spec` and `st2common.spec`) to:\n  - `cp -R contrib/chatops %{buildroot}/opt/stackstorm/packs/`\n  - `chmod -R 775 %{buildroot}/opt/stackstorm/packs/chatops`.",
            "- Rebuild and install the packages, then verify that `/opt/stackstorm/packs/chatops` exists and is readable/executable.",
            "",
            "Step 3: Define the ChatOps transport action (`post_message`)",
            "- Implement an action that posts messages to your ChatOps stream. For StackStorm:\n  - Use `runner_type: announcement`.\n  - Provide parameters like `channel` (required), `message` (required), `user`, `whisper`, and any routing metadata.\n  - Keep `entry_point` empty for announcement-type actions that rely purely on metadata.",
            "- Test this action independently by manually calling it with a sample channel and message to confirm messages reach the ChatOps client.",
            "",
            "Step 4: Implement an execution result formatter (`format_result`)",
            "- Create a Python action that accepts an `execution` object as a parameter.",
            "- Inside the action:\n  - Read API URL and auth token from environment variables (e.g., `ST2_ACTION_API_URL`, `ST2_ACTION_AUTH_TOKEN`).\n  - Instantiate the platform client (`Client(api_url=..., token=...)`).\n  - Configure a Jinja2 Environment with useful options (`trim_blocks=True`, `lstrip_blocks=True`) and any custom tests/filters (e.g., a test `in` that checks membership in a list).\n  - Load a default Jinja template from a known path (e.g., `actions/templates/default.j2`).",
            "- In `run(execution)`:\n  - Build a context that includes the `execution` object and helpers (like `six`).\n  - Attempt to resolve any related action alias from the execution’s context (for StackStorm, `execution['context'].get('action_alias_ref', {}).get('id')`).\n  - Use the client to fetch the alias (`ActionAlias.get_by_id`). If the alias has a `result` section with `enabled: true` and a `format` field, override the default template with `alias.result['format']`.\n  - Render the selected template (`self.jinja.from_string(template).render(context)`) and return the string.",
            "- Design the default Jinja template to handle multiple runner types and nested result structures, using macros to serialize mappings and handle multi-line values.",
            "",
            "Step 5: Implement a workflow to fetch, format, and send results (`post_result`)",
            "- Create an action-chain or workflow that:\n  - Takes parameters such as `user`, `whisper`, `channel`, and `result` (the notification payload).\n  - First step: call the execution retrieval action (e.g., `st2.executions.get`) with `id: \"{{result.execution_id}}\"`, and publish the returned `execution`.\n  - Second step: call the formatter action (e.g., `chatops.format_result`) with `execution: \"{{execution}}\"`, and publish `message: \"{{format_result.result}}\"`.\n  - Third step: call the transport action (e.g., `chatops.post_message`) with `user`, `channel`, `whisper`, and the formatted `message`.",
            "- Test this workflow by feeding it a known execution id and verifying the final chat message content.",
            "",
            "Step 6: Define action aliases and alias-level result formats",
            "- Create action aliases that map chat commands to actions. For example:\n  - `name: get`, `action_ref: core.http`, with a format like `\"http get {{ url }}\"`.\n  - Add `ack.format` for immediate feedback to the user (e.g., `\"requesting...\"`).\n  - Add a `result.format` that references `execution.result` fields, such as `\"done, here it is: {{ execution.result.body }}\"`.\n  - Ensure the formatter action uses alias-specific `result.format` to override the default template when present.",
            "- Test via the chat client (e.g., `!http get http://httpbin.org/get`) and ensure the final reply matches the alias’s `result.format`.",
            "",
            "Step 7: Connect notifications to the ChatOps workflow with a rule",
            "- Define a rule that listens to the platform’s generic notification trigger and routes to the ChatOps workflow:\n  - For StackStorm: use `trigger: type: core.st2.generic.notifytrigger`.\n  - Add criteria to only handle notifications for a specific route, e.g., `trigger.route: pattern: \"hubot\", type: equals`.\n  - Configure the `action` to call `chatops.post_result` with parameters such as `channel: \"{{trigger.data.source_channel}}\"`, `user: \"{{trigger.data.user}}\"`, and `result: \"{{trigger}}\"`.",
            "- Trigger an execution that emits a notification with `route: hubot` and confirm the message appears in the chat channel with formatted results.",
            "",
            "Step 8: Debugging and diagnosing issues",
            "- If ChatOps messages are not appearing:\n  - Verify the `chatops` pack is installed under the correct path (`/opt/stackstorm/packs/chatops`) and registered.\n  - Check that the OS packages you installed contain the `contrib/chatops` directory and that file permissions (775) are correct.\n  - Confirm the notification trigger is firing (inspect execution history or logs for `core.st2.generic.notifytrigger`).\n  - Verify the notification `route` matches the rule’s criteria (e.g., `hubot`).\n  - Ensure the workflow `chatops.post_result` is executing and not failing in any step.\n  - Inspect the `format_result` action logs for Jinja rendering errors and confirm it can reach the API (API URL and token from environment are valid).\n  - Validate action alias definitions: check that `result.format` is well-formed Jinja and references valid fields in `execution.result`.",
            "",
            "Step 9: Extending the pattern",
            "- To support additional runners or result shapes, update the default Jinja template with new branches (e.g., new `elif execution.runner['name'] in (...)` blocks with appropriate serialization logic).",
            "- To add new chat transports (e.g., Slack instead of Hubot), create additional `post_*` actions and rules keyed on different `route` values, while reusing the same `format_result` logic.",
            "- To change formatting for specific commands, only modify `result.format` in the relevant action aliases, leaving the core formatter code untouched."
        ]
    }
}
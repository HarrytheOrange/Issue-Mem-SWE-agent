{
    "search_index": {
        "description_for_embedding": "Optuna example cleanup: removed deprecated n_jobs argument from study.optimize in rl/sb3_simple.py by eliminating the N_JOBS constant and relying on the default single-job behavior.",
        "keywords": [
            "Optuna",
            "study.optimize",
            "n_jobs deprecation",
            "examples/rl/sb3_simple.py",
            "API change",
            "backward compatibility",
            "deprecation warning",
            "stable-baselines3",
            "single-threaded optimization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Optuna repository, the `examples/rl/sb3_simple.py` example used `n_jobs` when calling `study.optimize`, with a constant `N_JOBS = 2`. In Optuna v2.7.0, the `n_jobs` parameter for `study.optimize` was deprecated. Keeping this argument in the example code would cause deprecation warnings and encourage users to rely on a parameter that is being phased out. The initial patch changed `N_JOBS` from 2 to 1 to match the new recommended default behavior, but after discussion, the maintainers suggested completely removing `N_JOBS` and not passing `n_jobs` at all, since the default for `study.optimize` is already 1. The final fix removed the `N_JOBS` constant and updated the `study.optimize` call from `study.optimize(objective, n_trials=N_TRIALS, n_jobs=N_JOBS, timeout=600)` to `study.optimize(objective, n_trials=N_TRIALS, timeout=600)`. This aligns the example with the current API, eliminates reliance on a deprecated parameter, and avoids deprecation warnings while preserving the same single-job execution behavior.",
        "semantic_memory": "When a library deprecates an API parameter, example code and documentation must be updated to avoid using that parameter, especially when the deprecated behavior is still the default. Continuing to include deprecated arguments in examples can mislead users and produce noisy warnings. A robust pattern is to (1) remove unnecessary parameters that only restate defaults, and (2) avoid exposing deprecated options in starter or tutorial code. For job parallelism, many optimization libraries are moving toward simpler defaults or centralized configuration rather than per-call parameters, so examples should highlight the supported, future-proof interface. More generally, when adapting to a deprecation, it is often better to remove redundant configuration completely rather than hardcoding the same value, so the code automatically tracks future default changes without extra maintenance.",
        "procedural_memory": [
            "When you see deprecation warnings or know that an API parameter has been deprecated, review all sample and production code that uses it and determine if it is truly needed.",
            "Step 1: Identify the deprecated parameter and its usage. Search the codebase (including `examples/` and documentation snippets) for the parameter name (e.g., `n_jobs=`).",
            "Step 2: Consult the library's changelog or documentation to understand the deprecation: what is the new default behavior, what is the recommended alternative, and when the parameter will be removed.",
            "Step 3: For each usage, check whether passing the parameter changes behavior compared to the current default. If it simply restates the default (e.g., `n_jobs=1` when the default is already 1), prefer removing the parameter rather than hardcoding it.",
            "Step 4: If behavior would change by removing the parameter, decide whether you need that non-default behavior. If you do, migrate to the library's recommended replacement configuration; if not, remove the parameter.",
            "Step 5: Clean up any now-unused constants or variables that existed solely to support the deprecated parameter (e.g., remove `N_JOBS` if it is no longer referenced).",
            "Step 6: Run tests and example scripts to ensure there are no runtime errors and the behavior matches expectations (e.g., same number of trials, same single-threaded execution).",
            "Step 7: If contributing to a public project, clearly describe in the PR that you are removing use of a deprecated parameter, explain that behavior is preserved because the library default matches the previously configured value, and reference the relevant deprecation or version change.",
            "Step 8: For future maintenance, avoid specifying parameters that merely mirror defaults unless there is a strong reason; this reduces churn when defaults or APIs evolve."
        ]
    }
}
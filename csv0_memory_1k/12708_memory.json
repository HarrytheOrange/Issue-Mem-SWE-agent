{
    "search_index": {
        "description_for_embedding": "Home Assistant integration for the Xiaomi MiIO Air Quality Monitor (PM2.5) as a read-only sensor platform (sensor.xiaomi_miio). Initial attempts wrongly added turn_on/turn_off services to sensors and extended the generic sensor domain with toggle support. The final fix reverts sensors back to pure Entity (no services), adds proper async integration, availability handling, unique_id, and uses python-miio to expose AQI plus power/charging/battery/time_state attributes.",
        "keywords": [
            "Home Assistant",
            "Xiaomi MiIO",
            "Air Quality Monitor",
            "PM2.5",
            "sensor.xiaomi_miio",
            "python-miio",
            "Entity vs ToggleEntity",
            "sensor domain services",
            "turn_on/turn_off removed",
            "PlatformNotReady",
            "availability handling",
            "unique_id"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request adds support in Home Assistant for the Xiaomi Mi Air Quality Monitor (PM2.5) via a new sensor platform `sensor.xiaomi_miio`. The sensor exposes the Air Quality Index (AQI) as its main state and adds attributes for power, charging status, battery level, time_state, and model. Configuration uses host and token credentials and depends on `python-miio==0.3.7`.\n\nInitially, the author implemented the Xiaomi sensor as a `ToggleEntity` and tried to expose `turn_on`/`turn_off` services directly from the sensor platform. They even temporarily modified the generic `sensor` component (`homeassistant/components/sensor/__init__.py`) to register domain-level services `sensor.turn_on`, `sensor.turn_off`, and `sensor.toggle`, and to provide convenience helpers like `is_on`, `turn_on`, and `toggle`. This conflicted with core design guidance: sensors in Home Assistant should be read-only and must not have services for turning devices on/off.\n\nAfter discussion with a core maintainer, the author iterated through several patches: \n- First, they added per-platform service handling in `sensor.xiaomi_miio` to map `SERVICE_TURN_ON`/`SERVICE_TURN_OFF` to `async_turn_on`/`async_turn_off` on the entity and stored devices in `hass.data` under a simple `PLATFORM` key.\n- Then they refactored to use a namespaced `DATA_KEY` (`'sensor.xiaomi_miio'`) for `hass.data` to avoid clashes with other domains. \n- Next, they moved turn_on/off to the abstract sensor component (trying to make all sensors potentially toggleable) and made the Xiaomi sensor a `ToggleEntity` with `is_on` state. This introduced support code for grouping all sensors and providing `sensor.is_on()` semantics.\n- Following feedback that \"A sensor should never have services\", the PR was revised again: sensor-domain services and helpers were completely removed from `sensor/__init__.py`, and the Xiaomi sensor was migrated back from `ToggleEntity` to a plain `Entity`. The turn_on/turn_off methods and any toggle logic were deleted.\n\nIn the final version, `sensor.xiaomi_miio` does the following:\n- Defines a `PLATFORM_SCHEMA` with required `host` and `token` (32-char string), optional `name`, and adds `python-miio==0.3.7` to `requirements_all.txt`.\n- Implements `async_setup_platform` (using async/await) that creates an `AirQualityMonitor` device, fetches `info()` to log model/firmware/hardware, constructs a unique_id from model and MAC address, and instantiates `XiaomiAirQualityMonitor` as an `Entity`. If the device cannot be contacted (miio `DeviceException`), it raises `PlatformNotReady` so HA can retry later.\n- Stores the device instance in `hass.data['sensor.xiaomi_miio'][host]` and adds it with `update_before_add=True`.\n- The entity implements `should_poll = True`, `name`, `unit_of_measurement = 'AQI'`, `icon`, `unique_id`, `available`, `state`, and `device_state_attributes`. \n- `async_update` calls `self._device.status` via `hass.async_add_job`, updates `self._state` with `state.aqi`, and populates attributes: `power`, `usb_power` as `charging`, `battery`, and `time_state`. On success it sets `_available = True`; on miio `DeviceException` it sets `_available = False` and logs the error.\n- A helper `_try_command` remains to run device calls and mark availability false when they fail, but actual turn_on/turn_off usage was removed. Availability is no longer inferred from a non-None state but from an explicit `_available` flag.\n\nThus the PR ends by adding a robust, read-only Xiaomi MiIO air quality sensor that adheres to HA's architectural rule that sensors must not expose control services.",
        "semantic_memory": "Generalizable lessons and patterns from this change:\n\n1. **Sensors in Home Assistant are read-only and must not have control services.**\n   - The core architecture treats the `sensor` domain as descriptive, not actionable. A sensor entity should expose state and attributes but should not implement `turn_on`, `turn_off`, or `toggle` as public services. If a physical device that produces sensor data is also controllable (e.g., turning the monitor on/off), that control should generally be represented as a separate entity in an appropriate domain (e.g., `switch`, `fan`, `light`, etc.), not by overloading `sensor`.\n   - Adding domain-wide services (like `sensor.turn_on`) or making the abstract sensor component manage `is_on` is considered a design error and will be reverted.\n\n2. **Keep domain responsibilities separated; don't generalize special cases into core abstractions prematurely.**\n   - Trying to add turn_on/turn_off behavior to the entire sensor domain to support a single device introduced unnecessary complexity (groups of all sensors, `is_on` helpers, new service schemas). This was later all removed when it became clear it violated the design. This underscores the importance of aligning with core architecture before changing generic components.\n\n3. **Use a namespaced `DATA_KEY` for platform-specific storage in `hass.data`.**\n   - Instead of using a generic string like `'xiaomi_miio'`, the final implementation uses `DATA_KEY = 'sensor.xiaomi_miio'`. This prevents collisions between different domain/platform combinations and makes it clear what data belongs where. This is a recommended pattern when storing per-platform objects in `hass.data`.\n\n4. **Use async/await with `async_add_job` to integrate blocking I/O in Home Assistant.**\n   - Device libraries like `python-miio` are typically synchronous. The platform wraps calls such as `device.info()` and `device.status()` via `await hass.async_add_job(...)` inside `async_setup_platform` and `async_update`. This keeps the event loop responsive and aligns with HAâ€™s async architecture.\n\n5. **Implement robust availability handling.**\n   - Instead of assuming a sensor is available whenever `state` is non-None, the final code maintains an explicit `_available` flag. Device calls are wrapped in `try/except` for the library's `DeviceException`. On failure, `_available` is set to `False`; on success it is set to `True`. This pattern yields more accurate UI behavior and safer automations.\n\n6. **Provide a stable, unique ID for entities.**\n   - The sensor builds a `unique_id` from the device model and physical MAC address: `f\"{model}-{mac_address}\"`. This allows HA to maintain stable entity IDs, supports entity registry, and is a general best practice for device integrations.\n\n7. **Pin external library versions and document new integrations.**\n   - The integration adds `python-miio==0.3.7` to `requirements_all.txt` with appropriate comments linking the Xiaomi MiIO components that depend on it. This consolidation avoids version drift between platforms that share the same library.\n\nOverall, the main conceptual takeaway is: respect domain semantics (sensors = read-only), keep device control in appropriate domains, and integrate devices asynchronously with explicit availability and unique IDs.",
        "procedural_memory": [
            "How to correctly integrate a new read-only sensor device in Home Assistant (and avoid incorrectly adding services):",
            "Step 1: Confirm domain semantics.\n- Determine whether your device should be modeled as a `sensor`, `binary_sensor`, `switch`, etc.\n- If the only thing your entity does is expose state (e.g., an AQI reading), use `sensor`.\n- If the device is controllable (on/off, mode changes), represent control in a suitable control domain (switch, fan, etc.) rather than extending `sensor` with services.",
            "Step 2: Define the platform schema and requirements.\n- Create `homeassistant/components/sensor/your_platform.py`.\n- Import and extend `PLATFORM_SCHEMA` with any configuration options:\n  - Require addresses/tokens as needed (e.g., `CONF_HOST`, `CONF_TOKEN`).\n  - Use `vol.All` and `vol.Length` for validation (e.g., 32-char tokens).\n- Add any external library your integration needs to `requirements_all.txt`, pinned to a known-good version, and tag it with comments for all components that use it.",
            "Step 3: Setup your platform asynchronously and handle 'not ready' errors.\n- Implement `async def async_setup_platform(hass, config, async_add_devices, discovery_info=None):`.\n- Inside, import the device library (e.g., `from miio import AirQualityMonitor, DeviceException`).\n- Initialize the device object with host/token from `config`.\n- Fetch some basic info (`device.info()`) to verify connectivity and log model/firmware/hardware.\n- If the device throws a library-specific exception (like `DeviceException`), raise `PlatformNotReady` so Home Assistant retries later instead of failing permanently.",
            "Step 4: Use a dedicated DATA_KEY for storing devices in hass.data.\n- Define a constant like `DATA_KEY = 'sensor.your_platform'`.\n- In `async_setup_platform`, initialize `hass.data[DATA_KEY]` if not present and store your device instance under a key (e.g., the host address).\n- This avoids collisions across platforms and domains and clarifies where each platform keeps its state.",
            "Step 5: Implement the entity as a read-only Entity.\n- Subclass `Entity` (not `ToggleEntity`) when you are modeling a pure sensor.\n- Implement these properties and methods:\n  - `should_poll` returning `True` if you poll the device.\n  - `name` returning the configured or default name.\n  - `unit_of_measurement`, e.g., `'AQI'`.\n  - `icon` with an appropriate Material Design Icons identifier.\n  - `unique_id` built in a stable, device-specific way (often model + MAC or serial).\n  - `available` returning an internal `_available` flag.\n  - `state` returning your main measurement (e.g., `state.aqi`).\n  - `device_state_attributes` returning a dict of extra attributes (battery level, power, charging, etc.).",
            "Step 6: Use async/await and async_add_job to call synchronous device APIs.\n- In your entity, implement `async def async_update(self):`.\n- Use `state = await self.hass.async_add_job(self._device.status)` (or equivalent) to make synchronous library calls off the event loop.\n- Log the state for debugging and map library fields to Home Assistant state and attributes.",
            "Step 7: Handle device errors and availability explicitly.\n- Wrap device calls (both in setup and in updates) with `try/except` for library-specific exceptions.\n- In `async_update`, on success:\n  - Set `_available = True`.\n  - Update `self._state` and any attributes from the device's status object.\n- On failure:\n  - Set `_available = False`.\n  - Log the exception with enough context to debug network or token issues.\n- If you need a generic helper for executing device commands, follow the pattern of `_try_command(mask_error, func, *args, **kwargs)` that logs errors and updates `_available`.",
            "Step 8: Do NOT add domain-level turn_on/turn_off services to the sensor component.\n- Avoid modifying `homeassistant/components/sensor/__init__.py` to add services like `sensor.turn_on`, `sensor.turn_off`, or `sensor.toggle`.\n- Do not implement `is_on`, `async_turn_on`, `async_turn_off`, or `async_toggle` on sensor entities purely to control the physical device.\n- If control is required, implement a separate entity (e.g., `switch.xiaomi_miio`) in the appropriate domain and expose the services there.",
            "Step 9: Add and test the platform.\n- Register the entity in `async_setup_platform` via `async_add_devices([device], update_before_add=True)` so the first state is fetched before HA shows it.\n- Create a minimal `configuration.yaml` snippet for manual testing, like:\n  - `sensor:`\n    `  - platform: xiaomi_miio`\n    `    name: Xiaomi Air Quality Monitor`\n    `    host: 192.168.x.x`\n    `    token: <32-char-token>`\n- Verify that the entity appears, updates its AQI value, exposes attributes, and correctly shows as unavailable when the device is offline or unreachable.",
            "Step 10: Refactor any existing incorrect implementations.\n- If you previously added services or toggle behavior to the sensor domain to support a specific device:\n  - Remove domain-level service registrations (`SERVICE_TURN_ON`, `SERVICE_TURN_OFF`, `SERVICE_TOGGLE`) from `sensor/__init__.py`.\n  - Remove helper functions like `is_on`, `turn_on`, `toggle` from the abstract sensor component.\n  - Revert sensors that inherit from `ToggleEntity` back to `Entity` unless they truly represent binary on/off semantics in a supported domain.\n  - Move any control services to an appropriate domain (e.g., `switch.xiaomi_miio`) and adjust automations accordingly."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant homekit_controller bug where newly discovered HomeKit entities were set up via discovery.load_platform but not added to the integration's internal entities list due to a missing append call. Fix adds self.entities.append((aid, iid)) after successful platform load to correctly track entities.",
        "keywords": [
            "homekit_controller",
            "Home Assistant",
            "accessory_setup",
            "missing append",
            "entity tracking",
            "discovery.load_platform",
            "integration state consistency",
            "backport regression",
            "config entry branch",
            "device discovery bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant homekit_controller integration, a regression was introduced while backporting changes from a long-running config entry branch. During accessory setup, each HomeKit service is inspected and, if a corresponding Home Assistant component is found, discovery.load_platform is called to set up the entity. However, unlike the original or intended logic, the (aid, iid) pair identifying the accessory instance was not being appended to self.entities after the platform load. This meant entities were created but not tracked in the integration's internal entities list, potentially breaking later operations that rely on self.entities for updates, clean-up, or state management. The fix is a one-line change in homeassistant/components/homekit_controller/__init__.py: after a successful discovery.load_platform call, the code now executes self.entities.append((aid, iid)), restoring proper tracking of created entities. This was identified in code review (comment by @MartinHjelmare) as an error in the backport and corrected accordingly.",
        "semantic_memory": "When building integrations that manage dynamically discovered entities, it is crucial to maintain a consistent internal registry of those entities. Any place where an entity is created, loaded, or otherwise materialized (e.g., via a discovery mechanism) must also ensure the entity is registered with the integration's internal tracking structures. Omitting a seemingly small step like appending an identifier to a list can lead to subtle bugs, such as entities that exist in the system but are never updated, never cleaned up, or are not reachable by later logic that assumes the registry is authoritative. Backporting or cherry-picking code between branches is particularly error-prone: it's easy to bring over the entity creation logic but forget related bookkeeping lines, especially if they were added in separate commits. Code reviews and tests that exercise the full lifecycle of discovered entities (creation, update, and removal) are key to catching these discrepancies. A best practice is to centralize entity registration logic or enforce invariants such that any successful creation path must also update the internal registry in a single, shared code path.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom: Look for inconsistencies between entities that appear to be created (e.g., visible in logs or partially in the UI) and the integration’s internal tracking structures (lists, dicts, registries like self.entities). Symptoms may include entities not updating, not unloading, or not being found in internal lookups.",
            "Step 2: Trace the entity lifecycle: For the problematic entity type, trace where it is discovered and created (e.g., discovery.load_platform or equivalent). Examine every code path that leads to entity creation during setup or discovery.",
            "Step 3: Verify registry updates: For each entity creation path, check that the integration updates its internal registry (e.g., appending (aid, iid) pairs to self.entities or equivalent structures). Compare with similar, working code paths to spot missing registration calls.",
            "Step 4: Compare branches/commits when backporting: If the issue arises after backporting or cherry-picking changes, diff the working branch against the target branch for the affected function or module. Look specifically for small bookkeeping lines (append, add, register) that might not have been copied over.",
            "Step 5: Add or restore the missing registration: Once the missing registry update is identified, add the appropriate code at the correct place—typically immediately after successful entity creation or platform loading. For example, after discovery.load_platform(...), add self.entities.append((aid, iid)) to ensure the entity is tracked.",
            "Step 6: Write or run lifecycle tests: Implement tests that not only verify entities are created, but also that they are present in the integration’s internal registry and can be updated/removed. Use these tests to guard against similar regressions in future refactors or backports.",
            "Step 7: Perform integration testing: Run the system end-to-end (e.g., pairing a HomeKit accessory, triggering discovery, and then updating/removing it) to confirm that entities behave correctly throughout their lifecycle and that no orphaned or untracked entities remain.",
            "Step 8: Document invariants: Optionally document in code comments or developer docs that every successful entity creation must update the internal registry, and consider refactoring to a single helper that encapsulates both creation and registration to reduce the risk of missing steps."
        ]
    }
}
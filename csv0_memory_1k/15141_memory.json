{
    "search_index": {
        "description_for_embedding": "Home Assistant PR adding a new switch.ecoplug platform to support Wion/EcoPlug smart plugs via pyecoplug, with automatic network discovery, polling-based state updates, and proper Home Assistant integration (requirements_all, coveragerc, and config schema). Iterative fixes addressed linting, dependency declaration, entity lifecycle, and discovery shutdown.",
        "keywords": [
            "Home Assistant",
            "switch.ecoplug",
            "EcoPlug",
            "Wion",
            "pyecoplug",
            "device discovery",
            "auto-discovery",
            "SCAN_INTERVAL",
            "SwitchDevice",
            "hass.bus.listen_once",
            "requirements_all.txt",
            "coveragerc",
            "voluptuous",
            "PLATFORM_SCHEMA",
            "entity lifecycle"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR introduced a new Home Assistant switch platform to support Wion/EcoPlug Wi-Fi plugs using the external library pyecoplug. The goal was to auto-discover devices on the network and expose them as switch entities without explicit configuration, with periodic polling to keep their on/off state synced.\n\nThe initial implementation created homeassistant/components/switch/ecoplug.py and defined EcoPlugSwitch(SwitchDevice), which wrapped a pyecoplug device object. It implemented is_on, turn_on, turn_off, and update to query the real device state. The platform set SCAN_INTERVAL to 5 seconds and used pyecoplug.EcoDiscovery to discover devices. Discovered plugs were added via add_devices, and discovery was stopped using a listener on EVENT_HOMEASSISTANT_STOP.\n\nOver multiple iterations, the author:\n- Cleaned up imports (removed unused ATTR_HIDDEN, EVENT_TIME_CHANGED, ToggleEntity, etc.).\n- Ensured a default name via DEVICE_DEFAULT_NAME when the plug has no name.\n- Added module and method docstrings to satisfy HA’s linting and style requirements.\n- Experimented with different forms of REQUIREMENTS (first a direct zip URL, later a proper `pyecoplug==0.0.5` pinned dependency) and added pyecoplug to requirements_all.txt.\n- Added ecoplug.py to .coveragerc’s omit list.\n- Adjusted the switch entity to initialize _state as None and rely on update() to fetch the real state, rather than querying in __init__.\n- Refactored setup_platform to use hass.data as a shared dict of discovered devices to avoid duplicate entities, and to tie the EcoDiscovery lifecycle to the Home Assistant event bus.\n- Attempted to implement removal of devices discovered by pyecoplug by wiring a remove callback, but used async_will_remove_from_hass incorrectly (this API is a method on entities, not a free function), so the removal logic is likely not functional.\n- Started to introduce a CONFIG/PLATFORM_SCHEMA with voluptuous (DEVICE_SCHEMA, PLATFORM_SCHEMA), but left it incomplete and likely invalid (e.g., misusing SCAN_INTERVAL as a config key without proper typing and missing imports for voluptuous and config constants).\n\nDespite the progress, the PR was never merged. A maintainer requested signing the CLA, and after going stale, the PR was closed. Functionally, the PR shows how to wrap pyecoplug into a Home Assistant switch platform with auto-discovery and basic entity behavior, but the final revision still has some structural issues (particularly around removal and configuration schema).",
        "semantic_memory": "Generalizable knowledge from this PR centers on how to add and refine a new device platform in Home Assistant, especially for auto-discovered network devices.\n\nKey concepts and patterns:\n\n1. **Wrapping an external device library as a Home Assistant entity**\n   - Use an external Python library (pyecoplug) to abstract low-level device communication.\n   - Implement a SwitchDevice (or other entity type) that:\n     - Holds a reference to the library’s device object.\n     - Exposes `name` and state properties (`is_on`, or appropriate domain-specific properties).\n     - Implements control methods (`turn_on`, `turn_off`) by delegating to the library.\n     - Uses `update()` to refresh and cache state (_state) from the library’s API.\n   - Avoid doing network I/O in `__init__`; set initial state to None and let Home Assistant call `update()`.\n\n2. **Automatic discovery and entity registration**\n   - Use a discovery helper from the device library (here, EcoDiscovery) to find devices on the network asynchronously.\n   - Provide callbacks to the discovery object:\n     - `add(plug)` to wrap a newly discovered device into a Home Assistant entity and register it via `add_devices`.\n     - Optionally, `remove(plug)` to tear down entities when devices disappear.\n   - Maintain a set/dict of already-discovered identifiers (e.g., device name or MAC) to prevent duplicate entities when the same device is rediscovered.\n\n3. **Integration with Home Assistant platform lifecycle**\n   - Implement `setup_platform(hass, config, add_devices, discovery_info=None)` to:\n     - Initialize any discovery mechanisms.\n     - Register a listener for `EVENT_HOMEASSISTANT_STOP` to cleanly stop background discovery (e.g., `hass.bus.listen_once(EVENT_HOMEASSISTANT_STOP, stop_disco)`).\n   - Use `SCAN_INTERVAL` to define the default polling interval for the platform, letting Home Assistant schedule regular calls to each entity’s `update()`.\n   - Use `DEVICE_DEFAULT_NAME` to ensure entities always have a sensible name.\n\n4. **Configuration and validation with voluptuous**\n   - Extend `PLATFORM_SCHEMA` to define optional configuration keys (e.g., per-device config, automatic_add flags), using voluptuous types and defaults.\n   - Ensure all schema-related symbols (vol, cv, CONF_NAME, CONF_DEVICES, PLATFORM_SCHEMA, etc.) are imported, and that keys are regular strings, not objects like `SCAN_INTERVAL`.\n   - Misusing config keys or omitting imports can make the platform unusable at runtime.\n\n5. **Dependencies and project-wide integration**\n   - Declare third-party requirements via module-level `REQUIREMENTS = ['pyecoplug==0.x.y']`.\n   - Add the dependency to `requirements_all.txt` with a comment referencing the component, to keep the project’s dependency graph complete.\n   - Avoid pinning to GitHub zip URLs in REQUIREMENTS for a long-term integration; prefer published, version-pinned packages.\n   - If test coverage is not yet available, add the new component to `.coveragerc`’s omit list to avoid impacting coverage metrics (temporary but common during initial feature work).\n\n6. **Entity removal and async lifecycle caveats**\n   - Removing entities dynamically is non-trivial in older-style sync platforms; you cannot call entity methods (like `async_will_remove_from_hass`) as free functions or from the platform module without a handle to the actual entity instance.\n   - Dynamic removal must be coordinated with Home Assistant’s entity registry and either use the entity object itself or rely on more advanced APIs; otherwise, a `remove` callback should be omitted or implemented as a no-op.\n\n7. **Process/maintenance lessons**\n   - PRs that add new integrations must adhere to stylistic and architectural guidelines: docstrings, linting, configuration validation, dependency management, and test considerations.\n   - Contributor license agreements (CLAs) are mandatory in many open-source projects; failing to sign will block merging regardless of code quality.\n   - Long-lived, unmaintained PRs risk being closed as stale, so responding promptly to review feedback is critical.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Understand the device library and capabilities\n- Identify an external Python library that communicates with the target device (e.g., pyecoplug for EcoPlug/Wion).\n- Verify that the library can perform all needed operations: discovery, status fetch, and control (on/off).\n- Experiment with the library standalone to ensure it works correctly in your environment.",
            "Step 2: Design the Home Assistant entity wrapper\n- Choose the appropriate Home Assistant entity type (SwitchDevice, Light, Sensor, etc.).\n- Implement a wrapper class that:\n  - Stores the underlying device object.\n  - Exposes `name` and state properties (`is_on`, `state`, etc.).\n  - Implements control methods by delegating to the library API (e.g., `self._plug.turn_on()`).\n  - Implements `update()` to query current state from the device and store it in private attributes (e.g., `self._state`).\n- Initialize internal state to None in `__init__` and rely on `update()` for the first actual state fetch.",
            "Step 3: Implement setup_platform and discovery\n- Define `setup_platform(hass, config, add_devices, discovery_info=None)` as the entry point.\n- Import any discovery helper from the device library (e.g., `from pyecoplug import EcoDiscovery`).\n- Create a dictionary / set in `hass.data` to track discovered devices and avoid duplicates (e.g., `discovered = hass.data.setdefault(DOMAIN, {})`).\n- Implement an `add(device)` callback:\n  - Compute a unique key (name, ID, MAC, etc.).\n  - If the key is not already in `discovered`, create a new entity and call `add_devices([entity])`.\n  - Store the device reference in `discovered` to mark it as handled.\n- If the library supports removal, implement a `remove(device)` callback, but only attempt entity removal if you have a reference to the existing entity and can call its lifecycle methods correctly; otherwise, document that removal is not currently supported.",
            "Step 4: Wire discovery lifecycle to Home Assistant\n- Instantiate the discovery object with the add/remove callbacks (e.g., `disco = EcoDiscovery(add, remove)`).\n- Start discovery (e.g., `disco.start()`).\n- Define a `stop_disco(event)` function that stops discovery (e.g., `disco.stop()`).\n- Register a one-time listener for `EVENT_HOMEASSISTANT_STOP` to call `stop_disco`, ensuring no background threads continue after HA shutdown.",
            "Step 5: Configure polling and state updates\n- Set `SCAN_INTERVAL = timedelta(seconds=n)` at module level to specify how often Home Assistant should call `update()` on your entities.\n- Ensure your entity’s `update()` does not block excessively or raise unhandled exceptions; handle network errors gracefully (e.g., catch exceptions and log them).",
            "Step 6: Define configuration schema\n- Import voluptuous and helpers (e.g., `import voluptuous as vol`, `import homeassistant.helpers.config_validation as cv`).\n- Import `PLATFORM_SCHEMA` and any required config keys (e.g., `CONF_NAME`, `CONF_DEVICES`, `CONF_SCAN_INTERVAL`, or a custom key like `CONF_AUTOMATIC_ADD`).\n- Extend `PLATFORM_SCHEMA` with your platform’s options (e.g., per-device config, flags controlling automatic discovery).\n- Use proper keys and types, not objects like `SCAN_INTERVAL`; if you want a configurable scan interval, use a dedicated config key and map it to a timedelta in code.\n- Validate that the schema is syntactically and semantically correct before committing.",
            "Step 7: Manage dependencies and project integration\n- Declare external library requirements via `REQUIREMENTS = ['library_name==x.y.z']` at module level.\n- Add the same dependency and version to `requirements_all.txt`, annotated with a comment linking it to your component.\n- Run Home Assistant’s tooling (e.g., `script/gen_requirements_all.py`) to regenerate requirements if needed.\n- If tests are missing initially, temporarily add the new file to `.coveragerc`’s omit list, but plan to write tests and remove it later.",
            "Step 8: Test and lint the component\n- Run local tests (e.g., `tox`) to ensure style and unit tests pass.\n- Test the platform manually with real hardware if possible:\n  - Start Home Assistant with the new component enabled.\n  - Verify that devices are discovered and appear in the UI.\n  - Confirm that toggling the entity correctly controls the physical device.\n  - Check that HA shuts down cleanly and that any discovery threads stop without errors.",
            "Step 9: Handle entity removal correctly (if required)\n- If automatic removal of devices is needed, design a mapping from device identity to the created entity instance so you can call entity methods like `async_will_remove_from_hass` properly.\n- Avoid calling asynchronous entity methods as standalone functions; they must be invoked on the entity object, typically inside HA’s event loop.\n- If robust removal is too complex for an initial version, clearly document that dynamic removal is not yet supported and ensure the `remove` callback is either a no-op or safely implemented.",
            "Step 10: Maintain contribution hygiene\n- Add or update documentation in the docs repo to describe configuration and behavior.\n- Ensure the CLA is signed (or any equivalent project requirement) before expecting a merge.\n- Respond promptly to maintainer review comments, especially around architecture (use of hass.data, config schema, async vs sync APIs).\n- Keep the PR up to date with the main branch to avoid it going stale and being closed."
        ]
    }
}
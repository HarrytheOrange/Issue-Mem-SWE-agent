{
    "search_index": {
        "description_for_embedding": "Home Assistant Aftership integration extended to expose detailed tracking data via a 'trackings' attribute and to support adding/removing packages through dedicated services. The sensor now refreshes reliably after these service calls using dispatcher-based callbacks, with proper throttling and services.yaml documentation.",
        "keywords": [
            "homeassistant",
            "aftership",
            "sensor",
            "trackings attribute",
            "add_tracking service",
            "remove_tracking service",
            "services.yaml",
            "async_update",
            "Throttle",
            "dispatcher",
            "UPDATE_TOPIC",
            "DOMAIN constant",
            "pyaftership",
            "entity attributes",
            "integration design"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this Pull Request, the Aftership integration for Home Assistant was enhanced to better support UI use cases and dynamic management of package trackings. Originally, the Aftership sensor only exposed simple counts of packages by status and had no native way to add or remove trackings from within Home Assistant. The author needed richer data for a custom Lovelace card and the ability to manage trackings via Home Assistant services. To achieve this, the sensor implementation was modified to:\n\n1. Add a new `trackings` attribute on the sensor entity: a list of dictionaries, one per tracking, containing fields like `name`, `tracking_number`, `slug`, `link` (constructed from a base URL and slug/number), `last_update`, `expected_delivery`, `status` (Aftership tag), and `last_checkpoint` (latest checkpoint from the tracking data).\n2. Introduce two new services in the Aftership domain: `aftership.add_tracking` and `aftership.remove_tracking` (internally named `add_tracking` and `remove_tracking` and bound to the `aftership` domain). These services accept `tracking_number`, optional `title`, and optional `slug` (for add) and `tracking_number` + `slug` (for remove). Voluptuous schemas validate the inputs.\n3. Wire these services up in `async_setup_platform`: they call `pyaftership`'s `add_package_tracking` and `remove_package_tracking` methods and then trigger an update of the sensor state.\n4. Ensure updates after service calls are timely and respect throttling. Initially, the code attempted to call `instance.async_update(no_throttle=True)` directly. This was refactored to use Home Assistant's dispatcher: a constant `DOMAIN` was moved into `aftership/const.py`, an `UPDATE_TOPIC` string (`aftership_update`) was introduced, and `async_dispatcher_send(hass, UPDATE_TOPIC)` is called from the service handlers. The sensor's `async_added_to_hass` subscribes to this topic and calls a `force_update` coroutine, which invokes `async_update(no_throttle=True)` and then `async_update_ha_state()`.\n5. The core `async_update` method remains throttled with `@Throttle(MIN_TIME_BETWEEN_UPDATES)` (now five minutes), fetches trackings from Aftership, validates the API response (`meta` exists and code is 200), aggregates status counts while ignoring 'delivered' for the main state, and builds the detailed `trackings` list. The sensor state is set to the number of non-delivered trackings, and attributes combine attribution, status counts, and the `trackings` list.\n6. A new `services.yaml` file for the Aftership component documents the `add_tracking` and `remove_tracking` services, their descriptions, and expected fields, aligning with Home Assistant service documentation conventions.\n\nAdditional minor cleanups included reusing config constants (`CONF_TITLE`, `CONF_SLUG`, `CONF_TRACKING_NUMBER`), changing the unit to the string 'packages', adjusting the update interval, centralizing the DOMAIN constant in `const.py`, and making small linting and formatting fixes. The resulting integration now exposes richer structured data usable by front-end cards and allows users to manage Aftership packages entirely within Home Assistant while keeping updates efficient and synchronized.",
        "semantic_memory": "This change illustrates several reusable patterns for Home Assistant integrations and asynchronous service-driven state updates:\n\n1. **Expose rich, structured attributes for front-end consumption**: Instead of only publishing aggregate counts or basic states, sensors can provide detailed lists or dictionaries under an attribute key (e.g., `trackings`) with all the fields a UI might need. This avoids multiple API calls from the front end and lets custom Lovelace cards render complex domain data from a single entity state.\n\n2. **Use Home Assistant services for domain operations**: Domain-specific actions (like adding/removing Aftership trackings) should be exposed as services and not overloaded into entity states. Services should be clearly named under the integration's domain (e.g., `aftership.add_tracking`), validated with voluptuous schemas, and documented in `services.yaml`. This pattern generalizes to any integration that needs to create, modify, or delete remote resources.\n\n3. **Decouple service calls from entity updates via dispatcher**: When a service mutates backend state that should be reflected in entities (like adding/removing trackings), it's better to signal entities via a dispatcher topic rather than directly touching entity internals from the service handler. Using an `UPDATE_TOPIC` and `async_dispatcher_send`, entities subscribing in `async_added_to_hass` can perform `force_update` logic. This keeps services and entities loosely coupled and avoids circular dependencies.\n\n4. **Respect throttling but allow forced updates**: The `@Throttle` decorator limits how often `async_update` runs, protecting APIs. When a service requires an immediate refresh, `async_update(no_throttle=True)` can be used to bypass throttling, but should be invoked through a clean wrapper (`force_update`) that also calls `async_update_ha_state()`. This pattern balances rate-limiting with responsiveness after user-driven changes.\n\n5. **Centralize shared constants in `const.py`**: Placing cross-module constants like `DOMAIN` in a `const.py` file is a common and recommended pattern in Home Assistant. It avoids duplication, aligns imports, and simplifies future refactors.\n\n6. **Use services.yaml for discoverability and tooling**: Defining service schemas and descriptions in a `services.yaml` file improves documentation, auto-completion, and consistency in the ecosystem. Any new services in a Home Assistant integration should typically be described there.\n\n7. **Error handling and logging for API-based integrations**: Always check API responses (`meta`, status codes) and log clear error messages when calls fail, so users and maintainers can quickly diagnose configuration problems (e.g., invalid API keys) or upstream outages.\n\nOverall, this PR exemplifies how to evolve an integration from a simple read-only sensor into a richer, bidirectional interface that supports UI-driven workflows while remaining idiomatic to Home Assistant's architecture.",
        "procedural_memory": [
            "When extending a Home Assistant integration to support richer front-end use and service-driven state changes, follow these steps:",
            "Step 1: Identify the front-end data needs and structure attributes accordingly.\n- Determine what fields your UI or custom card needs (e.g., name, identifier, status, timestamps, links).\n- In your entity's `async_update`, transform the raw API data into a stable, well-structured attribute (e.g., a list of dicts under `ATTR_TRACKINGS`).\n- Ensure attribute names are consistent and future-proof, as they become a de facto API for frontend components.",
            "Step 2: Define new services with clear schemas and domain naming.\n- Choose service names that make sense under your integration's domain (e.g., `add_tracking`, `remove_tracking` for the `aftership` domain).\n- Define voluptuous schemas for each service, using existing HA config constants where appropriate (`CONF_TITLE`, `CONF_SLUG`, `CONF_TRACKING_NUMBER`).\n- Validate required fields and make optional fields truly optional with `.get()` when reading from `call.data`.",
            "Step 3: Implement service handlers in `async_setup_platform` or the appropriate setup function.\n- Inside `async_setup_platform`, after initializing your API client and entities, register the services using `hass.services.async_register(domain, service_name, handler, schema=...)`.\n- In each handler, call the appropriate client methods (e.g., `add_package_tracking`, `remove_package_tracking`) to perform the action on the external service.\n- Handle API errors: check response metadata (e.g., `meta['code']`), log meaningful error messages, and exit early on failure.",
            "Step 4: Ensure entity state updates after service-driven changes.\n- Do not directly mutate entity state or attributes from the service handler. Instead, propagate a signal that entities can respond to.\n- Use the dispatcher: define an `UPDATE_TOPIC = DOMAIN + '_update'` and call `async_dispatcher_send(hass, UPDATE_TOPIC)` at the end of each service handler.\n- In the entity class, implement `async_added_to_hass` to subscribe to this topic via `self.hass.helpers.dispatcher.async_dispatcher_connect(UPDATE_TOPIC, self.force_update)`.",
            "Step 5: Implement a force update mechanism that respects throttling logic.\n- Mark your standard `async_update` with `@Throttle(MIN_TIME_BETWEEN_UPDATES)` to protect the remote API.\n- Implement a `force_update` coroutine on the entity that calls `await self.async_update(no_throttle=True)` followed by `await self.async_update_ha_state()` so the state is immediately reflected in Home Assistant.\n- This lets service-triggered updates bypass the throttle without changing behavior for normal periodic updates.",
            "Step 6: Centralize shared constants in `const.py`.\n- Create a `const.py` file in your component package and move common constants like `DOMAIN` there.\n- Import `DOMAIN` (and any other shared constants) from `.const` in your modules instead of hardcoding strings.\n- This improves consistency and makes it easier to reuse constants for events, topics, or config flows.",
            "Step 7: Add and maintain `services.yaml` for service documentation.\n- Create or update `services.yaml` in the component directory.\n- For each service, include a description and document each field (description and example).\n- This documentation is used by the Home Assistant UI and by developers when discovering services.",
            "Step 8: Test and lint the integration.\n- Run local tests and any relevant integration tests to ensure service calls perform as expected and that entity states update correctly.\n- Verify that the throttle interval is respected, but that service-triggered updates bypass it via `no_throttle=True`.\n- Use code formatting and linting tools to clean up imports, constants, and string formatting. Confirm that `const.py`, `services.yaml`, and any new files are included in coverage and requirements metadata if needed."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant core services cleanup: restrict stop/restart/check_config and location update to admin users, enforce per-entity permissions on update_entity, validate turn_on/turn_off/toggle service calls to accept only concrete entity_ids (not 'all'/'none' or invalid values), ignore ENTITY_MATCH_ALL/NONE in group expansion, move turn_* intent registration from homeassistant to the intent integration, and add robust error handling for conversation HTTP API when intents fail.",
        "keywords": [
            "Home Assistant",
            "core services",
            "admin permissions",
            "service security",
            "SERVICE_HOMEASSISTANT_STOP",
            "SERVICE_HOMEASSISTANT_RESTART",
            "SERVICE_CHECK_CONFIG",
            "SERVICE_RELOAD_CORE_CONFIG",
            "SERVICE_SET_LOCATION",
            "SERVICE_TURN_ON",
            "SERVICE_TURN_OFF",
            "SERVICE_TOGGLE",
            "update_entity permissions",
            "Unauthorized",
            "UnknownUser",
            "entity_id validation",
            "cv.entity_ids schema",
            "ENTITY_MATCH_ALL",
            "ENTITY_MATCH_NONE",
            "group.expand_entity_ids",
            "intent integration",
            "ServiceIntentHandler",
            "conversation HTTP API",
            "intent.IntentError",
            "error handling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant core services were tightened up for both security and correctness.\n\nPreviously, any authenticated user could trigger critical core services like `homeassistant.stop`, `homeassistant.restart`, and `homeassistant.check_config`. There were minimal permission checks around `homeassistant.update_entity`, and the generic `turn_on`, `turn_off`, and `toggle` services allowed inputs like `all` or `none`, relying on downstream logic to interpret them, which could be unsafe and ambiguous. Intent handlers for turning entities on/off/toggling were registered in the `homeassistant` integration instead of the dedicated `intent` integration, and the conversation HTTP API did not robustly handle intent errors.\n\nThe changes introduced:\n- Critical core services (`homeassistant.stop`, `homeassistant.restart`, `homeassistant.check_config`, and `homeassistant.reload_core_config`) are now registered via `hass.helpers.service.async_register_admin_service`, making them admin-only operations. Tests (`test_require_admin`) verify that a read-only user invoking these services receives an `Unauthorized` exception; `SERVICE_SET_LOCATION` is also confirmed to be admin-only.\n- The `homeassistant.update_entity` service now enforces per-entity permission checks. If a call has a `context.user_id`, the code retrieves the user via `hass.auth.async_get_user`. If the user doesn't exist, it raises `UnknownUser`. For each entity in `ATTR_ENTITY_ID`, it checks `user.permissions.check_entity(entity, POLICY_CONTROL)` and raises `Unauthorized` if the user lacks control permission for any entity.\n- `turn_on`, `turn_off`, and `toggle` services for the `homeassistant` domain now use a strict voluptuous schema: `vol.Schema({ATTR_ENTITY_ID: cv.entity_ids}, extra=vol.ALLOW_EXTRA)`. This ensures that `entity_id` is a list of valid entity IDs, rejecting invalid inputs such as `None`, arbitrary strings like `'nothing'`, and the wildcard selectors `ENTITY_MATCH_ALL` and `ENTITY_MATCH_NONE`. A new test (`test_turn_on_off_toggle_schema`) asserts that these invalid values raise `vol.Invalid`.\n- The group helper `expand_entity_ids` was updated to ignore non-string IDs and to explicitly skip `ENTITY_MATCH_ALL` and `ENTITY_MATCH_NONE`. This prevents wildcard constants from being treated as actual entity IDs during group expansion.\n- Intent registration for `HassTurnOn`, `HassTurnOff`, and `HassToggle` was moved out of `homeassistant/__init__.py` and into `homeassistant/components/intent/__init__.py`. The `intent` integration now registers `ServiceIntentHandler` instances that map these intents to the `homeassistant` domain's `turn_on`, `turn_off`, and `toggle` services with appropriate speech responses.\n- Intent-related tests were moved/rewritten from `tests/components/homeassistant/test_init.py` to `tests/components/intent/test_init.py` to reflect the new responsibility of the `intent` integration. These tests verify that the intents resolve to the proper light domain services with the correct entity_ids and speech output, including a case that disambiguates among several similarly named lights.\n- The conversation HTTP API (`homeassistant/components/conversation/__init__.py`) was updated so that `_async_converse` calls are wrapped in a `try/except intent.IntentError`. If an intent error occurs, the API logs the error and returns a JSON payload with `success: False` and a structured `error` object (`code` and `message`) along with an HTTP 500 status code instead of letting the exception propagate unhandled. The conversation HTTP test was also updated to ensure `homeassistant`, `conversation`, and `intent` components are all set up before testing the API.\n\nOverall, the PR turns lax or implicit behaviors into explicit, permission-aware and schema-validated flows, and properly delegates intent handling to the dedicated intent integration while hardening the conversation API error handling.",
        "semantic_memory": "This change illustrates several generalizable patterns for building secure, maintainable service APIs in a home automation or microservice environment:\n\n1. **Privilege separation for core/critical operations**:\n   - Operations that can disrupt or fundamentally change the system (e.g., stop, restart, configuration checks, location changes) should be limited to admin-level users. Instead of relying on ad hoc checks at call sites, central helpers like `register_admin_service` give a uniform way to enforce this across multiple services.\n   - Treat \"core\" operations as having higher risk and explicitly codify their security requirements in the registration mechanism, not just in documentation.\n\n2. **Per-resource permission checks**:\n   - When a service operates on multiple entities or resources, permissions should be checked per entity, not only at the service level. This prevents a user who has access to some devices from indirectly operating on devices they cannot control by bundling them in the same request.\n   - Integrating permission checks with the `context.user_id` and a centralized permission model (`user.permissions.check_entity`) creates a consistent security story and makes it easier to reason about access control.\n\n3. **Schema-level validation for service inputs**:\n   - Using schema validation (`vol.Schema`, `cv.entity_ids`) prevents invalid or ambiguous inputs from reaching business logic. In this case, the schema ensures that `entity_id` is a concrete list of valid entity IDs and explicitly blocks wildcard values like `ENTITY_MATCH_ALL`/`ENTITY_MATCH_NONE` for services where such wildcards are not intended.\n   - Pushing validation to the edge of the system (on service registration) leads to more predictable behavior and clearer error signaling (`vol.Invalid`) for incorrect usage.\n\n4. **Handling wildcard and sentinel values carefully**:\n   - Special constants such as `ENTITY_MATCH_ALL` and `ENTITY_MATCH_NONE` are useful at one conceptual layer (e.g., high-level selectors), but they should not be passed into lower layers that expect concrete identifiers. Each layer should explicitly decide whether it supports such wildcards; if not, they should be filtered out early.\n   - This prevents bugs where wildcard constants are misinterpreted as real entity IDs or cause unintended bulk operations.\n\n5. **Component responsibility and separation of concerns**:\n   - Intent registration belongs in the `intent` integration, not in the generic `homeassistant` core integration. Moving the `HassTurnOn/Off/Toggle` intent registration into the `intent` component clarifies ownership and makes the system more modular.\n   - Tests should live alongside the component that owns the behavior; moving intent tests from `homeassistant` to `intent` reflects this separation and prevents accidental coupling.\n\n6. **Robust error handling in HTTP APIs that wrap internal intent systems**:\n   - When an HTTP endpoint depends on an internal intent system, it should catch and translate intent-level errors into well-structured HTTP responses. This ensures clients receive predictable `success` flags and structured `error` details instead of opaque server errors or stack traces.\n   - Logging the error while returning an appropriate JSON error payload (with code and message) provides both observability for maintainers and usability for API consumers.\n\n7. **Tests as safety nets for security and validation**:\n   - Adding tests specifically for admin-only enforcement and schema validation makes it much harder to accidentally regress security or relax input validation in future changes.\n   - By testing both successful paths and failure paths (Unauthorized, Invalid), the tests document intended security behavior as executable specifications.\n\nThese practices are applicable to any system where user-triggered services act on shared resources: enforce least privilege, validate inputs early and strictly, treat wildcard or sentinel values carefully, and ensure that public interfaces convert internal errors into clear, structured outputs.",
        "procedural_memory": [
            "To diagnose and fix similar issues around core service permissions, entity selection, and intent-driven APIs, follow these steps:",
            "Step 1: Identify critical or sensitive services",
            "- Enumerate services that have high impact (stop, restart, configuration reload, location changes, bulk operations).",
            "- Review who can currently call them and how permissions are enforced (if at all).",
            "- Look for services registered via generic registration functions without explicit admin or permission requirements.",
            "Step 2: Introduce or leverage admin-only registration mechanisms",
            "- If the framework supports it (like Home Assistant's `async_register_admin_service`), register high-impact services through this admin-only mechanism instead of the generic service registry.",
            "- For each such service, add tests using a non-admin user (e.g., a read-only user) to assert that calling the service raises an `Unauthorized` (or equivalent) error.",
            "- Ensure calls made without a user context behave as intended (e.g., system-initiated calls may be allowed or blocked based on your security model).",
            "Step 3: Enforce per-entity permission checks for multi-entity services",
            "- For services that accept `entity_id` or similar resource lists, retrieve the calling user from the context (e.g., `call.context.user_id`).",
            "- If a user ID is present, fetch the user object. If it doesn't exist, raise an appropriate exception like `UnknownUser`.",
            "- Iterate over each target entity and check permissions via the centralized permission system (e.g., `user.permissions.check_entity(entity, POLICY_CONTROL)`).",
            "- If any entity fails the permission check, raise an `Unauthorized` error including context about the permission category and user.",
            "- Add tests to ensure a user without permissions cannot update or control entities they shouldn't access.",
            "Step 4: Add strict schema validation for service inputs",
            "- Define service schemas using your validation library (e.g., voluptuous) that strictly describe allowed inputs. For entity IDs, use helper validators like `cv.entity_ids` that ensure concrete, valid IDs.",
            "- Avoid accepting free-form values for critical parameters (`entity_id` should not accept arbitrary strings like `'all'` or `'none'` where not intended).",
            "- Ensure wildcard or sentinel constants (e.g., `ENTITY_MATCH_ALL`, `ENTITY_MATCH_NONE`) are rejected by the schema for services that only support concrete IDs.",
            "- Write tests that call the services with invalid inputs and assert that `vol.Invalid` (or equivalent) is raised.",
            "Step 5: Guard lower-level helpers against wildcard/sentinel values",
            "- Inspect helper functions (such as group expansion or resource resolution) that operate on lists of IDs.",
            "- Update them to ignore or specially handle wildcard/sentinel values and non-string values to prevent misinterpretation as real IDs.",
            "- For example, filter out `ENTITY_MATCH_ALL` and `ENTITY_MATCH_NONE` before lowering or expanding entity IDs.",
            "- Add tests ensuring that wildcard tokens are not returned from these helpers when they are meant to return only concrete entities.",
            "Step 6: Align component responsibilities and move logic to the right module",
            "- Review where functionality like intent registration is implemented; move it into the most appropriate integration/module (e.g., from a core module into a dedicated `intent` integration).",
            "- Update imports and initialization so that the concerned component (e.g., `intent`) sets up its own handlers, not the core module.",
            "- Relocate or rewrite tests to the module that now owns the behavior, to avoid coupling tests to the wrong integration.",
            "Step 7: Harden HTTP APIs that wrap internal intent or service logic",
            "- Wrap calls to internal intent or service handlers in try/except blocks for known error types (e.g., `IntentError`).",
            "- On exceptions, log the error for observability and return a structured HTTP response (e.g., JSON with `success: false` and an `error` object containing `code` and `message`).",
            "- Choose appropriate HTTP status codes (500 for internal errors, 4xx for client misuse, etc.).",
            "- Update API tests to set up all required components (e.g., core, conversation, intent) and verify both successful and error responses.",
            "Step 8: Maintain and evolve tests as a security contract",
            "- For every new permission rule or schema constraint, add tests that both confirm correct behavior and confirm that violations are correctly blocked.",
            "- Treat these tests as part of the security contract of your API; changes that break them should be reviewed as potential security regressions."
        ]
    }
}
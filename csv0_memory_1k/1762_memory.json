{
    "search_index": {
        "description_for_embedding": "napari labels layer: replace deprecated SELECTED color mode with a `show_selected_label` boolean filter and add a 'show selected' checkbox in Qt labels layer controls. The checkbox toggles filtering of the visualization to only the currently selected label, working with both AUTO and DIRECT color modes.",
        "keywords": [
            "napari",
            "Labels layer",
            "QtLabelsControls",
            "color_mode",
            "LabelColorMode",
            "show_selected_label",
            "filter_to_selected",
            "selected label",
            "label colormap",
            "AUTO color mode",
            "DIRECT color mode",
            "Qt checkbox",
            "GUI layer controls",
            "image segmentation visualization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the goal was to let users easily view only the currently selected label in a napari Labels layer via the GUI. An initial approach added a new `SELECTED` entry to the `LabelColorMode` enum and toggled that mode via a checkbox located next to the label selection spinbox. However, this was reworked based on code review: rather than overloading the color mode enum with a special `SELECTED` state, the team introduced an independent boolean filter and integrated it into the label-to-color mapping logic.\n\nConcretely, the `LabelColorMode.SELECTED` enum value was removed from `LabelColorMode` and all associated logic. A new attribute `self._show_selected_label` was added to the `Labels` layer model, exposed via a `show_selected_label` property with getter and setter. The setter calls `self.refresh()` so that toggling the flag forces a redraw.\n\nThe `_raw_to_displayed` method in `napari/layers/labels/labels.py` was refactored to combine color mode and the new filter in a single function. Previously it branched only on `LabelColorMode.DIRECT` vs `LabelColorMode.AUTO`. Now it branches on both `self._color_mode` and `self.show_selected_label`:\n- If `show_selected_label` is False and color mode is DIRECT, it builds the full color-mapped image via `self._label_color_index` for all labels.\n- If `show_selected_label` is False and color mode is AUTO, it uses the low-discrepancy colormap for all labels (except background).\n- If `show_selected_label` is True and color mode is AUTO, it sets all pixels to zero except those equal to the currently selected label, which get the hashed color from `low_discrepancy_image(selected, self._seed)`.\n- If `show_selected_label` is True and color mode is DIRECT, it filters to the selected label, using `self._label_color_index` to pick the appropriate color and handling the background and \"none\" color correctly. If the selected label has no explicit entry in `self._label_color_index`, it falls back to `None`.\n\nThe earlier hacky post-processing block that applied `filter_to_selected` on top of an already computed image was removed; instead, the filtering is integrated into the main color mapping branches.\n\nOn the Qt side (`napari/_qt/layer_controls/qt_labels_controls.py`), a new `QCheckBox` was added and wired up after existing UI elements (brush size, opacity, preserve labels, etc.). The checkbox tooltip is \"Display only selected label\" and its label text is \"show selected:\". Its state is connected to a new `toggle_selected_mode` method, which sets `layer.show_selected_label` to True when checked and False when unchecked. The checkbox was moved to the bottom of the grid layout next to the \"preserve labels\" option and its grid coordinates were adjusted in a couple of follow-up commits to align the label and checkbox neatly.\n\nThe tests were updated accordingly:\n- A labels-layer test that previously checked SELECTED color mode behavior was renamed and rewritten as `test_show_selected_label`, now toggling `layer.show_selected_label = True` and verifying that only the selected label remains visible while background and 'None' colors behave as expected.\n- The Qt labels control test `test_changing_layer_color_mode_updates_combo_box` was updated not to rely on the removed `'selected'` color mode. It now constructs a `Labels` layer with a color mapping (`color=_COLOR`) and verifies that changing `layer.color_mode` to 'auto' keeps the GUI combo box in sync.\n\nOverall, the incident resolved the design tension of adding a `SELECTED` color mode by instead introducing a clean, orthogonal `show_selected_label` flag, integrating it into the rendering pipeline, and exposing it through a simple checkbox in the labels layer controls.",
        "semantic_memory": "This change illustrates a general design pattern in visualization and state management: avoid encoding orthogonal concerns into a single enum or mode when a separate, composable flag is clearer.\n\nOriginally, the concept of \"only show the selected label\" was modeled as a special `SELECTED` color mode alongside `AUTO` and `DIRECT`. That approach conflated two separate dimensions: (1) how colors are determined (hash-based automatic vs direct mapping) and (2) which subset of labels is visible (all vs only selected). Adding another enum value for `SELECTED` makes the enum harder to reason about, complicates tests, and requires more branching logic.\n\nA cleaner model is to:\n- Keep color mode focused solely on the mapping from label IDs to colors (AUTO vs DIRECT).\n- Introduce a separate boolean property controlling visibility filtering (`show_selected_label`).\n- Combine these orthogonal dimensions inside the rendering pipeline (`_raw_to_displayed`) with clear branching logic.\n\nThis design has several generalizable advantages:\n- **Composability**: You can apply the same filter (show only selected) regardless of color mode, without multiplying enum states (`AUTO_SELECTED`, `DIRECT_SELECTED`, etc.).\n- **Separation of concerns**: Internal logic for color mapping remains simple and testable, while visibility filtering is added as a distinct step.\n- **Simpler UI/UX**: The checkbox maps directly to a boolean model property, reducing impedance between UI and domain model.\n- **Easier evolution**: If future features (e.g., multiple selected labels, visibility of label groups) are added, they can extend the filtering dimension without touching the color-mode dimension.\n\nOn the testing and API side, this PR emphasizes:\n- When an enum entry is removed or behavior is redefined, update all dependent tests to align with the new model rather than trying to emulate old semantics.\n- Trigger redraws/updates directly in property setters (`show_selected_label`, `selected_label`) when UI-visible state changes; this avoids stale views.\n- In visualization code, handle every combination of relevant state (e.g., color mode + filter) explicitly, and raise a clear `ValueError` for unsupported combinations.\n\nMore broadly, the pattern here is: when adding a new view behavior (like filtering, highlighting, visibility toggles), prefer adding orthogonal state and integrating it in one well-defined mapping function rather than expanding enumerations that were originally meant for different concerns.",
        "procedural_memory": [
            "Step-by-step instructions on how to implement or refactor a visualization toggle like 'show only selected label' without overloading existing enums.",
            "Step 1: Clarify the dimensions of state you are modeling.\nIdentify what is being controlled by existing enums (e.g., color_mode decides how colors are computed: AUTO vs DIRECT) and what new behavior you want (e.g., filtering visible items to only the selected one). Avoid mixing these into a single enum if they are orthogonal.",
            "Step 2: Introduce a dedicated model property for the new behavior.\nAdd a boolean attribute in the model class (e.g., `self._show_selected_label = False`) and expose it via a property with getter and setter. In the setter, call the appropriate update hooks (`self.refresh()`, `self.events.<something>()`) so any UI that depends on it will redraw when the property changes.",
            "Step 3: Integrate the new property into the core mapping/rendering logic.\nLocate the function that converts raw data to display data (e.g., `_raw_to_displayed(self, raw)`). Refactor branching logic to handle the cross-product of existing modes and the new flag:\n- When the flag is off, keep existing behavior unchanged.\n- When the flag is on, implement the filtered behavior for each relevant mode (e.g., AUTO and DIRECT) explicitly.\n- For unsupported combinations, raise a clear exception (`ValueError(\"Unsupported Color Mode\")`) to catch future misuse.",
            "Step 4: Remove or deprecate any misfit enum entries.\nIf a special enum variant (e.g., `SELECTED`) was used to encode the new behavior, remove it once the dedicated property is in place. Clean up all code paths that set or test this old enum value, and re-run tests to ensure no references remain.",
            "Step 5: Wire up the GUI control directly to the new property.\nIn the Qt/GUI layer, create an appropriate widget for the toggle (e.g., `QCheckBox` for 'show selected'). Add it to the layout with a clear label and tooltip. Connect its state change signal to a small handler (e.g., `toggle_selected_mode`) that simply sets the model property (`layer.show_selected_label = state == Qt.Checked`). Avoid letting the GUI manipulate low-level internal state like enum values directly when a higher-level property exists.",
            "Step 6: Adjust UI layout for clarity and consistency.\nPlace the new control near related options (e.g., other labels visibility or editing options). Tweak grid positions/row/column spans so labels and controls align neatly. This may require one or two small follow-up commits adjusting grid indices.",
            "Step 7: Update and extend tests.\n- Update model tests: replace tests relying on old enum behavior with tests that exercise the new property (e.g., `test_show_selected_label` that verifies the color mapping when `show_selected_label` is True and the selected label changes).\n- Update GUI tests: ensure that changing `layer.color_mode` or the new flag keeps combo boxes and checkboxes in sync, and that removed modes (like 'selected') are no longer used.\n- Use deterministic/random seeds where necessary to ensure color mapping tests are stable.",
            "Step 8: Verify behavior across all combinations.\nManually verify (or write automated tests) for every combination of the key state dimensions: color_mode (AUTO vs DIRECT) and show_selected_label (False vs True). Confirm that:\n- The full label map is rendered when filtering is off.\n- Only the selected label is visible when filtering is on.\n- Background and 'None' colors are handled correctly.\n- Changing the selected label updates the view immediately when `show_selected_label` is True.",
            "Step 9: Guard against future regressions.\nLeave the branching logic in a single, well-defined place (like `_raw_to_displayed`) so that future changes to color modes or filtering are localized. Keep raising exceptions for unsupported modes to surface issues early, and keep tests for all supported combinations up-to-date."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "PokemonGo-Bot navigation logic change to allow the bot to wait at a lured Pokestop (fort) until the lure expires. Introduces a `wait_on_lure` configuration flag, modifies fort selection to keep lured forts despite timeouts and anti-circle logic, and updates spin logic to use `cooldown_complete_timestamp_ms` instead of an internal timeout list.",
        "keywords": [
            "PokemonGo-Bot",
            "MoveToFort",
            "SpinFort",
            "lure module",
            "wait_on_lure",
            "wait at fort",
            "fort timeout",
            "cooldown_complete_timestamp_ms",
            "navigation logic",
            "avoid circles"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request (Experimental #5002), the author added an experimental feature so the PokemonGo-Bot can stay near a Pokestop with an active lure module until the lure expires, instead of walking away immediately after spinning it. Previously, the MoveToFort worker filtered out forts that were in `bot.fort_timeouts` and also those in `bot.recent_forts` when `forts_avoid_circles` was enabled, which caused the bot to avoid returning to the same fort. This behavior made it impossible to \"camp\" at a lured fort and repeatedly spin it as it came off cooldown.\n\nThe fix introduced a new configuration option `wait_on_lure` (stored as `wait_at_fort` in code). When this flag is enabled:\n- MoveToFort, on arrival, checks if the nearest fort has an `active_fort_modifier` (indicating an active lure) and, if so, emits a message that it is waiting near the fort until the lure expires, instead of just logging \"Arrived at fort\".\n- In `get_nearest_fort`, the fort filtering is altered: forts in `bot.fort_timeouts` are still excluded, but lured forts (`active_fort_modifier`) are allowed through even if they are in `fort_timeouts`, so the bot can keep targeting the same lured fort while the lure is active. Likewise, the anti-circle filter (`forts_avoid_circles`) is disabled when `wait_at_fort` is true, allowing repeated visits to the same lured fort.\n- In `_get_nearest_fort_on_lure_way`, when `wait_at_fort` is enabled, the bot additionally filters lures by `active_fort_modifier`, ensuring it focuses on forts where the lure is actively running.\n\nIn the SpinFort worker, `get_forts_in_range` was also updated. Instead of filtering forts using `bot.fort_timeouts`, it now uses the server-provided `cooldown_complete_timestamp_ms` compared to the current time to decide whether a fort can be spun. This makes spinning logic more accurate, especially while staying at the same lured fort over multiple cooldown cycles.\n\nOverall, this PR implements an opt-in behavior (disabled by default) allowing the bot to remain at lured forts and continue spinning them as they come off cooldown until the lure expires, without being forced away by generic timeout or anti-circle logic.",
        "semantic_memory": "This change illustrates a common pattern in autonomous agent behavior: special-casing high-value targets so they are not subject to generic avoidance or de-duplication rules. In navigation or farming bots, there is often global logic to avoid revisiting the same resource node too frequently (e.g., to prevent circles or mimic human behavior). When a resource has a temporary buff or high value (like a lured Pokestop), the agent may need separate logic that overrides these global constraints.\n\nTwo general principles emerge:\n1. **Special targets should bypass generic avoidance filters when appropriate.** If a resource is time-limited or currently boosted, global rules like \"avoid recent targets\" or \"respect custom timeouts\" may be counter-productive. Instead, the agent should treat these targets as exceptions, while still honoring safety or server constraints.\n2. **Use server-sourced cooldown timestamps instead of internal timeout lists when available.** Relying on `cooldown_complete_timestamp_ms` provides an authoritative source of when a resource can be reused, which is more reliable than maintaining an internal timeout list that can drift or be mishandled. This is especially important when an agent can remain near the same resource and repeatedly attempt actions.\n\nThe feature is also a good example of how to introduce experimental behaviors safely: gate new behavior behind a configuration flag (`wait_on_lure`) that defaults to `false`, ensure the existing behavior remains unchanged when the flag is off, and adjust logging to make the new behavior observable to users.\n\nMore broadly, the pattern applies to any system where:\n- There is a general \"avoid repetition\" or \"cooldown\" mechanism, and\n- Some entities under certain conditions should be exempt from that mechanism (e.g., boosted nodes, events, temporary buffs, or high-priority jobs).",
        "procedural_memory": [
            "When you need an autonomous agent or bot to stay at a high-value, time-limited target (e.g., a resource node with a temporary buff) instead of leaving due to generic anti-loop or timeout logic, follow these steps:",
            "Step 1: Identify the existing avoidance and timeout mechanisms.\n- Locate code where targets/resources are filtered out due to timeouts (e.g., custom timeout lists) or anti-loop logic (e.g., \"avoid circles\" using recent target history).\n- Understand how internal timeouts interact with server-provided cooldown timestamps (if any).",
            "Step 2: Introduce a configuration flag for the new behavior.\n- Add an explicit, opt-in config option (e.g., `wait_on_lure`) and default it to `false` to preserve existing behavior.\n- In your worker/agent initialization, read this config into a clear boolean (e.g., `self.wait_at_fort`).",
            "Step 3: Special-case the high-value target selection when the flag is enabled.\n- Adjust target selection logic to treat high-value targets (e.g., lured forts with `active_fort_modifier`) as exceptions.\n- Example: when computing candidate targets, allow lured/boosted targets even if they appear in timeout or recent lists.\n- Ensure that when `wait_on_lure` is disabled, the original filters still apply without change.",
            "Step 4: Use authoritative cooldown timestamps instead of internal timeout lists where possible.\n- If the server provides cooldown timestamps (e.g., `cooldown_complete_timestamp_ms`), filter resources based on `current_time >= cooldown_complete_timestamp_ms`.\n- Remove or de-emphasize internal timeout lists for actual availability decisions, or keep them only as a fallback.\n- This ensures accuracy when the agent stays near a single resource and attempts repeated actions.",
            "Step 5: Update logging to reflect the new behavior.\n- Emit different events or messages when the agent is in \"wait at high-value target\" mode versus normal arrival.\n- Example: log \"Waiting near fort X till Lure module expired\" instead of just \"Arrived at fort\" when a lure is active and waiting behavior is enabled.",
            "Step 6: Preserve and respect safety / realism options.\n- Keep existing realism settings (e.g., GPS noise, movement walkers) unchanged unless specifically required.\n- Ensure that when the wait-at-target feature is enabled, it does not inadvertently disable essential safety checks (only bypass non-critical anti-loop logic).",
            "Step 7: Test the behavior with and without the feature flag.\n- Run the agent with `wait_on_lure = false` and verify the behavior is identical to the pre-change behavior.\n- Then enable `wait_on_lure` and confirm that the agent:\n  - Moves to a high-value target (e.g., lured fort),\n  - Stays near it and continues to re-spin/reuse it as cooldowns expire,\n  - Stops favoring it once the buff/lure expires and resumes normal route planning.",
            "Step 8: Document configuration and limitations.\n- Document the new config option, its default value, and how it alters behavior.\n- Note any caveats (e.g., experimental status, potential for longer sessions at single locations, or interaction with other navigation settings)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Added an automated, configurable team selection step to the CompleteTutorial worker in a PokemonGo bot. The worker now sets the playerâ€™s team once after reaching level 5, skips if a team is already chosen or if auto-team is disabled, and avoids repeated API calls via internal run flags.",
        "keywords": [
            "CompleteTutorial",
            "set_player_team",
            "auto team selection",
            "PokemonGo bot",
            "player team",
            "config.json",
            "one-time task in loop",
            "idempotent worker",
            "player level check",
            "tutorial state",
            "cell_workers",
            "player inventory"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR implements automatic team assignment for the PokemonGo bot when the player reaches level 5, integrated into the existing `complete_tutorial` cell worker. Previously, `CompleteTutorial` only handled tutorial completion and ran once per bot start using a single `may_run` flag and `should_run()` method. The new requirement was to allow the bot to automatically pick a team based on configuration.\n\nTo support this, the worker was refactored:\n- Two separate flags were introduced: `self.tutorial_run` for tutorial completion and `self.team_run` for team selection, both initialized to `True` in `initialize()`. A typo introduced in an intermediate patch (`self.team_run == True`) was later corrected to assignment (`self.team_run = True`).\n- The `should_run()`/`may_run` mechanism was removed. Instead, the `work()` method manages one-time execution of each subtask by flipping the respective boolean flags after execution.\n- In `work()`, the tutorial logic runs once via `_check_tutorial_state()` when `self.tutorial_run` is `True`. If this call fails, the worker returns `WorkerResult.ERROR`.\n- After that, if `self.team_run` is `True` and the player level (`player()._level`) is at least 5, `_set_team()` is invoked. On failure it returns `WorkerResult.ERROR`; on success (or if not applicable) the worker returns `WorkerResult.SUCCESS`.\n\nThe new `_set_team()` method encapsulates team selection logic:\n- If the configured `self.team` is `0`, it simply returns `True`, meaning 'no team auto-selection requested'.\n- It checks `self.bot.player_data.get('team', 0)`. If a team is already set (non-zero), it logs 'Team already picked' and returns `True` to avoid redundant or error-prone API calls.\n- Otherwise, it performs a short delay (`sleep(10)`) to mimic human-like behavior or allow the game state to stabilize, then calls `self.api.set_player_team(team=self.team)`.\n- The response's `status` is read from `response_dict['responses']['SET_PLAYER_TEAM']['status']`. For `status == 1`, it maps the numeric team code to a human-readable string (Mystic/Valor/Instinct), logs which team was picked, and returns `True`.\n- For other status codes, it uses a small `error_codes` map to log a meaningful error message and returns `False`. Any `KeyError` while parsing the response also results in `False`.\n\nConfiguration examples (`config.json*.example`) were updated to introduce a new `team` field under the `CompleteTutorial` task configuration:\n- `\"team\": 0` with a comment `\"// 0 = No Team, 1 = Blue, 2 = Red, 3 = Yellow\"`.\n\nOverall, the incident was not a bug fix in behavior but a feature addition with careful handling of one-time behavior in a looped worker, proper precondition checks (level >= 5, team not already set), and configuration exposure. A minor internal bug (using `==` instead of `=` when initializing `team_run`) was caught and corrected in a later patch.",
        "semantic_memory": "This change illustrates best practices for implementing one-time or conditionally executed actions in a periodically invoked worker, especially when those actions involve external API calls and persistent game state.\n\nKey generalizable ideas:\n1. **Idempotent, state-aware workers:**\n   - When a worker is executed in a loop, but some actions should only occur once (e.g., completing a tutorial, picking a team), keep explicit boolean flags or equivalent state to ensure each action executes at most once per run or per condition.\n   - Use the underlying domain state (e.g., `player_data.team`, player level) to guard against repeated or inappropriate API calls. This makes the worker idempotent: if the desired state is already reached, it simply returns success without calling the API again.\n\n2. **Configuration-driven behavior:**\n   - Expose decisions (like auto-selecting a team) as configuration parameters with sensible defaults (e.g., `team = 0` meaning 'do not auto-select').\n   - Document allowable values and behavior directly in example configs or comments to guide users.\n\n3. **Precondition checks before external calls:**\n   - Check prerequisites (e.g., player must be at least level 5 to select a team) before hitting an external API. This reduces errors, spam, and unnecessary requests.\n   - Also check for already-satisfied conditions (e.g., `team != 0` in player data) so the logic is robust and can be safely re-run without harm.\n\n4. **Robust response handling and logging:**\n   - When calling an external API, parse response status codes into readable messages and log them for debugging.\n   - Catch `KeyError` or similar schema issues defensively; on unexpected responses, prefer clear failure signals (like returning `False`) rather than letting exceptions propagate silently.\n\n5. **Clear separation of responsibilities within a worker:**\n   - Break down complex `work()` logic into helper methods (`_check_tutorial_state`, `_set_team`) that each handle a single responsibility (tutorial vs. team selection). This makes it easier to extend or modify behavior later.\n\n6. **Avoiding subtle initialization bugs:**\n   - In Python and similar languages, accidentally using comparison (`==`) instead of assignment (`=`) during initialization can silently produce incorrect behavior because it evaluates but does not set state. For workers reliant on flags, this can completely disable parts of the logic. Tests or review should specifically look for these typos in control flow code.\n\nThese lessons apply whenever you extend a job/worker system that runs repeatedly but needs to perform some actions only once or under strict conditions (e.g., account setup flows, first-run migrations, one-time configuration writes).",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the one-time or conditional behavior within a recurring worker.\n- Determine which actions should run only once (e.g., initial configuration, tutorial completion, team selection) and under what conditions (e.g., minimum level, state flags).",
            "Step 2: Introduce explicit state flags for each distinct subtask.\n- Add boolean attributes (e.g., `self.tutorial_run`, `self.team_run`) in the worker's initialization.\n- Initialize them via assignment (`self.flag = True`) to ensure they start enabled.\n- If persistent behavior across runs is needed, store these flags in a durable state store instead of only in memory.",
            "Step 3: Refactor the `work()` method to use those flags.\n- For each subtask, wrap its invocation in a condition like `if self.flag:`.\n- Inside the block, set `self.flag = False` before or immediately after executing the subtask to prevent repeat execution.\n- Ensure the overall `work()` method returns appropriate `WorkerResult` values: return `ERROR` if a critical subtask fails; otherwise return `SUCCESS` even if no actions were needed.",
            "Step 4: Perform domain-level precondition checks before API calls.\n- Check whether the external action is allowed or meaningful at this time (e.g., verify player level >= required level for team selection).\n- Check whether the desired state has already been achieved (e.g., `if self.bot.player_data.get('team', 0) != 0: log and return True`).\n- Only call the external API when these preconditions are satisfied.",
            "Step 5: Implement and harden the API call handling.\n- Call the relevant API method (e.g., `self.api.set_player_team(team=self.team)`).\n- Safely navigate the nested response structure using `try/except` for `KeyError` or use defensive access patterns.\n- Interpret numeric or symbolic `status` codes via a mapping dictionary to human-readable text.\n- Log success with clear information (e.g., which team was selected) and log failures with mapped status messages.\n- Return `True` on success and `False` on failure so the caller (`work()`) can decide how to proceed.",
            "Step 6: Add configuration options and document them.\n- Introduce a new config field that controls the behavior (e.g., `\"team\": 0` to disable auto-team selection).\n- Add comments explaining possible values and their meanings to all example config files.\n- Ensure the worker reads the config via `self.config.get('team', 0)` or similar, with a safe default.",
            "Step 7: Test and validate behavior.\n- Test with `team = 0` to confirm the worker skips team selection and does not call the API.\n- Test with `team` set to a valid value and player level < required level to ensure no premature API calls occur.\n- Test with player already assigned to a team to confirm the worker logs 'already picked' and exits without errors.\n- Test with a new account at level >= required level to verify that the team is selected once and `team_run` prevents repeat calls.",
            "Step 8: Watch out for control flow and assignment typos.\n- Search for any accidental `==` instead of `=` in flag initialization or updates.\n- Consider adding unit tests or simple assertions that verify flags change state after the first run of the worker.",
            "Step 9: Monitor logs in production.\n- Review logs for error messages from the new logic to catch unexpected API status codes or schema changes.\n- Use these logs to refine error handling mappings and possibly add retries or backoff if appropriate."
        ]
    }
}
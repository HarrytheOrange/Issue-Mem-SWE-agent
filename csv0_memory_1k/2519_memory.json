{
    "search_index": {
        "description_for_embedding": "CI tests for the Optuna Ray integration example were failing because the 'ray' dependency was not declared in setup.py extras_require. The fix adds 'ray' to the appropriate extras so environments that run the Ray example install Ray automatically.",
        "keywords": [
            "ray",
            "requirements",
            "extras_require",
            "setup.py",
            "dependency missing",
            "CI failure",
            "optuna integration",
            "ray-joblib example",
            "python packaging",
            "import error"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Optuna repository had an example script `examples/ray-joblib.py` that depends on the Ray library. Continuous Integration (CI) runs for this example were failing because Ray was not installed in the test environment. The root cause was that `ray` was not listed as an extra requirement in `setup.py`, so `pip install` commands used in CI didn't include Ray. The failure was visible in the CI logs, where the Ray-based example could not run successfully. Local verification using Docker images for Python 3.6, 3.7, and 3.8 showed that installing Ray manually (`pip install ray`) allowed the example to run correctly. The fix was to update `setup.py`'s `get_extras_require()` function and add `'ray'` to the appropriate extras list (the same group containing `jax`, `optax`, `dm-haiku`, and `hydra-optuna-sweeper`). After this change, environments that install this extra will automatically pull in Ray, preventing missing-dependency errors when running the Ray example in CI or user environments.",
        "semantic_memory": "When a project includes optional integrations or example scripts that rely on third-party libraries, those libraries must be explicitly declared in the project's dependency metadata (e.g., `install_requires` or `extras_require` in `setup.py`, or the equivalent in `pyproject.toml`). If they are not, automated environments—such as CI pipelines or users installing extras—will not receive the needed packages, leading to import errors or runtime failures. Maintaining alignment between examples/integration code and dependency declarations is crucial. Each new integration or example that adds an external dependency should be accompanied by an update to the appropriate extras group. This is especially important for optional integrations (like Ray, Dask, or Redis) that aren't part of the core install but are exercised in tests or examples. Properly using `extras_require` helps keep the core installation minimal while ensuring that optional features are reproducible and testable via well-defined extras.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify failing tests or examples in CI or user reports that raise `ImportError` or `ModuleNotFoundError` for a third-party library (e.g., `ray`).",
            "Step 2: Confirm locally that the code runs successfully if you manually install the missing library (e.g., `pip install ray` and rerun the example or tests).",
            "Step 3: Inspect the project's packaging configuration (`setup.py`, `setup.cfg`, or `pyproject.toml`) to see if the missing library is listed in `install_requires` or `extras_require` under an appropriate extra (e.g., `ray`, `integration`, or `all`).",
            "Step 4: If the dependency is missing, determine whether it should be a core requirement or an optional extra. For integrations or examples that not all users need, prefer adding it to an extra group.",
            "Step 5: Add the missing library to the correct extras group in the packaging config. In `setup.py`, this usually means updating `extras_require` in the function or dict that defines it, e.g. adding `'ray'` to the list alongside related integration libraries.",
            "Step 6: Run `pip install .[extra_name]` (or the equivalent for your build system) in a clean environment to ensure the extra pulls in the new dependency and that the previously failing example/test now passes.",
            "Step 7: Update CI configuration to install the correct extras before running integration tests or examples (e.g., `pip install .[integration]`), ensuring CI mirrors the expected user installation path.",
            "Step 8: Add or update tests that exercise the integration or example so future changes that forget dependencies will cause a clear and early CI failure.",
            "Step 9: Document the required extra in the project's README or docs so users know which extra to install when using the integration (e.g., `pip install optuna[ray]`)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant qBittorrent sensor was implemented as async but used a blocking client.sync() call inside async_update and async_setup_platform, causing event loop locking. The fix converts the platform setup and entity update methods back to synchronous (setup_platform and update) to avoid blocking the asyncio event loop.",
        "keywords": [
            "Home Assistant",
            "qBittorrent",
            "sensor",
            "async_setup_platform",
            "async_update",
            "blocking I/O",
            "event loop lock",
            "Client.sync",
            "LoginRequired",
            "RequestException"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant qBittorrent integration, the sensor platform was defined using async APIs: async_setup_platform and async_update. However, the underlying qBittorrent client used a synchronous method client.sync() to fetch data. This synchronous network call was executed directly inside the async_update coroutine, which could block the asyncio event loop and degrade responsiveness of the entire Home Assistant system.\n\nThe reported issue was to fix the qBittorrent sensor to avoid locking the event loop. The change replaced async_setup_platform with a synchronous setup_platform function and replaced async_add_entities with add_entities. Similarly, the sensor's async_update coroutine was converted into a regular synchronous update method. Error handling was kept the same, still catching RequestException (marking the sensor unavailable) and LoginRequired (authentication error). By aligning the platform and entity methods with synchronous behavior, the blocking calls no longer run in the event loop context, thereby preventing event loop locking while preserving existing functionality.\n\nThe PR was acknowledged as a good catch, indicating that the root problem was mixing synchronous I/O with async Home Assistant lifecycle hooks.",
        "semantic_memory": "When integrating synchronous libraries (e.g., HTTP clients, RPC clients) into an asynchronous framework like Home Assistant or any asyncio-based application, it is critical to avoid calling blocking functions from async coroutines that run on the main event loop. Doing so can freeze or significantly slow down the entire system.\n\nIn Home Assistant specifically, entity platforms can be either synchronous or asynchronous. If you must use a blocking API (like a qBittorrent Client.sync() call), you should either:\n- Implement the platform and entities using the synchronous setup_platform and update methods, which Home Assistant will call in a way that doesn’t block the core event loop; or\n- Wrap blocking calls in an executor (e.g., hass.async_add_executor_job) if you need to stay in async.\n\nThe general pattern is: don’t mix blocking I/O directly inside async_* methods unless you explicitly offload them. Also, the names of the hooks (async_setup_platform vs setup_platform, async_update vs update) are not just cosmetic; they determine how Home Assistant executes the code (on the event loop vs in a thread executor). Correctly choosing between them based on whether your code is blocking is a key best practice.\n\nRobust integrations should also handle network and authentication failures explicitly (e.g., catching RequestException and login-related exceptions) and adjust the entity availability state accordingly.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of event loop blocking.\n- Observe that the system (e.g., Home Assistant) becomes slow or unresponsive when a particular integration updates.\n- Check logs for warnings about long-running tasks or blocked event loop.\n- Correlate the timing of slowdowns with sensor updates or platform setup functions.",
            "Step 2: Inspect async code for blocking calls.\n- Open the integration’s platform file (e.g., sensor.py, binary_sensor.py).\n- Look for async functions such as async_setup_platform, async_setup_entry, async_update, or async_added_to_hass.\n- Inside these async functions, search for calls to libraries that are known to be synchronous (e.g., requests, synchronous SDKs, client.sync(), blocking DB queries).",
            "Step 3: Determine whether the library supports async.\n- Check the third-party client library’s documentation for native asyncio support.\n- If there is an async API (e.g., async_client.fetch()), consider switching to it.\n- If only a blocking API exists (e.g., Client.sync()), plan to treat those calls as blocking I/O.",
            "Step 4: Choose a strategy based on framework conventions.\n- For Home Assistant:\n  - If you must use blocking I/O and don’t need async features: use synchronous platform hooks (setup_platform) and entity methods (update).\n  - If you want to keep async hooks: wrap blocking calls with hass.async_add_executor_job or a similar helper to run them in a thread pool.\n- For general asyncio apps: run blocking calls in a ThreadPoolExecutor via loop.run_in_executor or similar utilities.",
            "Step 5: Refactor the platform setup.\n- If using blocking calls in setup:\n  - Change async_setup_platform(hass, config, async_add_entities, ...) to setup_platform(hass, config, add_entities, ...).\n  - Update all references from async_add_entities(...) to add_entities(...).\n- Remove async keywords from functions that are no longer coroutines.",
            "Step 6: Refactor the entity update logic.\n- Replace async def async_update(self): with def update(self): when the body contains blocking calls.\n- Keep the logic the same, but ensure the function is synchronous.\n- If you stay with async_update, wrap blocking calls as: data = await hass.async_add_executor_job(self.client.sync).",
            "Step 7: Preserve and improve error handling.\n- Continue to catch network-related exceptions (e.g., RequestException) and mark the entity as unavailable when appropriate.\n- Catch authentication-specific exceptions (e.g., LoginRequired) and log a clear error.\n- Avoid silently swallowing exceptions; log them at an appropriate level to aid debugging.",
            "Step 8: Test locally under realistic conditions.\n- Run the application/integration locally.\n- Trigger updates (e.g., force sensor updates, restart the integration).\n- Verify there are no warnings/errors about blocked event loop or long-running tasks.\n- Confirm that entity states update correctly and that availability toggles on network/auth failures.",
            "Step 9: Run automated tests and static checks.\n- For Home Assistant, run tox and any project-specific scripts (e.g., hassfest, gen_requirements_all) to ensure integration metadata and dependencies are correct.\n- Consider adding tests that simulate failures from the blocking client library to verify the error handling paths.",
            "Step 10: Document the decision.\n- In code comments or PR description, note that the platform/entity is synchronous because the underlying client library is blocking.\n- This helps future maintainers understand why async_* hooks are not used and prevents reintroducing event loop blocking by mistake."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Added a new time_throttle filter to Home Assistant's sensor.filter platform. This filter emits at most one sample per configured time window based on event timestamps, useful for sensors with non-constant update frequency. Implementation includes configuration schema, registry registration, and unit tests validating throttling behavior over time.",
        "keywords": [
            "time_throttle",
            "sensor.filter",
            "Home Assistant",
            "time-based throttling",
            "event frequency control",
            "non-constant frequency sensors",
            "filter schema",
            "unit test",
            "Rate limiting",
            "TimeSMAFilter",
            "ThrottleFilter"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, a new `time_throttle` filter was added to the Home Assistant `sensor.filter` platform to address the need for controlling emission frequency of sensor data with irregular update intervals. Existing filters like `throttle` were count-based, not time-based, and thus not ideal for signals that arrive at non-constant rates.\n\nThe developer introduced a new filter name constant `FILTER_NAME_TIME_THROTTLE` and extended the validation schema (`FILTER_TIME_THROTTLE_SCHEMA`) to require a `window_size` specified as a positive `time_period` (e.g., `00:01` for one minute). This schema was added to the `PLATFORM_SCHEMA` so that `time_throttle` can be configured in `configuration.yaml` under the `sensor: platform: filter` integration.\n\nThe `TimeThrottleFilter` class was implemented and registered in the filter `Registry` via `@FILTERS.register(FILTER_NAME_TIME_THROTTLE)`. It subclasses `Filter`, stores a `_time_window` (the configured time period) and `_last_emitted_at` timestamp, and overrides `_filter_state`. For each new state, it computes `window_start = new_state.timestamp - self._time_window` and emits the state only if no previous emission occurred in the current window (i.e., if `_last_emitted_at` is `None` or `<= window_start`). When emitting, it updates `_last_emitted_at` and sets `_skip_processing = False`; otherwise it sets `_skip_processing = True`, effectively throttling out extra samples.\n\nA unit test `test_time_throttle` was added to `tests/components/sensor/test_filter.py`, importing `TimeThrottleFilter`. It constructs the filter with a 2‑minute window and iterates over a pre-defined list of timestamped states (`self.values`). Only states that are not skipped are collected, and the expected output sequence is `[20, 18, 22]`, confirming that only one sample per time window is passed through. The test suite already contained tests for other filters, so this followed the existing testing pattern.\n\nThe PR also corrected a comment typo in `TimeSMAFilter`'s documentation (`argorithm` → `algorithm`) and clarified the `TimeThrottleFilter` docstring to describe it as a 'Time Throttle Filter' that emits 'One sample per time period.' The maintainer requested a test, and after the test was added, the PR was accepted.",
        "semantic_memory": "This change illustrates a common pattern for implementing time-based throttling and for extending a filter framework in a large codebase.\n\nConceptually, a time-based throttle filter is different from a count-based throttle: instead of allowing N events in a row or skipping every Mth event, it restricts emissions based on elapsed time. This is particularly useful when the source data arrives at irregular intervals (non-constant frequency), because count-based throttling can either over-throttle or under-throttle depending on burstiness.\n\nThe filter design relies on the timestamp associated with each event or state. By storing the timestamp of the last emitted event and comparing it to the current event's timestamp minus a configured window size, the filter enforces a simple invariant: 'only emit if no emission has occurred in the last T.' This pattern generalizes to any event-driven system where each event has a notion of occurrence time.\n\nFrom a framework perspective, adding a new filter or plugin type should follow a consistent process:\n- Define a unique identifier for the new filter (`FILTER_NAME_TIME_THROTTLE`).\n- Extend the configuration/schema to validate required parameters using the project's validation utilities (here, `voluptuous` and Home Assistant's `cv.*` helpers), ensuring type safety and constraints like positive durations.\n- Register the filter implementation with a central registry so it can be looked up by name from configuration.\n- Implement the core behavior in an overridable method (here, `_filter_state`) that operates on a standard state object, respecting existing flags like `skip_processing` to integrate with the framework's pipeline.\n- Add targeted tests that verify both the existence and behavior of the new filter across realistic input sequences, particularly focusing on edge conditions (e.g., boundaries between time windows).\n\nMore broadly, this PR highlights best practices when handling noisy or high-frequency sensor data:\n- Use filters to decouple raw sampling frequency from downstream consumers that only need data at a coarser temporal resolution.\n- For irregular sampling, prefer time-based logic instead of sample-count-based logic.\n- Ensure configuration examples and documentation mirror real usage patterns (here, combining `time_simple_moving_average` with `time_throttle` in a single sensor).\n\nThese practices are applicable to other systems like streaming services, event buses, and IoT platforms where event rates and timings must be controlled or normalized.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the need for time-based throttling.\n- Observe that downstream components (e.g., UI, automation, logging) are overwhelmed or behave poorly when sensor readings arrive too frequently or in bursts.\n- Determine whether existing throttling or filtering mechanisms are sample-count based or time-based.\n- If samples come at non-constant intervals and count-based throttling does not give predictable behavior, conclude that a time-based throttle may be needed.",
            "Step 2: Define the filter contract and configuration.\n- Decide on the filter's semantic behavior: e.g., 'only allow one sample per configured time period.'\n- Choose a descriptive filter name (e.g., `time_throttle`) and add a constant in the module where filter names are stored.\n- Extend the configuration schema to support the new filter name. Require configuration fields such as:\n  - `filter: time_throttle`\n  - `window_size: <time period>`\n- Use the project's validation helpers to enforce correct types and constraints (e.g., positive timedelta, valid time period strings).",
            "Step 3: Register the filter in the framework.\n- Add a schema entry for the new filter type (e.g., `FILTER_TIME_THROTTLE_SCHEMA`) that extends the base filter schema.\n- Include this schema in the list of allowed filter schemas in the platform's configuration schema.\n- Register the new filter implementation in the central registry or factory using a decorator or explicit registration call (e.g., `@FILTERS.register(FILTER_NAME_TIME_THROTTLE)`).",
            "Step 4: Implement the time-based throttling logic.\n- Create a new class (e.g., `TimeThrottleFilter`) that subclasses the base `Filter` class or equivalent.\n- In the constructor, call the parent constructor with the filter name, `window_size`, precision, and entity, and store any additional state you need (e.g., `_time_window`, `_last_emitted_at = None`).\n- Override the method that processes each new state/event (e.g., `_filter_state(self, new_state)`).\n- For each new state:\n  - Compute the lower bound of the allowed emission window: `window_start = new_state.timestamp - self._time_window`.\n  - If `_last_emitted_at` is `None` or `<= window_start`, update `_last_emitted_at` to `new_state.timestamp` and set the framework-specific flag to indicate that this state should not be skipped (e.g., `_skip_processing = False`).\n  - Otherwise, set `_skip_processing = True` to skip processing/emitting this state.\n  - Return the state object as expected by the framework.",
            "Step 5: Integrate with existing pipeline semantics.\n- Confirm how the framework uses flags like `skip_processing` or similar to decide whether to propagate a state.\n- Ensure that your filter cooperates with other filters in a pipeline. For example, make sure that the throttle filter can be chained after smoothing filters (like `time_simple_moving_average`) without breaking assumptions.\n- Adjust documentation strings and comments to accurately describe purpose and behavior ('Time Throttle Filter', 'One sample per time period').",
            "Step 6: Write targeted unit tests.\n- Import the new filter class into the test module that covers related filters.\n- Reuse or construct a list of input states with explicit timestamps and values; make sure the timestamps span multiple windows and include edge cases around window boundaries.\n- Create an instance of the new filter with a known window size (e.g., 2 minutes).\n- Iterate through the test states, passing each into the filter method (e.g., `filter_state`). When the filter indicates that processing is not skipped, collect the state.\n- Assert that the collected values match the expected sequence for your chosen timestamps and window size.\n- Run the test suite and fix any failing tests, adjusting logic if the behavior doesn’t match the intended semantics.",
            "Step 7: Provide configuration examples and documentation.\n- Update or add documentation showing how to use the new filter in configuration, including realistic examples that combine it with other filters.\n- For example:\n  - Apply a time-based moving average to smooth raw sensor data.\n  - Then apply `time_throttle` to limit updates to once per minute:\n    ```yaml\n    sensor:\n      - platform: filter\n        name: room_purifier_aqi\n        entity_id: sensor.room_purifier_aqi_raw\n        filters:\n          - filter: time_simple_moving_average\n            window_size: 00:03\n          - filter: time_throttle\n            window_size: 00:01\n    ```\n- Explain when to prefer this filter (non-constant sensor frequency, need for predictable emission interval).",
            "Step 8: Validate in a live or simulated environment.\n- Deploy the filter configuration to a test or development environment.\n- Monitor the filtered sensor entity to confirm that values update at the expected rate (no more than once per configured period).\n- Check the logs and downstream automations/UI to ensure that reduced update frequency solves the original problem without introducing excessive lag or stale data.",
            "Step 9: Generalize the approach for other systems.\n- If working in a different codebase, adapt the same pattern:\n  - Use event timestamps and a stored `last_emitted_at` value.\n  - Compare `current_time - last_emitted_at` to a configured interval.\n  - Only forward events when enough time has elapsed.\n- Ensure that the behavior is well-tested, well-documented, and fully integrated into any plugin/registry or configuration systems present in that project."
        ]
    }
}
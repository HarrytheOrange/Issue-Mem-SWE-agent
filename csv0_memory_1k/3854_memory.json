{
    "search_index": {
        "description_for_embedding": "Rework of the polyline-based walking logic for PokemonGo-Bot. Adds a walker factory and PolylineWalker integration with MoveToMapPokemon, introduces caching of Google Directions routes, steps along the polyline incrementally instead of teleporting, and falls back to StepWalker when the Google API fails or quota is hit. Also relocates StepWalker into a walkers package and updates human_behaviour RNG utilities.",
        "keywords": [
            "PolylineWalker",
            "polyline_generator",
            "walker_factory",
            "MoveToMapPokemon",
            "StepWalker",
            "Google Maps Directions API",
            "route caching",
            "teleport bug",
            "walker configuration",
            "human_behaviour",
            "random_lat_long_delta"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the bot's movement system—specifically the polyline-based walker used for pathing—was reworked and integrated more cleanly.\n\nPreviously, PolylineWalker constructed a Google Directions polyline and then effectively drove the bot along that polyline in a tight loop until the destination was reached. There was no caching, so each use would hit the Google Directions API anew. Under heavy multibot usage or when many workers tried to use the polyline walker simultaneously, this led to two problems: (1) the Directions API quota could be exceeded, causing the route decoding logic to fail and the bot to \"teleport\" instead of walking, and (2) the tight stepping loop meant the bot moved in one call rather than truly stepping over time.\n\nThe rework introduces several key components:\n\n1. **walker_factory** (pokemongo_bot.walkers.walker_factory): A simple factory function that chooses between StepWalker and PolylineWalker based on a configuration string. MoveToMapPokemon now reads a `walker` option from its config (defaulting to `\"StepWalker\"`) and constructs the movement strategy via `walker_factory`. If PolylineWalker construction fails (e.g., due to Google API issues), the factory catches the exception and gracefully falls back to StepWalker.\n\n2. **PolylineObjectHandler** and cached polylines (pokemongo_bot.walkers.polyline_generator): A new helper that caches Polyline instances keyed by a `parent_cls` (e.g., MoveToMapPokemon). When `cached_polyline` is called, it either returns an existing cached Polyline, creates a new one if none exists, or replaces it if the destination has changed. This avoids hammering the Directions API on every tick. A `delete_cache` method removes the cached polyline once the walker is done.\n\n3. **Polyline** refactor and error handling: The Polyline constructor builds the Google Directions URL and decodes the route. If it encounters an IndexError (commonly triggered by empty `routes` when the API quota is exceeded or the response is malformed), it now raises the exception after setting a fallback `polyline_points` field. The factory caller uses this to detect failure and choose StepWalker instead of leaving the bot in a broken state that could produce teleportation.\n\n4. **PolylineWalker behavior change** (pokemongo_bot.walkers.polyline_walker): This class still extends StepWalker but now:\n   - Uses `PolylineObjectHandler.cached_polyline` to get a shared route.\n   - Precomputes the straight-line distance between current position and destination.\n   - In `step()`, if the remaining distance is less than 10 meters, it deletes the cached polyline and returns `True` (destination reached).\n   - Otherwise, it unpauses the underlying Polyline object for one second, sleeps for that second using humanized `sleep()`, pauses the polyline, updates the bot's position (preserving altitude), and calls `heartbeat()`. It then returns `False` to indicate more steps are needed.\n   This turns the walker into a true incremental stepper instead of a blocking loop that instantly moves along the entire polyline.\n\n5. **Wiring into MoveToMapPokemon** (pokemongo_bot/cell_workers/move_to_map_pokemon.py): The task now reads a `walker` config key (e.g., \"PolylineWalker\" or \"StepWalker\") and uses `walker_factory` in its `_move_to()` method. The `parent` kwarg (`parent=MoveToMapPokemon`) is passed through to the factory, which in turn is used as the cache key for PolylineObjectHandler.\n\n6. **StepWalker relocation**: StepWalker was moved into `pokemongo_bot.walkers.step_walker`, and all references (FollowCluster, FollowPath, FollowSpiral, MoveToFort, tests) were updated to import from the new module path. The tests in `step_walker_test.py` were moved under `pokemongo_bot/test` and the patch targets updated to the new module path.\n\n7. **Human behaviour utilities expansion** (pokemongo_bot/human_behaviour.py):\n   - Introduced `lognormal_model()` to lazily load lognormal parameters from a model file for jitter and reflex times.\n   - Added `pareto()` (Zipf-like) helper, `sleep(seconds)` that adds jitter and human reflex delays, `jitter_rng()` and `human_reflex_rng()` based on the precomputed lognormal model, and a more realistic `random_lat_long_delta()` using a bounded Gaussian.\n   - Added features for ball-throw behavior: `ball_throw_reticle_fail_delay`, `aim_rng`, `normalized_reticle_size` and `spin_modifier` now support different modes (bot, uniform, human) and use Gaussian noise. Internal visualization and model-precalc helpers (`_visualize`, `_precalc_lognormal_ping_param`) were included but guarded under `__main__`.\n\nSome intermediate commits accidentally added or duplicated files (a local `data/lognormal.model`, a stray `pokemon_catch_worker.py`, and some other artifacts). These were removed in later commits so the net diff only includes the intended polyline and human behaviour changes. Tests were adjusted multiple times to get CI passing, mostly due to the new package name for StepWalker and updated patch targets in the mocks.\n\nThe final outcome is that MoveToMapPokemon can optionally use a polyline-based walker that follows realistic routes, respects Google Directions API limits via caching and fallback, and steps incrementally instead of teleporting. The human_behaviour module now provides richer, more human-like timing and movement noise.",
        "semantic_memory": "Several generalizable patterns emerge from this work:\n\n1. **Introduce a strategy/factory layer for interchangeable behaviors**\n   Instead of hardcoding a single movement implementation, the bot now uses a simple factory (`walker_factory`) keyed by a configuration string (e.g., \"StepWalker\", \"PolylineWalker\"). This allows different walking strategies to be swapped without modifying task code, encourages experimentation, and makes it easier to roll back to a safe default if a new strategy is unstable. This is a generic pattern: use a factory or strategy pattern so high-level workflows depend on abstractions, not concrete implementations.\n\n2. **Cache external API-derived data to avoid quota issues and latency**\n   The PolylineObjectHandler caches route objects keyed by a logical owner (`parent_cls`) and destination. Instead of requesting a Google Directions route every tick, the bot reuses the previous polyline until the destination changes, and explicitly clears the cache when done. This reduces the number of external API calls, helps stay under quota, and speeds up repeated operations. In any system that repeatedly queries deterministic endpoints (e.g., routing, exchange rates, metadata resolution), caching by input parameters and explicitly invalidating the cache on relevant state changes is a robust pattern.\n\n3. **Graceful degradation when external services fail**\n   When Google Directions returns an unexpected structure (e.g., empty `routes` due to hitting a quota or a transient error), the Polyline constructor raises an exception that the factory catches. Rather than letting the bot misinterpret the response and \"teleport\" (jump directly to the destination), the factory falls back to a simpler StepWalker. This is a general best practice: wrap external API usage so that failures result in degraded but safe behavior, not undefined or obviously bot-like behavior.\n\n4. **Make navigation incremental and non-blocking**\n   The earlier PolylineWalker implementation essentially moved the bot along the entire route in a single tight loop, blocking other bot operations and creating unrealistic motion. The new implementation steps for one second at a time: it unpauses the polyline, lets one second of motion happen, pauses it again, updates position, and heartbeats. This pattern—breaking long-running operations into time-sliced steps—is broadly applicable in bots, games, and any long-running state machine; it ensures responsiveness and makes behavior smoother and more realistic.\n\n5. **Isolate and reuse humanization logic**\n   The human_behaviour module centralizes timing and movement noise (sleep jitter, reflex time, GPS noise) and ball-throw parameters. Instead of each task hand-rolling `time.sleep` jitter or randomization logic, they can call `sleep()`, `random_lat_long_delta()`, `normalized_reticle_size()`, and `spin_modifier()`. Using empirically driven distributions (lognormal for ping latency, Gaussian for aim and GPS noise) leads to more realistic behavior and keeps the logic consistent across the code base.\n\n6. **Refactor modules without breaking tests by updating imports and mocks**\n   Moving StepWalker into a `walkers` package required updating import paths in both production code and tests, and adjusting mock patch targets accordingly. Keeping tests aligned with the module structure is crucial when refactoring; tests that import via the public API or package alias can reduce brittleness.\n\n7. **Use configuration to wire features instead of hardcoding**\n   The MoveToMapPokemon task now reads a `\"walker\"` option from the config (defaulting to `\"StepWalker\"`), allowing users to opt-in or opt-out of new behavior via configuration. This pattern—feature selection and tuning via configuration rather than code changes—makes it easier for operators to test new behavior safely and rollback if necessary.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving route-based walking, external routing APIs, and configurable movement strategies:",
            "Step 1: Reproduce and observe the movement bug.",
            "Run the bot or simulation in the scenario where the issue occurs (e.g., multiple bots using a polyline-based walker simultaneously). Observe whether the bot is teleporting, moving in a single blocking loop, or hammering an external API on every tick. Collect logs, especially around route generation and movement steps.",
            "Step 2: Inspect the walker implementation.",
            "Locate the movement/walker class used (e.g., PolylineWalker, StepWalker). Examine how it computes routes and advances position. Check if it performs a tight loop on each invocation or if it moves incrementally, and whether it calls external APIs (like Google Directions) directly.",
            "Step 3: Analyze external API usage and responses.",
            "Review how the walker constructs requests and parses responses from external services. Confirm what happens when `routes` or required fields are missing or empty. Check if errors like IndexError or KeyError are caught or allowed to propagate. Verify whether there is any caching of route data or if every tick triggers a new request.",
            "Step 4: Introduce a walker factory / strategy selection.",
            "If movement logic is hardcoded, add a factory function that selects the walker based on a configuration string or enum. Implement a default fallback (e.g., a simple StepWalker) that does not depend on external APIs. Plug the factory into tasks that need movement so they no longer instantiate walkers directly.",
            "Step 5: Implement route caching around the external API.",
            "Create a small handler (like PolylineObjectHandler) that caches route objects using a meaningful key (e.g., parent task class plus destination). Before invoking the external API, check the cache. On subsequent ticks with the same destination, reuse the cached route instead of making a new API call. Provide a clear method to delete or invalidate the cache when the route is no longer needed (destination reached or logic changed).",
            "Step 6: Add robust error handling and fallback.",
            "In the class that wraps the external API (e.g., Polyline), detect anomalies such as empty `routes` arrays or missing fields, and raise a clear exception instead of allowing code to index into invalid structures. In the factory, catch that exception and fall back to a simpler, reliable walker. Optionally log an event indicating that the external service failed and a fallback was used.",
            "Step 7: Make walking incremental and non-blocking.",
            "Refactor the walker’s `step()` method to advance the bot for a fixed time slice (e.g., one second) or distance increment instead of traversing the whole route in one call. Within `step()`, advance the internal route state, update the bot’s position, call any necessary heartbeat or update methods, and return whether the destination is reached. This enables the main loop to interleave movement with other tasks.",
            "Step 8: Integrate humanization utilities for timing and noise.",
            "Use a centralized module (like human_behaviour) to provide realistic timing (`sleep` with jitter and reflex delays) and position noise (Gaussian GPS jitter). Replace direct calls to `time.sleep` and ad-hoc random offsets with these helpers. Ensure any model data or parameters needed by these helpers (e.g., lognormal parameters) are present and loaded lazily to avoid startup or I/O overhead.",
            "Step 9: Wire the new behavior into tasks via configuration.",
            "Update tasks (e.g., MoveToMapPokemon) to read a `walker` option from their configuration. Default to the safe choice (e.g., `\"StepWalker\"`) and allow advanced users to configure `\"PolylineWalker\"` or other strategies. When creating a walker, call the factory and pass any necessary context (such as the parent task class used for caching).",
            "Step 10: Update tests and mocks to match the refactor.",
            "Adjust unit tests to import walkers from the new module paths. Update `patch()` targets in tests to point to the correct module, such as `pokemongo_bot.walkers.step_walker.sleep` instead of the old path. Add tests for factory behavior (e.g., that it falls back to StepWalker when Polyline construction fails) and for incremental stepping semantics.",
            "Step 11: Validate under load and with multiple bots.",
            "Run the updated code under realistic load conditions (multiple walkers, multiple bots). Monitor external API call volumes, verify that routes are reused via cache, and confirm that movement is incremental and no longer teleports. Check logs to ensure that error handling and fallback behaviors are working as intended.",
            "Step 12: Iterate on configuration and thresholds.",
            "Expose parameters like the minimum distance at which to clear cached routes (e.g., 10 meters), maximum number of retries, or API timeouts as configuration options if necessary. Tune these based on observed behavior and user feedback."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant deCONZ climate integration: Eurotronic Spirit Zigbee thermostat reported incorrect HVAC modes and on/off state. The integration was mapping HVAC state from a generic on/off flag rather than the device's mode field and did not support AUTO mode. Fix adds HVAC_MODE_AUTO to supported modes, maps hvac_mode directly to the deCONZ thermostat 'mode' attribute (auto/heat/off), falls back to state_on when mode is unknown, and updates tests. Also adjusts deCONZ logging to use the package logger for selective logging.",
        "keywords": [
            "homeassistant",
            "deconz",
            "climate",
            "thermostat",
            "Eurotronic Spirit Zigbee",
            "HVAC_MODE_AUTO",
            "HVAC_MODE_HEAT",
            "HVAC_MODE_OFF",
            "hvac_mode mapping",
            "state_on",
            "mode attribute",
            "integration bug",
            "entity state mismatch",
            "tests update",
            "logging configuration",
            "pydeconz"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a user reported that their Eurotronic Spirit Zigbee thermostat, connected via deCONZ to Home Assistant, did not behave correctly. The thermostat worked in deCONZ itself but the Home Assistant climate entity showed wrong HVAC modes: the Heat/Off state was incorrect, on/off UI buttons did not function as expected, and AUTO mode was not available at all.\n\nThe root cause was in the `homeassistant.components.deconz.climate` integration. The HVAC mode reported to Home Assistant was derived too simplistically from a boolean 'on' state and did not use the more accurate `mode` field provided by the deCONZ / pydeconz thermostat (which can be 'auto', 'heat', 'off'). As a result, the thermostat's real operating mode was not reflected correctly in the HA UI, and commands sent from the UI did not map back correctly to the device.\n\nThe fix introduced several changes:\n- Added `HVAC_MODE_AUTO` to the supported HVAC modes list (now `[AUTO, HEAT, OFF]`).\n- Changed the `hvac_mode` property to return `self._device.mode` when it is one of the supported HVAC modes. If the mode is not recognized but `self._device.state_on` is true, it falls back to reporting `HEAT`; otherwise it reports `OFF`.\n- Updated `async_set_hvac_mode` to send the correct `mode` value to the deCONZ API: AUTO -> `{\"mode\": \"auto\"}`, HEAT -> `{\"mode\": \"heat\"}`, OFF -> `{\"mode\": \"off\"}`.\n- Adjusted tests in `tests/components/deconz/test_climate.py` to account for AUTO mode being the default and to verify correct API calls for AUTO, HEAT, and OFF. The test now expects the initial state to be `auto` instead of `off`, adds a distinct test for setting AUTO and then HEAT, and increments the expected count of PUT calls.\n- Separately, the deCONZ component's logging was adjusted so that `_LOGGER` is defined via `logging.getLogger(__package__)` in `const.py` and reused, instead of using a root logger name like \".\". Intermediate changes that added per-module loggers were reverted in favor of this centralized pattern.\n\nAfter these changes, the Eurotronic Spirit Zigbee thermostat reports the correct HVAC mode in Home Assistant, on/off and mode buttons work as expected, AUTO mode is supported, and tests pass in CI.",
        "semantic_memory": "This fix illustrates several general integration patterns and best practices:\n\n1. **Use device-native mode attributes, not just on/off flags**:\n   When integrating thermostats (or other multi-mode devices), relying solely on a generic boolean (e.g., `on` or `state_on`) often loses information. Many devices expose a `mode` field (e.g., `auto`, `heat`, `cool`, `off`) that should be mapped directly to the platform's mode constants. This ensures the UI reflects the full capabilities and state of the device.\n\n2. **Explicitly support all meaningful HVAC modes**:\n   Platforms like Home Assistant define a set of HVAC mode constants (e.g., `HVAC_MODE_AUTO`, `HVAC_MODE_HEAT`, `HVAC_MODE_OFF`). Integrations should include all modes the device actually supports in their `SUPPORT_HVAC` (or equivalent) list, and ensure both the state mapping and the command logic cover those modes.\n\n3. **Graceful fallback behavior**:\n   When encountering an unknown or unsupported mode from the device, it’s useful to have a deterministic fallback strategy. In this case, falling back to HEAT if `state_on` is true and OFF otherwise provides a reasonable approximation instead of failing silently or misrepresenting the state.\n\n4. **Symmetric state/command mapping**:\n   The mapping used to interpret device state (e.g., `device.mode -> hvac_mode`) should be symmetric with the mapping used when sending commands (`hvac_mode -> payload`). Bugs often arise when these two paths diverge or handle different sets of modes. Keeping them aligned and centralized reduces errors.\n\n5. **Tests as a contract for integration behavior**:\n   Updating tests when changing behavior (especially around state and modes) is essential. Tests should validate initial state, transitions between modes, and the exact API payloads sent to underlying services. This PR's updated tests ensure that the integration sends the correct JSON to the deCONZ API for each hvac_mode and that the entity's state in Home Assistant matches expected modes.\n\n6. **Scoped logging for components**:\n   For large applications, using `logging.getLogger(__package__)` or module-specific loggers allows selective and structured logging. Avoid using overly broad logger names like \".\" which make it harder to filter logs per integration or component.\n\nOverall, the pattern is: correctly read device capabilities, map them faithfully to the platform’s abstractions, implement symmetric state/command conversion, provide sensible fallbacks, and lock in behavior with precise tests.",
        "procedural_memory": [
            "Step-by-step approach to diagnose and fix thermostat mode mapping issues in an integration:",
            "Step 1: Reproduce and characterize the problem",
            "- Use the UI to interact with the climate entity (change modes, turn on/off) and observe incorrect behavior (e.g., wrong mode shown, buttons not working).",
            "- Check the entity state and attributes via the platform's developer tools (e.g., Home Assistant Developer Tools > States) to see what hvac_mode and attributes are being reported.",
            "",
            "Step 2: Inspect the underlying device data",
            "- Look at the raw data from the bridge or library (e.g., deCONZ / pydeconz) that backs the integration.",
            "- Identify fields that represent the device's true operational mode (e.g., `mode: auto|heat|off`) and other relevant flags (e.g., `on`, `state_on`).",
            "- Confirm which fields change when you operate the thermostat directly (via its native app or physical controls).",
            "",
            "Step 3: Compare device data to integration mapping",
            "- Open the integration's climate (or equivalent) module and locate the property that exposes the device mode (e.g., `hvac_mode` property).",
            "- Check how it determines the platform-specific mode (e.g., `HVAC_MODE_*`).",
            "- Verify whether it is using the device's `mode` field, or just a boolean like `on`.",
            "- Check the command method (e.g., `async_set_hvac_mode`) and ensure it maps platform modes back to the device payload.",
            "",
            "Step 4: Define the supported modes",
            "- Determine the full set of modes supported by the device (e.g., `auto`, `heat`, `off`).",
            "- Update the integration's supported modes list (e.g., `SUPPORT_HVAC = [HVAC_MODE_AUTO, HVAC_MODE_HEAT, HVAC_MODE_OFF]`).",
            "- Ensure these align with the platform's constants and with what the device actually reports.",
            "",
            "Step 5: Implement accurate state mapping",
            "- Update the `hvac_mode` (or equivalent) property to:",
            "  - Return the platform mode that corresponds directly to the device's `mode` field if it is one of the supported values.",
            "  - Introduce a fallback if the mode is unknown, e.g.:",
            "    - If a boolean like `state_on` is true, return a reasonable mode (such as HEAT).",
            "    - Otherwise, return OFF.",
            "- Avoid logging noise unless needed; if logging is required, log at debug level when encountering unknown modes.",
            "",
            "Step 6: Implement symmetric command mapping",
            "- In the method that handles mode changes (e.g., `async_set_hvac_mode`):",
            "  - Map `HVAC_MODE_AUTO` to the appropriate payload (e.g., `{\"mode\": \"auto\"}`).",
            "  - Map `HVAC_MODE_HEAT` to `{\"mode\": \"heat\"}`.",
            "  - Map `HVAC_MODE_OFF` to `{\"mode\": \"off\"}`.",
            "- Ensure that this mapping is the mirror of the state mapping, so reading and writing modes are consistent.",
            "",
            "Step 7: Update and extend tests",
            "- Add or modify tests to:",
            "  - Verify the initial hvac_mode for a thermostat (e.g., ensure it reports `auto` if that’s what the device reports).",
            "  - Call the service/API to set each supported mode and assert that the correct payload is sent to the underlying API (e.g., deCONZ endpoint).",
            "  - Confirm that the number of calls matches expectations (e.g., update `len(mock_calls)` assertions when new calls are added).",
            "  - Validate that state transitions reflect the correct modes.",
            "",
            "Step 8: Run tests and static checks",
            "- Run the integration’s test suite (e.g., `pytest` for the relevant component).",
            "- Ensure formatting (e.g., Black) and linting pass.",
            "- Fix any remaining test failures related to state or payload expectations.",
            "",
            "Step 9: Validate logging configuration (optional but recommended)",
            "- Ensure the integration uses a scoped logger, e.g., `_LOGGER = logging.getLogger(__package__)` or per-module `__name__`.",
            "- Avoid using overly generic logger names like \".\" that hinder selective logging.",
            "- Use debug-level logging when inspecting edge cases (like unknown modes) rather than errors, unless it's truly exceptional.",
            "",
            "Step 10: Re-test in a real environment",
            "- Deploy the updated integration to a test or local environment.",
            "- Confirm that the thermostat entity now shows the correct hvac_mode, that AUTO/HEAT/OFF can be selected from the UI, and that the physical device behaves as expected.",
            "- Verify that logs look sane and that users can filter logs for the specific integration if needed."
        ]
    }
}
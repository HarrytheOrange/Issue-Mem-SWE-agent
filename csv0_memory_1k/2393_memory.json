{
    "search_index": {
        "description_for_embedding": "Optuna example scripts were updated to use the newer Study.get_trials API with state filtering (and deepcopy=False) instead of manually iterating over study.trials and comparing t.state to TrialState values. This aligns examples with the current recommended API and avoids unnecessary deep copies.",
        "keywords": [
            "Optuna",
            "get_trials",
            "TrialState",
            "study.trials",
            "state filtering",
            "pruned trials",
            "complete trials",
            "examples update",
            "API modernization",
            "deepcopy performance"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, several Optuna example scripts had outdated patterns for accessing pruned and completed trials. They manually iterated over study.trials and filtered by checking t.state == optuna.trial.TrialState.PRUNED or COMPLETE. Since Optuna now provides Study.get_trials with a states parameter, the examples were out of sync with the recommended API and did not demonstrate efficient usage. The fix replaced these list comprehensions with calls to study.get_trials(deepcopy=False, states=[TrialState.PRUNED]) and study.get_trials(deepcopy=False, states=[TrialState.COMPLETE]) across multiple example files: chainer_integration.py, chainermn_integration.py, keras_integration.py, mxnet_integration.py, pytorch_distributed_simple.py, pytorch_simple.py, simulated_annealing_sampler.py, simple_pruning.py, tensorflow_estimator_integration.py, and tfkeras_integration.py. The code now imports TrialState from optuna.trial and uses it consistently. In one helper (_get_last_complete_trial) in the simulated annealing sampler example, the last complete trial is now retrieved using get_trials with state filtering instead of manually filtering study.trials. The result is cleaner, API-aligned sample code that avoids unnecessary deep copies and uses the officially supported mechanism for state-based trial selection.",
        "semantic_memory": "When a library evolves, sample code and documentation can become stale even if the old patterns still work technically. In Optuna, Study.get_trials provides a standard way to retrieve trials with optional state-based filtering and deep-copy control. Continuing to manually filter study.trials by accessing t.state is redundant, less efficient if deep copies are made unnecessarily, and may mislead users away from best practices. A better pattern is to use Study.get_trials(deepcopy=False, states=[TrialState.X]) to query pruned, complete, or other trial states. This also centralizes behavior (e.g., future changes to state semantics or returned structure) in one API instead of scattering manual filtering logic across the codebase. In general, example scripts should showcase the idiomatic, current APIs rather than low-level or legacy patterns. Importing enums like TrialState directly (from optuna.trial import TrialState) improves readability and reduces verbosity compared to qualifying through a longer namespace each time.",
        "procedural_memory": [
            "When you see code manually iterating over Optuna study.trials to filter by state, consider replacing it with Study.get_trials using the states argument.",
            "Step 1: Identify all places where trials are filtered by state, e.g. [t for t in study.trials if t.state == optuna.trial.TrialState.PRUNED] or similar patterns.",
            "Step 2: Import the TrialState enum close to the top of the module for readability, e.g. from optuna.trial import TrialState.",
            "Step 3: Replace the manual filtering expressions with the get_trials API using state filtering, for example:\n- Before: pruned_trials = [t for t in study.trials if t.state == optuna.trial.TrialState.PRUNED]\n- After: pruned_trials = study.get_trials(deepcopy=False, states=[TrialState.PRUNED])",
            "Step 4: Do the same for other states (e.g., COMPLETE, RUNNING, etc.), ensuring the states parameter is a list: complete_trials = study.get_trials(deepcopy=False, states=[TrialState.COMPLETE]).",
            "Step 5: For helper functions that need the last trial of a specific state, first retrieve filtered trials with get_trials, then index, e.g. complete_trials = study.get_trials(deepcopy=False, states=[TrialState.COMPLETE]); last_complete = complete_trials[-1].",
            "Step 6: Use deepcopy=False unless you specifically need deep-copied Trial objects. This avoids unnecessary overhead when you only read trial attributes.",
            "Step 7: Run the examples or tests to confirm that behavior (e.g., counts of pruned/complete trials, logged statistics) remains correct after the refactor.",
            "Step 8: When updating examples or documentation, prefer the official high-level API (like get_trials with states) over manual patterns so users learn the most maintainable and future-proof approach."
        ]
    }
}
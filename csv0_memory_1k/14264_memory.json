{
    "search_index": {
        "description_for_embedding": "Adds an availability_template option to Home Assistant's template binary_sensor platform so that sensor availability can be dynamically determined by a Jinja2 template. The BinarySensorTemplate entity now implements the available property, tracks entities referenced by the availability_template, and marks the sensor as unavailable if the template evaluates to false or fails to render.",
        "keywords": [
            "Home Assistant",
            "template binary sensor",
            "availability_template",
            "Entity.available",
            "CONF_AVAILABILITY_TEMPLATE",
            "template rendering failure",
            "async_render",
            "extract_entities",
            "dynamic availability",
            "binary_sensor.template"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, support for an `availability_template` configuration key was added to Home Assistant's template-based binary sensors. Previously, template binary sensors only supported `value_template`, and their availability state was not explicitly controllable via templates; the entity would conceptually always be 'available' even if its underlying dependencies were in an undefined or unavailable state.\n\nThe change introduces `CONF_AVAILABILITY_TEMPLATE` in `homeassistant.const` and integrates it into the template binary sensor platform (`homeassistant/components/binary_sensor/template.py`). The SENSOR_SCHEMA now accepts an optional `availability_template`. When setting up each sensor, the code:\n\n- Stores the provided `availability_template`, if any, and assigns `hass` to it.\n- Determines the set of entities the availability depends on using either an explicit `entity_id` list from config or by calling `availability_template.extract_entities()`.\n- Initializes the internal `_available` flag to `False` if an availability template is present (and `True` if not), ensuring that availability will be computed explicitly once Home Assistant starts up.\n- Registers a state change listener for the entities referenced by `availability_template` and calls `async_check_availability` when any of those entities change.\n\nThe `BinarySensorTemplate` class now implements the `available` property, which simply returns `_available`, and introduces `_availability_template` and `_availability_entities` fields. A new helper method `_async_render_availability` is responsible for rendering the availability template via `async_render()` and interpreting its result as a boolean by lowercasing the string and comparing to 'true'. If the template render fails with a `TemplateError`, availability is set to `False`. The code logs a warning when the failure is due to common HA startup conditions (e.g., `UndefinedError: 'None' has no attribute`), and logs an error otherwise.\n\n`async_check_availability` re-renders the availability template, compares the new result with the current `_available` value, and only schedules a Home Assistant state update if the availability changed. On startup (`EVENT_HOMEASSISTANT_START`), the component now sets up both the state tracking (for `value_template`) and availability tracking (for `availability_template`), and triggers initial evaluations for both.\n\nTests in `tests/components/binary_sensor/test_template.py` were updated to reflect the constructor signature changes and a new test `test_availability` was added. This test configures a template binary sensor whose availability depends on the existence/state of `sensor.test_state` (unavailable if missing or explicitly 'unavailable') and verifies that:\n\n- Initially, the binary sensor is `unavailable` when the source sensor does not exist.\n- It becomes `on` when the source sensor state is 'on'.\n- It transitions back to `unavailable` when the source sensor state becomes 'unavailable'.\n- It returns to `on` when the source sensor is 'on' again.\n\nAnother existing test (`test_update_template_error`) was updated to accommodate the new constructor arguments. Overall, this PR enables users to represent binary sensors as unavailable based on template-driven conditions, typically when dependencies are unavailable, providing more accurate overall system state reporting.",
        "semantic_memory": "This change illustrates a general pattern for implementing dynamic availability for entity-like objects in reactive systems.\n\nKey conceptual points:\n\n1. **Separation of value and availability**: An entity's state (e.g., 'on'/'off') should be conceptually independent from its availability (e.g., is the state valid or meaningful right now?). Providing a dedicated `available` property and separate configuration (like `availability_template`) yields clearer semantics and more expressive configuration.\n\n2. **Template-driven availability**: When an entity's state depends on other entities or external conditions, availability can be computed using the same templating mechanism used for value computation. This lets users encode domain-specific rules such as \"mark sensor as unavailable if any of its dependencies are unknown/unavailable\".\n\n3. **Explicit dependency tracking**: To update availability or value efficiently and correctly, the system should track which entities a template depends on. Using something like `template.extract_entities()` allows automatic dependency detection, with a fallback to manually provided `entity_id` lists. This ensures that updates are only triggered when relevant entities change.\n\n4. **Error handling in template execution**: Template evaluation can fail due to missing entities, startup race conditions, or syntax/runtime errors. The safest default for availability is to treat template failures as 'unavailable' (fail closed), especially for availability computations. Logging must distinguish between expected transient errors (e.g., undefined entities at startup) and real problems, using appropriate log levels.\n\n5. **State-change driven evaluation**: For both value and availability, recomputation is best done in response to tracked state changes and on startup rather than periodic polling. This supports scalable, event-driven design and consistent state across restarts.\n\n6. **Change-based state updates**: Before scheduling UI or state updates, the new computed value/availability should be compared to the current one. Avoiding unnecessary updates reduces overhead and noise in state/event logs.\n\n7. **Consistent configuration semantics across similar components**: Once a pattern like `availability_template` is established in one template-based integration (binary_sensor here), it should be replicated to similar integrations (sensor, switch, light, cover) to provide a coherent user experience and reduce mental overhead.\n\nThe broader takeaway is: when building configurable, template-driven components in a reactive home automation system (or similar frameworks), always account for availability as a first-class dimension, derive dependencies from configuration, and handle template errors in a way that keeps the system safe and predictable.",
        "procedural_memory": [
            "How to add template-based availability to an entity platform and handle rendering failures safely.",
            "Step 1: Introduce a configuration option for availability templates.\n- Define a constant for the new configuration key (e.g., `CONF_AVAILABILITY_TEMPLATE`) in a central constants module.\n- Extend the platform's configuration schema to include an optional template field, ensuring it uses the same template type/validation as the main value template.",
            "Step 2: Wire the availability template into entity setup.\n- In the platform setup (e.g., `async_setup_platform`), read the `availability_template` from each entity's configuration.\n- Assign `hass` (or equivalent context) to the template object so that it can access states and services when rendering.\n- Determine the list of entities that affect availability. Prefer automatically extracting them via something like `availability_template.extract_entities()`, with a fallback to explicitly provided `entity_id` configuration.",
            "Step 3: Extend the entity class to support availability.\n- Add internal fields for availability state (e.g., `_available`) and the availability template (e.g., `_availability_template`) and its entity dependencies.\n- Initialize `_available` sensibly: if no template is provided, default to `True`; if there is a template, initialize to a conservative default like `False` until computed.\n- Implement an `available` property (or equivalent API in your framework) that returns `_available`.",
            "Step 4: Implement availability rendering and error handling.\n- Add a helper method (e.g., `_async_render_availability`) that:\n  - Calls the template's render/async_render method.\n  - Normalizes the result to a boolean (e.g., treating string 'true'/'True' as `True`).\n  - Wraps rendering in a try/except block to catch template errors.\n  - On any `TemplateError`, set availability to `False` and log the error. Use different log levels for expected transient issues (like missing entities at startup) vs genuine failures.\n- Ensure this helper returns a boolean availability value even when errors occur.",
            "Step 5: React to dependency state changes.\n- During platform initialization or startup event handling, register state change listeners for the entities referenced by the availability template.\n- In the listener callback, call a method (e.g., `async_check_availability`) that:\n  - Re-renders the availability template.\n  - Compares the new availability value with the current `_available`.\n  - If it changed, updates `_available` and schedules a state update (`async_schedule_update_ha_state` or equivalent).",
            "Step 6: Integrate with startup behavior.\n- On a framework-specific startup event (e.g., `EVENT_HOMEASSISTANT_START`), trigger initial evaluation of both the value template and availability template.\n- Set up listeners inside this startup callback to ensure templates do not fire before the system state registry is ready.\n- Accept that some template errors may occur at startup due to missing entities and treat them as transient (log warnings, not errors).",
            "Step 7: Update tests and constructor signatures.\n- If the entity constructor signature changes (e.g., adding `availability_template` or availability entity IDs), update all callers in tests accordingly.\n- Add tests that verify the entire availability lifecycle:\n  - Initial state when dependencies do not exist.\n  - Transition to available when dependencies become valid and match conditions.\n  - Transition back to unavailable when dependencies are explicitly unavailable or missing.\n- Add tests that mock template rendering failures to ensure that such failures cause availability to become `False` and appropriate logging occurs.",
            "Step 8: Apply the pattern to similar components.\n- Once availability is properly handled in one template-based platform (e.g., binary_sensor), replicate the pattern across other template-driven platforms (sensor, switch, light, cover).\n- Maintain consistent semantics: same config key (`availability_template`), same boolean evaluation logic, same error handling strategy, and similar test coverage.\n- Document the new configuration in the user-facing docs, including examples of availability templates that depend on other entities' `unknown`/`unavailable` states.",
            "Step 9: Diagnosing issues when availability behaves unexpectedly.\n- When users report that a template-based entity is unexpectedly unavailable:\n  - Check if an `availability_template` is configured and inspect its logic for edge cases involving `None`, `unknown`, or `unavailable` values.\n  - Verify that the entities it references actually exist and are spelled correctly.\n  - Confirm that `extract_entities()` (or equivalent) picks up all referenced entities, or adjust `entity_id` configuration if needed.\n  - Look in the logs for template rendering warnings/errors that could indicate startup race conditions or syntax issues.\n  - Temporarily simplify the availability template to a constant 'true' to verify that the rest of the pipeline works, then incrementally add logic back."
        ]
    }
}
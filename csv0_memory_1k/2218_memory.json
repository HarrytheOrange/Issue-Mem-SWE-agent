{
    "search_index": {
        "description_for_embedding": "Attempted feature to add SHA-512 salted hash utilities for Home Assistant's HTTP API password configuration. Introduced helpers to parse, generate, and split /etc/shadow-style '$alg$salt$hash' strings, plus tests, but the PR was closed in favor of a more robust keyring-based secret storage approach and concerns about using a single SHA-512 round instead of a proper KDF.",
        "keywords": [
            "Home Assistant",
            "HTTP component",
            "api_password",
            "api_hash",
            "SHA-512",
            "salted hash",
            "password hashing",
            "config file security",
            "key derivation function",
            "keyring support",
            "hash format $alg$salt$hash"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, a contributor tried to improve how Home Assistant's HTTP API password is stored by introducing SHA-512-based salted hash helpers, without yet changing the live authentication logic. The target was to move from a plaintext `api_password` in configuration.yaml to a hashed representation similar to Unix /etc/shadow entries.\n\nThe changes were:\n- New config key `CONF_API_HASH = 'api_hash'` alongside the existing `CONF_API_PASSWORD = 'api_password'`.\n- New constant `SALT_LENGTH = 8` and imports for `hashlib`, `random`, and `string`.\n- Helper `new_hash(password, salt=None)` that:\n  - Generates a random 8-character alphanumeric salt if none is provided, using `random.sample` from `string.ascii_letters + string.digits`.\n  - Asserts that the salt does not contain '$'.\n  - Computes SHA-512 over `(salt + password)` and returns a string of the form `$sha512$<salt>$<hexdigest>`.\n- Helper `split_hash(hash_string)` that asserts the string has exactly three '$' characters and returns a tuple `(algorithm, salt, hash)` by splitting on '$' and discarding the leading empty element.\n- Helper `collect_hash(config)` that:\n  - Looks at an HTTP config dict (i.e., `configuration['http']`).\n  - If `api_hash` is present, uses that; if not, but `api_password` is present, generates a new hash from the password via `new_hash`.\n  - Returns the result of `split_hash(...)` or `None` if neither is present.\n- Minor refactor of the `handle_request` authentication condition to use a multi-line `hmac.compare_digest` call (no functional change).\n- New tests in `tests/components/test_http.py` using `unittest` and `unittest.mock` to verify:\n  - `collect_hash` prefers `api_hash` over `api_password` when both are present.\n  - `collect_hash` returns a tuple corresponding to a newly generated hash when only `api_password` is present, mocking `random.sample` for determinism.\n  - `collect_hash` returns `None` if no password/hash config exists.\n  - `new_hash` produces different hashes for the same password (due to random salt).\n  - `new_hash` embeds the salt and SHA-512 digest correctly in the `$alg$salt$hash` format.\n\nHowever, reviewers raised concerns:\n- Using a single round of SHA-512 is weak for password protection; a proper key derivation function (like PBKDF2 from Python's stdlib) should be used instead.\n- Protecting only the HTTP API password while other secrets (API keys, other passwords) remain plaintext in configuration.yaml provides limited real-world security benefit.\n- The MQTT server reuses the same API password, meaning complete migration off plaintext would require further work and a migration path.\n- Parallel work was introducing keyring support for secrets, making the hashed password approach less compelling.\n\nGiven these concerns and the impending keyring solution, the maintainer closed the PR without merging. The hashing utilities and tests never became part of the main codebase.",
        "semantic_memory": "This incident illustrates several important lessons about password handling and security-oriented changes in application configuration:\n\n1. **Hashing vs. proper password storage**\n   - Simply hashing a password once with a fast hash (e.g., SHA-512) is insufficient for secure password storage. Modern hardware can brute-force such hashes extremely quickly.\n   - Use a dedicated *key derivation function* (KDF) for passwords, such as PBKDF2, bcrypt, scrypt, or Argon2. Python's `hashlib.pbkdf2_hmac` is a suitable standard-library option.\n   - The goal of hashing passwords is to make brute-force attacks expensive, not just to obscure the password.\n\n2. **Format and parsing of salted hashes**\n   - Representing hashes in a structured string format like `$algorithm$salt$hash` (similar to /etc/shadow) is a practical pattern. It allows the system to:\n     - Store algorithm, salt, and hash in one field.\n     - Allow future migrations to different algorithms while preserving compatibility.\n   - Helper functions like `new_hash`, `split_hash`, and `collect_hash` encapsulate the logic of generating and parsing these strings, minimizing repeated parsing logic and mistakes.\n\n3. **Security scope and consistency**\n   - Protecting only one secret (e.g., HTTP API password) is of limited value if many others (API tokens, integration passwords, etc.) remain unprotected in the same file.\n   - A holistic secret management strategy (e.g., OS keyring, environment variables, encrypted config, or dedicated secret storage) is often more valuable than piecemeal improvements.\n   - Changes to password handling must account for all consumers of the credential (e.g., HTTP API and embedded MQTT) to avoid inconsistent or broken behavior.\n\n4. **Beware of partial security features**\n   - Incomplete or superficial security measures can create a false sense of security for users, who may assume their data is more protected than it actually is.\n   - When introducing security features, it is crucial to:\n     - Communicate their threat model and limitations clearly.\n     - Avoid merging features that are known to be weak or misleading.\n\n5. **Randomness and salt generation**\n   - Salts should be generated using a cryptographically secure random source (`secrets` module or `os.urandom`), not `random`, which is not designed for security.\n   - Salt length and character set should be large enough to avoid collisions and be unguessable. Using ASCII letters and digits is fine, but ensure robust randomness.\n   - Utility functions must enforce simple invariants for their formats (e.g., that a salt does not contain the delimiter used in the hash format).\n\n6. **Testing helper functions for security primitives**\n   - Even small helper functions around hashing must be well-tested: verifying formats, parsing behavior, and ensuring deterministic behavior when randomness is mocked.\n   - Tests should explicitly check the structure and correctness of hash strings (e.g., number of delimiters, correctness of the digest for a known password and salt).\n\nOverall, this case shows both technical best practices (structured password hash utilities, testing) and process-level best practices (rejecting insufficient security features and preferring comprehensive secret management solutions).",
        "procedural_memory": [
            "When considering moving from plaintext configuration passwords to hashed or more secure storage, follow a structured process to avoid weak or misleading security.",
            "Step 1: Clarify the threat model and scope.",
            "Step 1.1: Identify what you are protecting against (e.g., config file leakage, offline attacks, online brute force).",
            "Step 1.2: List all secrets stored in configuration (passwords, API tokens, keys) and all components that depend on them (HTTP API, MQTT, integrations).",
            "Step 1.3: Decide whether you need incremental improvement (e.g., hashing) or a holistic solution (keyring, secret manager, encrypted config).",
            "Step 2: Choose appropriate cryptographic primitives.",
            "Step 2.1: Prefer a password KDF (PBKDF2, bcrypt, scrypt, Argon2) over a single fast hash. In Python, consider `hashlib.pbkdf2_hmac` for PBKDF2.",
            "Step 2.2: Select strong parameters (iterations, salt length) appropriate for current hardware and expected threat level.",
            "Step 2.3: Use cryptographically secure randomness for salt generation (`secrets.token_bytes`, `secrets.token_hex`, or `os.urandom`), not `random`.",
            "Step 3: Define a stable hash string format.",
            "Step 3.1: Adopt a structured format that includes algorithm, salt, and hash in one string. A typical pattern is `$<algorithm>$<salt>$<hash>`.",
            "Step 3.2: Document the format, including any constraints (e.g., salt must not contain '$').",
            "Step 3.3: Ensure the format allows future migration to other algorithms or parameters by encoding them in the algorithm portion.",
            "Step 4: Implement helper utilities to encapsulate hashing logic.",
            "Step 4.1: Implement `new_hash(password, salt=None)`:\n- Generate a random salt if none is provided.\n- Assert or validate that the salt meets format constraints.\n- Run the chosen KDF/hash and return a formatted string (e.g., `$alg$salt$hash`).",
            "Step 4.2: Implement `split_hash(hash_string)`:\n- Validate the string structure (e.g., correct number of delimiters).\n- Parse and return `(algorithm, salt, hash)`.\n- Raise clear errors when the format is invalid.",
            "Step 4.3: Implement `collect_hash(config)` or similar config helper:\n- Prefer a precomputed hash field (e.g., `api_hash`) if present.\n- Fall back to generating a hash from a plaintext password field (`api_password`) if needed.\n- Return `None` if neither is available, so callers can handle the absence of credentials cleanly.",
            "Step 5: Integrate with authentication logic carefully.",
            "Step 5.1: Identify where authentication currently compares plaintext passwords (e.g., HTTP query parameter vs stored `api_password`).",
            "Step 5.2: Replace plaintext comparison with logic that:\n- Parses the stored hash (using `split_hash`).\n- Recomputes the hash/KDF with the provided password and stored salt.\n- Performs a constant-time comparison (e.g., `hmac.compare_digest`) to avoid timing leaks.",
            "Step 5.3: Ensure all consumers (HTTP, MQTT, etc.) are updated consistently or provide a backward-compatibility path.",
            "Step 6: Write comprehensive tests for the hashing utilities.",
            "Step 6.1: Test `new_hash`:\n- That it returns differently salted hashes for the same password.\n- That the digest matches the expected value for known salt+password pairs.\n- That the format contains the correct number of delimiters and correct algorithm label.",
            "Step 6.2: Test `split_hash` for valid and invalid inputs:\n- Valid strings parse into the correct `(alg, salt, hash)` tuple.\n- Invalid formats (wrong number of delimiters, empty fields) raise clear errors or assertions.",
            "Step 6.3: Test `collect_hash` behavior with various configurations:\n- Both hash and password present → hash is preferred.\n- Only password present → a new hash is created and returned.\n- Neither present → returns `None`.",
            "Step 6.4: Use mocking for randomness in tests:\n- Mock the random or secrets calls to make hash outputs deterministic for assertions.",
            "Step 7: Evaluate whether to merge the feature given broader architecture and alternatives.",
            "Step 7.1: Compare the marginal security gain from hashed config passwords to other available or planned mechanisms (e.g., keyring integration, environment variable injection, external secret stores).",
            "Step 7.2: Consider the maintenance cost and user confusion risk of introducing partial security measures.",
            "Step 7.3: If a more robust solution (like keyring support) is available or imminent, favor that and avoid merging incomplete hashing implementations.",
            "Step 8: Communicate limitations clearly to users if you do ship a hashing feature.",
            "Step 8.1: Document that hashed passwords protect against some threats (e.g., casual inspection of config files) but not others (e.g., offline brute force if using a fast hash).",
            "Step 8.2: Encourage users to use strong passwords and, where available, central secret management solutions.",
            "Step 8.3: Provide tooling or instructions to generate hashes consistently (e.g., CLI command to generate `$alg$salt$hash` entries for configs)."
        ]
    }
}
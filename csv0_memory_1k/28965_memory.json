{
    "search_index": {
        "description_for_embedding": "Home Assistant conversation and intent handling was not context-aware: user context (e.g., user_id) from HTTP, WebSocket, or service calls was not propagated into intents or downstream service calls. The fix introduces a Context parameter into conversation agents and intent handling, wires context through HTTP/WebSocket views and the conversation service, and ensures all intent-based service calls run with the correct context.",
        "keywords": [
            "Home Assistant",
            "conversation integration",
            "intent handling",
            "Context propagation",
            "user_id on intents",
            "AbstractConversationAgent.async_process signature change",
            "HTTP view context",
            "websocket_api context",
            "intent_script",
            "light intent handler",
            "service call context",
            "missing context bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant conversation and intent systems were updated to be context-aware. Previously, when a user triggered a conversation via HTTP, WebSocket, or the `conversation.process` service, the `Context` (especially `user_id`) was not consistently propagated into the intent handling pipeline or to the service calls that resulted from those intents. This meant that actions originating from a specific user could appear as unassociated or system-originated in logs and permission checks.\n\nTo fix this, the core conversation agent interface (`AbstractConversationAgent.async_process`) was changed to accept an additional `Context` parameter: `async_process(self, text: str, context: Context, conversation_id: Optional[str] = None)`. All agents (including the Almond integration and the default conversation agent) were updated accordingly.\n\nThe conversation integration refactored its logic into two helpers: `_get_agent`, which lazily initializes and caches the active agent, and `_async_converse`, which takes `hass`, `text`, `conversation_id`, and `context`, calls the agent with context, and normalizes errors and empty responses into an `IntentResponse`. All entry points (service handler, WebSocket `conversation/process`, and HTTP `ConversationProcessView.post`) now obtain a `Context` (from `service.context`, `connection.context(msg)`, or `HomeAssistantView.context(request)`) and pass it through `_async_converse`.\n\nThe HTTP view base class was adjusted: `HomeAssistantView.context` became a `@staticmethod` returning a `Context` with the `user_id` from `request['hass_user']`, and `HomeAssistantView.json` was made a `@staticmethod` as well.\n\nOn the intent side, `helpers.intent.async_handle` was extended to accept an optional `context: Optional[Context]`. If no context is provided, it creates a new `Context()`. The `Intent` object now stores `context` (added to `__slots__` and the constructor) and passes this context along to service calls in `IntentScript` and the generic `ServiceIntentHandler` by using `context=intent_obj.context` in `hass.services.async_call`. Also, in `intent_script`, async actions are now run with `action.async_run(slots, intent_obj.context)` so actions can use the originating context.\n\nTests for the conversation integration were updated to create explicit `Context` objects and verify that: (1) the `Intent` created during a conversation service call includes the passed context; (2) HTTP and WebSocket conversation endpoints associate the intent's context with the correct `hass_admin_user.id`; and (3) custom conversation agents receive the correct `Context` object and conversation ID. This confirms that context now flows end-to-end from the caller to the conversation agent, through intent handling, and into resulting service calls.",
        "semantic_memory": "This change illustrates a broader pattern: when building a system that handles user-initiated actions (especially in a multi-user, permissioned environment), it is crucial to propagate contextual information (such as user identity, request identifiers, and trace IDs) through all layers of the call stack.\n\nKey generalizable concepts:\n\n1. **Context as a first-class parameter**:\n   - Interfaces that perform actions on behalf of a caller should take a `Context` or equivalent object explicitly, rather than inferring it implicitly. This includes API handlers, service layers, and plugins/agents.\n   - Changing core abstract interfaces (like `AbstractConversationAgent.async_process`) to include context forces all implementations to handle context correctly, eliminating silent drops.\n\n2. **Single source of truth for context derivation**:\n   - Centralize the logic that builds a `Context` from incoming requests (e.g., `HomeAssistantView.context(request)`), so the mapping from HTTP/WebSocket/session data to internal context is consistent and easy to audit.\n\n3. **Default contexts vs. explicit contexts**:\n   - When a context is not provided (e.g., internal calls, tests, or background jobs), use a default, benign context (`Context()`), but prefer passing a real context whenever you have one. This avoids breaking existing callers while still enabling context-aware behavior.\n\n4. **Plumbing context through helper layers**:\n   - Helper functions that wrap domain logic (e.g., `intent.async_handle`, `_async_converse`) must accept and forward context to lower layers, not terminate it. This prevents context loss at abstraction boundaries.\n\n5. **Context-aware side effects (service calls, actions)**:\n   - Any side-effecting call (such as `hass.services.async_call` or an automation/action `async_run`) should be executed with the originating context. This enables accurate attribution, permission checks, and tracing.\n\n6. **Refactoring for clarity and testability**:\n   - Splitting responsibilities into private helpers (`_get_agent`, `_async_converse`) clarifies the flow and makes it easier to ensure that context is always provided and tested.\n\n7. **Testing end-to-end context propagation**:\n   - Tests should not only validate output values but also verify that context (e.g., `user_id`) is preserved from the entry point to the final handler. This guards against regressions where parameters are accidentally dropped.\n\nThese practices apply broadly to any event-driven or service-oriented system where actions need to be attributable and permission-aware, not just to Home Assistant's conversation/intent framework.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving missing or improperly propagated context in a multi-layered system.",
            "Step 1: Identify symptoms of missing context.\n- Look for actions (service calls, commands, or side effects) that appear as coming from an anonymous or system user when they should be tied to a specific user or request.\n- Check logs/audit trails where `user_id`, correlation IDs, or trace tokens are unexpectedly null or default.\n- Inspect permission-related bugs where requests that should be allowed/denied are behaving incorrectly because user information is missing.",
            "Step 2: Trace the call flow from entry point to side effect.\n- Map how a request reaches the point where the side effect occurs: HTTP handler → WebSocket handler → service call → intent handler → domain logic, etc.\n- For each layer, note what parameters are passed (especially any context-like object) and where they are created or modified.\n- Verify whether a context object is available at the entry point (e.g., `request.user`, `service.context`, connection context).",
            "Step 3: Introduce or standardize a Context type.\n- If your system does not have a dedicated context type, define one (e.g., `Context(user_id, request_id, trace_id, ... )`).\n- If you already have a context type (like Home Assistant’s `Context`), ensure it has the fields you need (at least `user_id` for attribution, optionally correlation/trace IDs).",
            "Step 4: Update core interfaces to accept context explicitly.\n- Identify the abstraction boundary where actions are decided (e.g., agent interfaces, handler classes).\n- Add a `context` parameter to these methods, making it a required or strongly encouraged argument. Example: change `async_process(self, text, conversation_id=None)` to `async_process(self, text, context, conversation_id=None)`.\n- Update all implementations of these interfaces to accept the new argument, even if some do not yet use it internally.",
            "Step 5: Ensure all entry points construct and pass a context.\n- For HTTP endpoints, create a helper (e.g., `View.context(request)`) that builds a `Context` from the authenticated user/session info.\n- For WebSocket endpoints, use any built-in mechanism (like `connection.context(msg)`) to obtain a context object.\n- For internal service calls, pass `service.context` where available.\n- Refactor repeated logic into shared helpers (as in `_async_converse` in the conversation integration) to minimize duplication and ensure consistent behavior.",
            "Step 6: Plumb context through helper functions and facades.\n- Audit helper layers that wrap domain logic (e.g., `intent.async_handle`, `conversation.process`, domain-specific helper modules).\n- Add a `context` parameter to these helpers and make sure they forward it to the underlying handlers.\n- Provide a sensible default: if `context` is `None`, create a new context instance, but prefer explicit context downstream when available.",
            "Step 7: Make side-effecting calls context-aware.\n- Wherever you perform external or system actions (service calls, database writes, external API calls), pass the current context. Example: `hass.services.async_call(domain, service, data, context=intent_obj.context)`.\n- For action/automation objects, update their `async_run` or equivalent to accept a `context` argument and pass it along.\n- Ensure that the components (like `intent_script` and `light` in this case) use `intent_obj.context` when initiating service calls.",
            "Step 8: Refactor and centralize logic where needed.\n- If context-related logic becomes scattered, extract common behavior into small private helpers (e.g., `_get_agent`, `_async_converse`) that take context as a parameter.\n- This reduces the chance of forgetting to pass context in new entry points or features.",
            "Step 9: Extend tests to validate context propagation.\n- In tests of HTTP and WebSocket endpoints, authenticate as a known user and assert that the final handler receives a context with `user_id` equal to that user’s ID.\n- For internal service calls, create an explicit `Context()` and pass it, then assert that `Intent` objects and downstream calls see the same context instance.\n- For custom or plugin-based agents/handlers, verify that they are invoked with the correct context and conversation IDs.\n- Add tests for default behavior where no context is provided, verifying that a valid (non-crashing) default context is used.",
            "Step 10: Review and document interface changes.\n- Because adding a context parameter is a breaking change for interface implementors, document the new method signatures and expectations for context handling.\n- Communicate these changes to integration authors, emphasizing why context is important (attribution, permissions, auditing, observability).\n- Where possible, keep compatibility layers or clear error messages for outdated implementations that still use old signatures.",
            "Step 11: Monitor after deployment.\n- After deploying the fix, monitor logs to confirm that user IDs and other context fields are correctly populated on intents and service calls.\n- Check permission enforcement and audit trails to ensure they now behave as expected.\n- Be alert for any custom integrations that may not have been updated to the new interface and fix them accordingly."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fixes a Pokémon Go bot walking bug where movement speed was based on per-tick distance instead of elapsed time, causing the bot to move too slowly, randomly, or not at all. Refactors StepWalker to treat speed as m/s, scales movement by real time delta, recalculates movement vectors from the current position, prevents overshooting the target, and reuses a single StepWalker instance for MoveToFort and spiral navigation.",
        "keywords": [
            "Pokémon Go bot",
            "StepWalker",
            "MoveToFort",
            "SpiralNavigator",
            "follow_spiral",
            "walk speed",
            "time-based movement",
            "delta time",
            "movement simulation bug",
            "bot stuck",
            "incorrect speed units",
            "overshooting destination",
            "navigation refactor",
            "random jitter removal"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Pokémon Go bot's walking behavior was effectively broken. Users reported that the bot either stayed in place, moved randomly, or moved at a speed far lower than configured (e.g., specifying 12 km/h but getting around 1.2 km/h in practice). The root cause was that the `walk` parameter was being used as a fixed distance per tick instead of a true speed. The bot's 'ticks' (worker cycles) happen at irregular intervals, so using 'meters per tick' implicitly assumes a fixed tick duration that no longer matched reality once more work was added between movement steps.\n\nThe implementation of `StepWalker` had several specific issues:\n1. Speed was interpreted as a constant step size per invocation of `step()`, not meters per second, so the actual speed varied with how often `step()` was called.\n2. `StepWalker` was re-instantiated on every `MoveToFort.work()` call and some spiral navigation code, which meant its internal state (like component vectors and progress) was constantly reset, leading to no net progress or erratic movement.\n3. The math used to compute step vectors recalculated components from the original starting position each time and did not always use the current position, which could result in 'standing still' or strange behavior, especially after partial movement.\n4. There was no robust prevention for overshooting the target: large time gaps between ticks could cause a big step that jumped far beyond the destination, potentially 'walking off the planet'.\n5. Randomized offsets (`random_lat_long_delta`) were added each step directly to lat/lng, introducing additional unpredictability and making debugging and control of speed harder.\n\nThe fix involved a substantial refactor of `StepWalker` and integration points:\n\n- `StepWalker` now treats `speed` as a real speed in meters per second and scales movement by the elapsed time since the last `step()` call, using `time()` to compute `time_scale`.\n- A `lastTime` field tracks the time of the previous step. On each `step()`, `time_scale` is computed as `current_time - lastTime`. The movement distance for this call is `speed * time_scale`, applied via the component lat/lng deltas.\n- Component vectors (`dLat`, `dLng`) are recalculated from the current bot position to the destination each tick in `update_component_vectors()`, which computes `dist` from the live position to `destLat`/`destLng`, computes `steps = dist / speed`, and then sets `dLat` and `dLng` as `(destLat - currentLat) / steps` and `(destLng - currentLng) / steps` when `steps > 1`. This removed the bug where calculations were anchored on stale initial coordinates.\n- An early check prevents overstepping: if `self.dist < self.speed * dist_scale` (with a small jitter applied to `time_scale` via `jitter()`), `StepWalker` logs that the target is in range, snaps directly to `destLat`/`destLng`, marks itself as `complete`, and returns `True` instead of stepping past the destination.\n- `StepWalker` now has a `complete` flag and will raise an exception if `step()` is called after completion, ensuring callers don't silently reuse a finished walker.\n- Random lat/lng deltas have been removed from `StepWalker`'s core movement. Instead, human-like variance is modeled via scaling the effective time with `jitter(time_scale, time_scale * 0.03)` rather than randomizing coordinates directly.\n\nIntegration changes:\n\n- `MoveToFort` now holds and reuses a `StepWalker` instance (`self.step_walker`) and a cached `nearest_fort`. In `navigate_to_fort()`, it resolves the nearest fort, creates a `StepWalker` with a descriptive `label` (e.g., 'FortWalker'), and keeps it. In `work()`, it first initializes navigation once, then uses the same `StepWalker` repeatedly until the fort is reached (`step()` returns `True`). Only after arrival does it call `navigate_to_fort()` again to select a new fort. This eliminates the prior pattern of re-instantiating `StepWalker` every tick.\n- `MoveToFort` was adjusted to handle the case of `nearest_fort` being `None` safely, avoiding attempts to create a walker to a non-existent target.\n- Spiral navigation (`SpiralNavigator` and `follow_spiral`) was updated to use a persistent `StepWalker` similarly: it tracks `self.step_walker` and `self.next_point`, calls `walk_to_next_point()` to set up a walker from the current position to the next spiral point, logs the planned movement and distance, then calls `step()` until that segment is completed. When `step()` returns `True`, it sets `self.step_walker = None` and advances the spiral pointer.\n- Bot initialization refactored navigator setup into a dedicated `_setup_navigator()` method, which instantiates `SpiralNavigator` or `PathNavigator` based on config.\n- The old `random_lat_long_delta()` was removed from `human_behaviour.py` and replaced conceptually with the more controlled `jitter`-based adjustment.\n\nAfter these changes, walking behavior became smooth and consistent with the configured speed. Users reported a significant increase in effective experience per hour and reliable travel between forts and along spiral paths, resolving the earlier issues with the bot staying in place or moving unpredictably.",
        "semantic_memory": "This fix illustrates several generalizable patterns for time-based movement and simulation in systems where update intervals are irregular:\n\n1. **Treat speed as units per time, not units per tick**:\n   If you configure a 'speed' value (e.g., `walk`, `velocity`), it should represent a real physical unit (e.g., meters/second), not a per-tick step size. Since ticks or update loops often run at variable rates due to workload, relying on a 'per tick' distance leads to inconsistent and misleading speeds. The fix here corrects this by interpreting `speed` as m/s and scaling movement by the elapsed real time (`delta_t`) between updates.\n\n2. **Always factor in elapsed time (delta time) for state updates**:\n   In any movement or simulation loop, you should compute `delta_t = now - last_time` and use `speed * delta_t` to derive how far something should move. This pattern decouples simulation correctness from the scheduling behavior of the main loop.\n\n3. **Recalculate direction vectors from the current state, not stale origin**:\n   When walking from point A to B with multiple intermediate steps, it's safer to compute direction or component vectors from the current position on each update rather than from the original starting position. This prevents accumulation of floating point errors, compensates for slight deviations, and ensures that corrections/teleports or jitter don't lead to stepping in the wrong direction or not moving at all.\n\n4. **Avoid re-instantiating stateful controllers each tick**:\n   Movement controllers like `StepWalker` maintain internal state (remaining distance, last time, completion status). Recreating these on each tick resets their state and often prevents progress, as seen in this case. The better pattern is to create a walker once for a given journey, call `step()` until completion, then discard or recycle the instance.\n\n5. **Snap to destination when within one step instead of overshooting**:\n   For movement with variable `delta_t`, the next computed step may be larger than the remaining distance. A robust algorithm checks `if remaining_distance <= speed * delta_t` and, in that case, moves directly to the target instead of overshooting. This prevents 'orbiting', 'bouncing', or moving off-map.\n\n6. **Limit randomness to controlled parameters rather than core state**:\n   Adding random noise directly to coordinates each step can cause erratic behavior and complicate correctness. It is usually better to randomize higher-level parameters (like effective speed or time) or apply small, bounded jitter before recalculating deterministic paths. The patch replaces random lat/lng offsets with a small jitter on the time scaling factor, retaining human-like variability without destabilizing pathfinding.\n\n7. **Use labels and invariants to guard stateful components**:\n   The updated `StepWalker` takes a `label` and throws an error if `step()` is called after completion. This pattern makes misuse visible and traceable via logs, helping catch lifecycle mismanagement (e.g., calling a finished walker) early.\n\n8. **Centralize setup logic and reuse navigators**:\n   Refactoring navigator setup into a dedicated method (`_setup_navigator`) reduces duplication and potential inconsistencies between startup code paths. Similar centralization and reuse of navigators and walkers simplifies reasoning about movement and makes future improvements less likely to break behavior.\n\nThese concepts apply broadly to game bots, simulations, physics engines, animations, and any system that moves entities over time in response to a loop that may not run at perfectly regular intervals.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar time-based movement issues:",
            "Step 1: Reproduce and characterize the movement problem.\n- Run the system with logging enabled around movement code.\n- Observe whether the entity:\n  - Moves much slower or faster than the configured speed.\n  - Appears stuck (no change in position), despite frequent movement calls.\n  - Moves erratically or overshoots destinations.\n- Collect specific examples: configured speed, start/end coordinates, timestamps, and actual movement.",
            "Step 2: Verify how 'speed' is interpreted in code.\n- Find where the speed parameter (e.g., `walk`, `velocity`) is used.\n- Check if it is treated as 'distance per tick' or as 'distance per second/time unit'.\n- Inspect whether the movement step computation is `position += speed` (per tick) or `position += speed * delta_t` (per time).\n- If speed is documented or expected to be in real units (e.g., km/h or m/s) but used as per-tick, plan to refactor to time-based usage.",
            "Step 3: Introduce and use delta time (`delta_t`).\n- Add a `last_time` field to the movement controller or entity.\n- On each update:\n  - Compute `now = time()` (or equivalent monotonic time function).\n  - If `last_time` is not `None`, compute `delta_t = now - last_time`; otherwise, default `delta_t` to a reasonable fallback (e.g., 1 second) for the very first step.\n  - Store `last_time = now` for the next iteration.\n- Replace any fixed step size with `distance_to_move = speed * delta_t`.\n- If needed, you can add slight jitter (e.g., `jitter(delta_t, delta_t * 0.03)`) to simulate human-like variability, but keep it bounded.",
            "Step 4: Recalculate direction from current position.\n- When moving from a current position `P` to a destination `D`, avoid basing steps only on the initial starting position.\n- At each step:\n  - Recompute `remaining_distance = distance(P, D)`.\n  - Compute `steps = remaining_distance / speed` if `speed > 0`.\n  - If `steps <= 1`, treat `dLat`/`dLng` as zero and allow a final snap.\n  - Otherwise compute `dLat = (D.lat - P.lat)/steps` and `dLng = (D.lng - P.lng)/steps`.\n- Update `P` by `P.lat += dLat * delta_t` and `P.lng += dLng * delta_t` (or equivalent vector math).\n- This ensures the path remains correct even if the position is perturbed by other logic.",
            "Step 5: Prevent overshooting the destination.\n- After computing `remaining_distance` and `distance_to_move = speed * delta_t` (possibly jittered):\n  - If `remaining_distance <= distance_to_move`, snap directly to the destination:\n    - Set the entity's position to `dest`.\n    - Mark the movement as complete (e.g., `self.complete = True`) and return success.\n  - Otherwise, move by the calculated step towards the destination.\n- This avoids infinite oscillation around the target or moving beyond world boundaries.",
            "Step 6: Manage the lifecycle of movement controllers.\n- If you have a helper class like `StepWalker`, do not reinstantiate it on every update/tick.\n- Instead:\n  - Create a controller when you start a journey from A to B.\n  - Store it on the owning object (e.g., `self.step_walker`).\n  - On each tick, call `step_walker.step()` until it returns `True`.\n  - Once complete, set the reference to `None` and optionally create a new one for the next segment.\n- Consider adding:\n  - A `complete` flag and an exception or log if `step()` is invoked after completion.\n  - A `label` or identifier for logging and debugging different usages (e.g., 'FortWalker', 'SpiralNavigator').",
            "Step 7: Keep randomness controlled and separate from core movement math.\n- Avoid adding random deltas directly to positions every frame, especially if they can be significant relative to the step size.\n- Instead, introduce randomness by:\n  - Jittering the effective time step or speed slightly.\n  - Occasionally perturbing the target or path within safe boundaries.\n- Recalculate direction vectors after applying randomness to avoid drifting away from the intended path.",
            "Step 8: Ensure navigation code respects movement controller state.\n- For higher-level navigators (e.g., 'move to fort', 'spiral walk'):\n  - Cache the current target (e.g., nearest fort or next spiral point).\n  - Create and reuse a movement controller for that target.\n  - After arrival, update the target and recreate the controller.\n- Log:\n  - Current position.\n  - Destination.\n  - Remaining distance.\n  - Effective speed and time delta.\n- Use these logs to verify that movement is smooth and consistent with configured speed.",
            "Step 9: Refactor and centralize setup for navigators/controllers.\n- Move navigator initialization logic into clearly named methods (e.g., `_setup_navigator`) instead of scattering it in `start()` or other unrelated places.\n- Ensure that configuration is used consistently (e.g., always using `bot.config.walk` and `bot.config.distance_unit` instead of mixing `self.config` vs `bot.config`).\n- This reduces the chance of misconfiguration causing subtle movement bugs.",
            "Step 10: Test and validate behavior after changes.\n- Run the system and measure:\n  - Actual distance covered per unit time vs configured speed.\n  - Behavior when CPU load or work per tick increases.\n  - Behavior when targets are very close or very far.\n- Confirm the entity:\n  - Reaches its destinations.\n  - Does not overshoot or oscillate.\n  - Moves at a realistic, consistent speed even if tick intervals vary.\n- Add assertions or automated tests where possible to prevent regressions."
        ]
    }
}
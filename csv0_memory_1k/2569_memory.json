{
    "search_index": {
        "description_for_embedding": "Fixes Optuna's Plotly contour visualization where parameters suggested via categorical distributions but containing only numeric values (ints/floats) were treated as categorical. This caused axes to be typed as category and sorted lexicographically as strings. The fix introduces an `_is_numerical` helper that classifies parameters based on observed trial values, treating all-int/float (non-bool) parameters as numerical, adjusts padding logic, and only casts values to strings or marks axes as category when the data is truly non-numeric.",
        "keywords": [
            "optuna",
            "visualization",
            "plot_contour",
            "contour plot",
            "plotly",
            "categorical",
            "numeric-only categorical",
            "axis sorting",
            "axis type category",
            "string casting",
            "_is_categorical",
            "_is_numerical",
            "parameter type detection",
            "padding logic",
            "visualization bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In Optuna's Plotly-based `visualization.plot_contour`, a user reported that when a parameter was defined with `suggest_categorical` but all choices were integers (e.g., `list(range(-10, 10))`), the axis for that parameter was treated as categorical. Internally, `_get_param_values` converted categorical values to strings and the axis was set to `type='category'`. Plotly then used categorical indices, which led to lexicographical ordering and non-numeric treatment of an actually numeric axis, making the visualization misleading.\n\nThe root cause was that the visualization logic only had `_is_categorical(trials, param)` and used it to decide casting to string, axis type, range calculation, and padding. It did not distinguish between categorical distributions whose values are numeric vs truly non-numeric categories. As a result, numeric-only categorical parameters were always treated as categorical.\n\nThe fix added a new helper `_is_numerical(trials, param)` in `optuna/visualization/_utils.py`, which returns `True` when all observed values for a parameter across trials are ints or floats but not bools. The contour plotting code in `optuna/visualization/_contour.py` was updated to rely on `_is_numerical` instead of `_is_categorical` for several decisions:\n- `_get_param_values` now returns raw values when `_is_numerical` is `True`, and only casts values to strings otherwise.\n- Axis ranges and padding in `_get_contour_plot` now treat log-scale parameters first, then apply numeric padding if `_is_numerical` is `True`, and only fall back to the categorical range/index-based logic for non-numeric parameters (which also handles Plotly's categorical indexing behavior).\n- Axis types are now set to `type='category'` only when `_is_numerical` is `False`.\n- In `_generate_contour_subplot`, padding via extending `x_indices`/`y_indices` with the numeric min and max is only applied for numerical parameters. Casting to string for indexing is applied only for non-numeric parameters.\n\nA unit test `test_plot_contour_mixture_category_types` was updated to reflect the new behavior: for parameters where all observed values are numeric, the y-axis range is now a numeric padded range (e.g., `(100.95, 102.05)`) and `yaxis.type` is no longer `'category'`, while parameters with mixed numeric and non-numeric values (e.g., `100` and `'None'`) remain categorical. This ensures numeric-only categorical parameters are visualized with properly ordered numeric axes and appropriate padding.",
        "semantic_memory": "Generalizable knowledge from this fix:\n\n1. **Classify data by observed values, not just by declared distribution type.**\n   A parameter might be defined as \"categorical\" in a modeling/optimization library but still represent a numeric domain (e.g., a list of ints or floats). For visualization and analytics, treating such parameters as numeric can produce more meaningful plots (e.g., numeric axes, proper ordering, numeric interpolation), as opposed to categorical/string semantics.\n\n2. **Heuristic numeric detection should exclude booleans.**\n   In Python, `bool` is a subclass of `int`, so naive `isinstance(x, int)` checks can misclassify boolean parameters as numeric. Robust numeric detection should ensure values are `int` or `float` **and not** `bool`.\n\n3. **Visualization semantics depend heavily on axis typing.**\n   Plotly (and other plotting libraries) behave quite differently depending on whether an axis is numeric or categorical. For contour plots especially, Plotly 4.12+ uses categorical indices rather than actual values, which affects range and padding. Correctly typing axes (numeric vs categorical) is crucial to get both correct geometry and sensible tick labels.\n\n4. **Range and padding logic must match axis semantics.**\n   Numeric axes typically need continuous padding around min and max; categorical axes often need padding on index space (e.g., [-padding, n-1+padding]) or no padding at all. Using the wrong padding strategy for a given axis type can cause misleading visual spacing or clipped data.\n\n5. **Type conversions in visualization code can have hidden side effects.**\n   Converting values to strings for categorical handling simplifies label rendering but also loses numeric ordering and can change how the plotting library interprets the axis. Such conversions should be conditional and conservative.\n\n6. **Tests should cover mixed-type and edge cases.**\n   The updated test uses a mixture of numeric and string values to ensure the type detection function differentiates between truly categorical (mixed or non-numeric) and purely numeric parameters. This pattern can be reused whenever logic depends on runtime type classification.\n\n7. **Library-specific quirks should be encapsulated.**\n   The code explicitly works around Plotly's behavior for categorical contour plots by adjusting ranges based on cardinality. Encoding such behavior into clearly separated branches (numeric vs categorical) keeps the logic maintainable and easier to reason about.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the visualization behavior.\n- Create a minimal example where a parameter is defined as categorical but uses only numeric values (e.g., ints or floats) and is involved in a visualization (e.g., contour, scatter, heatmap).\n- Generate the plot and inspect:\n  - Axis ordering (is it numeric or lexicographic?),\n  - Axis type in the plotting library (e.g., Plotly's `axis.type`),\n  - How padding and ranges are computed.",
            "Step 2: Identify how the library determines parameter/axis types.\n- Locate helper functions that classify parameters or axes, such as `_is_categorical`, `_is_numerical`, or similar.\n- Look for logic that converts values to strings or explicitly sets axis type to `category` or `linear`.\n- Confirm whether the classification is based on distribution metadata, value types, or both.",
            "Step 3: Design a robust numeric detection function.\n- Implement a helper (e.g., `_is_numerical(trials, param)`) that scans observed values across data points and returns `True` if **all** values are numeric:\n  - `isinstance(v, (int, float))` and **not** `isinstance(v, bool)`.\n- Ensure the function only considers trials that actually contain the parameter (skip missing).\n- Keep in mind that mixed-type parameters (e.g., `100` and `'None'`) should be treated as non-numeric.",
            "Step 4: Update visualization logic to use numeric detection appropriately.\n- Replace broad \"categorical\" checks with more precise numeric checks where needed:\n  - When deciding whether to cast values to strings, cast only if the parameter is **not** numeric.\n  - When computing axis ranges and padding:\n    - For log-scale parameters, use multiplicative/log-based padding.\n    - For numeric (non-log) parameters, compute linear padding around min and max.\n    - For non-numeric parameters, use categorical index-based ranges or appropriate discrete handling.\n  - When setting axis types in the plotting library:\n    - Use `type='category'` only for non-numeric parameters.\n    - Leave numeric parameters as the default numeric type.",
            "Step 5: Adjust subplot/grid preparation logic.\n- If you pad indices or extend coordinate arrays for numeric axes (e.g., adding min/max guard values around data), ensure this only happens for numeric parameters.\n- Where values are used as keys or indices, convert to strings only for non-numeric parameters so that numeric parameters maintain numeric semantics.",
            "Step 6: Add or update tests to lock in behavior.\n- Create tests that cover:\n  - Purely numeric categorical parameters (should be treated as numeric axes).\n  - Mixed-type categorical parameters (should remain categorical).\n  - Interactions with library versions (e.g., Plotly version differences) if behavior depends on them.\n- Assert:\n  - Axis ranges and padding are numeric for numeric-only parameters.\n  - Axis types are not `'category'` for numeric-only parameters.\n  - Axis types remain `'category'` for mixed or non-numeric parameters.",
            "Step 7: Verify with real plots and regression examples.\n- Re-run the original user scenario and visually inspect the contour plot or other visualizations.\n- Confirm that numeric-only categorical parameters:\n  - Have correctly ordered numeric axes,\n  - Use appropriate padding,\n  - Do not suffer from categorical index quirks of the plotting library.\n- Check that truly categorical parameters are unaffected and still behave correctly.",
            "Step 8: Document the behavior.\n- Optionally note in developer docs or comments that even for categorical distributions, parameters with purely numeric values are treated as numeric for visualization purposes.\n- Mention any library-specific reasoning (e.g., Plotly's categorical indexing behavior) so future maintainers understand why the distinction exists."
        ]
    }
}
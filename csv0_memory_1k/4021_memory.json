{
    "search_index": {
        "description_for_embedding": "Fix for napari view_* helpers where Dims-related kwargs (e.g. ndisplay) were incorrectly applied to the Viewer before any layers were added. The change separates Dims parameters from other Viewer kwargs, creates the Viewer with only non-dims args, adds the layer, and then applies dims attributes to viewer.dims. This ensures dimension state is set after data loading, preventing inconsistent dimension handling when using view_* functions.",
        "keywords": [
            "napari",
            "view_layers",
            "view_* functions",
            "Viewer",
            "Dims",
            "dims kwargs",
            "ndisplay",
            "viewer initialization order",
            "layer creation",
            "post-init configuration",
            "bug fix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this napari PR, the issue was that Dims-related keyword arguments passed into the high-level view_* convenience functions (e.g. view_image, view_labels) were being forwarded directly to the Viewer constructor. The Viewer was thus created with Dims parameters (like ndisplay) before any data layers were added. Since the Viewer and its Dims object configure their state based on the data that becomes available when layers are added, applying Dims configuration too early could lead to incorrect or unstable dimension state.\n\nThe relevant code path was the helper _make_viewer_then(add_method, args, kwargs). It built vkwargs from the incoming kwargs by taking those that matched the Viewer signature and then constructed Viewer(**vkwargs). This implicitly included any Dims parameters that happen to be in the Viewer signature. After constructing the Viewer, it called the appropriate add_* method to add the data.\n\nThe fix separates Dims-related kwargs from other viewer kwargs. The signature of Dims is inspected and stored in _dims_params. In _make_viewer_then, vkwargs is first built from kwargs that match Viewer parameters. Then dims_kwargs is extracted by popping from vkwargs any keys that are also in _dims_params. The Viewer is created with the remaining vkwargs (non-dims parameters only). After the layer is added via method(*args, **kwargs), the Dims parameters are applied by iterating over dims_kwargs and calling setattr(viewer.dims, arg_name, arg_val) for each. This ensures Dims properties are set only after data is present.\n\nA unit test was updated to reflect this behavior change. Previously, the test expected the viewer mock to be called with title='my viewer', ndisplay=3. After the change, it now expects the Viewer to be called only with title='my viewer', confirming that ndisplay is no longer passed at construction time and instead is applied later to viewer.dims. This addresses the linked issue #3344 about only setting Dims attributes on the Viewer after data has been loaded via view_* methods.",
        "semantic_memory": "This fix illustrates a common pattern in UI and stateful object design: configuration that depends on data should often be applied after the data is loaded, not at initial construction time. Especially in frameworks where a 'dimension' or 'view' subsystem (like napari's Dims) reacts to the currently loaded data, setting those parameters before the data exists can produce inconsistent or misleading state.\n\nA key lesson is to distinguish between constructor arguments that are pure viewer-level configuration (e.g., window title) and those that are logically properties of a subordinate component whose correct values depend on the presence and shape of data (e.g., Dims configuration). For the latter, a post-init configuration step—after the object has access to the relevant data—is safer and more predictable.\n\nAnother generalizable technique is using introspection (inspect.signature) to discover which kwargs belong to which object or subsystem (Viewer vs Dims). This allows generic helper functions to correctly route configuration parameters without hardcoding lists of names, making the approach more robust to future changes in the underlying API.\n\nFinally, when refactoring such initialization flows, tests should be updated not just to validate final state but also to verify call order and arguments, ensuring that side-effectful configuration happens at the correct time in the lifecycle.",
        "procedural_memory": [
            "When facing issues where configuration parameters appear to be applied at the wrong time in a UI or viewer lifecycle, examine the initialization sequence carefully.",
            "Step 1: Identify symptoms and scope. Look at bug reports or failing tests that indicate incorrect state after using high-level convenience functions (e.g., view_* methods). Check whether properties that depend on data (like dimension settings) are incorrect immediately after creation.",
            "Step 2: Trace the call path. Locate the helper or wrapper functions that construct the main object (Viewer) and then add data or layers. In this case, that was _make_viewer_then(add_method, args, kwargs) in view_layers.py.",
            "Step 3: Determine which kwargs belong to which subsystem. Inspect the signatures of the constructor (Viewer) and any subordinate stateful components (Dims) using inspect.signature, or read their APIs to decide which arguments configure what.",
            "Step 4: Separate time-sensitive or data-dependent kwargs. Extract arguments that configure the data-dependent subsystem (Dims) from the general constructor kwargs before instantiation. Keep them in a separate dict (e.g., dims_kwargs).",
            "Step 5: Instantiate with only safe kwargs. Call the main constructor (Viewer(**vkwargs)) with only the non-data-dependent parameters (window title, theme, etc.). Avoid passing Dims-related kwargs at this stage.",
            "Step 6: Load data or add layers. Use the appropriate add_* method (e.g., viewer.add_image, viewer.open) to add the data that the dependent subsystem will inspect to configure itself.",
            "Step 7: Apply deferred configuration. After the data is loaded and layers exist, iterate through the deferred Dims-related kwargs and apply them directly to the corresponding component, e.g., setattr(viewer.dims, name, value). This guarantees that Dims state is set with full knowledge of the current data.",
            "Step 8: Update or add tests. Modify existing tests to reflect the new call patterns. For example, assert that the Viewer constructor is called without Dims kwargs and that those kwargs are instead applied later. Where necessary, also assert the final Dims state to ensure correctness.",
            "Step 9: Run the full test suite and any relevant UI smoke tests to confirm that other initialization paths (e.g., directly constructing Viewer) are unaffected and that behavior is consistent.",
            "Step 10: Document the lifecycle expectations. Note in developer documentation or comments that certain configuration parameters (like dims settings) are intentionally applied post-layer-addition to avoid subtle bugs and to keep behavior consistent across different entry points."
        ]
    }
}
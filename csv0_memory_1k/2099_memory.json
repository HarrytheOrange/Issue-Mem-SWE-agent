{
    "search_index": {
        "description_for_embedding": "Bug fix in napari plugin widget registration: the validation of magicgui keyword arguments was too strict and rejected kwargs intended for the decorated function's parameters, causing valid plugin dock/function widgets to be ignored. The fix expands the allowed magicgui kwargs to include both magicgui's keyword-only parameters and the decorated function's parameters, and improves the warning message.",
        "keywords": [
            "napari",
            "plugin widgets",
            "magicgui",
            "kwargs validation",
            "register_function_widget",
            "decorated function parameters",
            "inspect.signature",
            "overly strict validation",
            "plugin registration warning"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari's plugin system was rejecting valid magicgui keyword arguments when registering function widgets. The `register_function_widget` helper validated plugin-provided `magic_kwargs` against a global set of parameters derived solely from `magicgui`'s signature: `valid_magic_kwargs = set(signature(magicgui).parameters)`. However, plugins often pass configuration for individual function parameters (e.g., `{\"x\": {\"max\": 200}}`), which are **not** names in the magicgui function signature but are instead names of the decorated function's parameters. Because the validation only considered magicgui's parameters, these legitimate kwargs were flagged as invalid, and the corresponding widgets were ignored, with a generic warning. The fix restructures the validation. First, it defines `magicgui_sig` as the set of keyword-only parameters on `magicgui` itself, ensuring we only treat true magicgui configuration options as such. Then, inside `register_function_widget`, it recomputes `valid_magic_kwargs` per function as the union of the decorated function's parameter names and `magicgui_sig`: `valid_magic_kwargs = set(signature(func).parameters) | magicgui_sig`. Any `magic_kwargs` keys not in this union are considered invalid. The warning now reports the specific invalid keys and the full set of valid keys, making debugging easier: `f'{extra_kwargs}. Valid kwargs are {valid_magic_kwargs}. Widget ignored.'`. A new test case `good_magic_kwargs` was added to `napari/plugins/_tests/test_plugin_widgets.py` to ensure that a plugin entry with both a magicgui kwarg (`call_button`) and a parameter-specific config (`\"x\": {\"max\": 200}`) is accepted and no longer treated as invalid. The release notes were also updated to mention this fix as 'Fix overly strict magic kwargs (#2099)'.",
        "semantic_memory": "When building helper APIs or decorators that wrap another callable, kwargs validation must reflect **all** destinations the kwargs can be forwarded to. In this case, a wrapper (`magicgui`) accepts configuration both for its own keyword-only parameters (e.g., widget-level options) and for the parameters of the function it decorates (e.g., per-argument widget options). Validating plugin-provided kwargs only against the wrapper's signature is overly restrictive and will reject legitimate configuration aimed at the wrapped function's parameters. A better pattern is to derive the valid kwarg set as the union of: (1) the wrapper's explicit configuration parameters (often keyword-only), and (2) the wrapped function's parameter names, when the wrapper is known to interpret those names specially. This can be done with `inspect.signature` on both callables. Another generalizable lesson is that static validation used to prevent runtime crashes should be conservative enough not to block valid use cases; if multiple destinations can receive kwargs, validation must model that behavior accurately. Finally, error and warning messages should report both what was invalid and what is allowed; this makes it much easier for users (or plugin authors) to correct their code without digging into library internals.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify where kwargs are validated or filtered in your wrapper/decorator. Look for code that compares provided kwargs against a single function signature (e.g., `set(kwargs) - set(signature(wrapper).parameters)`).",
            "Step 2: Confirm the actual runtime behavior of the wrapper. Determine whether it forwards kwargs to another callable (the wrapped function) or uses special kwargs keyed by the wrapped function's parameter names (e.g., per-parameter configuration).",
            "Step 3: Use `inspect.signature` on both the wrapper and the wrapped function(s). For the wrapper, focus on keyword-only parameters when they represent special configuration options. For the wrapped function, collect its parameter names that are expected to appear in kwargs (e.g., argument names used for configuration).",
            "Step 4: Define the set of valid kwargs as the union of all relevant destinations. For example: `wrapper_cfg = {name for name, p in signature(wrapper).parameters.items() if p.kind is p.KEYWORD_ONLY}` and then `valid_kwargs = set(signature(target_func).parameters) | wrapper_cfg`.",
            "Step 5: Compute invalid/extra kwargs as `extra_kwargs = set(user_kwargs) - valid_kwargs`. If this set is non-empty, emit a clear warning or error that includes both the invalid keys and the list of valid keys to guide users.",
            "Step 6: Ensure that your validation is performed per target function, not just once globally, if the set of valid parameter names changes across functions (as in plugin systems where each plugin function has its own signature).",
            "Step 7: Add tests that cover both invalid and valid cases. Include cases where kwargs are aimed at wrapper-level configuration and cases aimed at the wrapped function's parameters, ensuring both are accepted as appropriate.",
            "Step 8: Update documentation or release notes to explain the behavior of configuration kwargs, how they are validated, and what names are expected (wrapper config options vs. function parameter-based config).",
            "Step 9: When changing validation rules, verify that error/warning messages remain informative and do not leak unnecessary internal details, but do provide enough context (invalid vs. valid keys) for plugin authors or users to correct their code."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Implementation of a new Home Assistant integration for Honeywell Lyric thermostats, including a base 'lyric' component with OAuth configuration and a 'climate.lyric' platform. The change wires in the python-lyric library, uses the configurator and HTTP views for OAuth, exposes away-mode and schedule-based behavior, adds a resume_program service, and updates to use hass.components.configurator instead of get_component.",
        "keywords": [
            "Home Assistant",
            "Honeywell Lyric",
            "climate.lyric",
            "lyric component",
            "python-lyric",
            "OAuth",
            "configurator",
            "HomeAssistantView",
            "away mode",
            "schedule periods",
            "fan mode",
            "service lyric_resume_program",
            "hass.data",
            "discovery.load_platform",
            "dependency version bump"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduces first-class support for Honeywell Lyric thermostats into Home Assistant by adding a new 'lyric' component and a 'climate.lyric' platform. The 'lyric' component is responsible for OAuth authentication with Honeywell's cloud API using the external 'python-lyric' library. It defines configuration schema options such as client_id, client_secret, optional redirect_uri, scan_interval, a list of locations to include, a fan support flag, and away periods tied to schedule periods. The component uses Home Assistant's configurator and an HTTP view (LyricAuthenticateView) to complete the OAuth flow: the configurator presents a 'Request Authorization' link to the Lyric authorize URL, the user logs in, Lyric redirects back to /api/lyric/authenticate with code and state, and the component exchanges that for tokens and persists them in lyric.conf. Once authorized, the component builds a LyricDevice wrapper around the python-lyric client, exposes selected locations and devices, stores it in hass.data['lyric'], and uses discovery.load_platform to automatically set up the climate platform.\n\nThe 'climate.lyric' platform uses the shared LyricDevice object from hass.data to discover thermostats. Each thermostat is wrapped in a LyricThermostat ClimateDevice that exposes current temperature, humidity, heating/cooling state, operation modes (heat, cool, auto, off), fan modes (if supported by the physical device), hold modes, and dual-setpoint support (separate heat and cool setpoints in auto/heat-cool mode). The implementation carefully handles devices that can only heat, only cool, or both, and maps Lyric's 'heat-cool' mode to Home Assistant's STATE_AUTO. Away mode is computed either from the device's 'away' field or inferred from schedule periods configured as away periods, with an 'away_override' flag that allows manual overrides via turn_away_mode_on/off while broadcasting override events on the HA event bus.\n\nA custom service 'lyric_resume_program' is added under the climate domain (documented in climate/services.yaml). This service selects target thermostats by entity_id and calls set_hold_mode('NoHold') and clears the away_override flag, effectively returning the device to its programmed schedule and normal away behavior. Internally, the climate entity uses update() to pull state from python-lyric: operation mode, setpoints, dualSetpoint capability, fan mode, min/max temperatures, schedule type and current schedule period, and temperature units (mapped to TEMP_CELSIUS or TEMP_FAHRENHEIT). Over several small commits, the dependency on python-lyric is bumped from version 1.0.0 up to 1.1.4 as the external library evolved. Finally, after a Home Assistant API change, the component is updated to use hass.components.configurator instead of the deprecated get_component('configurator') and to adapt the configurator.request_config call signature, ensuring compatibility with the latest HA version.\n\nThe human discussion around the PR clarifies that the code actually belongs to another developer (@bramkragten) and that this PR was prematurely submitted by a user trying to get Lyric support working; the core team closes the PR so the original author can submit an official integration. Nevertheless, the code in this PR represents a complete implementation pattern for an OAuth-based third-party integration with a climate platform in Home Assistant.",
        "semantic_memory": "More generally, this change illustrates several reusable patterns for building and maintaining Home Assistant integrations with external cloud APIs:\n\n1. **Separation of concerns: base component vs. platforms** – A base component (here 'lyric') handles authentication, device discovery, and common configuration, while platform modules (here 'climate.lyric') focus on exposing specific domains (climate, sensors, etc.) using shared state stored in hass.data. This allows multiple Home Assistant platforms to reuse a single authenticated API client.\n\n2. **OAuth configuration with the configurator and HTTP views** – For integrations requiring an authorization code flow, it is standard to: (a) define client_id, client_secret, redirect_uri, and optional scan_interval in CONFIG_SCHEMA; (b) use the configurator (hass.components.configurator) to present a link to the provider's authorize URL; (c) implement a HomeAssistantView that listens for the redirect (e.g., /api/<integration>/authenticate), validates the presence of 'code' and 'state', then exchanges them for tokens; and (d) persist the token to a local cache file so that subsequent restarts can reuse it without re-authentication.\n\n3. **Using hass.data to share API clients and discovery.load_platform** – Integrations share state by placing wrapper objects or clients into hass.data[DOMAIN] so domain-specific platforms can retrieve them. They then use discovery.load_platform to dynamically load platforms like 'climate', passing along any configuration or flags needed (e.g., has_fan, away_periods).\n\n4. **Mapping device-specific modes to Home Assistant semantics** – External devices often have their own vocabulary for modes and settings (e.g., 'heat-cool' vs. 'auto', 'NoHold', dual setpoints). A robust integration defines translation layers: operation_list, current_operation, target_temperature vs. target_temperature_low/high, fan_list and current_fan_mode, and hold modes. For dual-setpoint thermostats, the integration must implement both single-setpoint and dual-setpoint code paths.\n\n5. **Handling away and schedule semantics cleanly** – Instead of exposing raw manufacturer fields verbatim, map 'away' behavior into HA's is_away_mode_on while considering both the device’s own away flag and schedule-derived away periods. Implement an 'override' concept (like away_override) when users manually change away mode, and use events or services (like lyric_resume_program) to reset override state and revert to the native schedule.\n\n6. **Adapting to framework API changes** – Frameworks like Home Assistant evolve, deprecating patterns like get_component(...) in favor of attributes like hass.components.<component>. Integrations must track these changes, updating their imports and call signatures (e.g., configurator.request_config no longer taking 'hass' as the first parameter) to remain compatible.\n\n7. **External dependency version management** – When wrapping a third-party library (python-lyric here), it's common to bump versions as bug fixes and features are needed. This should be reflected in the REQUIREMENTS list and coordinated with Home Assistant’s requirements_all generation scripts. Gradual, small bumps (1.0.0 → 1.1.4) help align the integration with upstream improvements while minimizing breakage.\n\nThese patterns apply not just to Lyric but to any OAuth-backed external service integration in Home Assistant or similar frameworks.",
        "procedural_memory": [
            "When implementing an OAuth-based third-party integration in Home Assistant with domain platforms (e.g., climate), follow these steps:",
            "Step 1: Design the base component’s configuration schema.\n- Define DOMAIN = '<integration_name>'.\n- Create CONFIG_SCHEMA using voluptuous, including client_id, client_secret, optional redirect_uri, scan_interval, and any integration-specific options (e.g., locations, feature flags, away periods).\n- Include DEPENDENCIES like ['http'] if you need HTTP views, and a REQUIREMENTS list for external libraries (e.g., 'python-lyric==<version>').",
            "Step 2: Implement the base component’s setup() and OAuth client.\n- Import the external library inside setup() to avoid import-time errors if the dependency is missing.\n- Instantiate the library’s client with the configured client_id, client_secret, redirect_uri, cache file path, and scan interval.\n- If necessary, construct redirect_uri using hass.config.api.base_url + '/api/<integration>/authenticate'.\n- Call a helper (e.g., setup_<integration>) responsible for handling authorization and discovery.",
            "Step 3: Implement configurator-based OAuth flow.\n- At module level, maintain a _CONFIGURING dict to track ongoing configuration.\n- Write a request_configuration(...) function:\n  - Access the configurator via hass.components.configurator (not get_component).\n  - If this integration is already in _CONFIGURING, call configurator.notify_errors(...) and return.\n  - Register a HomeAssistantView subclass on a unique path (e.g., /api/<integration>/authenticate) that will handle the OAuth redirect.\n  - Call configurator.request_config(\n      '<Friendly Name>',\n      callback_fn,\n      description='Instructions for the user',\n      link_name='Request Authorization',\n      link_url=<authorize URL from the library>,\n      submit_caption='Continue...'\n    ).\n  - Store the returned request id in _CONFIGURING[DOMAIN].",
            "Step 4: Implement the HTTP callback view for OAuth.\n- Subclass HomeAssistantView.\n- Set url, name, and requires_auth = False.\n- Implement async def get(self, request):\n  - Validate that 'code' and 'state' are present in request.GET; return HTTP_BAD_REQUEST if not.\n  - Call the external client’s method to exchange the authorization code for tokens (e.g., authorization_code(code=data['code'], state=data['state'])).\n  - Return a JSON message indicating success and instructing the user to close the window and press Continue in the configurator.",
            "Step 5: Finalize setup after authentication.\n- In the helper (e.g., setup_lyric), if the library’s token is not present yet, call request_configuration and return.\n- Once the token is present, if the integration is in _CONFIGURING, obtain configurator = hass.components.configurator and call configurator.request_done(...) to clear the pending configuration.\n- Wrap the authenticated library client in an internal class (e.g., LyricDevice) that provides convenient methods and filters (e.g., selecting locations by name). Store this wrapper in hass.data[DOMAIN] so platforms can access it.\n- Remove secrets like client_id and client_secret from the config dict before passing config to platforms.\n- Use discovery.load_platform(hass, '<domain>', DOMAIN, discovery_info, full_config) to initiate specific platforms (climate, sensor, etc.).",
            "Step 6: Implement a platform module using the shared client.\n- In homeassistant/components/<domain>/<integration>.py, declare DEPENDENCIES = ['<integration>'] so the base component loads first.\n- Define PLATFORM_SCHEMA as needed (e.g., to accept scan_interval overrides or additional flags). Typically extend the domain’s PLATFORM_SCHEMA.\n- In setup_platform(hass, config, add_devices, discovery_info=None):\n  - Return early if discovery_info is None, as the base component should provide discovery_info.\n  - Retrieve flags from discovery_info (e.g., fan support, away_periods).\n  - Access hass.data[DATA_<INTEGRATION>] to obtain the wrapper (e.g., LyricDevice).\n  - Iterate over devices (e.g., for location, device in hass.data[DATA_LYRIC].thermostats()): create entities (e.g., LyricThermostat) and call add_devices(entities, True).\n  - If needed, register services with hass.services.register, loading descriptions from a local services.yaml via load_yaml_config_file.",
            "Step 7: Map device capabilities and modes to Home Assistant.\n- In the entity class (e.g., LyricThermostat(ClimateDevice)):\n  - In __init__, build an operation_list based on device capabilities (can_heat, can_cool), mapping manufacturer modes (e.g., 'heat-cool') to Home Assistant constants (STATE_AUTO, STATE_HEAT, STATE_COOL, STATE_OFF).\n  - If the device supports a fan, populate fan_list from device settings.\n  - Track whether the device supports dual setpoints and expose target_temperature, target_temperature_low, and target_temperature_high appropriately.\n  - Implement temperature_unit based on the device’s units, mapping to TEMP_CELSIUS or TEMP_FAHRENHEIT.\n  - Provide min_temp and max_temp based on device-specific bounds.\n  - In set_operation_mode, convert Home Assistant operation_mode strings to the device’s expected values (e.g., 'heat-cool' with capitalization rules).\n  - In set_temperature, accept ATTR_TEMPERATURE for single setpoint or ATTR_TARGET_TEMP_LOW / ATTR_TARGET_TEMP_HIGH for dual setpoint devices and forward to the device client.",
            "Step 8: Implement away mode, schedules, and custom services.\n- For away behavior, maintain an internal flag (e.g., self.away_override) to represent manual overrides.\n- In is_away_mode_on:\n  - If away_override is True, return the overridden away state.\n  - Else, if scheduleType is 'Timed' and configured away_periods exist, infer away from the current schedule period.\n  - Otherwise, use the native device.away state.\n- Implement turn_away_mode_on/off to set self._away, set away_override = True, and optionally fire events on hass.bus (e.g., 'override_away_on', 'override_away_off') with the entity_id.\n- Implement a custom resume service (e.g., lyric_resume_program) that iterates over selected entities and calls set_hold_mode('NoHold') plus resets away_override to False, effectively resuming the native schedule.\n- Add an entry in services.yaml documenting the service and its fields.",
            "Step 9: Keep up with framework API changes.\n- Avoid using deprecated APIs like homeassistant.loader.get_component('configurator'); instead use hass.components.configurator.\n- Adjust to changes in configurator.request_config signature (e.g., removing the hass parameter if no longer required).\n- Regularly run tests and linting to catch signature mismatches or deprecation warnings when Home Assistant upgrades.",
            "Step 10: Manage external dependency versions carefully.\n- Pin to specific, tested versions in REQUIREMENTS (e.g., 'python-lyric==1.1.4').\n- When bumping versions, document why (bug fix, new feature, compatibility) and run integration tests.\n- After bumping, regenerate global requirements (e.g., via script/gen_requirements_all.py in HA) and ensure the new version is compatible across platforms."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Attempted addition of a Velbus climate (thermostat) platform to Home Assistant, including async platform setup via Velbus discovery, mapping Velbus thermostat methods to ClimateDevice properties, and updating the python-velbus dependency. The change was rejected because the climate platform did not follow Home Assistant’s climate entity specification for operation modes, highlighting the need for strict adherence to entity specs to avoid future breaking changes.",
        "keywords": [
            "Home Assistant",
            "climate.velbus",
            "Velbus thermostat",
            "ClimateDevice",
            "operation modes",
            "entity specification",
            "SUPPORTED_FEATURES",
            "SUPPORT_TARGET_TEMPERATURE",
            "SUPPORT_OPERATION_MODE",
            "async_setup_platform",
            "platform discovery",
            "python-velbus",
            "dependency version mismatch",
            "integration design error",
            "API contract compliance"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, a developer attempted to add climate (thermostat) support for Velbus to Home Assistant. They implemented a new platform `homeassistant/components/climate/velbus.py` and wired it into the existing Velbus component. The new `VelbusClimate` class extended `VelbusEntity` and `ClimateDevice`, exposing supported features (`SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE`), current and target temperature, and a custom `operation_list` of `['comfort', 'day', 'night', 'safe']`. The platform used `async_setup_platform` to consume devices discovered by the Velbus component (`hass.data[VELBUS_DOMAIN]`) and dynamically add entities. Alongside this, the PR bumped the python-velbus dependency from `2.0.20` to `2.0.21` both in `requirements_all.txt` and in the Velbus component’s `REQUIREMENTS` constant.\n\nDuring review, maintainers pointed out that the new climate platform did not comply with the Home Assistant climate entity specification, specifically around operation modes. The integration exposed custom mode strings instead of using the standardized operation modes expected by Home Assistant’s climate API. This non-compliance implied a future breaking change would be required to bring it in line with the spec. To avoid merging something that would later have to be changed incompatibly for users, the maintainer decided to remove this platform from the PR and indicated it could be resubmitted after aligning with the climate entity specification.\n\nThe PR also contained minor code-quality fixes (reordering imports, docstring corrections, linter-related edits) but the core issue remained conceptual: the API contract for a climate entity was not correctly followed. The end result is that Velbus climate support was not merged in its current form; instead, the lesson was highlighted that new platforms must strictly follow the entity specifications (operation modes, supported features, and behavior) to be accepted.",
        "semantic_memory": "This incident illustrates a few generalizable principles for building integrations in a large, API-driven home automation framework like Home Assistant:\n\n1. **Strict adherence to entity specifications is mandatory**: Each entity type (e.g., climate, light, switch) has a defined API surface and semantics: required/optional properties, standardized modes or states, and feature flags. Deviating from these—such as exposing custom operation modes (`'comfort', 'day', 'night', 'safe'`) instead of the framework’s standardized climate modes—introduces hidden technical debt. It will either break the UI/automations or force a breaking change later, which maintainers want to avoid.\n\n2. **Standardized enumerations vs. device-specific modes**: When a device has its own terminology (e.g., Velbus comfort/day/night/safe), those must be mapped onto the platform’s standardized enumerations (e.g., HEAT, AUTO, ECO, OFF) or exposed via a secondary mechanism (like presets) that’s allowed by the spec. Exposing device-specific enums in primary API fields breaks the contract with the rest of the system and user-facing tools.\n\n3. **FEATURE flags must match behavior**: `supported_features` like `SUPPORT_TARGET_TEMPERATURE` and `SUPPORT_OPERATION_MODE` should reflect real device capabilities and be compatible with how the front-end and automations use them. If you claim `SUPPORT_OPERATION_MODE`, the set of modes must match the spec expectations.\n\n4. **Keep dependency versions consistent across the codebase**: When updating a dependency for a component (e.g., `python-velbus`), it must be updated in both the component’s `REQUIREMENTS` and global `requirements_all.txt` (or equivalent aggregation). Mismatches lead to installation, CI, or runtime inconsistencies.\n\n5. **Discovery-driven platform setup**: A parent integration can maintain internal representations (modules) and use discovery to instantiate platform-specific entities (switch, climate, sensor, etc.). The pattern is: controller finds modules, classifies them, populates `discovery_info` for each platform, then `load_platform` triggers `async_setup_platform` in each platform module, which then wraps the underlying modules into entities.\n\n6. **Merge policy: avoid future breaking changes**: Core maintainers will reject or back out features that are known to be non-compliant with the core API even if they “work” in the short term, because accepting them entrenches a broken contract. The cost of fixing later (breaking users’ configurations and automations) is higher than rejecting early.\n\nThese points apply generally to any extensible framework with plugin-style components. When contributing new plugins, developers must not only get the code working but also conform to the framework’s semantic contracts and standardized behavior to ensure long-term stability.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Review the entity specification for the target integration type.\nBefore implementing or reviewing a new platform (e.g., climate, light, etc.), read the framework’s official entity spec. For Home Assistant, consult the developer docs for that entity (e.g., climate entity) and note: required properties, supported_operations list, valid enums, required methods, and how feature flags are supposed to be used.",
            "Step 2: Inventory device capabilities and terminology.\nList the device’s native capabilities: supported modes, temperature ranges, fan settings, presets, etc. Note the device’s terminology (e.g., comfort/day/night/safe) and how it maps conceptually to the standardized concepts in the framework (e.g., heat/auto/eco/off).",
            "Step 3: Design a mapping from device-specific states to standard enums.\nCreate an explicit mapping (e.g., a dict) between the device’s native modes and the platform’s standard modes or presets. If the framework has separate concepts for operation_mode vs. preset_mode, decide which device concepts belong where. Do not expose custom strings in fields that are supposed to carry standardized values.",
            "Step 4: Implement the entity class strictly according to the spec.\nImplement all required properties and methods (`current_temperature`, `target_temperature`, `current_operation` / `hvac_mode`, `operation_list` / `hvac_modes`, etc.) using the mapping designed in Step 3. Ensure `supported_features` only includes flags for features that are both available on the device and correctly implemented in your entity class.",
            "Step 5: Align dependency declarations across the project.\nIf your integration depends on or updates a Python package (e.g., `python-velbus`), update all relevant places: the component’s `REQUIREMENTS` and any global requirement aggregation files (`requirements_all.txt` or equivalents). Run the project’s requirement generation scripts if they exist (e.g., `script/gen_requirements_all.py` in Home Assistant).",
            "Step 6: Wire the platform into discovery correctly.\nIf your integration uses discovery, ensure the parent component populates `discovery_info` lists for each platform type and calls `load_platform(...)` appropriately. In your platform’s `async_setup_platform`, validate `discovery_info`, fetch the underlying module/device object from shared data (e.g., `hass.data[DOMAIN]`), instantiate the entity class, and pass it to `async_add_entities`.",
            "Step 7: Run tests and validate UI/automation behavior.\nRun the project’s test suite (e.g., `tox`) and verify that the climate (or relevant) UI behaves as expected: operation modes appear correctly, setting modes/temperatures works, and automations can reference the entity’s properties. Check that no warnings or errors indicate unsupported or unknown modes.",
            "Step 8: Review for future compatibility and breaking changes.\nBefore submitting the PR, mentally check: if the project later enforces stricter validation of modes or features, will this integration break? If you are using non-standard values anywhere, refactor to align with the spec now. Document any unavoidable deviations and propose them for review explicitly.",
            "Step 9: Respond to reviewer feedback about spec compliance.\nIf maintainers flag that your integration doesn’t follow the spec (e.g., non-standard operation modes), adjust your mapping and API usage accordingly instead of arguing that the device behaves differently. The goal is to be consistent with the platform so that all integrations behave predictably.",
            "Step 10: Only merge when the integration is spec-compliant.\nIf there remains a known spec violation (like custom operation mode strings), do not proceed with merging. Either redesign the integration to comply or defer/close the PR until a compliant design is ready, to avoid introducing future breaking changes for users."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Linky sensor was failing with a login error due to how the pylinky client session was handled. The fix updates pylinky to 0.1.8, reuses a single LinkyClient session across sensor updates, validates credentials during setup_platform, and improves error handling and session closing on failure. This ensures reliable authentication and data retrieval from the Linky API.",
        "keywords": [
            "homeassistant",
            "Home Assistant",
            "sensor.linky",
            "Linky",
            "pylinky",
            "pylinky==0.1.8",
            "login error",
            "authentication failure",
            "client session reuse",
            "requests session",
            "timeout parameter",
            "setup_platform validation",
            "PyLinkyError",
            "close_session",
            "integration bugfix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The Home Assistant Linky sensor integration was failing to log in to the Linky/Enedis service, showing a login error. The original implementation created a LinkyClient in setup_platform, stored it on the sensor, and repeatedly called fetch_data on it, with pylinky pinned at version 0.1.6. Users reported that authentication would fail, likely due to how sessions, cookies, and redirects were handled by the older pylinky and the integration's session lifecycle.\n\nFirst, a refactor created a new LinkyClient in each update() call and closed its session after each use. This made the component more fail-safe but didn’t solve the core issue, especially as the Linky website flows changed and pylinky evolved.\n\nThe final fix came in two parts:\n1. **Update dependency**: REQUIREMENTS and requirements_all.txt were updated from pylinky==0.1.6 to pylinky==0.1.8, which introduced support for reusing a client session in pylinky itself.\n2. **Reuse a single client session and validate early**:\n   - In setup_platform, a LinkyClient is now created with username, password, and timeout, and fetch_data() is called immediately. If authentication or the request fails, a PyLinkyError is caught, logged, the client session is closed, and platform setup aborts, preventing a broken sensor from loading.\n   - On success, the client is **not** closed and is passed directly to the LinkySensor, which stores the client instance rather than plain credentials/timeouts.\n   - LinkySensor.update() calls self._client.fetch_data(). If this fails, the error is logged and the client session is explicitly closed before returning. On success, it uses self._client.get_data() to read the latest data, logs the full JSON for debugging, and sets the sensor state to the previous day's consumption (['daily'][-2]['conso]) if data is present.\n   - Unused imports (LinkyClient inside update) were removed once the client was managed at the sensor level.\n\nThis combination of updating pylinky and reusing a persistent LinkyClient session fixed the login errors and made the platform more robust by validating credentials during platform setup and managing session lifecycles explicitly.",
        "semantic_memory": "Generalizable knowledge from this fix:\n\n1. **Session management with HTTP APIs matters**\n   - Many authentication flows (with redirects and cookies) require a persistent HTTP session. Creating a new client or session for each call can break login flows or cause rate limiting, especially when cookies like iPlanetDirectoryPro or similar are involved.\n   - When a third-party client library introduces proper session reuse, integrations should align with that design rather than constantly recreating clients.\n\n2. **Validate external integrations at setup time**\n   - For Home Assistant-style platforms, the integration should make an initial API request in setup_platform to verify credentials and connectivity. If it fails, fail the platform setup early rather than exposing an entity that will just fail during updates.\n\n3. **Handle failure and resource cleanup explicitly**\n   - On API errors, log them with enough context and clean up resources (e.g., close HTTP sessions) to avoid leaking connections or leaving the integration in a partial state.\n   - When an operation is expected to be repeated (like polling in update()), holding onto a single, healthy client and its session is usually preferable to creating and destroying clients repeatedly, both for correctness and performance.\n\n4. **Pin and update external dependencies thoughtfully**\n   - Bugs in integrations are often rooted in external libraries. Pinning a specific library version and updating it when fixes arrive (pylinky 0.1.6 → 0.1.8) is a key part of stabilizing an integration.\n   - Changes in upstream services (e.g., Enedis modifying login redirects) can necessitate library updates plus changes in how the integration uses the library.\n\n5. **Encapsulation of API client logic**\n   - Instead of passing raw credentials into each update cycle, the integration should create and manage a single API client object that holds authentication and session-related state. Entities should delegate API calls to this client rather than reimplement login logic.\n\nThese patterns apply broadly to any polled integration with login/session semantics, not just the Linky sensor or pylinky.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and instrument the failure\n- Reproduce the login error in the integration (e.g., Home Assistant logs show authentication failures).\n- Temporarily increase logging around the API calls (log exceptions, raw error messages, and relevant parts of the response/data). Confirm whether the failure is a bad credential, session issue, or a protocol change (redirects, cookies, etc.).",
            "Step 2: Check the third-party library and service changes\n- Identify the client library used (e.g., pylinky) and check its version.\n- Review the library’s changelog/issues for recent fixes related to authentication, sessions, or changed remote APIs.\n- Check if the external service (e.g., Enedis/Linky) has changed login flows (extra redirects, new cookies, CSRF tokens).",
            "Step 3: Update and pin the dependency\n- If the library has a newer version that addresses login/session issues, update the version in both the integration’s REQUIREMENTS and the central requirements file (e.g., requirements_all.txt).\n- Pin the version explicitly (e.g., pylinky==0.1.8) to ensure reproducible behavior.\n- Run tests and basic manual verification with the new library version.",
            "Step 4: Align integration code with the library’s session model\n- If the library expects a persistent client/session, refactor the integration so it:\n  - Creates a single client instance in setup_platform (or equivalent initialization).\n  - Stores that client on the entity/platform object (e.g., self._client) instead of passing username/password into each update.\n- Avoid creating a new client for each update() unless the library or protocol requires it.",
            "Step 5: Validate credentials and fail fast in setup\n- In setup_platform, instantiate the client with user credentials and configuration (e.g., timeout).\n- Call a basic API method (e.g., fetch_data()) to validate login and connectivity.\n- Catch any library-specific errors (e.g., PyLinkyError), log the exception, clean up the client (close_session or equivalent), and abort platform setup (return) if the check fails.\n- This ensures that broken credentials or unreachable endpoints prevent the platform from loading, instead of causing repeated failures at runtime.",
            "Step 6: Manage sessions and errors during periodic updates\n- In the entity’s update() method:\n  - Reuse the stored client instance to call fetch_data() or the relevant polling method.\n  - Wrap the call in try/except for the library’s error type.\n  - On error: log the exception, close the client session if appropriate, and return without updating state (optionally set state to None).\n  - On success: read the fetched data from the client (e.g., client.get_data()), log debug output if helpful, and update the entity’s state.",
            "Step 7: Ensure proper cleanup and avoid unnecessary imports\n- Only import heavy client classes where they are needed (typically at module level or setup, not inside tight loops).\n- Remove unused imports (e.g., LinkyClient inside update() once the client is stored on the entity).\n- Explicitly close sessions when the client is no longer usable (on errors or shutdown hooks, if available).",
            "Step 8: Test end-to-end and add regression coverage\n- Verify that the integration now loads successfully with valid credentials and that the sensor updates as expected over multiple polling intervals.\n- Confirm that invalid credentials cause setup to fail with clear log messages.\n- If possible, add or update tests that simulate authentication failure and success, ensuring that fast-fail setup behavior and session reuse remain correct in future changes."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "ZHA (Zigbee Home Automation) enhancements: expose NWK address in device info, fix Xiaomi Aqara vibration sensors that broke after adding door lock support by forcing them to use an attribute-listening channel instead of a lock channel, introduce clearer cluster classification (channel-only, input-bind-only, output-channel-only), and prevent creation of binary sensor entities for remote/control devices by using REMOTE_DEVICE_TYPES to filter OnOff clusters.",
        "keywords": [
            "home-assistant",
            "ZHA",
            "zigpy",
            "zigbee",
            "Aqara vibration sensor",
            "Xiaomi quirk",
            "door lock cluster misuse",
            "cluster discovery",
            "channel_only_clusters",
            "output_channel_only_clusters",
            "input_bind_only_clusters",
            "REMOTE_DEVICE_TYPES",
            "binary sensor suppression",
            "remote control devices",
            "OnOff cluster",
            "NWK in device info",
            "binding behavior",
            "endpoint in_clusters out_clusters",
            "entity discovery"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set addressed several related issues and enhancements in the Home Assistant ZHA integration.\n\nA key regression was that Xiaomi Aqara vibration sensors stopped working correctly after door lock support was added. Xiaomi uses the Zigbee door lock cluster incorrectly, exposing it as `ep_attribute == 'multistate_input'`. When ZHA started treating the door lock cluster as a real lock, these vibration sensors were no longer handled as simple attribute-listening devices. The fix added a targeted hack in `zha/core/discovery.py` in `_async_create_cluster_channel`: if a cluster has `ep_attribute == 'multistate_input'`, the code forces the use of `AttributeListeningChannel` regardless of the standard cluster-to-channel mapping. This restores the previous vibration sensor behavior without affecting normal lock devices.\n\nThe PR also refactored how clusters are classified and discovered:\n- `NO_SENSOR_CLUSTERS` was renamed to `CHANNEL_ONLY_CLUSTERS` for clarity. These are clusters that should create channels (internal control/coordination) but not user-facing entities.\n- `OUTPUT_CHANNEL_ONLY_CLUSTERS` was introduced so certain output clusters (e.g., `Scenes`) are only represented as channels and not entities.\n- `INPUT_BIND_ONLY_CLUSTERS` was introduced and wired into the gateway: on device initialization, input clusters in this list are treated as `bind_only`, while all non-ZDO output clusters are always `bind_only`. This formalizes which clusters should only be bound and not polled or represented as entities.\n\nIn `discovery._async_handle_single_cluster_matches`, handling of channel-only clusters was updated so that `CHANNEL_ONLY_CLUSTERS` (for input clusters) and `OUTPUT_CHANNEL_ONLY_CLUSTERS` (for output clusters) are always processed into channels and then skipped for normal entity discovery via `continue`. A minor bug was fixed by adding that `continue` so these clusters don't also go through the regular single-cluster match path.\n\nAnother behavioral change targeted remote and controller devices. Previously, certain remotes exposed binary sensor entities (e.g., representing button state) that were not useful or correct. A new `REMOTE_DEVICE_TYPES` registry was added and seeded with Zigbee HA and Zigbee Light Link remote-like device types (scene controllers, remotes, controllers, control bridges, etc.). During discovery of output clusters, if an On/Off cluster is on a device whose `profile_id` and `device_type` match `REMOTE_DEVICE_TYPES`, ZHA now skips creating an entity for that cluster. This effectively suppresses binary sensor entities for remotes while still allowing their clusters to be used for event relay and binding.\n\nAdditionally, the PR exposed the NWK (network) address in `ZhaDevice.device_info` by adding `NWK: self.nwk` to the returned metadata, improving diagnostics and tooling that depend on full Zigbee addressing. A small comment format and log message wording update was also included.",
        "semantic_memory": "Several generalizable lessons emerge from this ZHA enhancement work:\n\n1. **Separate internal channels from user-facing entities.**\n   Many protocols (Zigbee included) expose clusters or capabilities that are necessary for control, binding, or configuration but do not make sense as Home Assistant entities. Distinguishing between `CHANNEL_ONLY` and entity-creating clusters avoids clutter and inconsistent UX. It is useful to maintain explicit registries such as `CHANNEL_ONLY_CLUSTERS` and `OUTPUT_CHANNEL_ONLY_CLUSTERS` and to guard entity creation logic with these lists.\n\n2. **Model binding semantics explicitly.**\n   Not all clusters should be treated equally regarding reporting and binding. Some are intended to be bound only (no polling or separate entities), especially output clusters used for controlling other devices. Introducing `INPUT_BIND_ONLY_CLUSTERS` and treating all non-ZDO output clusters as `bind_only` clarifies this. Explicit flags on clusters (e.g., `cluster.bind_only`) reduce subtle bugs in how the stack manages them.\n\n3. **Filter entity creation based on device type, not just cluster type.**\n   The same cluster (e.g., On/Off) can mean very different things on different devices. On a light bulb it represents the load state; on a remote control it might just be a control surface. By combining cluster ID with `profile_id` and `device_type` via a registry (`REMOTE_DEVICE_TYPES`), you can decide when NOT to create entities (e.g., avoid binary sensors for button presses on remotes) and instead rely on event relays.\n\n4. **Dealing with non-compliant or quirky devices may require targeted hacks.**\n   Some manufacturers (e.g., Xiaomi) misuse standard clusters or attributes. In those cases, pragmatic, narrowly-scoped overrides (here, checking `ep_attribute == 'multistate_input'` and forcing an `AttributeListeningChannel`) can restore functionality without refactoring the entire stack. The key is to make the hack small, well-commented, and conditional on a clear identifying trait.\n\n5. **Improve diagnostics by surfacing low-level identifiers.**\n   Exposing the NWK address alongside IEEE, manufacturer, and model in `device_info` aids debugging, device matching, and integration with coordinator logs and tools. In low-level networked protocols, having both long (IEEE) and short (NWK) addresses available to higher layers is valuable.\n\n6. **Guard against double-handling in discovery flows.**\n   When adding special-case handling (e.g., for channel-only clusters), ensure the general discovery path doesn't also run for those clusters. Using `continue` after special handling is a simple but important pattern to prevent duplicate entities or conflicting configuration.\n\nOverall, the PR demonstrates a pattern of: (a) defining central registries that encode protocol-specific knowledge (cluster roles, remote device types), (b) using those registries in discovery and initialization, and (c) applying narrowly scoped hacks for out-of-spec devices while keeping the main logic generic.",
        "procedural_memory": [
            "When Zigbee devices in ZHA behave incorrectly after protocol-level changes (e.g., adding support for new clusters like door locks), diagnose by mapping clusters to channels and entities, then refine cluster classification and device-type based logic.",
            "Step 1: Reproduce and characterize the issue.\n- Identify which specific device or class of devices is affected (e.g., Xiaomi Aqara vibration sensor stopped reporting correctly).\n- Confirm recent changes (e.g., added support for door lock cluster) that could affect the affected device’s clusters.\n- Inspect the device’s Zigbee signature: profile ID, device type, endpoints, clusters, and any quirk attributes (like `ep_attribute`).",
            "Step 2: Inspect discovery and channel creation logic.\n- Locate the discovery functions that translate clusters into channels and entities (in this case, `_async_create_cluster_channel` and `_async_handle_single_cluster_matches`).\n- Add logging or debug prints to see which channel class is being assigned to each cluster and which entities are being created.\n- Check if special-case clusters (e.g., Basic, PowerConfiguration, LightLink, Scenes) are being treated both as channels and entities accidentally.",
            "Step 3: Introduce or update cluster classification registries.\n- Define clear registries: `CHANNEL_ONLY_CLUSTERS`, `OUTPUT_CHANNEL_ONLY_CLUSTERS`, `INPUT_BIND_ONLY_CLUSTERS`, etc.\n- Populate these registries in a central place (e.g., `registries.py`) based on protocol knowledge: which clusters are for configuration only, which are control-only, which should never become standalone entities.\n- Replace vague or misleading names (e.g., `NO_SENSOR_CLUSTERS`) with ones that describe behavior (e.g., `CHANNEL_ONLY_CLUSTERS`).",
            "Step 4: Wire registries into discovery control flow.\n- In the input cluster loop: if `cluster.cluster_id in CHANNEL_ONLY_CLUSTERS`, create a channel (`_async_handle_channel_only_cluster_match`) and then `continue` so the cluster is not processed for entity creation.\n- In the output cluster loop: if `cluster.cluster_id in OUTPUT_CHANNEL_ONLY_CLUSTERS`, do the same: channel only, then `continue`.\n- Verify that no channel-only cluster also goes through the generic `_async_handle_single_cluster_match` path.",
            "Step 5: Model binding semantics via flags.\n- Decide which clusters should be bind-only (no separate entities), usually output clusters and some special input clusters.\n- Maintain an `INPUT_BIND_ONLY_CLUSTERS` registry for input clusters.\n- On device initialization, iterate over endpoints:\n  - For endpoints with `endpoint_id != 0`, set `cluster.bind_only = (cluster.cluster_id in INPUT_BIND_ONLY_CLUSTERS)` for input clusters.\n  - For output clusters, set `cluster.bind_only = True` by default, unless they are ZDO or another explicitly excluded type.\n- Ensure downstream logic respects `bind_only` when creating entities or setting up reporting.",
            "Step 6: Filter entities by device type for controllers/remotes.\n- Identify remote/controller device types for each profile (ZHA, ZLL, etc.) and store them in a `REMOTE_DEVICE_TYPES` mapping keyed by `profile_id`.\n- In discovery for output clusters, before calling `_async_handle_single_cluster_match`, check:\n  - If the cluster is an OnOff cluster, and\n  - The `profile_id` and `device_type` of the endpoint match entries in `REMOTE_DEVICE_TYPES`,\n  - Then skip entity creation for that cluster (do not create binary sensor entities for remote buttons).\n- Confirm that event relay channels are still created for these clusters so remotes still work via events.",
            "Step 7: Add targeted hacks for known non-compliant devices.\n- When a specific vendor misuses a cluster (e.g., Xiaomi using the door lock cluster as a multistate input), identify a reliable attribute that distinguishes the quirk (here, `cluster.ep_attribute == 'multistate_input'`).\n- In `_async_create_cluster_channel`, add a conditional override:\n  - If the quirk condition matches, force `channel_class = AttributeListeningChannel`.\n- Keep the hack narrow (only for that condition) and clearly comment why it exists and which devices it targets.",
            "Step 8: Expose additional diagnostic identifiers.\n- If troubleshooting is hampered by missing identifiers, extend device info structures to include them.\n- For Zigbee, add `NWK` (short address) to the `device_info` dict alongside IEEE, manufacturer, model, and name.\n- Use these in logs and UI to correlate devices between coordinator logs and Home Assistant entities.",
            "Step 9: Validate changes with real devices and regression tests.\n- Re-pair or reinitialize affected devices (e.g., Aqara vibration sensors, remotes, locks) and verify:\n  - Vibration sensors publish events/attributes as expected.\n  - No extra binary sensor entities are present for remotes.\n  - Locks and other devices using door lock cluster behave correctly.\n  - Channels exist for channel-only clusters, but no unintended entities appear.\n- Run the test suite (`tox` or equivalent) to ensure no regressions elsewhere.",
            "Step 10: Document or encode knowledge for future maintenance.\n- Comment hacks and registry entries with rationale (e.g., which vendor/device or spec quirk they address).\n- If a pattern recurs (misused clusters, special remote types), consider promoting the approach to a documented design pattern (e.g., using registries and device-type filters for entity creation)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix to ensure a specific, compatible version of virtualenv is bundled and pinned with StackStorm (st2) by updating requirements generation and adding virtualenv to requirements.txt, avoiding reliance on whatever virtualenv version is available on the system.",
        "keywords": [
            "StackStorm",
            "st2",
            "virtualenv",
            "dependency pinning",
            "requirements.txt",
            "fixate-requirements.py",
            "CI pipeline",
            "packaging",
            "environment mismatch",
            "Python tooling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the StackStorm (st2) project needed to ensure that a new, compatible version of virtualenv was always available with the st2 installation and in CI. Previously, the Makefile invoked scripts/fixate-requirements.py with a --skip=virtualenv flag when generating the consolidated requirements.txt. As a result, virtualenv was not pinned in the generated requirements and the system relied on the virtualenv version present in the build or runtime environment. This led to mismatches, especially for features like packs.install in development environments and when building new packages. The fix removed the --skip=virtualenv option from the Makefile so that virtualenv is included in the fixed requirements generation. Additionally, virtualenv was explicitly added and version-pinned in requirements.txt as `virtualenv<14.0,>=13.1.2`. This guarantees that the st2 environment consistently uses a known-good virtualenv version across CI, packaging, and dev environments, rather than whatever might be installed globally.",
        "semantic_memory": "When a project depends on tooling such as virtualenv, pip, or other environment managers, relying on the system-installed version can introduce subtle and hard-to-reproduce failures, especially in CI and packaging. A consistent and reproducible build requires that these tools themselves are modeled as dependencies: they should appear in requirements files, be version-pinned, and be included in whatever process generates or 'fixates' dependency lists. Flags or configuration that exclude tooling dependencies (like --skip=virtualenv in a requirements generation script) effectively outsource version selection to the host system, breaking reproducibility and potentially causing incompatibility with newer packaging workflows. A robust practice is to treat build-time and environment-management tools as first-class dependencies, pin them to tested versions, and ensure all automated pipelines (CI, dev setups, packaging) derive from the same dependency specification.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of environment/tooling mismatch.\n- Look for build or runtime errors that only occur on some machines or in CI but not locally.\n- Check whether environment management tools (like virtualenv, pip, tox) differ in version across environments.",
            "Step 2: Inspect dependency generation and requirements files.\n- Review Makefiles, build scripts, or CI scripts that generate requirements (e.g., custom fixate-requirements scripts).\n- Look for flags or logic that intentionally skip certain packages or tools (e.g., --skip=virtualenv) when generating the final requirements file.",
            "Step 3: Confirm whether critical tools are pinned.\n- Open requirements.txt (or equivalent) and verify whether virtualenv, pip, or other essential tools appear there.\n- If they are missing or unpinned, note the actual versions used on environments where things work vs where they fail.",
            "Step 4: Decide on a compatible version range.\n- Determine which versions of the tooling have been tested and are known to work (e.g., from working environments, documentation, or upstream compatibility notes).\n- Choose a conservative pinned range (e.g., virtualenv<14.0,>=13.1.2) that matches your tested matrix.",
            "Step 5: Update the requirements generation pipeline.\n- Remove any logic/flags that skip those tooling dependencies from requirements generation (e.g., remove --skip=virtualenv from the script invocation in the Makefile or CI configuration).\n- Regenerate the requirements file so that the tooling dependency is included.",
            "Step 6: Add and pin the tool in requirements.\n- Explicitly add the tooling package (e.g., virtualenv) to requirements.txt with the chosen version constraints.\n- Ensure this file is the single source of truth for both CI and packaging.",
            "Step 7: Rebuild and test across environments.\n- Recreate virtual environments and reinstall dependencies using the updated requirements.txt.\n- Run the full test suite in local, CI, and packaging/build environments to confirm consistent behavior.",
            "Step 8: Communicate changes to related projects.\n- If other repos (e.g., provisioning or workroom repos) rely on implicit system versions, update them or notify maintainers to align with the new pinned tooling versions.\n- Document the required virtualenv (or other tooling) version in project docs to minimize future confusion."
        ]
    }
}
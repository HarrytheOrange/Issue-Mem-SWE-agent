{
    "search_index": {
        "description_for_embedding": "Home Assistant conversation and Almond integrations were extended to support attribution metadata and onboarding workflow over WebSocket and HTTP. A unified AbstractConversationAgent interface now exposes attribution and onboarding methods, AlmondAgent persists onboarding state in config entries, and the conversation component exposes new WebSocket commands for processing text, retrieving agent info (attribution + onboarding), and setting onboarding status.",
        "keywords": [
            "homeassistant",
            "home-assistant",
            "conversation component",
            "almond integration",
            "AbstractConversationAgent",
            "attribution metadata",
            "onboarding workflow",
            "websocket_api",
            "conversation/process",
            "conversation/agent/info",
            "conversation/onboarding/set",
            "config_entries",
            "hass.io",
            "NLU",
            "intent handling",
            "HTTP API",
            "refactor",
            "default agent initialization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The conversation and Almond components in Home Assistant initially lacked a standardized way for the frontend to retrieve attribution metadata (e.g., 'Powered by Almond') and to handle an onboarding flow (e.g., asking the user to opt-in to share anonymized commands). Furthermore, conversation processing was only exposed via an HTTP view with ad‑hoc initialization logic.\n\nTo address this, the AbstractConversationAgent base class was extended with three capabilities: an `attribution` property (defaulting to `None`), `async_get_onboarding()` returning onboarding data or `None`, and `async_set_onboarding(shown: bool)` as a hook for updating onboarding state. The AlmondAgent was updated to accept `hass` and a `ConfigEntry` so it can persist onboarding state by storing an `onboarded` flag in the config entry data. Its `attribution` property now returns `{\"name\": \"Powered by Almond\", \"url\": \"https://almond.stanford.edu/\"}`, and `async_get_onboarding()` returns a message and URL for the Almond conversation UI only when the user is not yet onboarded. The URL is adjusted depending on whether Almond runs locally, via Hass.io (`/core_almond`), or in the cloud (`host/me`). `async_set_onboarding(shown)` updates `entry.data` with `\"onboarded\": shown` using a correct dictionary merge (`{**self.entry.data, \"onboarded\": shown}`) instead of a nested mapping.\n\nOn the conversation side, the component was refactored to centralize agent access and intent processing. A new `get_agent(hass)` helper (now async) ensures the DefaultAgent is created once and `async_initialize(config)` is called with configuration stored in `hass.data[\"conversation_config\"]`. Two helpers, `process(hass, text, conversation_id)` and `get_intent(hass, text, conversation_id)`, were introduced to handle agent processing, wrap errors (`IntentHandleError`), and provide a fallback response (\"Sorry, I didn't understand that\") when the agent returns `None`.\n\nNew WebSocket commands were added: `conversation/process` to process text and return intent responses, `conversation/agent/info` to return both onboarding info and attribution in a single call, and `conversation/onboarding/set` to update onboarding status. The previous, more granular onboarding WebSocket commands were removed. The HTTP view `/api/conversation/process` was simplified to use `get_intent` instead of capturing a per-setup `process` closure. Some small correctness and style adjustments were made, such as returning `None` (instead of `False`) when there is no onboarding/attribution data, and fixing lint issues and schema definitions.",
        "semantic_memory": "This change illustrates several generalizable patterns for designing conversational and pluggable integrations in a Home Assistant–like architecture:\n\n1. **Standardized agent capabilities via an abstract base class**:\n   - When multiple backends (agents) can handle the same logical feature (conversation), define an abstract base with common, optional capabilities (e.g., `attribution`, `async_get_onboarding`, `async_set_onboarding`).\n   - Provide sensible no-op defaults (`None` for \"no data\", `True` for a best-effort setter) so that existing agents can remain backward compatible while supporting richer capabilities when implemented.\n\n2. **Onboarding is a first-class concern**:\n   - Onboarding information (e.g., whether the user has seen an opt-in dialog) is stored in durable configuration (like config entries) so it survives restarts.\n   - The agent exposes an idempotent `async_get_onboarding()` that returns `None` if the user is already onboarded, and returns a structured object when onboarding UI should be shown. This separates onboarding logic from UI implementation.\n   - `async_set_onboarding(shown: bool)` allows the frontend to signal completion or user choice, enabling the integration to record this state.\n\n3. **Attribution and metadata for pluggable components**:\n   - Providing an `attribution` property lets the UI consistently show \"Powered by <provider>\" and link to external documentation, regardless of which agent is active.\n   - Returning `None` instead of booleans for \"no attribution\" clarifies the semantic meaning: absence of data vs. a negative value.\n\n4. **Centralized agent initialization and configuration**:\n   - Use a `get_agent(hass)` helper that encapsulates fetching/instantiating the active agent and calling its `async_initialize(config)` exactly once. This avoids duplicated initialization logic across different entry points (HTTP, WebSocket, services).\n   - Store shared configuration in `hass.data` (e.g., `conversation_config`) so that initialization can be deferred but still has access to initial config.\n\n5. **Unified APIs over HTTP and WebSocket**:\n   - The API for conversation processing (`/api/conversation/process` and `conversation/process` WebSocket command) is backed by shared helper functions (`get_intent`). This ensures identical behavior, error handling, and fallback responses across transport layers.\n   - WebSocket commands (e.g., `conversation/agent/info`, `conversation/onboarding/set`) are ideal for interactive UIs that need to query metadata and update state without full page reloads.\n\n6. **Careful handling of configuration updates**:\n   - When updating a config entry, use a shallow merge like `{**entry.data, \"onboarded\": shown}` instead of nesting dictionaries to avoid inadvertently changing the data shape.\n\n7. **Error handling and UX in conversational systems**:\n   - Catch agent processing errors at the outermost boundary (HTTP/WebSocket handler), convert them to meaningful `IntentResponse` messages, and supply a human-friendly fallback if the agent returns `None`. This ensures clients always get a valid response object.\n\nOverall, the change reflects a clean separation between conversation processing, UI metadata (attribution & onboarding), provider-specific logic (Almond), and transport (HTTP vs WebSocket), which is a good pattern for extensible conversational platforms.",
        "procedural_memory": [
            "When adding onboarding and attribution support to a conversational or pluggable integration, follow these steps:",
            "Step 1: Extend the agent interface",
            "- Identify the abstract base class that all agents implement (e.g., `AbstractConversationAgent`).",
            "- Add an `attribution` property returning either a dict with attribution data or `None` if not applicable.",
            "- Add `async_get_onboarding(self)` that returns either a structured onboarding payload (e.g., `{text, url}`) or `None` if onboarding is not required.",
            "- Add `async_set_onboarding(self, shown: bool)` that records the onboarding state and returns `True`/`False` to indicate success. Provide default no-op implementations to preserve backward compatibility.",
            "",
            "Step 2: Implement attribution and onboarding for a specific agent",
            "- Update the concrete agent (e.g., AlmondAgent) to receive whatever context it needs to persist state and construct URLs (usually `hass` and a configuration or `ConfigEntry`).",
            "- Implement `attribution` to return a dict like `{ 'name': 'Powered by Almond', 'url': 'https://almond.stanford.edu/' }`.",
            "- In `async_get_onboarding`, read existing state from configuration (e.g., `entry.data.get('onboarded')`). If onboarding is already done, return `None`. Otherwise, construct a text prompt and URL that the frontend can use to show onboarding, adjusting the URL based on environment (e.g., local vs cloud vs Hass.io).",
            "- In `async_set_onboarding(shown)`, update configuration to persist the new onboarding state, for example:\n  `hass.config_entries.async_update_entry(entry, data={**entry.data, 'onboarded': shown})`.",
            "",
            "Step 3: Centralize agent lookup and initialization",
            "- Add a helper like `async def get_agent(hass) -> AbstractConversationAgent:` that:\n  - Looks up `hass.data.get('conversation_agent')`.\n  - If missing, creates a default agent (e.g., `DefaultAgent(hass)`), stores it, and calls `await agent.async_initialize(hass.data.get('conversation_config'))`.",
            "- In your `async_setup`, store any relevant configuration in `hass.data['conversation_config']` so it can be used later during lazy initialization.",
            "- Ensure all entry points (services, HTTP, WebSocket) call this helper rather than duplicating agent construction logic.",
            "",
            "Step 4: Provide shared helpers for processing and intent responses",
            "- Implement a helper `async def process(hass, text, conversation_id)` that gets the agent via `get_agent(hass)` and calls `agent.async_process(text, conversation_id)`.",
            "- Implement `async def get_intent(hass, text, conversation_id)` that:\n  - Calls `process` inside a try/except catching `IntentHandleError`.\n  - On error, constructs an `IntentResponse` with an error message.\n  - If the result is `None`, creates an `IntentResponse` with a generic fallback message like \"Sorry, I didn't understand that\".\n  - Returns a valid `IntentResponse` in all cases.",
            "",
            "Step 5: Expose WebSocket APIs for conversation and agent metadata",
            "- Define a WebSocket command for processing text, for example:\n  `@websocket_api.websocket_command({'type': 'conversation/process', 'text': str, vol.Optional('conversation_id'): str})`.\n  - In the handler, call `intent_result = await get_intent(hass, msg['text'], msg.get('conversation_id'))` and send it back with `connection.send_result(msg['id'], intent_result)`.\n  - This enables real-time conversational UIs.\n",
            "- Define a WebSocket command to get agent info (onboarding + attribution):\n  `@websocket_api.websocket_command({'type': 'conversation/agent/info'})`.\n  - In the handler, get the agent via `await get_agent(hass)` and send back a payload like `{ 'onboarding': await agent.async_get_onboarding(), 'attribution': agent.attribution }`.",
            "- Define a WebSocket command to set onboarding status, e.g.:\n  `@websocket_api.websocket_command({'type': 'conversation/onboarding/set', 'shown': bool})`.\n  - In the handler, call `success = await agent.async_set_onboarding(msg['shown'])` and respond with either `send_result` or `send_error`.",
            "",
            "Step 6: Align HTTP API with the new helpers",
            "- Simplify your HTTP view (e.g., `/api/conversation/process`) to use the same intent helper:\n  - In the POST handler, extract `text` and optional `conversation_id` from the request data.\n  - Call `intent_result = await get_intent(hass, text, conversation_id)`.\n  - Return `self.json(intent_result)`.",
            "- Remove any closure-based agent initialization; rely on the central `get_agent` helper instead.",
            "",
            "Step 7: Use correct sentinel values and data shapes",
            "- Prefer `None` to represent \"no value\" (e.g., no onboarding or attribution) rather than `False`, which can be misinterpreted as a meaningful boolean state.",
            "- When updating configuration dicts, use a shallow merge like `{**existing, 'key': value}` instead of nesting a dict (`{**existing, **{'key': value}}` is also valid but more verbose). This keeps the data structure predictable.",
            "",
            "Step 8: Test and validate behavior",
            "- Verify that a fresh setup returns onboarding info via `conversation/agent/info` and that calling `conversation/onboarding/set` subsequently suppresses future onboarding responses.",
            "- Confirm that the frontend can retrieve attribution and display the correct provider name and URL.",
            "- Exercise both HTTP and WebSocket conversation processing and ensure they both return consistent error handling and fallback messages.",
            "- For integrations like Almond, test all environment-specific URL branches (local, Hass.io, cloud) to ensure onboarding links are correct."
        ]
    }
}
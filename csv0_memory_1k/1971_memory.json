{
    "search_index": {
        "description_for_embedding": "CI fix for nightly GitHub release artifacts where versioned artifact names prevented overwriting previous nightlies. The workflow was updated so the uploaded asset name no longer includes the version, ensuring the nightly build asset is consistently overwritten per OS.",
        "keywords": [
            "CI",
            "GitHub Actions",
            "nightly build",
            "release artifact",
            "asset_name",
            "asset_path",
            "workflow",
            "napari",
            "upload-release-asset",
            "artifact overwrite",
            "versioned filenames"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the project maintained a nightly build release on GitHub tied to a fixed release_id. The CI workflow uploaded build artifacts as GitHub release assets using a name that included both the version and the OS: `napari-${{ env.version }}-${{ runner.os }}.zip`. Because the version tag changed with each nightly, every run produced a new, uniquely named asset. As a result, the nightly release accumulated many artifacts instead of reusing a single perâ€‘OS artifact, and the previous asset was not overwritten. To fix this, the `.github/workflows/make_bundle.yml` workflow was updated so that the uploaded asset's name no longer includes the version. The final configuration keeps the actual file path versioned (`asset_path: napari-${{ env.version }}-${{ runner.os }}.zip`) but changes the published asset name to be stable per OS (`asset_name: napari-${{ runner.os }}.zip`). This ensures that each nightly upload uses the same asset name per OS, allowing the action/release logic to overwrite the prior nightly asset instead of creating a new, versioned one every time.",
        "semantic_memory": "When publishing nightly or rolling builds as GitHub release assets, using versioned filenames for the asset *name* can prevent reuse or overwrite of previous artifacts. GitHub treats assets with different names as distinct files, so nightlies with names containing the version string will accumulate indefinitely and consumers cannot rely on a stable download URL or asset identity. A robust pattern is to distinguish between the on-disk artifact path and the logical asset name used in the release: keep `asset_path` versioned for traceability and caching, but keep `asset_name` stable (e.g., just the OS or a generic label like `nightly-linux.zip`). This allows clients to download a predictable artifact while CI can still manage different physical files internally. More broadly, CI configuration for rolling releases should explicitly control artifact naming semantics to match the desired lifecycle (overwrite vs. keep history).",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom: In your nightly or rolling release, check the GitHub Release page (or API) for the relevant release_id. If you see many assets accumulating with different versioned names instead of a single updated asset per platform, you likely have an asset naming issue.",
            "Step 2: Inspect the workflow configuration: Open your GitHub Actions workflow YAML that uploads release artifacts (e.g., using actions like `upload-release-asset` or similar). Look for parameters such as `asset_path` and `asset_name` (or equivalent fields) used in the upload step.",
            "Step 3: Distinguish path vs. name: Determine whether the workflow is using the same string for both `asset_path` (the file on disk) and `asset_name` (the name in the GitHub release). If both include the version (or another changing identifier), every nightly run will create a unique asset instead of overwriting the previous one.",
            "Step 4: Decide on overwrite strategy: If the goal is to maintain a single rolling/nightly artifact per OS (or per target), choose a stable naming scheme for `asset_name` that does not include the version or other changing data. For example, use `myapp-${{ runner.os }}.zip` or `myapp-nightly-linux.zip`.",
            "Step 5: Keep internal paths versioned if needed: Optionally leave `asset_path` versioned (e.g., `myapp-${{ env.version }}-${{ runner.os }}.zip`) so that the build output is unique and cacheable in CI, while only the logical asset_name remains stable.",
            "Step 6: Update the workflow: Modify the YAML so that `asset_name` is stable and aligned with how you want clients to consume the nightly artifacts. For example, change from `asset_name: myapp-${{ env.version }}-${{ runner.os }}.zip` to `asset_name: myapp-${{ runner.os }}.zip`.",
            "Step 7: Verify overwrite behavior: Run the workflow (or trigger a nightly build) and examine the release assets. Confirm that the action either overwrites the existing asset with the same name or otherwise replaces it, rather than creating a new, uniquely named asset.",
            "Step 8: Validate consumer usage: Ensure any scripts, documentation, or users that download nightlies refer to the stable `asset_name` or a stable download URL, and no longer rely on the versioned filename for nightly builds.",
            "Step 9: Document the convention: Record in project docs that nightly builds use stable asset names (per OS or platform) and that version information may be embedded in the file contents or path but not necessarily in the published asset name.",
            "Step 10: Monitor over time: Periodically check the nightly release to ensure only the intended number of assets exist and that the naming scheme continues to support your overwrite and consumption model."
        ]
    }
}
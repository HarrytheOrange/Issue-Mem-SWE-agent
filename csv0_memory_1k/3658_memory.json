{
    "search_index": {
        "description_for_embedding": "Adds support in StackStorm for sharing common Python code between actions and sensors via a pack-level lib/ directory. Stores the pack's filesystem path on the PackDB model, computes a lib path, and prepends it to PYTHONPATH for Python actions and sensors when packs.enable_common_libs is true. Includes examples, configuration, and tests to avoid breaking existing packs.",
        "keywords": [
            "StackStorm",
            "pack common lib",
            "shared code actions sensors",
            "lib directory",
            "python_runner",
            "ProcessSensorContainer",
            "PackDB.path",
            "enable_common_libs",
            "PYTHONPATH manipulation",
            "import behavior",
            "backwards compatibility",
            "stdlib module shadowing",
            "AttributeError module has no attribute path"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set implements a long-requested feature in StackStorm: a way to share common Python code between actions and sensors within the same pack. The design centers around a pack-level lib/ directory, e.g. /opt/stackstorm/packs/<pack_name>/lib/. Any Python modules there (with an __init__.py so it’s a package) can be imported directly in Python actions and sensors using plain module names (e.g. from environ import get_environ), not lib.environ.\n\nTo support this, the PackDB model was extended with a new optional 'path' field that stores the pack's on-disk location. During pack registration (bootstrap/base.py), the pack_dir is now added to the PackAPI as 'path', and the DB layer persists that value. A helper function get_pack_common_libs_path(pack_db) was added in st2common.util.pack to compute <pack_path>/lib when a path is present, or return None otherwise.\n\nThe Python action runner (contrib/runners/python_runner/python_runner.py) and the sensor process container (st2reactor/container/process_container.py) were updated to compute the pack's common lib path and conditionally prepend it to PYTHONPATH. For actions, the runner now uses a new ActionRunner.get_pack_ref() method (replacing the older get_pack_name(), which is now decorated as deprecated) to fetch the pack reference, then loads the PackDB via Pack.get_by_ref(). It builds the normal sandbox_python_path using existing sandboxing utilities and, if a lib path is available and the feature is enabled, sets PYTHONPATH to \"<pack_lib_path>:<sandbox_python_path>\". Sensors use a similar approach in _spawn_sensor_process, querying Pack.get_by_ref(sensor['pack']) and wiring PYTHONPATH accordingly.\n\nBecause of concerns about backwards compatibility and potential import conflicts, the feature is gated behind a configuration option. A new [packs] section was added to st2.conf with a BoolOpt enable_common_libs, defaulting to False. Both the Python runner and the process container read cfg.CONF.packs.enable_common_libs and only inject the pack lib path into PYTHONPATH if this flag is true. This ensures existing deployments are unaffected until explicitly opted in.\n\nExample usage was added to the examples pack: contrib/examples/lib/__init__.py and environ.py define get_environ(), which fetches environment variables in a case-insensitive way. The sample Python action contrib/examples/actions/pythonactions/isprime.py imports from environ and logs PYTHONPATH, and the FibonacciSensor example sensor was updated to import from environ as well and log internal state.\n\nThe team also investigated potential import conflicts when user modules in lib/ share names with stdlib or venv modules (e.g., creating an os.py in lib/). Tests showed that this can cause Python initialization to fail deeply within site.py (AttributeError: 'module' object has no attribute 'path'). Because detecting such conflicts at runtime is non-trivial and would require maintaining a reserved-module list, the decision was to document this limitation rather than trying to fully guard against it in code.\n\nMultiple unit tests were added: PackDB CRUD tests now cover the 'path' field and its optional nature; get_pack_common_libs_path tests verify behavior with and without pack_db.path; python_runner tests assert that when _enable_common_pack_libs is true, the PYTHONPATH passed to subprocess.Popen contains the pack’s lib path (matched using a relative substring so it works both locally and on CI), and when false, that lib path is absent. ProcessSensorContainer tests similarly validate that PYTHONPATH contains or omits /opt/stackstorm/packs/<pack>/lib depending on the _enable_common_pack_libs flag. This ensures both the configuration gating and the path construction behave as expected across environments.",
        "semantic_memory": "This PR illustrates several generalizable patterns for adding shared-library support to a plugin-based system without breaking existing behavior:\n\n1. **Pack/Plugin Root Path in Metadata**: Storing the on-disk path of a pack (or plugin) in its persistent model (PackDB.path) enables future features that depend on filesystem layout (e.g., shared libraries, data directories) without changing all call sites. Any extensible system with filesystem-backed plugins benefits from recording the plugin root path in metadata.\n\n2. **Config-gated Feature Flags for Backwards Compatibility**: Introducing behavior that might alter module resolution (like modifying PYTHONPATH) is potentially breaking. A configuration toggle (packs.enable_common_libs) lets maintainers ship the feature in a disabled state, allow early adopters to opt in, and avoid surprise regressions for existing users. This is a general best practice when changing runtime environments for third-party code.\n\n3. **Selective PYTHONPATH Manipulation**: The feature injects a per-pack lib directory into PYTHONPATH just before launching an action or sensor. It builds on existing sandbox_python_path, only prepending the pack lib path when available and enabled. This pattern—compose the base environment and then conditionally layer in extra search paths—is safer than globally mutating sys.path or environment variables at process startup.\n\n4. **Graceful Handling of Optional Metadata**: get_pack_common_libs_path() returns None when pack_db.path is missing, and callers explicitly handle that case. This prevents runtime errors when dealing with older records that lack the new field. The pattern is: introduce optional metadata, write helper functions that tolerate its absence, and update callers to behave sensibly in both new and old states.\n\n5. **Deprecation Strategy**: The ActionRunner API evolved from get_pack_name() to get_pack_ref() while preserving the old method, annotated using a @deprecated decorator that emits DeprecationWarning. This pattern allows API evolution without an immediate breaking change, and encourages gradual migration of call sites.\n\n6. **Testing the Environment of Spawned Subprocesses**: The unit tests inspect the environment passed into subprocess.Popen to verify PYTHONPATH contents. This is a robust way to test environment-dependent features (like module search paths) without executing real actions or sensors. When adding env-manipulation features, always test the constructed environment rather than relying only on high-level behavior.\n\n7. **Risks of Shadowing Stdlib or Installed Modules**: Allowing user-defined modules in a directory added to PYTHONPATH can cause hard-to-diagnose failures if those modules share names with stdlib or venv-installed modules (e.g., os, site, json). The breakage can surface far away from user code (e.g., in Python’s own site.py). The general lesson is that any framework that manipulates import paths should document the risk of module name collisions and recommend namespaced or sufficiently unique module names.\n\n8. **Examples as Documentation of New Features**: The examples pack was updated to contain a lib/ directory and code that imports from it, serving both as functional tests and as living documentation for users. For new platform features, providing minimal but realistic samples in the default examples is an effective onboarding strategy.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the need to share code between plugins/components.\nDetermine whether multiple actions/sensors/plugins in a system are duplicating Python logic (e.g., utility functions, API wrappers) and whether a common library directory within each pack/plugin would help.",
            "Step 2: Ensure each pack/plugin’s filesystem path is available in metadata.\nIf not already present, add a 'path' (or equivalent) field to your pack/plugin DB model to store the absolute path where the pack is installed. Update registration/bootstrap code to populate this field when packs are loaded.\n- Add the field to the model schema.\n- Modify the registration/loader to set path=<pack_dir> when creating/updating records.\n- Write tests to verify the path is saved and optional for older data.",
            "Step 3: Implement a helper to compute the shared lib path.\nCreate a small utility function (like get_pack_common_libs_path(pack_db)) that:\n- Reads pack_db.path.\n- Returns os.path.join(path, 'lib') if path is present, otherwise returns None.\n- Add unit tests for both cases (with and without path).",
            "Step 4: Add a configuration flag to gate the new behavior.\nIntroduce a config option (e.g., [packs] enable_common_libs = False) that controls whether shared lib directories are added to PYTHONPATH.\n- Register the option in your config schema (e.g., oslo.config or equivalent).\n- Provide a clear, detailed help string explaining what enabling the option does and linking to documentation.\n- Set the default to False to preserve existing behavior.",
            "Step 5: Update runners or process managers to manipulate PYTHONPATH.\nFor any component that launches user code in a subprocess (e.g., action runner, sensor container):\n- Resolve the pack reference for the action/sensor.\n- Fetch the PackDB record via Pack.get_by_ref or equivalent.\n- Use get_pack_common_libs_path() to compute the lib path.\n- Build the existing sandbox python path (e.g., using get_sandbox_python_path()).\n- If config enable_common_libs is true and the lib path is not None, set PYTHONPATH to '<lib_path>:<sandbox_python_path>'. Otherwise, leave PYTHONPATH as just the sandbox path.\n- Ensure this environment is passed to subprocess.Popen or the equivalent execution mechanism.",
            "Step 6: Maintain backwards compatibility in APIs.\nIf you need to change how you determine the pack (e.g., from get_pack_name() to get_pack_ref()):\n- Introduce the new method.\n- Mark the old method as deprecated using a decorator that emits a DeprecationWarning.\n- Implement the old method in terms of the new one, so existing callers still work.",
            "Step 7: Add and/or update examples to exercise the new feature.\nCreate a lib/ directory in an example pack and add __init__.py and a small utility module (e.g., environ.py with a get_environ function).\n- Update sample actions and sensors to import from that module (from environ import get_environ).\n- Optionally log PYTHONPATH and outputs to make it easy to see when the feature is active.",
            "Step 8: Write tests that assert correct environment construction.\nFor runners:\n- Mock subprocess.Popen so no real actions are executed.\n- Run the runner with a fixture action whose pack has a lib/ directory.\n- Force runner._enable_common_pack_libs to True and False in separate tests.\n- Inspect the env argument passed to Popen and assert that PYTHONPATH contains or omits the lib path accordingly.\nFor sensors/process containers:\n- Mock Pack.get_by_ref to return a PackDB with a known path.\n- Mock os.path.isdir to avoid filesystem dependencies.\n- Call the internal spawn method (e.g., _spawn_sensor_process) and verify PYTHONPATH behavior in the env passed to Popen.",
            "Step 9: Diagnose problems when imports from the shared lib fail.\nIf users report ImportError or ModuleNotFoundError when importing from pack-level lib/:\n- Check that packs.enable_common_libs is set to True in st2.conf (or the system config).\n- Confirm the pack has a lib/ directory with an __init__.py file.\n- Verify the pack’s 'path' is correctly stored in the PackDB (e.g., via CLI or DB inspection).\n- Enable debug logging and confirm, via logs or tests, that PYTHONPATH for the action/sensor includes the expected lib path.\n- If PYTHONPATH does not include the lib path, re-check config, pack registration, and Pack.get_by_ref behavior.",
            "Step 10: Diagnose issues caused by module name shadowing.\nIf an action or sensor fails with strange errors deep in Python internals (e.g., AttributeError: 'module' object has no attribute 'path' from site.py):\n- Inspect the pack’s lib/ directory for modules named like stdlib or commonly installed packages (os.py, site.py, json.py, etc.).\n- Rename those modules to more specific names (e.g., my_os_helpers.py) to avoid shadowing.\n- Re-deploy the pack and re-run the action/sensor.\n- Consider documenting a guideline for pack developers to avoid using reserved or commonly-used module names in lib/.",
            "Step 11: Document the feature and its limitations for users.\nUpdate user-facing documentation to describe:\n- How to enable the feature via configuration.\n- Where to place shared code (pack/lib/), and that lib/ must be a Python package.\n- How to import shared modules from actions and sensors.\n- The risk of name collisions with stdlib or installed modules and recommended naming conventions.",
            "Step 12: Roll out gradually.\nGiven that changing PYTHONPATH can have subtle effects, keep enable_common_libs disabled by default and encourage early adopters to try it in non-production environments. Collect feedback, adjust docs and tests as needed, then recommend it more broadly once stable."
        ]
    }
}
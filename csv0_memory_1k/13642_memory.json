{
    "search_index": {
        "description_for_embedding": "Home Assistant Broadlink switch component was incorrectly using the friendly_name as the entity_id instead of the configuration key (object_id). The fix passes the configured object_id into the BroadlinkRMSwitch constructor and uses ENTITY_ID_FORMAT to set entity_id, so automations must now reference the real entity_id rather than the friendly_name.",
        "keywords": [
            "Home Assistant",
            "Broadlink",
            "BroadlinkRMSwitch",
            "switch.broadlink",
            "entity_id vs friendly_name",
            "ENTITY_ID_FORMAT",
            "configuration.yaml switches object_id",
            "breaking change",
            "automation entity_id mismatch",
            "component initialization bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant Broadlink switch platform, users reported that the component was using the friendly_name as the entity_id instead of using the key defined under the 'switches:' mapping in configuration.yaml (the object_id). For example, with:\n\nswitch:\n  - platform: broadlink\n    host: 192.168.1.2\n    mac: 'B4:43:0D:CC:0F:58'\n    switches:\n      tv_phillips:\n        friendly_name: \"Phillips TV Power\"\n\nthe expected entity_id was switch.tv_phillips, but in practice the system effectively treated the friendly_name as the entity identifier. This caused confusion and broke expectations for users who deliberately chose different object_ids and friendly_names, and it made automations depend on a user-facing label rather than a stable technical ID.\n\nThe root cause was that BroadlinkRMSwitch only took a single 'friendly_name' parameter and did not explicitly set its entity_id based on the configuration object_id. As a result, entity_id defaulting logic ended up using the wrong source.\n\nThe fix introduced the ENTITY_ID_FORMAT import from the switch domain and changed BroadlinkRMSwitch.__init__ to accept both a 'name' (the object_id from config) and a 'friendly_name'. The constructor now sets self.entity_id = ENTITY_ID_FORMAT.format(name) and stores the friendly_name separately in self._name. When building switches from the config, the code now calls BroadlinkRMSwitch(object_id, device_config.get(CONF_FRIENDLY_NAME, object_id), ...), ensuring the entity_id is derived from the configuration key while still exposing a separate, human-readable friendly name.\n\nThis change is a breaking change for users who had automations/groups referencing ids that effectively matched the friendly_name behavior; after the fix, they must update their automations to use the true entity_id based on the configuration key (e.g., switch.tv_phillips) instead of the friendly_name (e.g., 'Phillips TV Power').",
        "semantic_memory": "When designing entity-based systems (such as Home Assistant or similar platforms), there is an important distinction between an entity's internal identifier (entity_id) and its user-facing label (friendly_name). The entity_id should be a stable, configuration- or system-derived identifier that is safe to use in automations, code, and integrations. The friendly_name should be a mutable, display-only label for UI purposes.\n\nA common mistake is to conflate these two concepts, either by using the friendly_name as the entity_id or by letting UI-driven names control back-end identifiers. This leads to brittle automations (because labels are more likely to change), ambiguous behavior, and bugs when users expect object_ids (e.g., the keys in a configuration mapping) to control entity_ids.\n\nBest practices include:\n- Deriving entity_id from stable configuration keys (object_ids) or system-generated identifiers, using a standard format (e.g., ENTITY_ID_FORMAT in Home Assistant).\n- Treating friendly_name purely as a display concern, not as a primary key or identifier.\n- Ensuring constructors for entity classes accept distinct parameters for entity_id seed (name/object_id) and friendly_name, and explicitly set entity_id instead of relying on ambiguous defaults.\n- Documenting any change that alters how entity_ids are computed as a breaking change, since it can affect automations, scripts, and integrations.\n\nThis pattern is generalizable to any system with persistent entities and user-editable labels: clearly separate internal IDs from display names and enforce that separation in the codebase.",
        "procedural_memory": [
            "When an entity-based integration appears to be using the wrong identifier (e.g., friendly_name instead of entity_id), diagnose and fix the issue systematically:",
            "Step 1: Reproduce the behavior.\n- Define a configuration where the technical identifier (object_id) and friendly_name differ.\n- For example, configure a switch with key 'tv_phillips' and friendly_name 'Phillips TV Power'.\n- Observe the resulting entity in the system (e.g., via UI or logs) and see whether the entity_id matches the object_id-based expectation (switch.tv_phillips) or incorrectly tracks the friendly_name.",
            "Step 2: Inspect entity initialization code.\n- Locate the entity class (e.g., BroadlinkRMSwitch) and its __init__ method.\n- Check which parameters are passed to it (name, friendly_name, config key, etc.).\n- Examine how self.entity_id is set. If it's not explicitly set, identify the default behavior (e.g., base class or framework might infer it from a provided name/friendly_name).",
            "Step 3: Identify the correct source of entity_id.\n- Determine what the canonical identifier should be (usually the key in a config mapping, such as 'tv_phillips').\n- Confirm that this value is available when constructing the entity (e.g., object_id variable in a for-loop over devices).",
            "Step 4: Update the constructor to distinguish between name and friendly_name.\n- Modify the entity class __init__ signature to accept a 'name' (for id) and 'friendly_name' (for display) if it's currently using a single parameter for both.\n- In the constructor, import and use any standardized formatting constant (e.g., ENTITY_ID_FORMAT) from the framework.\n- Explicitly set self.entity_id = ENTITY_ID_FORMAT.format(name).\n- Store the display label separately, e.g., self._name = friendly_name.",
            "Step 5: Adjust call sites to pass both object_id and friendly_name.\n- Find where the entity is instantiated (e.g., inside a loop over configured devices).\n- Change calls from BroadlinkRMSwitch(friendly_name, device, ...) to BroadlinkRMSwitch(object_id, friendly_name, device, ...), where friendly_name defaults to object_id if not provided.\n- Ensure each call passes the new parameters in the correct order to avoid introducing new bugs (e.g., keep super().__init__ calls in subclasses in sync with the updated signature).",
            "Step 6: Test behavior and verify entity_id.\n- Restart or reload the integration and re-check the resulting entity_id.\n- Confirm that entity_id matches the expected format derived from the configuration key (e.g., switch.tv_phillips) and that the UI still shows the correct friendly_name.\n- Run the project's test suite (e.g., tox) to ensure no regressions.",
            "Step 7: Assess and document breaking changes.\n- Identify any user-facing impact: existing automations/scripts that may have relied on the previous entity_id naming behavior.\n- Add a clear breaking-change note describing that entity_ids are now derived from config object_ids; users must update automations to reference the new entity_ids if they previously depended on friendly_name behavior.\n- Ensure documentation matches the new behavior and remove misleading examples if needed.",
            "Step 8: Prevent future regressions.\n- Add tests that explicitly validate the mapping from config keys to entity_ids when friendly_name differs.\n- Codify the separation between entity_id and friendly_name in guidelines for contributors and in class interfaces (required parameters, docstrings, and comments)."
        ]
    }
}
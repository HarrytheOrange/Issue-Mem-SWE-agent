{
    "search_index": {
        "description_for_embedding": "Fixes a Home Assistant climate unit-conversion regression where min_temp/max_temp were incorrect when the global temperature unit was Fahrenheit. The previous refactor bypassed ClimateDevice's built-in unit conversion by using DEFAULT_MIN_TEMP/DEFAULT_MAX_TEMP and raw device values. This PR restores use of the superclass min_temp/max_temp (which handle conversion) for generic_thermostat and sensibo, and adds explicit temperature conversion for tado, which always reports min/max in Celsius.",
        "keywords": [
            "Home Assistant",
            "climate",
            "generic_thermostat",
            "sensibo",
            "tado",
            "temperature unit conversion",
            "Celsius to Fahrenheit",
            "min_temp",
            "max_temp",
            "DEFAULT_MIN_TEMP",
            "DEFAULT_MAX_TEMP",
            "regression",
            "configuration units",
            "Fahrenheit bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "A previous pull request (#14690) introduced a regression in Home Assistant's climate components when the global temperature unit was set to Fahrenheit. The bug manifested as incorrect min_temp and max_temp values for certain climate platforms (generic_thermostat, sensibo, and tado). The regression came from replacing or bypassing the ClimateDevice default min_temp/max_temp behaviour (which internally respects the system's unit configuration) with direct uses of DEFAULT_MIN_TEMP/DEFAULT_MAX_TEMP or raw device-specific temperature values. These defaults and device values were effectively in Celsius, but were treated as if they were already in the configured unit, so in Fahrenheit setups, the min/max temperatures were off.\n\nIn this PR, the author reverses those problematic changes and adds explicit conversions where needed:\n\n1. **tado**: This integration always has a device-provided `_min_temp` and `_max_temp` in a known unit (Celsius). Instead of falling back to DEFAULT_MIN_TEMP/DEFAULT_MAX_TEMP, the code now imports `convert_temperature` from `homeassistant.util.temperature` and converts `_min_temp` and `_max_temp` from `self._unit` to `self.hass.config.units.temperature_unit` in the `min_temp` and `max_temp` properties. The code also fixes the reference to the Home Assistant instance, using `self.hass` instead of a bare `hass` variable.\n\n2. **sensibo**: Previously, when there was no `_temperatures_list`, the integration returned `DEFAULT_MIN_TEMP` or `DEFAULT_MAX_TEMP`. Those constants do not automatically adapt to the configured unit. The fix is to return `super().min_temp` and `super().max_temp` in the fallback path, thereby relying on the base `ClimateDevice` implementation, which handles proper unit conversion according to the system configuration.\n\n3. **generic_thermostat**: Similarly, this component had begun returning `DEFAULT_MIN_TEMP` and `DEFAULT_MAX_TEMP` when its own `_min_temp` and `_max_temp` were not set. This bypassed the unit-aware behaviour in `ClimateDevice`. The PR changes the implementation to: if `_min_temp`/`_max_temp` are present, return those; otherwise, call `super().min_temp` and `super().max_temp`. A minor cleanup replaces explicit `ClimateDevice.min_temp.fget(self)` with `super().min_temp` for clarity.\n\nCollectively, these changes restore correct min/max temperature handling for environments using Fahrenheit and prevent raw Celsius values or constants from being misinterpreted in the UI and automations.",
        "semantic_memory": "This incident illustrates a general pattern: **unit conversion logic must be centralized and respected by all callers**.\n\nKey lessons:\n\n1. **Do not bypass framework helpers for unit-dependent values**.\n   In Home Assistant's climate domain, `ClimateDevice.min_temp` and `ClimateDevice.max_temp` encapsulate the logic for translating base values into the system's configured unit (Celsius or Fahrenheit). When platform code directly uses raw constants (`DEFAULT_MIN_TEMP`, `DEFAULT_MAX_TEMP`) or device-reported values without conversion, it risks breaking whenever the global unit configuration changes or differs from the device's native unit.\n\n2. **Device values often have a fixed unit; UIs may not**.\n   Integrations like tado expose min/max temperature limits in a fixed unit (here, Celsius). The user-facing API (Home Assistant UI) may operate in another unit (e.g., Fahrenheit). The integration code must explicitly convert between device units and system units when exposing properties that users or automations rely upon. Assuming that device units match UI units is fragile.\n\n3. **Constants are not unit-aware by default**.\n   Numbers like `DEFAULT_MIN_TEMP` and `DEFAULT_MAX_TEMP` typically assume a specific base unit (Celsius in this ecosystem). When the system switches to Fahrenheit, such constants need either a conversion step or, better, to be accessed through a helper that returns the appropriately converted value. Returning the raw constants for all configurations silently introduces incorrect values.\n\n4. **Superclasses often encapsulate policy/behaviour; use them**.\n   The base `ClimateDevice` class exists to centralize climate-related behaviour such as default temperature ranges and unit conversions. Child integrations should delegate to `super().min_temp`/`super().max_temp` when they do not have device-specific overrides. Reimplementing or partially overriding this logic is error-prone, especially around cross-cutting concerns like units.\n\n5. **Regression risk after refactoring**.\n   Seemingly small refactors (e.g., simplifying min/max temperature handling) can introduce behaviour regressions, particularly in multi-unit systems. Whenever unit-related code is touched, tests should be run under multiple configurations (Celsius and Fahrenheit) to ensure that defaults and derived values are correctly converted.\n\nIn general: when building integrations that surface measurements, store or reason in a canonical unit internally, expose helpers that convert to the configured units, and have callers consistently use those helpers rather than manipulating raw constants or values.",
        "procedural_memory": [
            "When diagnosing and fixing unit-conversion issues in temperature-based components (or similar measurement-driven domains), follow these steps:",
            "Step 1: Reproduce the issue under different unit configurations.\n- Set the system's temperature unit to each available option (e.g., Celsius and Fahrenheit in Home Assistant).\n- Inspect affected entities (e.g., climate devices) to see if properties such as min_temp, max_temp, and target temperatures behave unexpectedly or show implausible values in one unit but not the other.",
            "Step 2: Identify where units are determined and converted.\n- Locate the base class (e.g., ClimateDevice) and see how it defines default values and handles unit conversion.\n- Find any helper functions (e.g., a `convert_temperature` utility) that are intended to standardize unit handling.\n- Note what unit the core of the system assumes for constants (e.g., Celsius) and where the configured unit (e.g., `hass.config.units.temperature_unit`) is consulted.",
            "Step 3: Inspect integration/platform overrides.\n- For each affected platform (e.g., generic_thermostat, sensibo, tado), inspect overrides for `min_temp`, `max_temp`, and any other unit-dependent properties.\n- Look for direct usage of raw constants like `DEFAULT_MIN_TEMP`/`DEFAULT_MAX_TEMP` or device values being exposed without conversion.\n- Check whether they call `super().min_temp`/`super().max_temp` or ignore the superclass implementation.",
            "Step 4: Determine the device's native measurement units.\n- Confirm from API docs or existing code what unit the device uses for its values (e.g., tado reporting min/max in Celsius).\n- If device values differ from the system's configured unit, ensure the code is converting between them before exposing those values to the rest of the application.",
            "Step 5: Restore or introduce proper delegation to the framework.\n- If an integration previously relied on the base class for defaults, prefer delegating back to `super()` rather than reintroducing constants.\n- Example: replace `return DEFAULT_MIN_TEMP` with `return super().min_temp` when `_min_temp` is not set, so the base logic can perform any necessary conversion.",
            "Step 6: Add explicit conversion when exposing device-specific values.\n- When an integration has device-specific min/max values in a known unit, wrap them with a conversion helper:\n  - `return convert_temperature(self._min_temp, device_unit, hass.config.units.temperature_unit)`.\n- Ensure you reference the correct app/context object (e.g., `self.hass.config.units.temperature_unit` instead of a bare `hass`).",
            "Step 7: Remove redundant or misleading imports/constants.\n- If defaults are now retrieved via the superclass, remove imports of DEFAULT_MIN_TEMP/DEFAULT_MAX_TEMP to avoid confusion and reduce the temptation to bypass conversion.\n- Keep min/max logic centralized either in the base class or in clearly unit-aware platform code.",
            "Step 8: Add or run tests for multiple unit systems.\n- If possible, add tests that run the same component under both Celsius and Fahrenheit configurations and assert that min_temp/max_temp and other exposed temperatures are logically consistent.\n- Run the full test suite with different unit settings to catch regressions early.",
            "Step 9: Perform manual sanity checks.\n- After implementing fixes, manually observe the climate entities in the UI and via the API.\n- Verify that min/max bounds look correct (e.g., reasonable values in Fahrenheit rather than clearly-Celsius numbers) and that changing the system unit properly changes displayed values without changing the underlying logical limits.",
            "Step 10: Document assumptions and unit handling.\n- Where an integration assumes that device values are in a certain unit (e.g., tado always in Celsius), document this in code comments.\n- Note that defaults and conversions are delegated to the base class where applicable, so future refactors understand not to bypass these mechanisms."
        ]
    }
}
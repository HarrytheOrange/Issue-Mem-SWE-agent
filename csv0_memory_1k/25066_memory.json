{
    "search_index": {
        "description_for_embedding": "Adds a new Home Assistant websocket API command `zwave/network_status` to expose Z-Wave network status via the frontend. The command is registered in a dedicated `websocket_api.py` module, requires admin permissions, and returns the network's state from `hass.data[DATA_NETWORK]`. Refactor ensures proper async integration via `@callback` and cleanup of unused `state_str` field.",
        "keywords": [
            "Home Assistant",
            "Z-Wave",
            "websocket API",
            "zwave/network_status",
            "DATA_NETWORK",
            "require_admin",
            "async_register_command",
            "frontend integration",
            "network status",
            "callback decorator"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Z-Wave integration in Home Assistant lacked a websocket API endpoint to query the Z-Wave network status, which would be needed by the frontend for better feedback and UX (e.g., during node inclusion). To address this, a new `websocket_api.py` module was added under `homeassistant/components/zwave/`. In `__init__.py`, the Z-Wave setup flow now imports this module and calls `wsapi.async_load_websocket_api(hass)` during `async_setup_entry` to ensure the websocket commands are registered when the integration is initialized.\n\nThe new module defines a websocket command `zwave/network_status` using `@websocket_api.websocket_command` and restricts it with `@websocket_api.require_admin`. The command handler `websocket_network_status(hass, connection, msg)` retrieves the Z-Wave network object from `hass.data[DATA_NETWORK]` and responds via `connection.send_result(msg[ID], { 'state': network.state })`. Originally, it also returned `state_str`, but that field was later removed (likely because it was unnecessary or not part of the desired public API). The registration function `async_load_websocket_api` is marked with `@callback` to indicate it is a synchronous callback-style function callable in an async context, and it uses `websocket_api.async_register_command(hass, websocket_network_status)`.\n\nMinor follow-up patches cleaned up lint issues (spacing, removing unused `state_str`) and ensured code style compliance. The overall result is a dedicated, admin-only websocket endpoint for retrieving Z-Wave network status, structured in a way that allows additional Z-Wave websocket commands to be added easily in the future.",
        "semantic_memory": "This change illustrates several generalizable patterns for extending a Home Assistant integration with websocket APIs and integrating with its async architecture:\n\n1. **Dedicated websocket API module**: Placing websocket-related code in a separate `websocket_api.py` file for an integration keeps concerns separated and makes it easier to add, maintain, and discover websocket commands.\n\n2. **Websocket command declaration pattern**: Websocket commands in Home Assistant are usually declared using `@websocket_api.websocket_command(schema)` where the schema is defined via `voluptuous`. At minimum, a `type` field is required for routing, and the handler receives `hass`, `connection`, and `msg`. This provides a consistent pattern for registering and handling websocket commands.\n\n3. **Admin-only operations**: Commands that expose sensitive or system-level state (like full network status) should be protected via `@websocket_api.require_admin`. This enforces authorization at the API layer rather than relying on callers to behave correctly.\n\n4. **Using `hass.data` as shared integration state**: Integration runtime state (e.g., the Z-Wave network object) is stored under keys in `hass.data`. Websocket handlers can read from this shared state to serve realtime information without re-initializing components.\n\n5. **Async-safe registration with `@callback`**: Functions that do not perform blocking I/O but are invoked in the async setup or registration flow can be marked with `@callback`. This clarifies intent and fits Home Assistant’s asynchronous event loop model while avoiding unnecessary `async def` when no `await` is needed.\n\n6. **API payload minimization**: Exposing only what is needed (e.g., `state` instead of `state` and `state_str`) makes the API simpler, decreases coupling with internal representation, and reduces maintenance overhead.\n\nThese patterns can be reused in other integrations or frameworks that have similar async/event-driven architectures: separate transport layer modules, explicit registration of commands, authorization decorators, and careful selection of public API fields.",
        "procedural_memory": [
            "To add or fix a websocket API endpoint for an integration (like Z-Wave) in an async, Home Assistant-like architecture, follow these steps:",
            "Step 1: Create or use a dedicated websocket API module\n- Add a `websocket_api.py` file under the integration's package (e.g., `homeassistant/components/your_integration/websocket_api.py`).\n- This file will contain all websocket-specific schema definitions and handlers.",
            "Step 2: Define the websocket command schema and handler\n- Import the websocket API subsystem and validation library, e.g.: `from homeassistant.components import websocket_api` and `import voluptuous as vol`.\n- Define a schema using `@websocket_api.websocket_command({ vol.Required('type'): 'your_integration/your_command', ... })`.\n- Implement the handler with the signature `def your_handler(hass, connection, msg):`.\n- Inside the handler, obtain required integration state from `hass.data[YOUR_DATA_KEY]` or other shared storage.\n- Use `connection.send_result(msg['id'], { ...payload... })` to send structured results back to the client, or `connection.send_error(...)` on failures.",
            "Step 3: Enforce proper permissions\n- If the command exposes sensitive or administrative operations (system status, configuration, control of devices), decorate the handler with `@websocket_api.require_admin`.\n- For non-sensitive read-only data, choose more permissive decorators as appropriate, or none if the framework permits.",
            "Step 4: Register the command during integration setup\n- Define a function like `def async_load_websocket_api(hass):` or `@callback def async_load_websocket_api(hass):` that calls `websocket_api.async_register_command(hass, your_handler)`.\n- Use `@callback` if this function is sync and performs no blocking I/O but is invoked in an async context.\n- In the integration's `async_setup_entry` or equivalent setup function, import the websocket module and call this registration function (e.g., `from . import websocket_api as wsapi` then `wsapi.async_load_websocket_api(hass)`).",
            "Step 5: Keep the API payload stable and minimal\n- Decide which fields are actually needed by the frontend or clients (e.g., `state`) and avoid exposing internal or redundant fields (like `state_str` if not required).\n- Remove unused fields early, before the API is widely depended on, to minimize breaking changes.",
            "Step 6: Lint, test, and validate behavior\n- Run static analysis and formatting tools (lint, type checks) to ensure style compliance.\n- Write or run existing tests to validate that the websocket command can be called, returns the expected structure, and respects authorization requirements.\n- Test via a websocket client (or frontend dev tools) by sending a message with `{ \"id\": <int>, \"type\": \"your_integration/your_command\" }` and checking the response.",
            "Step 7: General debugging for similar issues\n- If a websocket endpoint is not working: verify that the command `type` string matches exactly the one in the schema.\n- Ensure the registration function is actually called during integration setup.\n- Check that `hass.data[...]` keys are populated before the handler is invoked; if not, adjust setup order or add guards.\n- Confirm that permission decorators (`require_admin`) match the user’s credentials; otherwise calls may fail silently or with auth errors."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Pokemon Optimizer was extended to handle marking and unmarking favorites based on rules, with new configuration flags to control evolving/upgrading favorites, plus fixes to the optimizer loop, transfer safety, and configuration misuse warnings.",
        "keywords": [
            "Pokemon optimizer",
            "favorites handling",
            "favorite rule",
            "may_evolve_favorites",
            "may_upgrade_favorites",
            "may_unfavor_pokemon",
            "pokemon_optimizer.work loop",
            "transfer safety",
            "configuration warning",
            "set_favorite_pokemon",
            "bot events pokemon_favored pokemon_unfavored"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Pokemon Optimizer was enhanced to manage 'favorite' status for Pokemon as part of its optimization rules, similarly to how it already handled evolve, upgrade, and buddy actions.\n\nThe feature:\n- New configuration flags were added:\n  - `may_evolve_favorites` (default true): controls whether favorite Pokemon are allowed to be evolved.\n  - `may_upgrade_favorites` (default true): controls whether favorite Pokemon are allowed to be upgraded.\n  - `may_unfavor_pokemon` (default false): controls whether the optimizer may remove the favorite flag from Pokemon that no longer match favorite rules.\n- A new `favorite` rule was added to the optimizer's rule language, using the same criteria system as `sort` and `upgrade`. Rules can specify `favorite: true|false|{criteria...}` to select which Pokemon should be marked as favorite.\n- Documentation and the example optimizer config were updated to describe these new options and provide examples.\n\nCore implementation details:\n- The optimizer's `initialize` method now reads the three new config options.\n- New bot events `pokemon_favored` and `pokemon_unfavored` were registered in `pokemongo_bot.__init__`, emitting `pokemon`, `iv`, and `cp` when favorite status changes.\n- In `pokemon_optimizer.get_score`, a new `rule_favor` and corresponding boolean `may_favor` were added to the per-Pokemon score tuple, indicating whether a Pokemon should be favorited by a rule. The debug logging string was updated to include F (favorite) state.\n- All helper methods that return optimization sets (`get_best_pokemon_for_rule`, `get_multi_best_pokemon_for_rule`, `get_better_pokemon`) were extended to return a fifth list for `favor` candidates alongside keep, try_evolve, try_upgrade, and buddy.\n- In `work`, a new `favor_all` collection is populated by aggregating favorite candidates from each rule. After deduplication (`unique_pokemon_list`), `try_favor_all` is used to:\n  - Unfavorite Pokemon (if `may_unfavor_pokemon` is true) by comparing the full inventory against `try_favor_all` and un-favoring any Pokemon that are currently favorite but not in the target list.\n  - Favorite Pokemon that are in `try_favor_all` but not already marked as favorite.\n- Two new helper methods were added:\n  - `favor_pokemon(pokemon)`: calls the API's `set_favorite_pokemon` with `is_favorite=True`, sets `pokemon.is_favorite = True` on success, emits the `pokemon_favored` event, and inserts a randomized `action_delay`.\n  - `unfavor_pokemon(pokemon)`: similar but with `is_favorite=False`, updating `pokemon.is_favorite = False`, emitting `pokemon_unfavored`, and adding `action_delay`.\n\nBehavioral safeguards and bug fixes:\n- Evolve/upgrade vs favorites:\n  - After computing `evolve_all` and `upgrade_all`, the worker now conditionally filters out favorites if the corresponding flags are false:\n    - If `may_evolve_favorites` is false, favorites are removed from `evolve_all`.\n    - If `may_upgrade_favorites` is false, favorites are removed from `upgrade_all`.\n  - Earlier, there were redundant checks inside `get_evolution_plan` that directly skipped favorite Pokemon. These were removed in favor of centralized filtering after planning, improving clarity and avoiding double-filtering.\n- Optimizer loop fix:\n  - Originally, the optimizer loop that repeats the optimization to clean up 'trash evolved' Pokemon was located after the main work pass. This structure could lead to incorrect or inefficient sequencing between collection of candidates and application of transfer/evolve/upgrade plans.\n  - The code was refactored so that the entire `work` logic (checking buddy, building keep/try_evolve/try_upgrade/buddy/favor lists, handling favorites, selecting buddy, etc.) is wrapped in a `for _ in itertools.repeat(None, 2)` loop. This ensures that the optimizer fully recomputes decisions twice, letting newly evolved low-value Pokemon be processed in the second pass.\n- Transfer safety configuration warning:\n  - Within the rules processing loop, the code now computes `check_top = rule.get(\"top\", \"all\")` and `check_keep = rule.get(\"keep\", True)`.\n  - If a rule has `top == \"all\"` (default), no names filter (`names == []`), and `keep` is true, the optimizer logs a warning block indicating that this rule will keep all Pokemon and hence not transfer anything, which is likely a misconfiguration.\n- Minor bug fixes:\n  - A Python syntax issue in the first version of the unfavor loop (`for pokemon in inventory.pokemons().all() if pokemon not in try_favor_all:`) was fixed by moving the condition into the body and using `if not pokemon in try_favor_all and pokemon.is_favorite:`.\n  - A wrong variable reference `rules.get(\"keep\", True)` was corrected to `rule.get(\"keep\", True)`.\n\nThe final result is a Pokemon Optimizer that:\n- Supports rule-based favorite management (both favoring and un-favoring).\n- Allows users to protect favorites from evolve/upgrade via configuration.\n- Provides event callbacks and human-like delays for favorite changes.\n- Logs when a rule would effectively prevent transfers.\n- Correctly repeats its optimization pass twice to clean up newly evolved low-value Pokemon.",
        "semantic_memory": "Generalizable lessons from this change focus on extending rule-based optimizers and safely handling stateful flags such as 'favorite' in an automation context.\n\n1. Treat new actions as first-class citizens in the rule system.\nWhen adding a new capability (like marking favorites), integrate it consistently with existing rule mechanisms:\n- Extend the scoring function to compute eligibility for the new action (e.g., `may_favor`) based on the same criteria system used for other actions.\n- Propagate this information through all helper methods (sorting, selection, multi-branch selection) so the new action participates uniformly in decision-making.\n- Aggregate action candidates in the main worker loop just as with existing actions.\n\n2. Centralize post-selection policy filters.\nRather than scattering checks throughout lower-level functions (e.g., skipping favorites at multiple points in evolution planning), it's often clearer and less error-prone to:\n- Compute a full candidate set based on scores and rules.\n- Apply policy filters (e.g., 'do not evolve favorites if `may_evolve_favorites` is false') in one place near where actions are finalized and executed.\nThis reduces duplication and makes configuration-driven behavior easier to reason about and modify.\n\n3. Separate desired state from current state to maintain invariants.\nFor reversible flags like 'favorite', determine the desired set from rules, then reconcile it with the current state:\n- Favor: `desired_favorites - current_favorites`.\n- Unfavorite: `current_favorites - desired_favorites` (if allowed by config).\nThis approach avoids incremental drift and ensures the system converges to rule-defined state after each run.\n\n4. Wrap external API side-effects with safety, events, and timing.\nWhen performing state-changing operations against an external service:\n- Check for success in the API response before mutating local state.\n- Provide structured events (e.g., `pokemon_favored`, `pokemon_unfavored`) with relevant metadata for logging/monitoring or other subsystems.\n- Add human-like random delays between actions (via `action_delay`) to reduce the risk of detection or rate-limiting and to simulate realistic behavior.\n\n5. Use repeated passes when actions change the optimization landscape.\nIf some actions (e.g., evolve) produce new entities that themselves need optimization (e.g., might be low-value and should be transferred), a single-pass optimizer may leave suboptimal remnants. A simple pattern is:\n- Run the full optimization pipeline repeatedly a limited number of times (e.g., 2 passes), so that newly created entities are re-evaluated under the same rules.\nThis avoids complex incremental logic while ensuring eventual cleanup.\n\n6. Provide configuration-level safety and diagnostics.\nOptimizers that can delete or transfer items should detect obviously harmful or confusing configurations and warn the user:\n- If a rule effectively keeps everything (e.g., `top = \"all\"`, empty name filters, and `keep = true`), log a clear warning that no transfers will occur.\n- This kind of check helps users diagnose 'why nothing is happening' and prevents silent misconfigurations from causing unexpected behavior.\n\n7. Avoid brittle inline filtering constructs.\nA bug surfaced from using a nonstandard inline `for` with a trailing condition in the `for` header. Using explicit loops with internal `if` statements improves clarity and prevents subtle syntax/logic errors.\n\nTaken together, these patterns support robust, maintainable design of rule-based automation systems that interact with remote APIs and user data, especially when adding new action types and configuration flags.",
        "procedural_memory": [
            "How to add a new rule-based action (like 'favorite') to an optimizer and keep behavior safe and predictable:",
            "Step 1: Extend configuration and documentation.",
            "- Add new config keys (e.g., `may_evolve_favorites`, `may_upgrade_favorites`, `may_unfavor_pokemon`, and a `favorite` rule block) with sensible defaults.",
            "- Update example configuration files to include the new options.",
            "- Update docs to describe the parameters, defaults, and behavioral notes (e.g., that favorites will not be evolved/upgraded when flags are false).",
            "",
            "Step 2: Load new config options in the worker/optimizer.",
            "- In the optimizer's initialization method, read the new config keys and store them in instance attributes (e.g., `self.config_may_evolve_favorites`).",
            "- Ensure defaults match the documented behavior.",
            "",
            "Step 3: Integrate the new rule into the scoring system.",
            "- In your `get_score` or equivalent method, read the new rule entry from the rule dict (e.g., `rule_favor = rule.get('favorite', False)`).",
            "- Determine whether a Pokemon may be a candidate for this new action using the existing requirement/satisfy logic (e.g., `may_favor = rule_favor not in [False, {}]` and `may_favor &= self.satisfy_requirements(pokemon, rule_favor)`).",
            "- Extend the per-Pokemon score/metadata tuple or object to include the new action flag (e.g., `may_favor`).",
            "- Update debug logging to show the new action flag for easier troubleshooting.",
            "",
            "Step 4: Propagate the new action through selection helpers.",
            "- Update helpers like `get_best_pokemon_for_rule`, `get_multi_best_pokemon_for_rule`, and `get_better_pokemon` to:\n  - Use the new score flag index (e.g., `p.__score__[5]`) to build a `favor` list.\n  - Return this list alongside existing lists (keep, try_evolve, try_upgrade, buddy).",
            "- Update callers to unpack and aggregate the new list (e.g., `keep, try_evolve, try_upgrade, buddy, favor`).",
            "",
            "Step 5: Aggregate and reconcile desired state in the main worker loop.",
            "- In the main `work` method:\n  - Initialize a collection for the new action (e.g., `favor_all = []`).\n  - For each rule, collect `favor` candidates and append them to `favor_all`.\n  - After processing rules, deduplicate using an existing helper (e.g., `try_favor_all = self.unique_pokemon_list(favor_all)`).",
            "- To un-favor, if allowed by config:\n  - Iterate over the entire inventory.\n  - For each Pokemon, if it's currently favorite and not in `try_favor_all`, add it to an `unfavor` list.",
            "- To favor:\n  - Filter `try_favor_all` to only those not already favorite.\n  - Execute favorite actions on this list.",
            "",
            "Step 6: Implement the side-effectful action handlers correctly.",
            "- For each new action (e.g., favor/unfavor), implement a dedicated method:\n  - Call the appropriate API endpoint (`set_favorite_pokemon`) with the correct parameters.\n  - Check the response for success (e.g., `result == 1`).\n  - Only then update local state (e.g., `pokemon.is_favorite = True/False`).\n  - Emit an event with structured data (name, IV, CP) for external consumers.\n  - Add a randomized delay (`action_delay(min, max)`) to throttle calls and mimic human behavior.",
            "",
            "Step 7: Apply centralized policy filters after planning.",
            "- After computing your full evolve/upgrade plans (e.g., `evolve_all`, `upgrade_all`):\n  - If `may_evolve_favorites` is false, filter out any Pokemon where `is_favorite` is true from `evolve_all`.\n  - If `may_upgrade_favorites` is false, similarly filter favorites from `upgrade_all`.\n  - Avoid duplicating favorite filters inside deeper planning methods; keep policy enforcement near the final action-application stage.",
            "",
            "Step 8: Handle repeated passes if actions change the optimization state.",
            "- If actions like evolve create new Pokemon that also need optimization, wrap the core optimization logic in a bounded loop:\n  - For example: `for _ in itertools.repeat(None, 2): run_full_optimization_pass()`.\n  - Within each pass, recompute keep/evolve/upgrade/favorite sets based on the latest inventory.",
            "",
            "Step 9: Add configuration-level safety checks and warnings.",
            "- Before applying rules, examine rule parameters for risky or surprising configurations, e.g.:\n  - If `top == 'all'`, `names` is empty, and `keep` is true, log a warning that this rule will prevent any transfers.\n  - Include the offending rule in the log to help the user diagnose configurational issues.",
            "",
            "Step 10: Test for and fix small but critical issues.",
            "- Verify loop constructs, especially when using inline ifs; prefer explicit loops with internal conditions to avoid syntax/logic errors.\n  - Check that variable names refer to the correct scope (`rule` vs `rules`).\n  - Confirm that favorite filtering logic, config flags, and event emission all behave as expected under different configurations (e.g., with/without un-favoring enabled, favorites allowed/disallowed for evolve/upgrade)."
        ]
    }
}
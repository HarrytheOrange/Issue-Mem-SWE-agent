{
    "search_index": {
        "description_for_embedding": "Refactor and bugfix for MoveToMapPokemon sniping: switch from PokemonGo-Map map_path/update_map to direct raw_data URL, validate external JSON and expiration, robustly handle missing encounter_id/spawnpoint_id, and prevent re-sniping the same Pokemon by caching inspected locations. Also restores unicode_literals import and updates logging color and config/docs.",
        "keywords": [
            "MoveToMapPokemon",
            "sniping",
            "PokemonGo-Map",
            "raw_data",
            "map_path deprecated",
            "update_map deprecated",
            "min_time deprecated",
            "encounter_id null",
            "spawnpoint_id null",
            "is_inspected cache",
            "duplicate sniping bug",
            "expiration check",
            "external API JSON parsing",
            "logging_handler color",
            "unicode_literals"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the MoveToMapPokemon sniping task was refactored and several bugs were addressed.\n\nPreviously, sniping used a `caught` list keyed by `encounter_id` and relied on PokemonGo-Map via an `address + map_path` combination and a separate `update_map` mechanism. This worked only when the external map data always had valid `encounter_id` and `spawnpoint_id` fields. When integrating with other crowd-based sources or newer PokemonGo-Map outputs, those IDs could be missing or null. As a result, the `was_caught` check (comparing encounter IDs) failed, so the same spawn could be targeted over and over again. Additionally, there was no robust expiration validation for non-social (URL-based) sources.\n\nThe refactor introduces a new URL-based flow (`get_pokemon_from_url`) that expects `config['address']` to point directly at a JSON endpoint (e.g. `http://localhost:5000/raw_data`) and deprecates both `map_path` and `update_map`. The code now:\n- Safely parses the external JSON, with clear error logging on connection or parse failure.\n- Normalizes nullable fields (`encounter_id`, `spawnpoint_id`, `iv`) and computes disappear times and names.\n- Filters out expired Pokemon and those not in the `catch` list unless they are VIPs.\n- Calculates distance and filters by `max_sniping_distance` and `max_walking_distance`, and by reachability based on mean walking speed.\n\nThe major behavioral change is around tracking which targets have been already inspected/attempted. Instead of `caught` keyed by `encounter_id`, the code now uses a `cache` of inspected Pokemon and a new `is_inspected` function that compares approximate latitude/longitude (rounded to 4 decimal places). This makes the cache robust even when IDs are missing or invalid. The `inspect` function appends a Pokemon to this cache (bounded at 200 entries) so that subsequent runs skip those coordinates. This is intended to fix the bug where the bot would repeatedly try to snipe the same target.\n\nIn the sniping flow (`snipe` method), the bot now:\n- Backs up the last position, locks heartbeats (`hb_locked`), and teleports to the Pokemon.\n- Optionally validates the existence of the target in the in-game cell data (`get_meta_cell`) when social sources are disabled, by scanning `wild_pokemons` and `catchable_pokemons`. If found, it updates missing IDs and disappear time.\n- Only proceeds to encounter and catch if the target is still present; otherwise, it logs that the Pokemon no longer exists, marks it as inspected in the cache, and returns.\n- Teleports back to the original position, resets API position, optionally calls `heartbeat()`, unlocks heartbeats, and returns success.\n\nConfiguration and documentation were updated to match this behavior:\n- The Sniping section is now labeled as `(MoveToMapPokemon)`.\n- `address` is documented as a direct source for Pokemon information, with PokemonGo-Map examples including `/raw_data` in the URL.\n- `map_path`, `min_time`, and `update_map` are deprecated/removed from examples.\n\nA small but important fix added back `from __future__ import unicode_literals` at the top of `move_to_map_pokemon.py` (fixing issue #5290, likely Python 2 unicode/logging issues), and the logging handler now colors `move_to_map_pokemon_teleport_to` messages yellow for better visibility.\n\nOverall, the incident was: sniping could repeatedly target the same spawn and was tightly coupled to a specific map backend. The fix: decouple from map_path/update_map, make URL consumption more generic and robust, add proper expiration and existence checks, and implement a location-based cache to avoid re-sniping the same coordinates.",
        "semantic_memory": "Generalizable lessons from this fix:\n\n1. **Do not rely solely on external IDs that may be missing or unstable.**\n   When integrating with third-party APIs (like crowd-sourced Pokemon maps), fields such as `encounter_id` or `spawnpoint_id` may be null, malformed, or change across versions. Using them as unique identifiers for caching and de-duplication can fail silently. Instead, combine more stable features (e.g., approximate latitude/longitude) or build a composite key. In this case, approximate coordinates are used to identify already-inspected targets.\n\n2. **Filter ephemeral resources by expiration and reachability.**\n   If the domain involves ephemeral entities (e.g., Pokemon that despawn, events that expire, time-limited offers), always check both:\n   - Whether the item is expired (current time vs. disappear/expiration time).\n   - Whether it is practically reachable given constraints (e.g., walking speed, max sniping/walking distance). This prevents the system from chasing targets that are already gone or impossible to reach in time.\n\n3. **Validate external data before acting.**\n   For expensive or disruptive operations (like teleporting, or performing a risky side effect), do a lightweight verification using authoritative data if available. Here, the bot teleports to the rough location, then checks live in-game cell data (`wild_pokemons` and `catchable_pokemons`) to confirm the target still exists before starting the encounter. This guards against stale third-party map data.\n\n4. **Use a dedicated cache of processed items to avoid repeated work.**\n   Maintaining a bounded cache (e.g., last N inspected items) and checking it via robust equality logic (`is_inspected`) is a simple but effective pattern to ensure idempotence and avoid reprocessing the same target, especially when inputs can be noisy or duplicated.\n\n5. **Keep configuration and documentation aligned with code behavior.**\n   When a feature changes from `address + map_path` to a single full URL field, or when options like `update_map` and `min_time` no longer apply, the configuration examples and docs must be updated simultaneously. Otherwise, users will misconfigure the system and experience failures or confusing behavior.\n\n6. **Graceful error handling for network and parse errors.**\n   When consuming JSON from external URLs, always catch connection errors and parsing errors separately and provide clear, actionable log messages (e.g., \"Could not get data from ...\" vs. \"Could not parse the JSON response. It might be related to a bad URL or JSON format.\"). This is broadly applicable to any service integration.\n\n7. **Refactor to centralize shared logic.**\n   The introduction of `pokemons_parser` consolidates all the filtering and normalization (VIP, catch list, distance, expiration, reachability) for both social and URL sources. Centralizing shared logic reduces duplication and the risk of divergent behavior between pathways.\n\n8. **Use configuration parameters consistently and cache them in the task.**\n   Reading frequently used configuration options (`snipe`, `snipe_sleep_sec`, debug flag) once during initialization and storing them as instance attributes simplifies the code and reduces repeated lookups. It also makes it easier to reason about the runtime behavior.\n\n9. **Small logging improvements can greatly help debugging.**\n   Coloring critical actions (like teleporting) and adding debug messages for skip reasons (e.g., \"Skipped X because it was already caught\", or because of distance limits) is a best practice to understand and debug complex decision logic in long-running agents.",
        "procedural_memory": [
            "How to diagnose and fix repeated processing of the same entity in a sniping / polling style task:",
            "Step 1: Identify symptoms and add targeted logging.",
            "  - Observe behavior: is the system repeatedly acting on the same target (e.g., same coordinates / same ID)?",
            "  - Add debug logs where decisions are made: when a target is skipped, when it is selected, and when it is marked as processed.",
            "  - Log key identifiers (ID, coordinates, name) and reasons for skips (already inspected, too far, expired).",
            "Step 2: Review the cache/de-duplication mechanism.",
            "  - Examine the functions that track processed items (e.g., `was_caught`, `is_inspected`, `inspect`).",
            "  - Verify what key(s) they use to determine uniqueness (encounter ID, coordinates, etc.).",
            "  - Check for cases where external data may not supply these keys (null IDs, missing fields, version changes in the external API).",
            "  - Validate that the function that *adds* entries to the cache actually runs and stores the current target; watch for early returns or incorrect arguments, such as calling `is_inspected` on a cached entry instead of the new target.",
            "Step 3: Choose a robust identity strategy.",
            "  - If IDs are unreliable or missing, use approximate coordinates (e.g., round latitude/longitude) or a composite key (e.g., floor(lat, 4 decimals) + floor(lon, 4 decimals) + species ID).",
            "  - Implement a helper like `is_inspected(pokemon)` that uses this strategy.\n  - Apply the check before acting on the target, and ensure successful processing calls an `inspect`/`mark_processed` function to store it.",
            "Step 4: Enforce expiration and reachability.",
            "  - For each target, compute its `disappear_time`/expiration from incoming fields and the current time.",
            "  - Drop any entries where `now > disappear_time`.",
            "  - Calculate distance from the current position and use configured thresholds (e.g., `max_sniping_distance`, `max_walking_distance`).",
            "  - For movement-based systems, estimate whether the target can be reached before expiration using mean speed and bail out early if not.",
            "Step 5: Validate external data before costly actions.",
            "  - For operations like teleporting, use a two-stage approach:\n    - Stage 1: Use the external data (e.g., map API) to plan.\n    - Stage 2: After moving into proximity, query an authoritative source (e.g., live game API or internal service) to confirm the target still exists.",
            "  - Only then perform expensive actions (encounter/capture). If not found, mark the target as inspected and skip.",
            "Step 6: Harden external API integration.",
            "  - Wrap HTTP calls in try/except and handle `ConnectionError` separately from JSON parse errors.",
            "  - Provide clear error messages (e.g., \"Could not get data from {url}\" vs. \"Could not parse the JSON response. It might be related to a bad URL or JSON format.\").",
            "  - Normalize nullable fields (e.g., treat missing `iv`, `encounter_id`, `spawnpoint_id` gracefully) and set defaults where reasonable.",
            "Step 7: Centralize common parsing/filtering logic.",
            "  - Extract shared logic for filtering targets (VIPs, catch list, distance, expiration, reachability) into a single function (e.g., `pokemons_parser`).",
            "  - Reuse this function for all data sources (social feeds, URL-based feeds) to ensure consistent behavior and easier maintenance.",
            "Step 8: Update configuration and documentation together.",
            "  - When changing how endpoints are specified (e.g., from `address + map_path` to a single full URL), update config examples and docs immediately.",
            "  - Deprecate or remove unused options (e.g., `map_path`, `update_map`, `min_time`) and clearly note this in documentation to prevent misconfiguration.",
            "Step 9: Verify unicode and logging behavior in mixed Python environments.",
            "  - For Python 2 compatibility, ensure `from __future__ import unicode_literals` is present when dealing with potentially non-ASCII text in logs or configuration.",
            "  - Adjust logging handlers (e.g., color mapping) to highlight critical actions, which helps future debugging and monitoring.",
            "Step 10: Regression test the whole flow.",
            "  - Run scenarios with and without social sources, with valid and invalid external data, and with missing IDs to ensure the cache and filters behave correctly.",
            "  - Confirm that once a target is processed, it no longer appears as a candidate, and that expired or unreachable targets are consistently ignored."
        ]
    }
}
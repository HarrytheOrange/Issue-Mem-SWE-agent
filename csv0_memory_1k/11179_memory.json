{
    "search_index": {
        "description_for_embedding": "Home Assistant Samsung TV integration fix: previous status polling sent a dummy key command over the websocket remote, which could wake up newer Samsung TVs and turn them on unintentionally during periodic checks. The change adds an optional get_status_via_rest flag that, for websocket-based TVs, queries the TV's REST endpoint (/api/v2/) with an HTTP GET to infer power state without sending any remote key commands, avoiding accidental wake-ups.",
        "keywords": [
            "home-assistant",
            "samsungtv",
            "media_player",
            "device status polling",
            "REST endpoint",
            "websocket",
            "dummy command",
            "wake up issue",
            "requests.get",
            "/api/v2/",
            "CONF_TIMEOUT",
            "get_status_via_rest",
            "side-effect free health check"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant Samsung TV media_player integration, status checks were implemented by sending an empty key command ('KEY') via the samsungctl remote. On newer Samsung TV models that use the websocket protocol, this dummy command could actually wake the TV and fully turn it on. This was particularly problematic when the TV briefly woke its network interface to check for updates: if Home Assistant happened to poll status during that window, the dummy key press would promote that transient state into a full ON state, disrupting users.\n\nTo address this, the PR introduced an optional configuration flag get_status_via_rest. When enabled, and when the TV is using the 'websocket' control method, the integration no longer sends a dummy remote key during update(). Instead, it calls a new helper method _update_status_via_rest(), which sends an HTTP GET request to the TV's REST endpoint at http://<host>:<port>/api/v2/ using the requests library with a 5-second timeout. If the request succeeds with HTTP 200, the TV state is set to STATE_ON; any timeout, connection error, HTTP error, or non-200 response results in STATE_OFF.\n\nThe configuration schema was extended to include CONF_STATUS_VIA_REST ('get_status_via_rest', default False) and to reuse CONF_TIMEOUT from homeassistant.const instead of redefining it locally. Device setup now passes the status_via_rest flag through to the SamsungTVDevice constructor. A small follow-up change renamed the private method from _update_status_via_rest_endpoint to _update_status_via_rest and removed the unused **kwargs parameter from requests.get to satisfy linting.\n\nAlthough the PR was ultimately closed in core with the note that REST logic should be moved into the underlying samsungctl library, the technical solution demonstrates how to switch from a command-based status check to a REST-based one to avoid side effects on the device.",
        "semantic_memory": "This incident illustrates a common issue in integrations with external devices: status polling that relies on sending control commands can cause unintended side effects, such as waking a device or changing its state. Health checks and presence detection should be designed to be as non-intrusive as possible.\n\nKey generalizable concepts:\n- **Side-effect-free status checks:** Avoid using actual control commands (e.g., key presses, power toggles) to determine whether a device is online or turned on. Prefer passive mechanisms such as pinging a known REST endpoint, reading a status API, or using discovery protocols that do not alter device state.\n- **Use device-native status APIs:** Many modern devices expose HTTP or REST endpoints (like Samsung TV's /api/v2/) that can be polled to infer power/network status. These should be preferred to synthetic commands, especially for newer models with more sensitive power management behavior.\n- **Make behavioral changes opt-in:** When changing how status is determined—especially if behavior differs across device models or firmware versions—gate new logic behind an explicit configuration flag (e.g., get_status_via_rest) with a sensible default. This lets users who experience issues adopt the new behavior without impacting others.\n- **Error handling for network checks:** When probing status via HTTP, treat connection errors, timeouts, and HTTP errors as the device being unavailable or OFF, and use conservative timeouts to avoid blocking the main loop.\n- **Push protocol logic down into libraries:** For maintainability and reuse, protocol-specific behavior (like how to check a Samsung TV’s status) is often better placed in the vendor-specific library (samsungctl) rather than scattered in the application layer.\n\nOverall, the fix emphasizes designing monitoring logic that does not inadvertently control the device, and properly separating configuration, error handling, and protocol details.",
        "procedural_memory": [
            "When status polling turns devices on or changes their state, redesign health checks to use passive, side-effect-free mechanisms such as REST endpoints or network presence checks.",
            "Step 1: Reproduce and characterize the issue\n- Observe under what circumstances a device is unintentionally turned on or otherwise affected by status checks.\n- Add logging around the integration’s update/polling method to see what commands or network calls are made during each poll.\n- Confirm whether the polling mechanism (e.g., a dummy remote command) correlates with the device waking up or changing state.",
            "Step 2: Inspect the existing polling mechanism\n- Locate the integration’s update or status-checking function (e.g., update() in the media_player or device class).\n- Identify whether status is inferred by sending a control command such as a key press, power toggle, or any other active operation.\n- Check what protocol or method is being used (e.g., websocket vs. legacy TCP) and whether behavior differs across methods or device models.",
            "Step 3: Research device capabilities for passive status detection\n- Consult the device’s documentation or reverse-engineered knowledge to find existing REST or HTTP endpoints, SSDP/UPnP services, or other APIs that report status without changing state.\n- For Samsung TVs using the websocket method, identify the REST endpoint /api/v2/ that indicates the TV’s active status.\n- Validate manually with curl or a browser (e.g., curl http://<host>:<port>/api/v2/) to see the response codes and behavior when the TV is ON vs OFF.",
            "Step 4: Design an opt-in configuration option\n- Add a new configuration flag (e.g., get_status_via_rest) with a default of False to avoid changing behavior for all users.\n- Extend the platform or integration schema to validate this flag (using the framework’s config validation utilities) and pass it through to the device class constructor.\n- Decide under which conditions the new method should be used (e.g., only for websocket-based TVs).",
            "Step 5: Implement a REST-based status check\n- Import an HTTP client (e.g., requests) in the module where the status check is implemented.\n- Implement a helper method that builds the appropriate URL (e.g., http://{host}:{port}/api/v2/) from the existing device configuration.\n- Perform a GET request with a reasonable timeout (e.g., 5 seconds), catching exceptions such as Timeout, ConnectionError, HTTPError, and ReadTimeout.\n- Interpret a successful HTTP 200 response as the device being ON; treat exceptions or non-200 codes as OFF or unavailable.\n- Ensure the method only updates internal state (e.g., self._state = STATE_ON/OFF) and does not send any control commands.",
            "Step 6: Integrate the new status logic into update()\n- In the device’s update() method, branch based on the configuration flag and any relevant protocol/method indicators.\n- If the flag is enabled and conditions are met (e.g., method == 'websocket'), call the REST-based status method; otherwise, fall back to the original behavior (e.g., send_key('KEY')).\n- Keep the branch minimal, ensuring that the rest of the update flow remains the same to reduce regression risk.",
            "Step 7: Handle errors and transient states thoughtfully\n- Decide how to treat brief periods where the device responds to the REST endpoint (e.g., during self-initiated update checks) even when the user perceives it as OFF.\n- Document that the device might appear ON for a few seconds during such checks, but the integration will reset the state to OFF shortly afterward.\n- Avoid adding new behavior that can actively change device power state during these transient windows.",
            "Step 8: Refine and align with architecture best practices\n- Consider moving the REST-based status logic into the underlying transport or device library (e.g., samsungctl), so all consumers benefit and behavior is centralized.\n- Ensure that new dependencies (like requests) are justified and compatible with project policies; if necessary, inject HTTP functionality via the existing framework utilities instead of adding new dependencies.\n- Run the test suite (e.g., tox) and fix linting issues such as unused parameters or method naming inconsistencies.",
            "Step 9: Document configuration and behavior for users\n- Update user-facing documentation to describe the new configuration option (get_status_via_rest), including when it should be enabled and any known caveats.\n- Provide example configuration snippets (e.g., in configuration.yaml) demonstrating how to enable the REST-based status check for supported devices.\n- Explain that the purpose is to avoid waking newer Samsung TVs during polling, and that the feature is optional."
        ]
    }
}
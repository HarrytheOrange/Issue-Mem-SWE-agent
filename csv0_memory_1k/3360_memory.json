{
    "search_index": {
        "description_for_embedding": "Home Assistant device_tracker Automatic integration was not polling vehicle/trip data correctly. The platform incorrectly used a scanner-style interface without being polled by Home Assistant. The fix refactors it to schedule periodic updates internally using track_utc_time_change and the setup_scanner pattern, removes unused scanner methods, and adjusts tests accordingly.",
        "keywords": [
            "homeassistant",
            "device_tracker",
            "automatic",
            "AutomaticDeviceScanner",
            "polling not working",
            "no automatic updates",
            "track_utc_time_change",
            "time-based callback",
            "setup_scanner",
            "scan_devices removed",
            "get_device_name removed",
            "integration patterns",
            "scheduler bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant `device_tracker.automatic` platform was reported as not polling correctly: users were not seeing up-to-date location data from their Automatic devices. The root cause was an architectural mismatch: the platform implemented `setup_scanner` (the pattern for self-managed tracking) but still behaved like a 'scanner' object that Home Assistant would poll via `scan_devices()`. Because `setup_scanner`-style platforms are expected to schedule their own updates and call `see()`, the Automatic integration ended up not being polled as expected.\n\nTo fix this, the developer refactored the integration so that `AutomaticDeviceScanner` no longer exposes `scan_devices` or `get_device_name` as public scanner APIs. Instead, in the constructor of `AutomaticDeviceScanner`, it performs an initial `_update_info()` and then registers a periodic callback with `track_utc_time_change(hass, self._update_info, second=range(0, 60, 30))`, causing `_update_info` to run every 30 seconds. `_update_info` refreshes the Automatic API token, fetches vehicles and trips from Automatic's APIs, and calls the `see()` callback to update Home Assistant's device tracker state.\n\nThe setup function `setup_scanner` was updated to accept a `hass` instance, construct `AutomaticDeviceScanner(hass, config, see)`, and rely entirely on its internal scheduling. The earlier attempts using `track_point_in_utc_time`, manual recursion, and `Throttle` were removed in favor of the simpler `track_utc_time_change` approach. Logging in `_update_info` was downgraded from info to debug to avoid noisy logs.\n\nTests were updated to create a real test Home Assistant instance (`get_test_home_assistant`) and pass it into `setup_scanner` and the scanner constructor. The test that depended on the now-removed `get_device_name` API was deleted, and imports were cleaned up accordingly. After these changes, the Automatic device tracker polls on its own schedule and correctly updates entities in Home Assistant.",
        "semantic_memory": "This fix illustrates several generalizable patterns for event-driven architectures and Home Assistant integrations:\n\n1. **Use the appropriate integration pattern for polling vs. self-managed updates**: In Home Assistant's `device_tracker` component, there are two main patterns:\n   - Platforms that provide `get_scanner(...)` and a scanner object with `scan_devices()` are polled by Home Assistant on a global schedule.\n   - Platforms that define `setup_scanner(hass, config, see)` are responsible for scheduling their own updates (polling or push) and must call `see()` when new data is available.\n   Mixing these patterns (e.g., implementing `setup_scanner` but still assuming Home Assistant will call `scan_devices()`) leads to integrations that silently never update.\n\n2. **Schedule periodic tasks with the framework's event helpers instead of manual recursion**: Home Assistant provides helpers like `track_utc_time_change` to schedule recurring callbacks. Using these helpers:\n   - Makes the behavior consistent and testable.\n   - Avoids subtle bugs from manual `track_point_in_utc_time` recursion or misusing throttling decorators.\n   - Ensures the callback signature matches what the scheduler expects (e.g., including `now` parameter).\n\n3. **Avoid redundant throttling when scheduling at a fixed interval**: When a task is already run on a fixed schedule (e.g., every 30 seconds via `track_utc_time_change`), applying additional throttling decorators (`Throttle`) is usually unnecessary and can complicate reasoning about update timing.\n\n4. **Remove unused public APIs when refactoring integration behavior**: If the integration no longer uses scanner-style methods like `scan_devices` or `get_device_name`, those methods should be removed both from the code and from tests. Keeping unused public methods can encourage misuse or mask design issues.\n\n5. **Tests must reflect framework lifecycle patterns**: When the integration relies on `hass` and scheduled callbacks, tests should construct a `HomeAssistant` test instance and pass it into setup functions, rather than using `None` or stubs that don't trigger expected behavior.\n\nOverall, the lesson is that in a framework with multiple integration patterns, it is crucial to understand which lifecycle the framework expects for a given hook, and to implement scheduling and updates consistently with that choice.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom\n- Observe that an integration (e.g., a device tracker) initializes successfully but never updates data after startup.\n- Confirm via logs or UI that no periodic updates are occurring (no new API calls, no new state changes).",
            "Step 2: Verify which integration pattern the platform is using\n- Check whether the component implements `get_scanner(...)` or `setup_scanner(hass, config, see)`.\n- If `get_scanner` is implemented, Home Assistant will poll the returned scanner via `scan_devices()`.\n- If `setup_scanner` is implemented, the platform is responsible for scheduling its own updates and calling `see()` directly.",
            "Step 3: Check for mismatches between pattern and implementation\n- If the platform defines `setup_scanner` but also exposes `scan_devices()` and expects Home Assistant to call it, this is a red flag: Home Assistant will not poll it automatically.\n- Look for unused scanner-like methods (`scan_devices`, `get_device_name`) that are never referenced by the framework entry points.",
            "Step 4: Decide on the appropriate scheduling model\n- If the integration should self-manage updates (typical for `setup_scanner`), plan to:\n  - Call the update routine once during initialization, and\n  - Schedule periodic updates using the framework's event helpers (e.g., `track_utc_time_change`).\n- Choose an appropriate interval (e.g., every 30 seconds) based on API limits and UX requirements.",
            "Step 5: Implement periodic scheduling correctly\n- In the scanner class `__init__`, store `hass` and `see` references.\n- Implement an internal update method, e.g. `_update_info(self, now=None)`, that:\n  - Fetches data from the external service.\n  - Parses it and calls `self.see(...)` for each relevant device.\n- Register the update method with the framework scheduler:\n  - `track_utc_time_change(self.hass, self._update_info, second=range(0, 60, interval_in_seconds))` or similar.\n- Ensure the callback signature matches what the scheduler expects (e.g., include `now` parameter, even if unused).",
            "Step 6: Remove redundant or misleading APIs\n- If the platform no longer relies on Home Assistant calling `scan_devices()` or `get_device_name()`, remove these methods.\n- Clean up any tests or external references to these methods to avoid confusion.\n- If throttling decorators were used solely to control call frequency, remove them if the scheduler already enforces the interval.",
            "Step 7: Update and fix tests\n- Use a real test `HomeAssistant` instance (e.g., `get_test_home_assistant()`) in tests that call `setup_scanner` or instantiate the scanner.\n- Adjust tests to validate that setup succeeds/fails correctly based on config and HTTP responses.\n- Remove or rewrite tests that validate now-removed public APIs, such as `get_device_name`.",
            "Step 8: Validate behavior\n- Run the full test suite to ensure no regressions.\n- Manually verify in a dev environment that:\n  - The integration initializes without errors.\n  - The scheduler triggers the update function at the expected interval.\n  - Entities in Home Assistant update in near real time, matching the new polling schedule.\n- Adjust log levels (e.g., from `info` to `debug`) to avoid log spam while still allowing debugging if issues reoccur.",
            "Step 9: Document or comment on the chosen pattern\n- In code comments or documentation, clarify that the integration uses `setup_scanner` and self-managed scheduling.\n- Optionally link to framework docs or patterns so future maintainers understand why `scan_devices` is not implemented and where updates are triggered."
        ]
    }
}
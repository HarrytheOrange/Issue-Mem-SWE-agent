{
    "search_index": {
        "description_for_embedding": "Home Assistant Pocket Casts sensor was using a GitHub-zip dependency (python-pocketcasts) that wasn’t on PyPI, causing dependency/installation problems. The fix switches to a proper PyPI package (pocketcasts-api==0.2.2) and updates the integration to use the new library’s API (Pocketcasts class, get_subscribed_podcasts, get_new_releases).",
        "keywords": [
            "homeassistant",
            "home assistant",
            "pocketcasts",
            "pocketcasts-api",
            "python-pocketcasts",
            "sensor.pocketcasts",
            "PyPI dependency",
            "requirements_all.txt",
            "GitHub zip requirement",
            "library API change",
            "dependency resolution",
            "installation failure",
            "integration breakage"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Pocket Casts sensor component depended on a library pulled directly from a GitHub repository (python-pocketcasts) via a zip URL pinned to a specific commit. This non-PyPI dependency caused problems with dependency management and installation in the Home Assistant ecosystem, which expects stable, versioned packages from PyPI and centralized tracking in requirements_all.txt. A PyPI-published alternative library, pocketcasts-api, became available. The fix updated the Pocket Casts sensor to require pocketcasts-api==0.2.2 instead of the GitHub zip URL. Because the new library exposed a different API, the integration’s code was updated accordingly: it now imports and instantiates pocketcasts.Pocketcasts instead of pocketcasts.Api, uses api.get_subscribed_podcasts() instead of api.my_podcasts(), and uses api.get_new_releases() instead of api.new_episodes_released(). requirements_all.txt was updated to remove the GitHub archive URL and add a normal PyPI requirement (pocketcasts-api==0.2.2) under the sensor.pocketcasts section. The overall behavior of the integration remains the same from a user perspective (counting subscribed podcasts and new releases), but the dependency is now a standard PyPI package, which should resolve dependency-management issues and align with project standards.",
        "semantic_memory": "This case illustrates several general principles about dependency management and third-party API evolution in integrations:\n\n1. **Prefer PyPI packages over GitHub zip URLs**: Depending on raw GitHub archives (e.g., specific commit zip URLs) is fragile and can cause installation, caching, and reproducibility issues, especially in ecosystems with centralized requirement management like Home Assistant. When a proper PyPI package becomes available, it is better to switch to that package, pin a version, and track it in the global requirements list.\n\n2. **Pin versions for third-party libraries**: Explicit version pinning (e.g., `pocketcasts-api==0.2.2`) helps ensure consistent behavior across environments and avoids unexpected breakage when upstream libraries change.\n\n3. **Update integration code when swapping libraries or versions**: Even if two libraries provide similar functionality, their class and method names often differ. Updating the dependency requires a careful review of the integration’s usage: constructors, method names, return types, and error handling. In this case, switching from `Api` to `Pocketcasts`, and from `my_podcasts()`/`new_episodes_released()` to `get_subscribed_podcasts()`/`get_new_releases()` was necessary.\n\n4. **Keep centralized dependency declarations in sync**: In large projects, there is usually a central list of dependencies (like Home Assistant’s `requirements_all.txt`). When updating a component-level `REQUIREMENTS` constant, you must also update the central list to include the same library and version, and remove obsolete references.\n\n5. **Stable public APIs matter for integrations**: When choosing or switching libraries, prefer ones with stable, documented APIs on PyPI. That reduces future breakage and makes it easier to maintain integrations.\n\n6. **Changes should preserve user-facing behavior**: Even when refactoring dependencies, the integration should preserve its external contract (configuration schema, entity behavior) unless there’s a good reason to change it. Here, the internal API calls changed, but the Home Assistant sensor still exposed the same conceptual state: the number of new Pocket Casts episodes.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify dependency-related symptoms.\n- Look for installation or CI failures mentioning inability to fetch or install a dependency.\n- Check for non-PyPI dependencies: GitHub zip URLs, local paths, or unpinned versions in the component’s REQUIREMENTS and in any global requirements files.\n- In Home Assistant-like projects, verify that `requirements_all.txt` or equivalent lists the dependency consistently.",
            "Step 2: Search for a proper PyPI package.\n- Go to PyPI (https://pypi.org) and search for the library or related functionality.\n- Confirm the package is actively maintained and has a suitable license.\n- Check the documentation for the public API (classes, methods, and expected behavior).",
            "Step 3: Plan the migration from the old library to the new PyPI package.\n- Compare the old library’s API with the new one: class names, constructor signatures, method names, and return types.\n- Identify every usage of the old library in your integration or component.\n- Map old calls to new calls (e.g., `Api` → `Pocketcasts`, `my_podcasts()` → `get_subscribed_podcasts()`, `new_episodes_released()` → `get_new_releases()`).",
            "Step 4: Update dependency declarations.\n- In the component/module, change the REQUIREMENTS (or equivalent) from the GitHub zip URL to a proper PyPI specifier, pinned to a specific version (e.g., `pocketcasts-api==0.2.2`).\n- In the project’s central requirements file (e.g., `requirements_all.txt`), remove the old GitHub archive URL and add the new PyPI package line, including a comment indicating which component uses it.\n- Ensure there are no lingering references to the old library name or URLs.",
            "Step 5: Update the integration code to match the new library’s API.\n- Adjust imports to use the new package name.\n- Replace old class instantiations with the new class (e.g., `pocketcasts.Api(...)` → `pocketcasts.Pocketcasts(...)`).\n- Replace old method calls with their new equivalents (e.g., `api.my_podcasts()` → `api.get_subscribed_podcasts()`, `api.new_episodes_released()` → `api.get_new_releases()`).\n- Confirm that any logging or state updates still reflect the right semantics (e.g., counting new episodes correctly).",
            "Step 6: Validate error handling and behavior.\n- Check the new library’s documentation for exceptions it may raise (e.g., network or auth errors) and ensure they are handled appropriately (e.g., catching `OSError` or library-specific exceptions).\n- Confirm that API calls happen in the right place (e.g., within `update()` methods for sensors) and that the entity state is updated based on the new methods’ return values.",
            "Step 7: Run and fix tests, then add or update tests if needed.\n- Run the project’s test suite (e.g., `tox` for Home Assistant) to catch regressions.\n- If the integration had unit tests referencing the old API, update them to use the new class and method names.\n- Add tests that verify the integration can instantiate the new client and correctly process its responses into entity state.",
            "Step 8: Manually verify the integration (if possible).\n- In a development environment, configure the integration with valid credentials.\n- Check logs to ensure the client is initialized successfully and that methods like `get_subscribed_podcasts()` and `get_new_releases()` return expected data.\n- Confirm that entities in the UI (e.g., sensors) show the correct state (e.g., number of new Pocket Casts episodes).",
            "Step 9: Document the change.\n- If user-facing behavior or configuration has changed, update the documentation.\n- For purely internal dependency changes (like this one), note in the changelog or PR description that the component’s library was switched and that the behavior is intended to remain the same.",
            "Step 10: Monitor after deployment.\n- After merging and releasing, watch for bug reports related to the updated integration.\n- If users report issues, compare their environment (library versions, logs) against the expected dependency (e.g., `pocketcasts-api==0.2.2`) and adjust or pin versions further if needed."
        ]
    }
}
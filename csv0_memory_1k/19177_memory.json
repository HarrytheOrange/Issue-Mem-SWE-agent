{
    "search_index": {
        "description_for_embedding": "Refactor of Home Assistant ZHA entities to centralize Zigbee ZCL attribute reporting configuration via a common async_configure method and a zcl_reporting_config mapping. Removes per-platform ad-hoc configure_reporting calls, introduces reporting-interval constants, supports manufacturer-specific clusters, and standardizes how entities bind clusters and configure attribute reporting on new Zigbee joins.",
        "keywords": [
            "ZHA",
            "Zigbee",
            "ZCL",
            "attribute reporting",
            "async_configure",
            "zcl_reporting_config",
            "configure_reporting",
            "REPORT_CONFIG_DEFAULT",
            "manufacturer_code",
            "cluster binding",
            "OnOff cluster",
            "LevelControl cluster",
            "Home Assistant",
            "binary_sensor zha",
            "light zha",
            "sensor zha",
            "switch zha",
            "fan zha",
            "refactor",
            "magic numbers removal"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the ZHA integration in Home Assistant was improved by introducing a centralized mechanism to manage Zigbee ZCL attribute reporting configuration for entities.\n\nOriginally, each platform (binary_sensor, switch, light, fan, sensor) manually configured attribute reporting by directly calling helpers.configure_reporting in their setup logic, typically only when a device newly joined the network. These calls duplicated logic (e.g., min/max report intervals and reportable change), used magic numbers for reporting intervals, and required each platform to understand cluster and attribute IDs. There was also no unified way to handle manufacturer-specific clusters during reporting configuration.\n\nTo address this, a new async_configure method was added to the base ZhaEntity class (homeassistant/components/zha/entities/entity.py). Entities now describe their ZCL attribute reporting needs through a zcl_reporting_config property, a dict that maps a cluster identifier (cluster class, instance, numeric ID, or endpoint attribute name) to per-attribute reporting tuples (min_interval, max_interval, reportable_change). The ZhaEntity.async_configure method iterates this configuration, resolves the cluster via a helper (_get_cluster_from_report_config), determines whether a manufacturer code is needed for manufacturer-specific clusters (cluster_id >= 0xfc00), and then calls helpers.configure_reporting with appropriate parameters. It also uses a small randomized sleep between reporting setup calls to avoid hammering the device.\n\nEach platform was updated to leverage this new mechanism:\n- binary_sensor Remote: now builds a _zcl_reporting dict for OnOff and LevelControl out clusters and exposes it via zcl_reporting_config; the previous direct configure_reporting calls in _async_setup_remote were removed in favor of remote.async_configure().\n- ZhaFan: added value_attribute, a cluster property, and a zcl_reporting_config that configures fan_mode reporting. New joins call fan.async_configure(). Attribute reporting is now also used to update state via attribute_updated.\n- Light: defines zcl_reporting_config for on_off, level, and light_color clusters with reporting constants; new joins call light.async_configure().\n- Sensor: now wraps its primary input cluster in a cluster property, defines reporting parameters via constants and a report_config tuple, and exposes them through zcl_reporting_config. async_configure is used for new joins rather than direct configure_reporting.\n- Switch: introduces a cluster property and zcl_reporting_config for the on_off attribute, replacing ad-hoc configure_reporting calls.\n\nAdditionally, reporting configuration constants (e.g., REPORT_CONFIG_DEFAULT, REPORT_CONFIG_IMMEDIATE, REPORT_CONFIG_ASAP, REPORT_CONFIG_OP, REPORT_CONFIG_BATTERY_SAVE, and their underlying interval/change values) were added to zha.const to remove magic numbers and standardize reporting behavior. helpers.configure_reporting was updated to use these constants as defaults and to accept an optional manufacturer parameter, which is passed through to cluster.configure_reporting.\n\nThe net effect is a cleaner, more maintainable, and more extensible ZHA reporting configuration flow: all ZCL reporting is described declaratively on each entity, executed centrally in async_configure, uses sensible shared defaults, and correctly handles manufacturer-specific clusters.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices for protocol integrations and event/reporting configuration:\n\n1. **Centralizing configuration logic**: Instead of scattering protocol-specific configuration calls (like ZCL configure_reporting) across multiple components, define a common method in a shared base class (async_configure) and a declarative configuration surface (zcl_reporting_config). This reduces duplication, simplifies updates, and ensures consistent behavior across entity types.\n\n2. **Declarative over imperative configuration**: Represent reporting requirements as data (a dict mapping cluster keys to attribute reporting tuples) rather than baked-in imperative calls. This makes configuration easier to reason about, test, and extend, and enables generic processing logic in a single place.\n\n3. **Type-flexible configuration keys**: Allow multiple key forms (cluster class, cluster instance, numeric cluster_id, and endpoint attribute name) in configuration, then normalize them in a resolver (_get_cluster_from_report_config). This gives flexibility to callers while keeping the core logic uniform.\n\n4. **Use of shared constants instead of magic numbers**: Extract common timing and reporting thresholds into named constants (e.g., REPORT_CONFIG_DEFAULT, REPORT_CONFIG_IMMEDIATE, REPORT_CONFIG_ASAP, REPORT_CONFIG_OP, REPORT_CONFIG_BATTERY_SAVE). This clarifies intent (e.g., \"immediate\" vs \"battery save\" reporting), avoids hard-to-maintain literals, and allows system-wide tuning from a single place.\n\n5. **Protocol-specific nuances encapsulation**: The logic for manufacturer-specific clusters (cluster_id >= 0xfc00) and passing manufacturer codes to configure_reporting is encapsulated in the base entityâ€™s async_configure logic. Consumers of this API just set manufacturer_code on the entity; they do not need to know the low-level details.\n\n6. **Rate limiting of configuration operations**: When configuring multiple attributes/clusters, adding short randomized delays between operations (sleep(uniform(...))) helps avoid overloading devices or the network. This pattern is important when performing batch configuration on constrained IoT devices.\n\n7. **Single entry point for new device setup**: Using an async_configure lifecycle hook for entities created on new device joins provides a consistent place to apply initial binding and reporting configuration. Each platform simply calls entity.async_configure() instead of re-implementing setup logic.\n\nThese patterns are broadly applicable to other integrations that must configure subscriptions, reporting, or notifications on remote systems or devices.",
        "procedural_memory": [
            "To diagnose and refactor scattered protocol reporting configuration into a centralized, maintainable flow, follow these steps:",
            "Step 1: Identify duplicated configuration calls.",
            "Search the codebase for repeated calls to the underlying reporting/subscription API (e.g., configure_reporting, subscribe, bind). Note which components or entity types are making similar calls with slightly different parameters or hard-coded values.",
            "Step 2: Define a declarative configuration structure.",
            "Design a data structure that can fully describe what needs to be configured. In this case, use a mapping from a cluster identifier (class, instance, ID, or attribute name) to another mapping of attribute identifiers to a (min_interval, max_interval, reportable_change) tuple. Ensure it is flexible enough to accept multiple key types and future extensions (e.g., manufacturer_id).",
            "Step 3: Add a common configuration method in a shared base class.",
            "In the base entity class, implement a method like async_configure that reads the declarative configuration (e.g., zcl_reporting_config), resolves any abstract keys into concrete cluster instances, determines additional parameters (such as manufacturer code for manufacturer-specific clusters), and calls the low-level helper (configure_reporting or equivalent). Include appropriate logging and error handling.",
            "Step 4: Implement a robust key-to-resource resolver.",
            "Create a helper method (e.g., _get_cluster_from_report_config) that can interpret different forms of keys: instances, classes, IDs, and attribute names. This function should return the correct cluster object or resource handle, encapsulating the resolution logic in one place.",
            "Step 5: Introduce shared constants for timing and thresholds.",
            "Extract commonly used numeric parameters into named constants (e.g., REPORT_CONFIG_MIN_INT, REPORT_CONFIG_MAX_INT, REPORT_CONFIG_RPT_CHANGE, and composed presets like REPORT_CONFIG_DEFAULT, REPORT_CONFIG_IMMEDIATE, REPORT_CONFIG_ASAP). Update the low-level helper (configure_reporting) to use these constants as defaults and adjust all callers to refer to the constants instead of raw numbers.",
            "Step 6: Update each entity type to declare zcl_reporting_config.",
            "For each platform-specific entity (binary_sensor, light, sensor, switch, fan, etc.), add a zcl_reporting_config property (or equivalent) that returns the relevant reporting configuration. Prefer referencing clusters via a property (self.cluster) or endpoint attributes and use the reporting constants to specify intervals and changes.",
            "Step 7: Wire async_configure into the entity lifecycle.",
            "In setup or discovery logic, especially for newly joined devices, call entity.async_configure() instead of directly invoking configure_reporting. This ensures all configuration goes through the centralized pipeline. For existing devices, you may choose whether to re-run configuration depending on migration needs.",
            "Step 8: Handle protocol-specific special cases centrally.",
            "Within async_configure or the helper functions, implement special-case logic such as detecting manufacturer-specific clusters (e.g., cluster_id >= 0xfc00) and applying manufacturer codes or other flags as needed. This keeps protocol details out of platform-specific entity code.",
            "Step 9: Add gentle rate limiting.",
            "When configuring multiple attributes/clusters in a loop, insert small, randomized delays (e.g., sleep(uniform(0.1, 0.5))) between configuration calls to avoid network or device overload, particularly in IoT and wireless environments.",
            "Step 10: Test end-to-end behavior on real devices.",
            "Verify that new devices correctly bind and start delivering attribute reports according to the desired intervals and thresholds. Confirm that state updates are driven by attribute reports (via attribute_updated handlers) and that polling can be minimized or disabled where appropriate. Adjust constants or configuration for specific device classes (e.g., battery-powered sensors) based on observed performance."
        ]
    }
}
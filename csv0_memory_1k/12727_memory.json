{
    "search_index": {
        "description_for_embedding": "Home Assistant Freebox device tracker added and migrated from a synchronous, throttled polling model using freepybox to an asynchronous model using aiofreepybox. Fixed a 'coroutine was never awaited' issue caused by wrapping an async update function with a non-async Throttle decorator and scheduling it via async_track_time_interval. The final solution uses async_setup_scanner, async_track_time_interval, async_see, and explicit minimum polling intervals instead of Throttle.",
        "keywords": [
            "Home Assistant",
            "device_tracker",
            "Freebox",
            "freepybox",
            "aiofreepybox",
            "async_setup_scanner",
            "async_track_time_interval",
            "async_see",
            "coroutine was never awaited",
            "Throttle decorator",
            "asyncio",
            "discovery",
            "netdisco",
            "polling interval",
            "MIN_TIME_BETWEEN_SCANS"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, a new Home Assistant device_tracker platform for Freebox routers was implemented. The initial version used the synchronous freepybox library and Home Assistant's DeviceScanner abstraction, with a _update_info method decorated by Throttle to enforce MIN_TIME_BETWEEN_SCANS. Later the author added support for automatic setup via discovery, wiring Freebox into Home Assistant's discovery system and using setup_scanner with track_time_interval and the see callback.\n\nTo better fit Home Assistant's async architecture and because the original upstream library was not updated, the author created and published aiofreepybox, an asynchronous Freebox API client, and rewrote the integration to be fully async. The component switched from setup_scanner to async_setup_scanner, from track_time_interval to async_track_time_interval, and from a synchronous see to an async_see. A FreeboxDeviceScanner class now wraps an aiofreepybox.Freepybox instance and exposes async_start and async_update_info methods. async_start performs an initial update, then schedules recurring updates via async_track_time_interval, enforcing a minimum scan interval by taking max(user_interval, MIN_TIME_BETWEEN_SCANS).\n\nDuring this migration, the author hit a 'coroutine was never awaited' warning. Investigation showed that using the Throttle decorator on an async method caused it to become a non-coroutine function: asyncio.iscoroutinefunction returned False for the bound method. When scheduled via async_track_time_interval (or async_add_job), Home Assistant treated it as a regular callable and ran it in an executor instead of awaiting it, leading to the 'never awaited' warning. The fix was to remove Throttle entirely and instead control request frequency via the polling interval (using max(configured_scan_interval, MIN_TIME_BETWEEN_SCANS)). The asynchronous update function async_update_info is now awaited correctly by async_track_time_interval and no longer wrapped by Throttle.\n\nThe final async implementation opens the aiofreepybox connection, calls lan.get_hosts_list(), filters for active devices, and calls async_see(mac=..., host_name=...) for each device via asyncio.wait. Errors from the Freebox API are handled using aiofreepybox.exceptions.HttpRequestError with a logged exception. The component also supports network discovery via netdisco: when discovery_info is present, it fills host and port from the discovered api_domain and https_port. The Windows-specific asyncio Proactor AssertionError the author observed turned out not to be caused by this code, as it disappeared under Ubuntu and was unrelated to the 'coroutine was never awaited' issue.",
        "semantic_memory": "1. **Avoid mixing non-async decorators with async functions in asyncio frameworks**: Decorators like Home Assistant's Throttle are often built for synchronous functions. Applying them directly to async functions can turn a coroutine into a regular callable, breaking the assumptions of async schedulers (eg, async_track_time_interval) and causing 'coroutine was never awaited' warnings. In such async contexts, it's usually better to enforce throttling via the scheduler (eg, by choosing an appropriate interval) rather than wrapping the coroutine.\n\n2. **Use the framework's async integration points consistently**: In Home Assistant, an async integration should use async_setup_* entry points, async_* helpers (eg async_track_time_interval), and async callbacks (eg async_see). This avoids blocking the event loop and integrates properly with the core's task scheduling model.\n\n3. **Prefer asynchronous client libraries for IO-bound integrations**: Migrating from a synchronous HTTP client (freepybox) to an asynchronous one (aiofreepybox) aligns with the event-driven nature of Home Assistant and asyncio. This prevents blocking the reactor thread and allows concurrent IO operations like polling multiple devices.\n\n4. **Control API call frequency via polling intervals instead of decorators**: When the integration itself is responsible for scheduling updates (via track_time_interval or async_track_time_interval), you can enforce a minimum period between calls by computing interval = max(user_configured_interval, MIN_TIME_BETWEEN_SCANS). This approach is simpler and more transparent than layering additional throttling decorators around the update function.\n\n5. **Structure async polling integrations cleanly**: A good pattern is: (a) create a client in __init__, (b) provide an async_start method that does a first update and sets up a recurring timer, and (c) implement async_update_info that performs one full polling cycle (fetch remote state, transform data, update entities) and is re-entrant and exception-safe.\n\n6. **Integrate discovery with configuration while respecting user control**: For device trackers that may be considered intrusive, it's important to wire discovery so that it merely provides host/port information and triggers setup flows, with the user having the ability to accept, configure, or ignore the discovered device. In Home Assistant, mapping netdisco services to (domain, platform) in discovery.py and using config flows/configurator is the recommended way.\n\n7. **Error handling in async polling loops**: When polling external APIs periodically, catch and log known request exceptions (eg, HttpRequestError) and continue scheduling future polls instead of letting exceptions bubble and terminate the loop. Only close the network client in finally-blocks to ensure resources are released even when requests fail.",
        "procedural_memory": [
            "Diagnosing 'coroutine was never awaited' when using async functions with Home Assistant's schedulers:",
            "Step 1: When you see 'coroutine was never awaited' in the logs, identify which function the message refers to (eg, async_update_info).",
            "Step 2: Check if that function is decorated with any non-async-aware decorators (eg, Throttle, custom caching decorators). Use asyncio.iscoroutinefunction on the bound method to confirm if it is still a coroutine.",
            "Step 3: If asyncio.iscoroutinefunction returns False for a function you expect to be async, remove or refactor the decorator. Many decorators written for sync code will wrap the coroutine and break its async nature.",
            "Step 4: If you need throttling, implement it at the scheduling level. For Home Assistant, compute a polling interval like interval = max(user_interval, MIN_TIME_BETWEEN_SCANS) and pass that to async_track_time_interval instead of using Throttle.",
            "Step 5: Ensure you're using the async variants of Home Assistant helpers: async_setup_* for integration setup, async_track_time_interval for timers, and async_* callbacks like async_see for updating entities.",
            "Step 6: After refactoring, run the integration and confirm there are no 'never awaited' warnings and that the update function is being called at the expected frequency.",
            "",
            "Implementing a new async polling-based device tracker in Home Assistant (similar to Freebox):",
            "Step 1: Choose or create an **async** client library for your device (eg, aiofreepybox). Instantiate the client in your scanner class's __init__ method, with configuration (host, port, token_file, etc).",
            "Step 2: Define PLATFORM_SCHEMA with configuration options (eg, CONF_HOST, CONF_PORT, CONF_SCAN_INTERVAL) using voluptuous.",
            "Step 3: Implement async_setup_scanner(hass, config, async_see, discovery_info=None). In it, merge config with discovery_info when present (eg, filling host/port from discovered properties).",
            "Step 4: Create a scanner class (eg, FreeboxDeviceScanner) that stores the client instance and the async_see callback. In __init__, set up any static configuration and app descriptors but do not schedule timers yet.",
            "Step 5: Add an async_start(hass, interval) method on the scanner that: (a) awaits a first call to async_update_info(), (b) enforces a minimum interval (max(interval, MIN_TIME_BETWEEN_SCANS)), and (c) registers async_update_info with async_track_time_interval.",
            "Step 6: Implement async_update_info(self, now=None) to: (a) open/connect the client, (b) perform the API call(s) to fetch current device or host state, (c) transform the raw data into structured Device objects, (d) call async_see(...) for each relevant device/entity using asyncio.gather or asyncio.wait, and (e) close/disconnect the client in a finally block.",
            "Step 7: Catch and log known request-level errors (eg, HttpRequestError) around the API calls so that a transient API failure does not break the polling loop.",
            "Step 8: If integrating with discovery, register the service key in discovery.py's SERVICE_HANDLERS (eg, 'freebox': ('device_tracker', 'freebox')) so Home Assistant can auto-discover and propose setup.",
            "Step 9: Test under different environments (Linux, Windows) and Python versions to confirm there are no platform-specific asyncio issues. If an error persists even when your integration is disabled, consider it may be unrelated to your code.",
            "Step 10: Document user requirements: initial authorization steps (eg, physical button press on the router), how discovery behaves, and how to disable or ignore the integration if desired."
        ]
    }
}
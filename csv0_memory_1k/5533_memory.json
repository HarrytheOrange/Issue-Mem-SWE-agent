{
    "search_index": {
        "description_for_embedding": "Added a new Home Assistant media_player platform to support Orange Livebox Play TV set-top boxes. The integration wraps the external liveboxplaytv Python library (v1.4.7), exposes power, play/pause, channel up/down, mute and volume controls, and reports current channel, current program, and channel artwork. It uses throttled polling, robust network error handling, and correct Home Assistant media_player feature flags and schemas.",
        "keywords": [
            "Home Assistant",
            "media_player",
            "liveboxplaytv",
            "Orange Livebox Play TV",
            "set-top box integration",
            "MEDIA_TYPE_CHANNEL",
            "supported_media_commands",
            "requests.ConnectionError",
            "util.Throttle",
            "requirements_all.txt",
            "REQUIREMENTS",
            "configuration.yaml",
            "network device integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request implemented first-class support for the Orange Livebox Play TV appliance as a Home Assistant media_player platform.\n\nThe author created homeassistant/components/media_player/liveboxplaytv.py and wired it into requirements_all.txt and .coveragerc. Initially, the code depended on a GitHub-zip version of the python-liveboxplaytv library, but after review it transitioned to a pinned PyPI dependency (liveboxplaytv) and was kept up-to-date through several versions, ultimately settling on liveboxplaytv==1.4.7. The matching entry in requirements_all.txt was updated accordingly.\n\nThe platform exposes a LiveboxPlayTvDevice which wraps the LiveboxPlayTv client. The platform schema requires a host (IP or hostname) and allows an optional port (default 8080) and name (default 'Livebox Play TV'). The earlier version attempted to support discovery via URL parsing and a configurator-based setup flow, but these were removed to simplify the integration after review, and host is now required in configuration.yaml.\n\nThe device implements the appropriate Home Assistant media_player properties and methods: name, state, is_volume_muted, source (current channel), source_list (all channels), media_content_type (MEDIA_TYPE_CHANNEL), media_image_url (current channel artwork), and media_title (a combination of current channel and current program using the backend's program property). It refreshes channel list and state via an update() method throttled with homeassistant.util.Throttle to avoid excessive polling (10 seconds between scans, 1 second between forced scans).\n\nThe code maps the Livebox media state (e.g., 'PLAY', 'PAUSE') to Home Assistant's STATE_PLAYING and STATE_PAUSED using a helper method refresh_state(), and falls back to STATE_ON/STATE_OFF based on the device's power state. It supports turning the device on/off, volume up/down, mute toggling, play/pause, and next/previous channel. Volume level setting is intentionally not implemented because the underlying device/library does not support setting an absolute volume value.\n\nError handling was iterated as well. Early versions caught websockets.ConnectionClosed and OSError, but as the library evolved and switched to HTTP, the final implementation imports requests at module level and catches requests.ConnectionError in update() to mark the device as STATE_OFF if the set-top box is unreachable. The code also defensively uses dict.get() when reading channel metadata (name, imageUrl) so missing keys do not cause exceptions.\n\nDuring review, style and architecture issues were fixed: unused configuration callbacks and the _CONFIGURING dict were removed, host is now required (instead of optional with discovery), unused attributes like _playing and volume_level setters were removed, global imports were minimized (LiveboxPlayTv imported only in __init__), long lines were wrapped to satisfy linting, and comments/docstrings were clarified. The file was added to .coveragerc's omit list, consistent with other media_player integrations that primarily wrap external devices.\n\nIn the end, this PR cleanly added Orange Livebox Play TV support with stable dependency management, correct feature reporting, and robust behavior in unreliable network conditions.",
        "semantic_memory": "Generalizable knowledge from this change centers around how to design and integrate a network media device into a larger home-automation framework like Home Assistant.\n\n1. **Platform design for external devices**:\n   - When adding a new platform for a device (e.g., a set-top box), implement a platform module that declares a clear PLATFORM_SCHEMA, setup_platform() entrypoint, and a device class subclassing the framework's base (here, MediaPlayerDevice).\n   - Require minimally necessary configuration (e.g., host) and use sensible defaults for optional parameters (e.g., port, display name) to keep configuration simple while avoiding implicit discovery complexity when not needed.\n\n2. **Dependency management best practices**:\n   - Wrap device-specific logic in a dedicated library (liveboxplaytv) and depend on it via a pinned version in REQUIREMENTS and a central requirements_all.txt list. This decouples the core application from vendor-specific protocols and allows quicker iteration and bug fixing in the external library.\n   - Avoid importing heavy or optional dependencies at global scope if they may not be installed outside the configured environment; however, for core requirements that must always be present (like requests, once added to requirements_all.txt), a top-level import is appropriate and keeps code simpler.\n\n3. **State mapping and feature flags**:\n   - Translate device-native states (strings like 'PLAY', 'PAUSE', or power booleans) into the framework's standardized state constants (STATE_PLAYING, STATE_PAUSED, STATE_ON, STATE_OFF, STATE_UNKNOWN). This ensures UI and automations behave correctly, regardless of backend implementation details.\n   - Use supported_* flags (e.g., SUPPORT_TURN_ON, SUPPORT_TURN_OFF, SUPPORT_PAUSE, SUPPORT_SELECT_SOURCE) to advertise exactly what capabilities the integration exposes. Don't claim support for features that the device or backend API doesn't support (e.g., SUPPORT_PLAY_MEDIA or absolute volume control) to avoid user confusion and failing service calls.\n\n4. **Polling and performance control**:\n   - When representing a local network device that must be polled, throttle update frequency using a mechanism like util.Throttle. This prevents overloading the device or spamming the network and reduces CPU usage in the host system.\n   - Separate quick state refresh logic (e.g., refresh_state) from heavier operations (like fetching channel lists or artwork) to make future performance tuning straightforward.\n\n5. **Robustness and graceful failure**:\n   - Always catch network-related exceptions (such as requests.ConnectionError) around communication with external devices. On failure, degrade gracefully by marking the device as offline (STATE_OFF or STATE_UNAVAILABLE) rather than propagating exceptions that would flood logs or break the scheduler.\n   - When accessing fields from external APIs, prefer dict.get() with default values instead of direct indexing, since external services may omit fields or change responses.\n\n6. **User-facing metadata enrichment**:\n   - Enhance the user experience by exposing useful metadata like the current program title and channel artwork via media_title and media_image_url. Compose these fields in a readable way (e.g., \"<Channel Name>: <Program Title>\") to provide informative UI labels.\n\n7. **Code quality and maintainability**:\n   - Follow the project-specific coding standards: respect linting rules (line length, imports ordering, unused code removal) and architectural conventions (e.g., not using the configurator if not actually needed).\n   - Remove dead or speculative code paths (like unused configuration callbacks or tracking dictionaries) to keep the integration small, understandable, and easier to maintain.\n\nOverall, this PR illustrates the pattern: wrap a device-specific library in a thin platform adapter, map its API cleanly into the framework's primitives, and ensure resiliency and clarity in configuration and error handling.",
        "procedural_memory": [
            "Step-by-step instructions on how to add and stabilize a new network media device integration in a Home Assistant-like environment:",
            "Step 1: Identify or create a dedicated Python library that encapsulates the device's protocol (HTTP, websockets, proprietary APIs). Ensure it exposes clear methods for power control, playback, channel/track management, and retrieval of metadata.",
            "Step 2: Add the device library as a pinned dependency in the platform module via a REQUIREMENTS list (e.g., REQUIREMENTS = ['liveboxplaytv==1.4.7']) and ensure the same version is listed in the global requirements_all.txt so the dependency is installed in all configurations.",
            "Step 3: Create a new platform module (e.g., homeassistant/components/media_player/<device>.py) that imports the framework's base media player interfaces, constants, and helper utilities (like util.Throttle and config validation).",
            "Step 4: Define a PLATFORM_SCHEMA that declares required options such as CONF_HOST and optional ones like CONF_PORT and CONF_NAME with sensible defaults. Use voluptuous / cv helpers (e.g., cv.port, cv.string) to validate user configuration.",
            "Step 5: Implement setup_platform(hass, config, add_devices, discovery_info=None) to read configuration, instantiate the device class with host/port/name, and call add_devices([...], True) for an initial state update. Avoid unnecessary complexity like configurator flows or discovery mechanisms if not required.",
            "Step 6: Implement a device class subclassing MediaPlayerDevice. In __init__, create the client instance from the external library (e.g., LiveboxPlayTv(host, port)) and initialize internal state variables such as _state, _channel_list, _current_channel, _current_program, _media_image_url, and _muted.",
            "Step 7: Implement an update() method decorated with util.Throttle(MIN_TIME_BETWEEN_SCANS, MIN_TIME_BETWEEN_FORCED_SCANS) to control polling frequency. Inside update(), fetch the device state and metadata (current channel, artwork, program), update internal attributes, and refresh auxiliary data like the channel list.",
            "Step 8: Wrap all network calls in update() (and other methods that contact the device) in try/except blocks catching network exceptions (e.g., requests.ConnectionError). On failure, set a safe fallback state (usually STATE_OFF or STATE_UNAVAILABLE) instead of letting exceptions propagate.",
            "Step 9: Map the backend's media states into framework constants via a helper method (e.g., refresh_state() that checks client.media_state and client.is_on and returns STATE_PLAYING, STATE_PAUSED, STATE_ON, or STATE_OFF). Use this method in update() to keep the reported state consistent.",
            "Step 10: Implement required media player properties: name, state, is_volume_muted, source, source_list, media_content_type (e.g., MEDIA_TYPE_CHANNEL), media_image_url, and media_title. When reading data from the client, use safe accessors (dict.get) to handle missing keys, and consider composing user-friendly media_title strings (e.g., '<Channel>: <Program>').",
            "Step 11: Determine which commands the device actually supports and set the supported feature bitmask accordingly (e.g., SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_PLAY | SUPPORT_PAUSE | SUPPORT_NEXT_TRACK | SUPPORT_PREVIOUS_TRACK | SUPPORT_VOLUME_STEP | SUPPORT_VOLUME_MUTE | SUPPORT_SELECT_SOURCE). Do not advertise capabilities like SUPPORT_PLAY_MEDIA or absolute volume control if the device or library does not support them.",
            "Step 12: Implement the command methods (turn_on, turn_off, media_play, media_pause, media_play_pause, media_next_track, media_previous_track, volume_up, volume_down, mute_volume, select_source) by delegating to the client library. Only implement set_volume_level if the underlying device can handle absolute volume levels; otherwise leave it unimplemented and do not set the corresponding support flag.",
            "Step 13: Keep error handling and state updates idempotent. For example, on turn_off, update _state to STATE_OFF and call client.turn_off(); on play/pause methods, update _state to STATE_PLAYING/STATE_PAUSED so the UI reflects the change immediately while the next poll will confirm it.",
            "Step 14: Run linting and tests (tox or equivalent) and fix style issues: adhere to line length limits, remove unused variables and functions (like unused configurator callbacks or setup helper layers), and ensure imports are correctly ordered and minimal.",
            "Step 15: Update documentation (e.g., home-assistant.github.io component docs) with configuration examples that reflect the final schema, including required host, optional port, and name. Provide an example configuration.yaml snippet for users.",
            "Step 16: If the integration initially required a GitHub-zip dependency or nonstandard installation, refactor it later to use a proper pinned PyPI version once the external library is stable, and update both REQUIREMENTS and requirements_all.txt accordingly.",
            "Step 17: When evolving the external library (e.g., adding support for current program or improved media state), increment the pinned version in both the platform module and requirements_all.txt, and adjust the adapter code to use new APIs, maintaining backward compatibility where necessary.",
            "Step 18: Monitor logs for runtime errors or unhandled edge cases (e.g., missing channel metadata, transient connection drops). Iterate by tightening exception handling and using safe defaults (None, empty strings) rather than allowing KeyError or other unhandled exceptions."
        ]
    }
}
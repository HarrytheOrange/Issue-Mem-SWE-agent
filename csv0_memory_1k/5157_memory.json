{
    "search_index": {
        "description_for_embedding": "StackStorm change set replacing unsafe `assert` statements in production code with explicit runtime validation and exceptions, improving type checking, error messages, and safety checks around paths, timestamps, and trigger/payload types. Also repairs a temporary regression in sandboxed Python path construction.",
        "keywords": [
            "StackStorm",
            "assert removal",
            "runtime validation",
            "TypeError",
            "ValueError",
            "KeyError",
            "RBAC",
            "sandbox_python_path",
            "git worktree",
            "garbage collector TTL validation",
            "trigger dispatch type checking",
            "safe path handling",
            "production safety",
            "error messaging"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the StackStorm codebase was hardened by systematically replacing `assert` statements in production code with explicit runtime checks and appropriate exceptions. The original problem was that Python `assert` is optimized out when running with optimizations (e.g. `-O`), so critical safety conditions and type checks could be silently skipped in production, potentially leading to unsafe behavior or difficult-to-debug failures.\n\nKey areas touched:\n\n1. **Type & shape validation instead of asserts**\n   - Many functions previously used `assert` to enforce types or invariants, for example:\n     - `_format_action_exec_result` in the action chain runner asserted that `created_at` and `updated_at` were `datetime` objects.\n     - The Python runner wrapper asserted `parent_args` was a list.\n     - The Python runner asserted the action output delimiter split produced 3 elements.\n     - Action executions and re-run specs asserted parameters/tasks/reset types.\n     - KeyValue controllers asserted `'scope'` and `'prefix'` presence in filters.\n     - Trigger controllers asserted payloads and trace contexts were dicts.\n     - Registrars for actions, aliases, configs, policies, rules, sensors, triggers asserted `packs_base_paths` was a list.\n     - Content loader asserted `base_dirs` was a list.\n     - Content utils asserted normalized paths and prefix safety.\n     - RBAC type parser asserted the permission string contained an underscore.\n     - Runners and sandboxing asserted various path and prefix relationships (e.g. worktree paths under `/tmp`).\n     - Crypto utilities asserted key sizes and binary types.\n     - Shell helpers asserted command types.\n   - These asserts were replaced with explicit `TypeError`, `ValueError`, or `KeyError`, often including detailed context such as the offending type value, the expected structure, or the current dict content. For example, the Python runner now raises `ValueError('The result length should be 3, was {len(split)}.')` instead of asserting the length is 3.\n\n2. **Improved error messages and contextual validation**\n   - Error messages were made more descriptive and often include the actual type or values encountered (e.g., `The pack base paths has a value that is not a list (was <class 'str'>).`).\n   - In `content.utils.get_pack_file_abs_path`, the code now raises a `ValueError` describing the normalized path and the resulting path if directory traversal is attempted, instead of a bare assert.\n   - In `rbac.types`, invalid permission strings without an underscore now raise `ValueError(\"The permission_type {permission_type} doesn't have an underscore.\")`.\n   - In crypto functions, type errors clearly state whether AESKey/HMACKey is not bytes and what the actual type is.\n   - In garbage collector code, TTL comparisons now raise precise messages if computed timestamps are in the future or violate minimum TTL constraints.\n   - Trace and trigger services now raise type errors when provided contexts or triggers are not dicts, again including actual type info.\n\n3. **Safety around filesystem paths and git worktrees**\n   - For `GitWorktreeActionRunner`, asserts verifying worktree paths under `/tmp` and under the worktree prefix were replaced with `ValueError` checks and better messages, preventing accidental deletion outside of the intended directory tree.\n   - The runner also checks that the calculated `entry_point` for a git worktree starts with the worktree path, and fails with a clear error if not.\n   - `content.utils.get_pack_file_abs_path` now does both normalized path inclusion and common-prefix based directory traversal checks using explicit exceptions, not asserts.\n\n4. **Dispatch and transport type safety**\n   - `AnnouncementDispatcher` and `TriggerDispatcher` now verify that payloads are dicts (or None where allowed) and that trace contexts are either `TraceContext` or dict/None, raising `TypeError` with informative messages otherwise.\n   - Trace services enforce that `trace_context` is either a `TraceContext` instance or dict, or raise `TypeError`.\n\n5. **Garbage collector logic correctness**\n   - The garbage collector previously used asserts and slightly incorrect inequalities. These were converted to guard conditions and clearer comparisons: timestamps must be strictly older than `utc_now`, and must not violate minimum TTL days. Where invalid, `ValueError` is raised with messages like `Calculated timestamp ({timestamp}) is later than now in UTC ({utc_now}).`.\n\n6. **Sandboxing regression fix**\n   - During the early assert removal refactor, `get_sandbox_python_path_for_python_action` in `util.sandboxing` was inadvertently replaced with a trivial wrapper, effectively removing pack-specific virtualenv and lib path logic.\n   - In a later patch, this regression was fixed by reintroducing the original behavior: the function now again constructs a Python path that includes the pack's virtualenv lib directory, site-packages, and actions/lib, ensuring that pack-specific Python dependencies are available and prioritized over system libraries.\n\nOverall, the cause was improper use of asserts in production and a temporary loss of functionality in the sandbox path helper. The fix was to replace asserts with explicit validation, improve messages, correct logical conditions, and restore the full sandbox path construction behavior.",
        "semantic_memory": "This change reinforces several generalizable best practices and patterns for production-grade Python services:\n\n1. **Avoid `assert` for production invariants**\n   - Python's `assert` is designed for debugging, not for enforcing runtime invariants in production. It is removed when Python is run with optimizations. Therefore, any critical checks (type checks, pre/post-conditions, security-related conditions, path and boundary validations) must use explicit conditionals and raise appropriate exceptions instead of relying on `assert`.\n   - For example, instead of `assert isinstance(x, dict)`, use `if not isinstance(x, dict): raise TypeError('...')`.\n\n2. **Use specific exception types with detailed messages**\n   - Use `TypeError` for wrong types, `ValueError` for invalid values or invalid combinations, and `KeyError` when expected dict keys are missing.\n   - Error messages should include: the expected type or constraint, the actual type/value encountered, and any relevant context (e.g. the name of the parameter or key). This makes issues easier to debug and more user-friendly.\n   - When parsing complex structures (e.g. permission strings, configuration dicts, Trigger specs), validate structure explicitly and raise clear errors rather than letting downstream code fail with less obvious exceptions.\n\n3. **Maintain strong invariants for security-sensitive operations**\n   - When dealing with filesystem paths that must be confined to a directory (like a pack base path or a git worktree), always:\n     - Normalize the input path (`os.path.normpath`) and verify it doesn't escape the expected root.\n     - Verify common prefix relationships (`os.path.commonprefix`) to ensure no directory traversal.\n     - Use explicit `ValueError` if invariants are violated.\n   - For git worktrees, enforce that the generated entry point path is within the worktree and that deletion logic is constrained to known safe directories like `/tmp`.\n\n4. **Validate TTLs and timestamps for cleanup jobs**\n   - Garbage collectors must verify TTL (time-to-live) configuration values and derived timestamps. Use minimum allowed TTLs to prevent accidental mass deletion of recently-created data.\n   - When computing cutoff timestamps, ensure they are strictly in the past and not equal or greater than `utc_now`. Raise clear errors if configuration leads to invalid or unsafe values.\n\n5. **Type-safe messaging and dispatch layers**\n   - When building generic dispatchers (e.g. for triggers, webhooks, announcements, streams), validate that payloads and context objects conform to expected contracts (mostly dict or specific dataclass-like types). Failing fast at the boundary avoids hidden runtime errors down the pipeline.\n\n6. **Preserve and test critical helper functions during refactors**\n   - The temporary regression in `get_sandbox_python_path_for_python_action` shows the risk of losing important behavior during code cleanups. When refactoring, especially large-scale mechanical changes (like removing asserts), ensure:\n     - Critical helpers remain functionally unchanged.\n     - There are regression tests that cover behavior such as environment construction and path ordering.\n\nOverall, the semantic lesson is: in a production system, invariants and safety checks must be explicitly implemented with robust error handling and clear diagnostics, rather than relying on debug-only mechanisms like `assert`. Refactors should be carefully validated to avoid regressions in critical support functions.",
        "procedural_memory": [
            "Step-by-step methodology to migrate from unsafe asserts to robust runtime checks and to harden safety-critical logic:",
            "Step 1: Identify asserts in production code",
            "1.1. Search the codebase for all uses of `assert`, especially in library and runtime paths (not tests).",
            "1.2. Classify each assert: is it enforcing a type, a value invariant, security constraint, or an assumption about external input?",
            "1.3. Prioritize asserts around security (paths, user input, credentials), clean-up (garbage collectors), and inter-service contracts (trigger payloads, trace context).",
            "Step 2: Replace asserts with explicit checks and appropriate exceptions",
            "2.1. For type checks, replace `assert isinstance(x, ExpectedType)` with:\n```python\nif not isinstance(x, ExpectedType):\n    raise TypeError(f\"<Context>: expected {ExpectedType}, got {type(x)}\")\n```",
            "2.2. For value/invariant checks (e.g., array length, non-empty set, relationship between sets):\n```python\nif len(split) != 3:\n    raise ValueError(f\"Expected 3 parts, got {len(split)}\")\n```",
            "2.3. For required dict keys, replace `assert 'key' in d` with:\n```python\nif 'key' not in d:\n    raise KeyError(\"'key' missing in <dict_name>: %s\" % d)\n```",
            "2.4. For resource-type or permission string structure (e.g. `FOO_BAR`), parse and validate explicitly. If the split doesn't match expectations, raise `ValueError` with the offending string.",
            "Step 3: Normalize and validate filesystem paths",
            "3.1. When accepting a file path relative to a base directory:\n  - Normalize the path: `normalized = os.path.normpath('/' + file_path).lstrip('/')`.\n  - Reject if `normalized != file_path` (detects `../` traversal).\n  - Join with base: `result = os.path.join(base_path, normalized)`.\n  - Verify common prefix: `common_prefix = os.path.commonprefix([base_path, result])` and ensure `common_prefix == base_path`.\n  - If any check fails, raise a `ValueError` with both the offending path and base path.",
            "3.2. For temporary work directories like git worktrees, verify they are under allowed roots (e.g., `/tmp`) and specific prefixes before performing deletion.",
            "Step 4: Harden TTL-based garbage collection",
            "4.1. Define minimum allowed TTLs in configuration (e.g., `MINIMUM_TTL_DAYS`).",
            "4.2. On start-up, validate config:\n```python\nif ttl < MINIMUM_TTL_DAYS:\n    raise ValueError(f\"Minimum possible TTL is {MINIMUM_TTL_DAYS} days\")\n```",
            "4.3. When computing a cutoff timestamp, ensure:\n  - `timestamp = utc_now - timedelta(days=ttl)`\n  - `timestamp < utc_now` (strictly older)\n  - `timestamp <= utc_now - timedelta(days=MINIMUM_TTL_DAYS)`\n  - If invalid, raise `ValueError` describing both timestamp and `utc_now`.",
            "Step 5: Validate messaging and dispatch data types",
            "5.1. In dispatchers or service boundaries, validate external-facing parameters early:\n```python\nif payload is not None and not isinstance(payload, dict):\n    raise TypeError(f\"payload must be dict or None, not {type(payload)}\")\nif trace_context is not None and not isinstance(trace_context, (dict, TraceContext)):\n    raise TypeError(\"trace_context must be None, dict, or TraceContext\")\n```",
            "5.2. For trace contexts, provide a small helper `_get_valid_trace_context` that canonicalizes dict -> `TraceContext` and validates types in one place.",
            "Step 6: Preserve environment construction helpers during refactors",
            "6.1. For helpers that build PATH/PYTHONPATH (e.g., `get_sandbox_python_path_for_python_action`):\n  - Ensure unit tests assert that the returned path:\n    - Includes the virtualenv lib directory.\n    - Includes the virtualenv site-packages before the system site-packages.\n    - Includes the pack's `actions/lib` directory.\n  - When refactoring, run tests to verify behavior hasn't been reduced to a stub inadvertently.\n  - If a regression is discovered, reintroduce the full behavior and consider adding more granular tests for edge cases (e.g., multiple Python versions in the virtualenv `lib/` directory).",
            "Step 7: Improve error messages and logging",
            "7.1. When raising exceptions, include the key details (expected vs actual type/value), the context (e.g., which parameter, which pack, which scope), and, where relevant, sanitized versions of sensitive values.\n  - Example: `raise ValueError(f\"The worktree path '{worktree_path}' is not within /tmp.\")`.\n  - Example: `raise ValueError(f\"The permission_type '{permission_type}' doesn't have an underscore.\")`.",
            "7.2. Use logging at appropriate levels (DEBUG/INFO/WARN/ERROR) to capture tracing information that doesn't belong in user-facing exceptions but assists in debugging.\n\nFollowing these steps, a developer can safely migrate away from asserts, ensure invariants are checked in production, and maintain or restore correctness in auxiliary infrastructure code such as sandbox environment construction and garbage collection."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Met integration extended to support Met.no lightning strike data as geo_location entities. Initial attempt as a separate met_lightning integration was refactored: lightning is now configured via the main Met config_flow with a radius option, a config-entry migration adds the new field, and a geo_location platform uses pyMetno LightningData to create/delete lightning strike GeolocationEvent entities around a configured location.",
        "keywords": [
            "Home Assistant",
            "met",
            "met_lightning",
            "Met.no",
            "lightning strikes",
            "geo_location",
            "config_flow",
            "config entry migration",
            "pyMetno",
            "radius configuration",
            "track_home",
            "integration refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR started as a new Home Assistant integration called `met_lightning` that exposed Met.no lightning strikes in Norway and Sweden as `geo_location` entities. The initial design added a separate domain (`met_lightning`), its own manifest, config_flow, constants, and tests. It used the `metno.LightningData` client stored in `hass.data[DOMAIN][DATA_CLIENT]` and forwarded config entries to the `geo_location` platform to create `GeolocationEvent` entities for lightning strikes within a configurable radius.\n\nOver time, the author decided that a separate `met_lightning` integration was not the right design. In later patches, lightning support was moved into the existing `met` integration instead of living under a separate domain. The `geo_location.py` module was renamed from `homeassistant/components/met_lightning/geo_location.py` to `homeassistant/components/met/geo_location.py`, and all of the `met_lightning` scaffolding (manifest, config_flow, consts, translations, and strings) was removed.\n\nTo integrate lightning into `met`, the `met` config_flow and constants were extended:\n- A new `CONF_RADIUS` option was added to the Met config schema and UI strings, labeled as a radius (km) for lightning (with a note that data is only available from Norway and Sweden).\n- The config_entry version for Met was bumped from 1 to 2.\n- An `async_migrate_entry` implementation was added that, for existing entries (version 1), injects a default `radius` of `-1` (meaning \"do not show lightning\") and updates the entry version to 2.\n- `async_setup_entry` in `met/__init__.py` was updated to also forward the entry to the `geo_location` platform in addition to `weather`, and `async_unload_entry` now unloads both.\n\nThe lightning event manager now lives under the Met integration:\n- `async_setup_entry` for `met/geo_location.py` checks the configured `radius`. If `radius <= 0`, it does nothing; otherwise it sets up lightning.\n- It respects `CONF_TRACK_HOME`: if true, it uses the Home Assistant core latitude/longitude; otherwise it uses the coordinates stored in the Met config entry.\n- It creates its own `LightningData` client (`metno.LightningData`) using the shared aiohttp session instead of relying on data stored in `hass.data`.\n- It periodically calls `within_radius(lat, lon, radius)` to fetch current strikes, calculates which strike IDs are new vs. removed, and creates/removes `MetLightningEvent` entities via dispatcher signals and `geo_location.GeolocationEvent`.\n- Each `MetLightningEvent` exposes distance (km), lat/long, an external strike ID, a publication date, attribution (`Data provided by Met.no`), a lightning icon, and uses the `met` domain as its `source`.\n\nThe original, separate `met_lightning` integration was fully removed: its `.translations`, `__init__`, `config_flow`, `const.py`, `manifest.json`, and `strings.json` were deleted. `CODEOWNERS`, requirements, and config_flows entries that referred to `met_lightning` were reverted or adapted to the new design. Tests specifically targeting `met_lightning` remained in the patch history but the PR itself was eventually closed by the author as they did not have time to complete it.",
        "semantic_memory": "Several generalizable practices emerge from this PR, even though it was ultimately closed:\n\n1. **Feature Placement and Domain Design**:\n   - When adding a new capability that is conceptually part of an existing integration (e.g., lightning data from the same Met.no service used for weather), it’s often better to extend the existing domain rather than creating a separate, parallel integration. This avoids configuration duplication, reduces user confusion, keeps ownership and lifecycle consistent, and leverages the existing config entry.\n\n2. **Config Entry Versioning and Migration**:\n   - When changing the schema of a config entry (adding `radius` in this case), bump the `VERSION` on the config_flow/integration and implement `async_migrate_entry`. This allows existing entries to be automatically migrated without user intervention.\n   - Use sentinel values (here `radius = -1`) to represent disabled optional features when migrating existing entries. This avoids breaking behavior for users who haven’t explicitly opted in.\n\n3. **Multi-platform Integrations in Home Assistant**:\n   - A single integration (domain) can expose multiple platforms (e.g., `weather` and `geo_location`). Use `async_forward_entry_setup` (and corresponding unload) to start and stop platform-specific logic for the same config entry.\n   - Platform modules (like `met/geo_location`) should be self-contained where possible, constructing their own external clients (via a shared aiohttp session) rather than relying on global data unless there’s a strong reason to centralize it.\n\n4. **Event-style Entities via `geo_location`**:\n   - For transient, location-based events (lightning strikes, earthquakes, etc.), the `geo_location.GeolocationEvent` entity type is well-suited: each event is a distinct entity with coordinates, a distance, a human-readable name, and optional external IDs and timestamps.\n   - Managing these entities requires tracking the set of known event IDs and comparing it on each poll to add new entities and remove old ones. Using dispatcher signals (e.g., `delete_entity_<id>`) allows the manager to tell each event when to remove itself.\n\n5. **Config UI and Documentation Clarity**:\n   - When adding optional functionality limited to specific regions (like lightning data only available for Norway and Sweden), explicitly communicate this in the config UI strings (e.g., as part of the field description for `radius`). This sets expectations and reduces confusion for users in unsupported areas.\n\n6. **Graceful No-Op Conditions**:\n   - Before setting up a platform, check configuration guard conditions early (e.g., `if radius <= 0: return`) to avoid unnecessary network calls or entities when the feature is disabled.\n\n7. **Leveraging Shared Libraries Across Features**:\n   - The same client library (`pyMetno`) can be used for both base functionality (weather) and extended functionality (lightning). Keeping the version in sync across related integrations (`met` and `norway_air`) ensures compatibility and avoids subtle bugs due to version drift.",
        "procedural_memory": [
            "Step 1: Decide whether to extend an existing integration or create a new domain.",
            "Evaluate whether the new functionality belongs conceptually with an existing integration. If it uses the same upstream service, user credentials, or configuration data (e.g., Met.no weather plus lightning), prefer extending the existing integration.",
            "Step 2: Extend the integration’s configuration schema and config_flow.",
            "Add new constants (e.g., `CONF_RADIUS`) to the integration’s `const.py`.",
            "Update the config_flow `VERSION` to a new integer and add the new field to the configuration schema (both schema code and translation/strings JSON). Use sensible defaults and clearly describe any regional limitations or constraints.",
            "If the new option can be disabled, choose a sentinel (e.g., `-1` or `0`) to represent 'feature disabled'.",
            "Step 3: Implement config entry migration.",
            "Add an `async_migrate_entry` function in the integration’s `__init__.py`.",
            "In the migration, check the existing `config_entry.version`. For older versions, inject the new field with an appropriate default and bump `config_entry.version`.",
            "Use `hass.config_entries.async_update_entry` to persist the modified data.",
            "Make sure migration is idempotent and does not break existing behavior for users who do not opt into the new feature.",
            "Step 4: Wire up additional platforms for the integration.",
            "In the integration’s `async_setup_entry`, forward the config entry to any new platforms you are adding (e.g., `geo_location`) using `hass.config_entries.async_forward_entry_setup`.",
            "In `async_unload_entry`, symmetrically forward the unload call to all platforms, and await their completion.",
            "Ensure the platform module (e.g., `met/geo_location.py`) has an `async_setup_entry` that respects configuration and can no-op if the feature is disabled (e.g., `radius <= 0`).",
            "Step 5: Implement the geo-location event manager.",
            "Create a manager class that accepts `hass`, `async_add_entities`, and any relevant configuration (latitude, longitude, radius, flags like `CONF_TRACK_HOME`).",
            "Inside the manager, obtain the shared aiohttp session with `aiohttp_client.async_get_clientsession(hass)` and instantiate the external API client (here, `LightningData(websession)`).",
            "Schedule periodic updates using `async_track_time_interval`, calling a method like `async_update` at reasonable intervals (e.g., every 5–10 minutes).",
            "In `async_update`, call the external API (e.g., `within_radius(lat, lon, radius)`) to get the current events, store them in a local map keyed by a unique ID, and compute which IDs are new vs. removed.",
            "Create new entities for new IDs and send a dispatcher signal to remove entities for IDs that no longer exist.",
            "Step 6: Define the geo-location event entity class.",
            "Subclass `geo_location.GeolocationEvent` and implement properties: `name`, `latitude`, `longitude`, `distance`, `icon`, `unit_of_measurement`, `source`, and any extra attributes (e.g., external ID, publication date, attribution).",
            "Use dispatcher connections in `async_added_to_hass` to listen for a delete signal specific to the entity’s ID, and in `_delete_callback` call `async_remove` when signaled.",
            "Ensure `should_poll` is `False` so the entity relies on the manager’s push-style lifecycle instead of individual polling.",
            "Step 7: Clean up deprecated or redundant components.",
            "If you initially implemented the feature as a separate integration but decide to integrate it into an existing one, remove the redundant domain: delete its `manifest.json`, `__init__.py`, `config_flow.py`, `const.py`, and translation/strings files.",
            "Update any generated or shared metadata (e.g., `config_flows.py`, `CODEOWNERS`, requirements files) to reflect the unified integration design.",
            "Step 8: Update requirements and shared libraries.",
            "If the feature relies on a newer version of a shared client library, bump that version in all relevant `manifest.json` files and central requirements (`requirements_all.txt`, `requirements_test_all.txt`).",
            "Run the appropriate Home Assistant scripts (e.g., `python3 -m script.gen_requirements_all`, `python3 -m script.hassfest`) to keep derived files in sync.",
            "Step 9: Add or adapt tests.",
            "Create or update tests for the config_flow to validate that new options are accepted, that duplicate configurations are rejected, and that import flows behave correctly.",
            "If needed, test that `async_setup_entry` correctly forwards entries to new platforms and that the data structures used by the platform (e.g., clients stored in `hass.data` or constructed in-place) are set up as expected.",
            "Step 10: Communicate limitations in UI and docs.",
            "Explicitly annotate configuration fields whose functionality is region-limited (e.g., lightning data only in Norway and Sweden) in localization files and user documentation.",
            "This helps set user expectations and reduces support overhead when data is unavailable outside supported areas."
        ]
    }
}
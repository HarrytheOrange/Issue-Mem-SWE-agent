{
    "search_index": {
        "description_for_embedding": "Fix inconsistent timezone handling by ensuring all datetime objects are timezone-aware and normalized to UTC. Change isotime.parse to return UTC by default, introduce a generic date utilities module, enforce UTC in DB fields, and replace direct datetime.now/utcnow calls with date_utils.get_datetime_utc_now across the codebase.",
        "keywords": [
            "datetime timezone bug",
            "UTC normalization",
            "isotime.parse",
            "st2common.util.date",
            "ComplexDateTimeField",
            "timezone-aware datetimes",
            "StackStorm",
            "timediff operators",
            "token expiry",
            "trigger instance timestamps"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, StackStorm was incorrectly handling datetime objects with mixed timezones. The core issue was that isotime.parse returned datetimes with whatever timezone was specified in the input ISO8601 string (or naive datetimes that were then treated as UTC in some places) without consistently converting them to UTC. As a result, if a user provided a non-UTC ISO8601 timestamp to the API, that value was stored and compared without normalization, which led to incorrect behavior in several areas (e.g., ComplexDateTimeField conversions, token expiry comparison, scheduled execution recovery, rule operators, and various timestamps in DB models).\n\nThe fix implemented several coordinated changes:\n\n1. A new module st2common.util.date was introduced to hold general date utilities:\n   - get_datetime_utc_now(): returns a timezone-aware datetime in UTC.\n   - add_utc_tz(dt): attaches UTC tzinfo to a naive datetime, but now raises ValueError if the datetime already has a non-UTC tzinfo (to avoid silent tzinfo replacement without conversion).\n   - convert_to_utc(dt): converts any datetime (with or without tz) to UTC, assuming naive datetimes are already UTC.\n   - parse(value, preserve_original_tz=False): parses arbitrary date strings using dateutil, ensures a tz-aware datetime, and converts to UTC by default unless preserve_original_tz=True.\n\n2. The existing st2common.util.isotime module was refocused strictly on ISO8601 formatting/parsing:\n   - format(dt, usec=True, offset=True): formats a datetime into an ISO8601 string, converting strings via parse first.\n   - validate(value, raise_exception=True): validates that a string is in the supported ISO8601 format.\n   - parse(value, preserve_original_tz=False, validate_value=True): validates ISO8601 inputs, then delegates parsing and UTC normalization to date_utils.parse; by default converts results to UTC unless preserve_original_tz=True.\n   - Responsibility for generic date parsing and now/UTC helpers was moved to st2common.util.date.\n\n3. ComplexDateTimeField was hardened:\n   - Its _datetime_to_microseconds_since_epoch now enforces that input datetimes must be in UTC (tzinfo.utcoffset == 0). If not, it raises ValueError. Previously this check was commented out, allowing non-UTC or naive datetimes to slip through.\n   - _microseconds_since_epoch_to_datetime now uses date.add_utc_tz to ensure reconstructed datetimes are marked as UTC.\n\n4. The entire codebase was updated to use UTC-aware helpers instead of naive datetime.datetime.now()/utcnow calls:\n   - DB models: LiveActionDB.start_timestamp, ActionExecutionDB.start_timestamp, MarkerDB.updated_at defaults now use date_utils.get_datetime_utc_now.\n   - Services and controllers: token creation (expiry), liveaction start/end timestamps, execution cancellation timestamps, recovery logic in the scheduler, and access token validation all use get_datetime_utc_now.\n   - Logging: rotating file handler timestamps use get_datetime_utc_now instead of datetime.utcnow.\n   - Exporter and Dumper: file names and marker.updated_at use UTC-aware timestamps.\n   - Reactor and triggers: trigger instance occurrence_time, timer schedules, and worker timestamps all use get_datetime_utc_now.\n   - Tests and tools: unit/integration tests and tools such as st2-inject-trigger-instances and submit_debug_info were updated to call date_utils.get_datetime_utc_now and the new UTC helpers instead of datetime.now/utcnow.\n\n5. Rule operators for time comparisons were corrected:\n   - The timediff_* operators now use date_utils.get_datetime_utc_now() for the current time and date_utils.parse(...) to parse the target date string, instead of datetime.strptime with a fixed format. This makes them robust to multiple date string formats and ensures all comparisons happen in UTC.\n\n6. Documentation was updated:\n   - A new section in docs/source/development/index.rst explains that all datetime objects in the codebase must be timezone-aware and in UTC, that timestamps are preferred for storage, and that developers should use st2common.util.date.get_datetime_utc_now and ComplexDateTimeField when dealing with timestamps.\n\n7. Tests were extended and reorganized:\n   - Added st2common/tests/unit/test_date_utils.py to test the new date utilities (get_datetime_utc_now, add_utc_tz, convert_to_utc, and parse with and without preserve_original_tz).\n   - test_isotime.py was renamed to test_isotime_utils.py and adjusted to use the new date utilities where appropriate.\n\nCollectively, these changes ensure that all internal handling of datetime values is consistently timezone-aware and normalized to UTC, eliminating subtle bugs where non-UTC timestamps were being stored, compared, or converted incorrectly.",
        "semantic_memory": "This change encapsulates several generalizable best practices around datetime and timezone handling in distributed systems:\n\n1. Always use timezone-aware datetimes internally.\n   - Naive datetime objects are ambiguous and lead to subtle bugs, especially in distributed systems or when daylight savings time is involved.\n   - Adopt a convention that all internal datetimes must be timezone-aware and in UTC.\n\n2. Normalize to UTC at boundaries.\n   - Whenever data enters the system (API input, configuration, external services), parse any date strings and immediately normalize them to UTC.\n   - Preserve original timezones only when there is a clear, explicit need (e.g., for display), and document those cases.\n\n3. Centralize date/time handling in utility modules.\n   - Provide a single set of utilities for getting the current time, adding tzinfo, converting between timezones, and parsing strings.\n   - In this fix, general date operations live in st2common.util.date, and ISO8601-specific operations live in st2common.util.isotime. This clear separation aids readability and reduces duplicated logic.\n\n4. Never overwrite tzinfo just to \"add UTC\" without conversion.\n   - Simply replacing tzinfo on a datetime that already has a non-UTC timezone is incorrect; it discards the original offset and produces a wrong instant in time.\n   - Instead, use astimezone(...) or an explicit conversion helper. In this fix, add_utc_tz now raises an error if called on a datetime with a non-UTC tzinfo, forcing callers to convert properly.\n\n5. Enforce invariants at the persistence layer.\n   - Database fields that represent timestamps should enforce constraints like \"must be UTC\" and raise on violations. This prevents incorrect data from being stored and surfaces errors early.\n   - ComplexDateTimeField now enforces UTC before converting to microseconds-since-epoch.\n\n6. Use microsecond-precision timestamps with explicit UTC for storage.\n   - Storing timestamps as microseconds since epoch coupled with explicit UTC semantics simplifies comparisons and range queries.\n   - When converting back to datetime, always attach UTC tzinfo.\n\n7. Make time-based operators format-flexible and timezone-safe.\n   - Time comparison operators should not rely on a single hard-coded datetime format. Instead, use robust parsing (dateutil.parser) and normalize to UTC before comparison.\n\n8. Update tests and docs alongside behavior changes.\n   - Any change to datetime handling requires thorough test updates (especially assertions around string representations) and documentation so that contributors know which helpers to use and what invariants to maintain.\n\nThese practices apply across many systems that manipulate timestamps: normalize everything to UTC, centralize time utilities, enforce invariants at the boundaries and persistence layer, and avoid silent timezone assumptions.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving datetime and timezone handling:",
            "Step 1: Identify where datetimes enter and exit the system.",
            "  - Search the codebase for uses of datetime.now(), datetime.utcnow(), and direct datetime constructors (datetime(...)).",
            "  - Locate all parsing points: where date strings from APIs, configs, or external services are converted into datetime objects (e.g., with strptime, dateutil.parser.parse, or custom parsing).",
            "  - Find all persistence points: fields in database models, serialization/deserialization logic, and any conversion to/from timestamps.",
            "Step 2: Decide on a global convention.",
            "  - Establish that all internal datetime objects must be timezone-aware and normalized to UTC.",
            "  - Decide where (if anywhere) original timezones are preserved (usually only at the UI or external boundary). Document this clearly.",
            "Step 3: Introduce centralized date/time utilities if they do not already exist.",
            "  - Implement a small module (e.g., util.date) that provides:\n    - get_datetime_utc_now() for the current UTC time with tzinfo.\n    - add_utc_tz(dt) that safely attaches UTC tzinfo to naive datetimes and raises if dt has a non-UTC timezone.\n    - convert_to_utc(dt) that properly converts any datetime (naive assumed UTC, or any tz-aware) into a UTC datetime.\n    - parse(value, preserve_original_tz=False) that uses a robust parser (like dateutil) and converts the result to UTC unless preserve_original_tz=True.",
            "  - For format-specific concerns (e.g., ISO8601), keep a separate module (e.g., util.isotime) that focuses on validation and formatting, delegating general parsing and conversion to the generic utilities.",
            "Step 4: Refactor parsing and now() calls to use the utilities.",
            "  - Replace datetime.now() and datetime.utcnow() with get_datetime_utc_now() everywhere in the codebase, including tests and tools.",
            "  - Replace direct uses of dateutil.parser.parse, datetime.strptime, or custom parsing for inbound values with date_utils.parse or isotime.parse (depending on whether the input is generic or ISO8601), making sure results are UTC by default.",
            "  - If some call sites need to preserve the original timezone, call parse(..., preserve_original_tz=True) explicitly and handle the result carefully.",
            "Step 5: Harden database field definitions.",
            "  - For timestamp fields, implement or use a field type that:\n    - Stores values as a numeric representation (e.g., microseconds since epoch) or explicit UTC datetimes.\n    - When converting from datetime to the storage representation, verifies that dt.tzinfo is UTC and raises an error otherwise.\n    - When converting back, attaches UTC tzinfo to reconstructed datetimes.",
            "  - Update any models that had naive defaults (e.g., datetime.utcnow) to use get_datetime_utc_now as the default value.",
            "Step 6: Audit and fix all comparisons and time-based logic.",
            "  - For token expiry, scheduled tasks, and time-based rules, ensure both operands are UTC-aware datetimes before comparing.",
            "  - Replace simplistic parsing (e.g., datetime.strptime with a single format) with robust parsing via date_utils.parse or equivalent, then normalize to UTC.",
            "  - For custom operators (e.g., timediff_lt, timediff_gt), ensure they:\n    - Use a UTC now from get_datetime_utc_now().\n    - Parse the target date string via a centralized parse helper, not ad hoc formats.\n    - Compare using total_seconds() or equivalent numeric comparison.",
            "Step 7: Prevent incorrect usage of tzinfo manipulation.",
            "  - Modify helpers like add_utc_tz to throw if they are given a datetime with a non-UTC tzinfo instead of silently replacing tzinfo. This surfaces misuse early.",
            "  - Encourage developers to use convert_to_utc(dt) instead of manually doing dt.replace(tzinfo=...).",
            "Step 8: Update tests for deterministic behavior.",
            "  - Adjust tests to use get_datetime_utc_now() rather than datetime.now/utcnow, or mock the utility function when a fixed time is needed.",
            "  - Update expectations of string representations to include timezone offsets (e.g., '+00:00') where applicable.",
            "  - Add dedicated tests for utilities to verify:\n    - get_datetime_utc_now returns UTC tz-aware datetimes.\n    - add_utc_tz raises for non-UTC tzinfo.\n    - convert_to_utc correctly converts from various timezones.\n    - parse handles multiple input formats and preserve_original_tz correctly.",
            "Step 9: Document the conventions.",
            "  - Add documentation explaining that all internal datetimes must be UTC and tz-aware.",
            "  - Document when and how to use the date utilities, and how to define DB fields for timestamps.",
            "  - Provide coding guidelines: never call datetime.now()/utcnow directly; always go through the utilities.",
            "Step 10: Monitor for regressions.",
            "  - After deploying the changes, watch logs and error reports for ValueError from date utilities (e.g., add_utc_tz) or ComplexDateTimeField. These might indicate remaining call sites that still violate the UTC invariant.",
            "  - Use static analysis or grep to ensure no new datetime.now()/utcnow usages are being introduced outside the utilities."
        ]
    }
}
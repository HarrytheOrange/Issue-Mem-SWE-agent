{
    "search_index": {
        "description_for_embedding": "Adds an automated CI step to validate Home Assistant integration manifests. A new Python script walks all component directories, checks that each has a manifest.json, validates its JSON schema with voluptuous, ensures the manifest domain matches the directory name, and verifies that all listed dependencies have their own manifests. The CI workflow is updated to run this validator in the virtualenv after installing project dependencies.",
        "keywords": [
            "CI validation",
            "manifest validation",
            "Home Assistant integrations",
            "manifest.json schema",
            "voluptuous schema",
            "CircleCI config",
            "virtualenv activation",
            "dependency manifest check",
            "domain matches directory name",
            "configuration validation",
            "repository-wide config check"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the project needed to ensure that every integration in the repository had a valid manifest.json and that these manifests stayed consistent over time. The solution was to introduce a dedicated validation script and integrate it into the CI pipeline.\n\nA new script, script/manifest/validate.py, was created. It uses Python's pathlib and json modules alongside the voluptuous validation library. The script defines MANIFEST_SCHEMA, requiring the following fields in each manifest.json: 'domain', 'name', 'documentation', 'requirements' (list of strings), 'dependencies' (list of strings), and 'codeowners' (list of strings). For each integration directory under homeassistant/components, validate_integration performs several checks:\n- A manifest.json file must exist. If it's missing, that's a fatal error for that integration.\n- The file must contain valid JSON. Parsing errors are reported as invalid JSON.\n- The parsed JSON must satisfy the MANIFEST_SCHEMA, with errors humanized via voluptuous.humanize_error.\n- The 'domain' value in the manifest must match the directory name of the integration.\n- For every listed dependency in 'dependencies', a corresponding manifest.json must exist in the sibling integration directory.\n\nA validate_all() function iterates over all entries in homeassistant/components, skipping files and __pycache__, runs validate_integration, collects all integrations with errors, and prints a human-readable report for each invalid manifest. It returns exit code 0 when all manifests are valid and 1 when any problems are found; this exit code allows CI to fail on manifest issues.\n\nOn the CI side, the .circleci/config.yml was updated. Initially, a new CircleCI run step 'validate manifests' was added before static checks, invoking `python script/manifest/validate.py`. The script's file mode was corrected from 100644 to 100755 so it can be executed as a script if needed. It became clear that the validator depends on the voluptuous library, which is installed as part of the Home Assistant environment. Therefore, the validation step was moved to run after the 'install' step, and the command was changed to first activate the virtualenv (`. venv/bin/activate`) and then run the validator (`python script/manifest/validate.py`). This ensures that voluptuous and other dependencies are available when the validation runs.\n\nNet effect: CI now automatically verifies the existence and correctness of every integration manifest, including dependencies and naming consistency, and fails early when manifests are missing or malformed.",
        "semantic_memory": "This change illustrates several generalizable practices around configuration/manifest validation and CI integration:\n\n1. Treat manifests and configuration as first-class, validated artifacts:\n   - When a project relies heavily on per-module or per-plugin manifests (e.g., integration descriptors), enforcing structural correctness prevents a large class of runtime errors and inconsistencies.\n   - A schema-based validator (e.g., voluptuous, JSON Schema, pydantic) is a robust way to define required fields, types, and constraints in a single central place.\n\n2. Validate integrity relationships, not just shape:\n   - Beyond ensuring a manifest has required keys, it is important to check consistency rules such as 'domain' matching the directory name. This guards against copy/paste errors and misconfigurations that might not be caught by simple type checks.\n   - Inter-resource references (e.g., `dependencies`) should be validated as well. If a manifest declares a dependency on another component, it is valuable to enforce that the dependent component actually exists and exposes its own valid manifest.\n\n3. Integrate validation into the CI pipeline with proper environment setup:\n   - Validation scripts should be part of the automated CI pipeline so that invalid manifests cannot be merged. This shifts failure from runtime (on user machines) to build time.\n   - If the validation script depends on runtime libraries (like voluptuous), it must be executed within the same environment (e.g., project virtualenv) where those dependencies are installed, and only after installation steps have run.\n   - The order of CI steps matters: if you run a validation step before dependencies are installed, it will fail for the wrong reason (missing libraries) instead of actual manifest issues.\n\n4. Make validation fast and repo-wide:\n   - A well-written validator that scans all modules (here, all integration directories) can be fast enough (~0.25s) to run on every CI job, rather than only on changed files. This ensures global consistency and avoids accumulating stale or broken manifests.\n\n5. Use fail-fast behavior and clear error reporting:\n   - The validator returns non-zero exit codes when any manifests are invalid, causing the CI job to fail.\n   - Printing a consolidated, readable report of all problematic manifests (listing each integration and its errors) helps maintainers quickly identify and fix issues.\n\nOverall, this patch reinforces the principle that structured project metadata should be validated as strictly and automatically as code, with schema-based checks and integrated CI enforcement.",
        "procedural_memory": [
            "To diagnose and implement similar manifest/configuration validation and CI integration:",
            "Step 1: Identify the configuration/manifest scope",
            "Determine which parts of the codebase rely on structured manifests or configuration (e.g., per-module manifest.json files, plugin descriptors, YAML configs). Decide which directories you need to scan (e.g., homeassistant/components).",
            "Step 2: Define a schema for valid manifests",
            "List all required fields, their types, and any constraints: for example, require 'domain', 'name', 'documentation', 'requirements' as list[str], 'dependencies' as list[str], and 'codeowners' as list[str]. Also decide on cross-field or external constraints (e.g., 'domain' must equal folder name; dependencies must exist as sibling modules). Implement that schema using a validation library such as voluptuous, JSON Schema, or pydantic.",
            "Step 3: Implement a validator function per item",
            "Write a function (like validate_integration(path)) that:\n- Accepts a path to a module/integration.\n- Checks for the existence of the manifest file.\n- Attempts to load and parse the manifest (catch JSON/YAML parsing errors).\n- Applies the schema validator to the parsed data and collects any validation errors.\n- Performs project-specific consistency checks (e.g., ID vs directory name, dependency existence checks).\n- Returns a list of error messages (empty if valid).",
            "Step 4: Implement a repository-wide validation runner",
            "Write a function (like validate_all()) that:\n- Iterates over all target directories within the root path (e.g., all subdirectories in homeassistant/components, skipping files and __pycache__).\n- Calls the per-item validator for each directory.\n- Collects all integrations with errors.\n- Prints a human-readable summary for each invalid manifest.\n- Returns exit code 0 if all are valid, or 1 if any errors were found.",
            "Step 5: Make the validation script executable and self-contained",
            "Ensure the script has an appropriate shebang (#!/usr/bin/env python3) and executable permissions (mode 755) if needed. At the bottom, include a standard main guard that exits with the validator’s return code: `if __name__ == '__main__': sys.exit(validate_all())`.",
            "Step 6: Integrate the validator into the CI config in the correct place",
            "Add a new step to your CI pipeline (e.g., in .circleci/config.yml, GitHub Actions workflow, or similar):\n- Place the validation step after dependency installation, especially if the script uses external libraries like voluptuous.\n- Activate the project’s virtual environment if applicable (e.g., `. venv/bin/activate`).\n- Run the validation script with `python script/manifest/validate.py` (or the appropriate path). The script’s non-zero exit code should cause the CI job to fail.",
            "Step 7: Verify runtime and adjust strategy if necessary",
            "Measure how long the validation takes to run over all items. If it’s fast (e.g., under a second), run it on every job over the entire repo. If it’s slow, you might instead restrict validation to changed paths or run it in specialized CI jobs.",
            "Step 8: Use the validator to debug broken manifests",
            "When CI fails due to manifest issues, read the error output produced by the validator: it should list each problematic manifest with specific reasons (missing file, invalid JSON, schema violations, mismatched domain, missing dependency manifests). Fix the manifest(s) accordingly and rerun CI to confirm.",
            "Step 9: Maintain and evolve the schema over time",
            "As new manifest fields or invariants are introduced, update the schema and validator logic, and ensure CI continues to enforce the new rules globally. This prevents new invalid manifests from entering the codebase and keeps existing manifests consistent."
        ]
    }
}
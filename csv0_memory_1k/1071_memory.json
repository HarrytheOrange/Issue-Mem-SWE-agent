{
    "search_index": {
        "description_for_embedding": "Fix for PokemonGo bot breaking on NotLoggedInException by adding a configurable reconnect timeout and retry loop in the main CLI entrypoint.",
        "keywords": [
            "broken connection",
            "auto reconnect",
            "NotLoggedInException",
            "reconnecting_timeout",
            "PokemonGoBot",
            "pokecli.py",
            "pgoapi",
            "login/session error handling",
            "retry with backoff",
            "CLI main loop"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the PokemonGo bot would terminate when the underlying pgoapi library raised pgoapi.exceptions.NotLoggedInException, typically due to a dropped or invalidated session with the game servers. The original main() function in pokecli.py only wrapped the bot lifecycle in a try/except for KeyboardInterrupt, so any NotLoggedInException bubbled up and crashed the process, resulting in a \"broken connection\" and forcing the user to restart the bot manually.\n\nThe fix introduced a new configuration parameter, reconnecting_timeout, exposed both in configs/config.json.example and as a CLI argument (--reconnecting_timeout / -rt, default 15 minutes). The main() function was refactored to run inside a while not finished loop. Inside this loop, the bot is created (PokemonGoBot(config)), started (bot.start()), and then steps are processed in an infinite loop (bot.take_step()). Two exception handlers are added around this lifecycle:\n\n1. KeyboardInterrupt: logs 'Exiting PokemonGo Bot', sets finished = True, and exits the outer loop so the process ends cleanly.\n2. NotLoggedInException: logs a message indicating a connection error and instructing the user to wait reconnecting_timeout minutes, then sleeps for reconnecting_timeout * 60 seconds before re-entering the loop and recreating/restarting the bot.\n\nSupporting changes include importing NotLoggedInException from pgoapi.exceptions and importing time to support the sleep call. A typo in the import statement was corrected in a follow-up patch (from 'from pgoapi.exceptions import import NotLoggedInException' to 'from pgoapi.exceptions import NotLoggedInException'). This change ensures that temporary login/session failures no longer crash the bot and instead trigger an automatic, configurable reconnection delay.",
        "semantic_memory": "This fix illustrates a common pattern for robust long-running CLI services that depend on remote APIs or authenticated sessions:\n\n1. **Treat certain exceptions as transient and recoverable.** Errors like NotLoggedInException (session expired, token invalid, temporary server issue) should not necessarily terminate the process. Instead, the program should recognize them as recoverable states and attempt to re-establish the session.\n\n2. **Centralize retry logic at the process boundary.** Rather than scattering retries throughout business logic, the main entrypoint can wrap the core run loop in a retry or supervision loop. This isolates control flow (start, run, handle fatal vs non-fatal errors, retry) from the domain logic.\n\n3. **Use configurable backoff for reconnection.** The reconnecting_timeout parameter allows operators to tune how aggressively the bot retries after encountering a connection or login error. Exposing this via config and CLI flags is a best practice for operations and experimentation.\n\n4. **Maintain graceful shutdown semantics.** While adding retries, it is important not to interfere with explicit shutdown signals (e.g., KeyboardInterrupt). The code preserves user control: Ctrl+C sets a finished flag and exits the supervisory loop, preventing infinite retries when the user wants to stop the program.\n\n5. **Log clearly when retrying.** Before sleeping and retrying, the program logs a clear message including the timeout duration. Clear logs are essential for diagnosing why the bot appears idle (it is waiting before reconnecting).\n\nIn general, when building resilient bots, agents, or daemons that talk to external services, it is good practice to: delineate between fatal and non-fatal exceptions, implement a supervised main loop, use configurable delays/backoff for retries, and ensure that shutdown signals always override retry logic.",
        "procedural_memory": [
            "Step-by-step guide to diagnosing and fixing similar connection/session break issues in long-running CLI bots:",
            "Step 1: Observe the failure mode.\n- Run the bot and watch the logs.\n- Note whether the process exits abruptly when a connection or login issue occurs (e.g., NotLoggedInException, authentication failure, timeouts).\n- Confirm if the user currently must manually restart the process after such an error.",
            "Step 2: Identify the exact exception and where it surfaces.\n- Check the stack trace in the logs to find the exception type (e.g., pgoapi.exceptions.NotLoggedInException) and where it is raised.\n- Determine whether this exception is truly fatal or a transient condition that can be retried (e.g., expired token, temporary network glitch).",
            "Step 3: Locate the main entrypoint / run loop.\n- Find the main() function or equivalent entrypoint script (in this case, pokecli.py).\n- Look for the top-level try/except or loop that controls bot startup and per-step execution (e.g., bot = PokemonGoBot(config); bot.start(); while True: bot.take_step()).",
            "Step 4: Design a supervisory loop with clear termination conditions.\n- Wrap the entire bot lifecycle (creation, start, step loop) in an outer loop controlled by a flag such as finished = False and while not finished: ...\n- Ensure that the loop is intended to restart the bot after certain exceptions, while still allowing a clean exit on user request.",
            "Step 5: Add exception handling for transient errors.\n- In the outer try/except surrounding the bot lifecycle, add an except block for the transient exception, e.g.:\n  - except NotLoggedInException:\n      - Log a clear message explaining that a connection/session error occurred and that the bot will retry after a delay.\n      - Sleep for a configurable interval before looping back and recreating the bot.\n- Import the required exception type from the appropriate package (e.g., from pgoapi.exceptions import NotLoggedInException).",
            "Step 6: Make the backoff configurable.\n- Add a configuration option (e.g., reconnecting_timeout) in the config file template (config.json.example) and CLI argument parser:\n  - parser.add_argument('-rt', '--reconnecting_timeout', type=float, default=15.0, help='Timeout between reconnecting if error occurred (in minutes, e.g. 15)').\n- Use this config value when sleeping before retry: time.sleep(config.reconnecting_timeout * 60).",
            "Step 7: Preserve graceful shutdown behavior.\n- Add a KeyboardInterrupt handler in the same try/except block:\n  - except KeyboardInterrupt:\n      - Log an exit message.\n      - Set finished = True to break the outer loop, allowing the process to terminate cleanly.\n- Avoid catching KeyboardInterrupt in a way that would cause the program to ignore user requests to stop.",
            "Step 8: Test the behavior under failure conditions.\n- Simulate or induce a NotLoggedInException (e.g., by invalidating credentials or forcing a reconnect error).\n- Verify that the process logs the error, waits the configured reconnecting_timeout, and then restarts the bot without manual intervention.\n- Also test Ctrl+C during normal operation and while waiting to reconnect, ensuring the bot exits promptly.",
            "Step 9: Review logging and documentation.\n- Ensure log messages clearly explain what is happening during failures and retries (include the timeout value).\n- Update documentation/config templates to describe the new reconnecting_timeout parameter and its effect.",
            "Step 10: Generalize for other transient failures if needed.\n- If there are other known transient exceptions (network timeouts, rate limits, etc.), consider handling them similarly with configurable backoff and clear logging.\n- Keep this logic centralized in the main supervisory loop to maintain clarity and consistency."
        ]
    }
}
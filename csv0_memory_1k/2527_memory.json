{
    "search_index": {
        "description_for_embedding": "Refactor and centralize Pokemon catching logic to remove duplicated berry/ball selection code, correctly choose the first available ball instead of always a Pokeball, fix negative/invalid ball usage, and align encounter/catch status handling and events (including NOT_IN_RANGE and POKEMON_INVENTORY_FULL) while respecting catch/ignore/VIP configurations.",
        "keywords": [
            "pokemon_catch_worker",
            "catch worker refactor",
            "ball selection bug",
            "no_pokeballs",
            "negative pokeball count",
            "berry usage",
            "VIP pokemon logic",
            "encounter status 5 7",
            "ENCOUNTER_NOT_IN_RANGE",
            "POKEMON_INVENTORY_FULL",
            "event emission",
            "duplicate logic",
            "refactor game logic"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the PokemonGo-Bot project had a large, heavily nested `pokemon_catch_worker.py` containing multiple copies of similar logic for catching Pokemon, choosing which Pokeball to use, and when to throw berries. This duplication made the behavior hard to reason about and introduced subtle bugs, such as defaulting to Pokeball even when none were available (resulting in effectively 'throwing -1 pokeballs'), inconsistent ball selection, and messy VIP/ignore rules. In addition, the code mixed encounter-level status handling with catch-level status, and did not properly emit events for certain server statuses (encounter NOT_IN_RANGE and POKEMON_INVENTORY_FULL) nor avoid events for Pokemon that were configured to be ignored.\n\nThe fix was a structural refactor of the catch worker. A small `Pokemon` value object was introduced to encapsulate name, CP, and IV calculations. Catch decision logic was centralized in helper methods (`_pokemon_matches_config`, `_should_catch_pokemon`, `_is_vip_pokemon`), which correctly interpret the `catch` and `vips` configuration, including treating an empty dict entry in `vips` as 'always VIP'. Berry and ball selection logic was consolidated into `_do_catch` and `_use_berry`, which now (1) always select the lowest available ball type and gracefully escalate to better balls, (2) ensure there is at least one usable ball before throwing (emitting a `no_pokeballs` event instead of attempting invalid throws), (3) use berries only when the catch rate is below a configurable threshold and there are berries to spare, and (4) correctly apply the `item_capture_mult` multiplier from the server to all ball catch rates.\n\nThe refactor introduced explicit constants for status codes, separated encounter status (`ENCOUNTER_STATUS_*`) from catch status (`CATCH_STATUS_*`), and wired them correctly. Encounter statuses NOT_IN_RANGE (5) and POKEMON_INVENTORY_FULL (7) now generate `pokemon_not_in_range` and `pokemon_inventory_full` events at the encounter stage instead of being misinterpreted as catch results. The worker was also updated to stop emitting 'pokemon appeared' or other events for Pokemon that the configuration says to ignore. Evolving newly caught Pokemon was updated to use inventory snapshots before and after the catch, and to emit a `pokemon_evolved` event.\n\nSeveral follow-up patches fixed small regressions introduced during the refactor: `_use_berry` was corrected to build the updated catch-rate list with `append` instead of indexing into an empty list, a typo in `emit_event('no_pokeballs', formatted=...)` was fixed, inconsistent variable names (`berries_count` vs `berry_count`, `catch_rate_before_throw` vs `ideal_catch_rate_before_throw`) were aligned, and events were registered with the right parameter signatures. After running the bot for hours, contributors reported that catching now worked reliably, defaulted to the first available ball instead of failing on missing Pokeballs, and properly informed users when Pokemon were out of range or the inventory was full.",
        "semantic_memory": "This fix illustrates several generalizable software engineering patterns for complex, stateful logic driven by external APIs:\n\n1. **Refactor duplicated decision logic into centralized helpers**: When multiple code paths implement similar decision trees (e.g., choosing items and triggers based on probabilities and inventory), bugs and inconsistencies proliferate. Encapsulating that logic in dedicated functions (`_do_catch`, `_use_berry`, `_pokemon_matches_config`) reduces the chance of divergence and makes reasoning about behavior much easier.\n\n2. **Introduce domain objects for clarity**: Wrapping raw API dictionaries in a `Pokemon` class clarifies what fields exist (name, CP, IV) and centralizes derived computations like IV percentage and display strings. This improves readability and makes it harder to misuse fields.\n\n3. **Use configuration-aware matching utilities**: Configurations for 'catch', 'ignore', and 'VIP' behavior can be tricky: multiple attributes (CP, IV), different logical operations (AND vs OR), and sentinel values (empty dict meaning 'always VIP'). A generic helper that interprets a config entry for an entity, with a well-defined default logic and precedence, makes those rules explicit and consistent.\n\n4. **Handle external API status codes explicitly and distinctly**: The code previously conflated encounter status codes with catch result status codes. Separating `ENCOUNTER_STATUS_*` from `CATCH_STATUS_*` and mapping them to explicit behavior (e.g., log, emit events, abort) prevents misinterpretation and ghost bugs. Having clearly named constants also documents what each numeric status means.\n\n5. **Guard against resource underflow / missing resources**: Item-using logic should always check that there is at least one usable item before trying to 'use' it. In this case, ensuring that at least one ball is present prevents attempts to use a ball type with zero quantity, which previously led to logical errors such as \"-1 pokeballs\".\n\n6. **Prefer `==` over `is` for numeric comparisons**: Comparing integers with `is` relies on CPython implementation details about object identity. The refactor clarifies semantics by using comparison operators (`==`) for status codes and other numeric checks.\n\n7. **Emit events only for relevant, user-visible situations**: Events should reflect meaningful actions or problems. The updated implementation ensures that no events are emitted for Pokemon that are configured to be ignored, while new events are added for important server feedback such as 'Pokemon not in range' and 'Pokemon inventory full'. This pattern keeps the event stream more accurate and useful for consumers.\n\n8. **Use pre/post snapshots to determine side effects**: To find which Pokemon was just caught or evolved, the bot compares pre- and post-inventory ID lists instead of assuming ordering or trusting returned data structure quirks. This pattern—taking state snapshots and diffing them—is broadly useful when APIs don't directly tell you which entity changed.\n\n9. **Hide tuning constants behind well-named variables**: Thresholds like ideal catch rates (0.9 for VIP, 0.35 for normal) are now expressed as `ideal_catch_rate_before_throw`, making it very clear what they represent and where to change them. This reduces magic numbers and aids in future tuning.\n\n10. **Fail fast and clearly on unsupported situations**: For example, when there are no usable balls, the worker emits a `no_pokeballs` event and stops trying, instead of repeatedly making invalid calls. This helps users diagnose configuration or inventory issues quickly.",
        "procedural_memory": [
            "How to diagnose and refactor duplicated, bug-prone game logic involving external API statuses and resource usage:",
            "Step 1: Identify duplication and inconsistent behavior. Search for all occurrences of complex logic (e.g., ball selection, berry usage, VIP checks). Note any differences and bugs reported by users (like attempts to use Pokeballs when none are available, or status codes being misinterpreted).",
            "Step 2: Introduce a small domain-specific object to represent the core entity. Here, create a `Pokemon` class that wraps raw API data and provides properties for common computed values (CP, IV percentage, IV display string). Replace scattered dictionary field accesses with this class to reduce verbosity and centralize data interpretation.",
            "Step 3: Centralize configuration-based decision logic. Implement a helper (like `_pokemon_matches_config`) that, given a configuration section and a Pokemon, answers whether conditions (e.g., CP/IV thresholds, always/never flags) are met using a well-defined default logic (`and` or `or`). Use this helper to implement `_should_catch_pokemon` and `_is_vip_pokemon`, including special cases (e.g., empty dict meaning 'always VIP').",
            "Step 4: Separate and name status codes clearly. Define constants for each numeric status from the external API, distinguishing between different categories (e.g., `ENCOUNTER_STATUS_SUCCESS` vs `CATCH_STATUS_SUCCESS`). Replace inline numeric comparisons throughout the code with comparisons to these constants using `==`. This makes it easy to add handling for new statuses like NOT_IN_RANGE and POKEMON_INVENTORY_FULL.",
            "Step 5: Rework the main workflow to use the new helpers. In the main `work()` method, perform the encounter, validate the response via the encounter status code, and early-return for non-success statuses, emitting the right events (e.g., `pokemon_not_in_range`, `pokemon_inventory_full`). Only construct the `Pokemon` object and emit appearance/VIP events when the encounter is successful and the Pokemon is not ignored.",
            "Step 6: Consolidate item usage (balls and berries) into dedicated functions. Implement `_do_catch` to be the single place where ball selection and berry usage occurs. It should:",
            "- Determine the initial ball as the lowest available type (Pokeball, then Greatball, then Ultraball), and abort with a clear event (`no_pokeballs`) if none are available.",
            "- Decide when to throw berrries based on current catch probability and berry availability, distinguishing between VIP and normal thresholds.",
            "- Recalculate catch probabilities after a berry is used via a helper like `_use_berry`, which correctly applies the multiplier to all ball types.",
            "- Try to upgrade to a better ball if the current ball's catch rate is below the desired threshold and better balls are available.",
            "- Handle catch result statuses: retry on FAILED, softban detection/logging on VANISHED with 100% catch rate, and success handling on SUCCESS.",
            "Step 7: Ensure that resources are never used when counts are zero. Before consuming a ball or berry, check the corresponding stock count. When a resource is consumed, decrement the count in the in-memory stock structure, and avoid negative counts. If depletion prevents any further meaningful action, emit an appropriate event and stop.",
            "Step 8: Implement pre/post state snapshots for downstream operations. When evolving newly caught Pokemon, capture the list of Pokemon IDs before the catch and after a successful catch, then diff the lists to determine the newly added Pokemon. Implement `_do_evolve` to perform the evolution and emit a suitable event (`pokemon_evolved`), handling failure cases gracefully.",
            "Step 9: Adjust the event system to reflect the new behavior. Register any new events needed (e.g., `pokemon_not_in_range`, `pokemon_inventory_full`, or updated variants) and ensure they have the correct parameter signatures. Remove or update events that no longer apply or should not fire for ignored entities.",
            "Step 10: Test the refactor end-to-end. Run the bot under typical and edge-case conditions: no Pokeballs, limited berries, full inventory, out-of-range Pokemon, VIP and ignored Pokemon. Verify that: the correct balls and berries are used, events match real situations, no negative resource counts are logged, and configuration-driven behavior (catch, ignore, VIP) is respected. Iterate on any regressions (typos, wrong variable names, missing list initialization) detected during this testing."
        ]
    }
}
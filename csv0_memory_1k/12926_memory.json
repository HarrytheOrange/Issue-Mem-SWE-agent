{
    "search_index": {
        "description_for_embedding": "Home Assistant SpotCrime sensor stopped working because the library-embedded default API key was removed and the integration did not require or pass a user API key. Additionally, include/exclude crime-type filters were not being forwarded to the SpotCrime client. Fix: bump spotcrime library to 1.0.3, add a required api_key configuration option, pass api_key and include/exclude to SpotCrime.SpotCrime, and clean up linting.",
        "keywords": [
            "Home Assistant",
            "SpotCrime",
            "sensor.spotcrime",
            "API key required",
            "authentication change",
            "breaking change",
            "configuration schema",
            "CONF_API_KEY",
            "include exclude filters",
            "filter not applied",
            "Python dependency bump",
            "requirements_all.txt",
            "library signature change",
            "spotcrime==1.0.3",
            "integration with third-party API"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The Home Assistant SpotCrime sensor relied on the underlying spotcrime Python library, which originally shipped with a default API key baked into the library. The upstream SpotCrime service changed its policy so that a shared default key was no longer valid, and the library was updated to remove the default key and instead require a caller-supplied API key. In Home Assistant, the SpotCrime sensor had not been updated accordingly: it neither exposed an API key in configuration nor passed one into the SpotCrime client. At the same time, the sensor had an `include`/`exclude` configuration for crime types that was not wired correctly and was effectively passing `None` for both to the SpotCrime client, so filters were not being applied.\n\nSymptoms: users’ SpotCrime sensors would silently or explicitly fail once the default key stopped working. Additionally, attempts to configure `include`/`exclude` filters had no effect on the returned incidents.\n\nFix implemented in this PR:\n1. The spotcrime dependency was bumped from `spotcrime==1.0.2` to `spotcrime==1.0.3` in both the integration’s `REQUIREMENTS` and `requirements_all.txt` to match the updated library that supports user-supplied API keys and the correct constructor signature.\n2. The sensor’s configuration schema (`PLATFORM_SCHEMA`) was updated to require `api_key` via `CONF_API_KEY`. Example YAML now includes:\n   ```yaml\n   sensor:\n     - platform: spotcrime\n       name: Spot Crime\n       days: 8\n       radius: 0.05\n       api_key: \"your_api_key_here\"\n       include:\n         - Theft\n         - Vandalism\n         - Other\n   ```\n3. `setup_platform` now reads `api_key` from the config and passes it into the `SpotCrimeSensor` constructor.\n4. `SpotCrimeSensor.__init__` was updated to accept `api_key` as a parameter and store it as `self.api_key`.\n5. The `spotcrime.SpotCrime` client is now instantiated with all relevant options:\n   - coordinates `(latitude, longitude)`\n   - `radius`\n   - `self._include`\n   - `self._exclude`\n   - `self.api_key`\n   - `self.days`\n   This both ensures the API key is supplied and fixes the previous bug where `include`/`exclude` were effectively `None` and not applied.\n6. Minor linting and formatting fixes were made (line-length and import formatting) to satisfy the project’s style and CI requirements.\n\nThe result: the SpotCrime sensor now requires the user to configure a valid API key, correctly passes that key to the SpotCrime library, and honors configured include/exclude filters for crime types. The change was released in Home Assistant 0.66 (not 0.65.x), as noted in the discussion.",
        "semantic_memory": "1. **External service auth changes must be surfaced through configuration**: When an external API removes a default credential (e.g., embedded API key) and requires caller-supplied credentials, any integration that wraps that library must:\n   - Update its dependency to a compatible version.\n   - Expose the new credential as an explicit configuration option.\n   - Make the option required if the service cannot function without it.\n   - Pass the credential through to the library.\n\n2. **Do not rely on shared or hard-coded API keys**: Shipping a shared or library-default API key is fragile and often violates providers’ terms of service. Best practice is to require per-user keys in configuration and never embed them in code or libraries.\n\n3. **Keep integration config in sync with library signatures**: When a dependency’s constructor signature changes (e.g., new `api_key` parameter, additional filter parameters), integration code must be updated to:\n   - Match the new call signature.\n   - Wire through all relevant configuration options from the platform’s config schema to the library call.\n   - Update tests and documentation accordingly.\n\n4. **Configuration options must be actually used**: It’s easy to define config options like `include`/`exclude` but forget to pass them to the underlying library. This results in confusing behavior where the configuration appears supported but does nothing. A best practice is to trace each config option from schema, through setup, into the runtime object and then into the external call.\n\n5. **Consistent dependency versioning across the project**: For monorepos like Home Assistant, dependencies must be updated consistently in all relevant places (`REQUIREMENTS`, `requirements_all.txt`, etc.), or runtime mismatches and subtle bugs can occur.\n\n6. **Lint and style checks are part of reliability**: Ensuring imports are formatted correctly and lines do not exceed project limits may seem cosmetic, but failing lint can block CI and delay important bug fixes. Integrating these checks into the development workflow reduces friction.\n\n7. **Communicate breaking changes and release versions**: When a breaking change such as requiring an API key is introduced, it’s important to update documentation and clearly communicate in which release the change will appear, so users understand why their configuration suddenly requires new fields.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Confirm the symptom and dependency behavior\n- Observe failing integration behavior (e.g., external API calls failing or returning no data).\n- Check logs for authentication errors or deprecation notices from the external service.\n- Inspect the underlying library’s documentation or changelog to see if authentication or constructor signatures changed (e.g., default API key removed, new api_key parameter added).",
            "Step 2: Verify configuration vs. actual usage\n- Review the integration’s configuration schema to see which options (API key, filters, etc.) are defined.\n- Trace those options through setup code (e.g., `setup_platform`) into the runtime entity or client object.\n- Confirm that all relevant config options are actually passed to the underlying library calls and not ignored or replaced with `None`.",
            "Step 3: Update the dependency and its usage\n- Bump the library version in the integration-specific REQUIREMENTS and any global requirements files to the version that supports the new behavior.\n- Update the instantiation of the library client to match the new function or constructor signature.\n  - Add parameters such as `api_key`, filters, or other options as required.\n  - Ensure order and naming match the updated library specification.",
            "Step 4: Expose and validate new configuration options\n- Add new required configuration keys (e.g., `api_key`) to the platform schema using the project’s config validation utilities.\n- Decide whether the field should be `Required` or `Optional` based on whether the integration can function without it.\n- Validate types (e.g., `cv.string` for API keys, `cv.positive_int` for days, `vol.Coerce(float)` for radius).",
            "Step 5: Wire configuration through to runtime objects\n- Modify `setup_platform` (or equivalent) to read the new config option.\n- Update the entity or client class constructor to accept the new parameter.\n- Store the value on the instance (e.g., `self.api_key`) and pass it into the library’s client constructor or request method.",
            "Step 6: Fix related configuration wiring issues\n- While touching the integration, verify that all existing config options (e.g., `include`, `exclude`) are correctly passed to the library and not ignored.\n- If any are missing, add them to the library call and, if necessary, update the underlying library to support them.",
            "Step 7: Update documentation and examples\n- Modify user-facing documentation to include the new required configuration fields (e.g., show `api_key` in YAML examples).\n- Note any breaking changes and give instructions on how to migrate existing configurations.",
            "Step 8: Run tests, lint, and verify end-to-end behavior\n- Run the project’s test suite (e.g., `tox`) to ensure changes don’t break other components.\n- Fix lint and style issues (import formatting, line length, etc.) to satisfy CI.\n- Test the integration locally with a real API key and various configurations (including include/exclude filters) to confirm expected behavior.",
            "Step 9: Communicate release expectations\n- Coordinate with maintainers to understand in which release the fix will ship.\n- If users are asking why their fix is not yet available, confirm whether it is in master, a beta branch, or a future version, and communicate that clearly."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fixes OwnTracks iBeacon handling in Home Assistant device_tracker by clearly separating mobile beacons (tags attached to objects) from region beacons (fixed zone triggers), ensuring beacons use the tracking device’s location instead of their own GPS (often 0/0), preventing duplicate active beacon entries, and correcting enter/leave transition logic that previously caused mobile beacons to remain 'stuck' to a device after leave events. Adds comprehensive tests and dynamic encrypted-payload fixtures.",
        "keywords": [
            "home-assistant",
            "owntracks",
            "device_tracker",
            "iBeacon",
            "mobile beacon",
            "region beacon",
            "zone transition",
            "gps accuracy",
            "mqtt",
            "async_see",
            "beacon leave event",
            "sticky beacon bug",
            "tests",
            "encryption",
            "libnacl"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant OwnTracks device_tracker integration handled iBeacon events in a way that mixed up two distinct behaviors: (1) fixed-location 'region beacons' that are used to trigger entry/exit of Home Assistant zones, and (2) 'mobile beacons' attached to movable objects like keys. The code used a single list-based structure (mobile_beacons_active as a list) and treated beacon transition messages almost the same as GPS region transitions. As a result:\n\n- Mobile beacons used the beacon message's GPS coordinates (frequently 0.0/0.0 with zero accuracy), which could place the user or their tagged object at coordinate (0,0) or other unintended places (\"bottom of the Atlantic\").\n- Enter/leave transition handling did not clearly distinguish between region transitions and mobile beacon transitions. A complex mix of GPS region enters/leaves and iBeacon events could cause a mobile beacon to remain 'stuck' to the tracking device even after a leave event, because leave logic processed regions first and then beacons, and beacons were updated using the wrong location context.\n- mobile_beacons_active was a list, allowing multiple identical entries for the same beacon, complicating state reasoning and race conditions.\n\nTo fix this, the contributor:\n\n1. Changed mobile_beacons_active from a defaultdict(list) to a defaultdict(set), enforcing uniqueness of active beacons for each device tracker.\n2. Rewrote async_see_beacons to accept the hass instance and dev_id, fetch the current device_tracker.<dev_id> state, and override the beacon update kwargs to use the device's latitude, longitude, and gps_accuracy. The battery field is dropped because it applies to the tracking device rather than the beacon. This ensures mobile beacons always track the *device's* current location, not the beacon payload's GPS.\n3. Updated the transition handlers:\n   - _async_transition_message_enter: If the transition is a beacon event (t == 'b') and there is no matching Home Assistant zone, treat it as a mobile beacon: add the beacon name to mobile_beacons_active[dev_id] (now a set) and immediately call async_see_beacons(hass, dev_id, kwargs). Do not attempt to use the beacon's GPS position.\n   - For region transitions (zones present or non-beacon transitions), maintain regions_entered[dev_id] as before, derive the GPS location from the zone center, call async_see for the main tracker, and then async_see_beacons(hass, dev_id, kwargs) so any currently active mobile beacons are updated to the new device position.\n   - _async_transition_message_leave: First update the regions_entered stack. Then, if the location corresponds to an active mobile beacon, remove it from mobile_beacons_active[dev_id] and call async_see_beacons(hass, dev_id, kwargs) to update remaining beacons according to the device’s current state. If the leave is not for a mobile beacon, fall back to the old region logic: exit to the previous region if any, else to raw GPS if accuracy is valid, and in both cases call async_see and async_see_beacons.\n\n4. Comprehensively rewrote the tests for owntracks:\n   - Introduced clear test fixtures for zones (INNER_ZONE, OUTER_ZONE) and helper build_message() plus structured location and transition messages (LOCATION_MESSAGE, REGION_GPS_ENTER_MESSAGE, REGION_BEACON_ENTER_MESSAGE, MOBILE_BEACON_ENTER_EVENT_MESSAGE, etc.), accurately modeling how OwnTracks publishes GPS and beacon messages.\n   - Split tests into logical groups: GPS-based region transitions, region beacons (fixed), mobile beacons (tags), and complex real-world sequences. Many tests assert that inaccurate or zero-accuracy GPS is ignored when appropriate, and that region vs mobile beacon semantics are correctly applied.\n   - Added two complex sequences to reproduce subtle bugs, including a 'sticky keys beacon' scenario where previously a keys beacon would follow the device even after leave events. The new logic ensures that after a mobile beacon leave, subsequent device movements do not update that beacon.\n   - Changed tests that directly compared mobile_beacons_active to an empty list to instead assert on len(mobile_beacons_active['greg_phone']) == 0, making the tests agnostic to the specific container type (list vs set).\n   - Reworked encrypted payload tests so the ciphertext is generated at runtime by generate_ciphers(secret) from DEFAULT_LOCATION_MESSAGE, rather than hardcoded base64 blobs. Tests for both a mocked cipher and real libnacl now assert that decrypted messages yield the expected device location.\n\nThis fix made OwnTracks iBeacon handling predictable: region beacons move the *device* into/out of zones, mobile beacons follow the *device's* position, and leave events for mobile beacons correctly detach them without corrupting region state.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices:\n\n1. **Clearly distinguish different semantic roles in event streams.**\n   - Not all similar-looking events should be handled identically. Here, beacon events fall into two conceptually different categories:\n     - Region beacons (named like zones) indicate the device’s presence inside or outside a zone.\n     - Mobile beacons (not matching a zone name) are secondary trackers whose position should be derived from the primary device.\n   - Correct behavior emerged only after explicitly modeling and branching on these two roles, rather than treating 'all beacons the same'.\n\n2. **Use the right data structure to represent state invariants.**\n   - The set-based mobile_beacons_active is a better match than a list because a beacon can either be active or not; duplicates are meaningless and harmful. Choosing a set enforces uniqueness and simplifies reasoning, especially under race conditions (multiple enter/leave events).\n\n3. **Do not trust GPS coordinates from entities whose location is by definition derived.**\n   - A mobile beacon's physical location is tied to another entity (the device running OwnTracks). Its own lat/lon fields often default to 0/0 or are stale. Using those coordinates directly introduces bogus locations. Instead, treat some entities as *derived-position* entities that always take their position from a master source.\n\n4. **Order of operations and branching in event handlers matters.**\n   - In leave-event handling, processing region stacks before checking for beacon-related semantics caused subtle bugs: a beacon leave could be misinterpreted as a zone exit or GPS move. The fix refactored the leave path to first test and handle the mobile beacon case, then fall back to region/GPS logic. This pattern—'handle the more specific case first, then the general case'—reduces unintended interactions.\n\n5. **Integrate business semantics into accuracy filtering.**\n   - GPS accuracy rules differ by context: entering a zone via region/beacon events may be allowed even with poor GPS, because zone boundaries are logical constructs; leaving via raw GPS should respect accuracy thresholds. The tests codify when inaccuracy should be ignored and when it should block updates.\n\n6. **Design tests to mirror real-world event sequences, not just single events.**\n   - Many location bugs only surface in longer sequences of events (e.g., GPS enter, beacon enter, mobile beacon enter, GPS leave, beacon leave, etc.). By encoding realistic sequences, the tests are more likely to catch regressions and subtle race conditions.\n\n7. **Generate cryptographic fixtures programmatically when possible.**\n   - Instead of hardcoding base64 ciphertexts, the tests use generate_ciphers(secret) to produce both libsodium and mock ciphertext from a canonical message. This makes tests more maintainable and robust to changes in message shape.\n\nOverall, this case emphasizes treating event sources according to their domain semantics (fixed vs mobile, primary vs derived), designing state structures around invariants (sets for unique membership), and structuring handlers and tests to model full, realistic flows.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the conceptual roles of entities and events.\n- Inspect the integration’s domain: which entities are primary (e.g., phones) and which are derived (e.g., tags attached to objects, hardware sensors that only signal state)?\n- Catalog event types and payloads (e.g., OwnTracks 'location' vs 'transition', 't' field values, 'desc' zone names).\n- Decide what each event *should* mean (e.g., region beacon vs mobile beacon) rather than relying on their implementation details.",
            "Step 2: Map current handler logic to those semantics and locate mismatches.\n- Review the existing enter/leave or update handlers.\n- Ask for each code path: Is this treating region events and tag events differently where it matters? Are any events sharing code paths that should be distinct (e.g., a beacon leave using the same logic as a GPS region leave)?\n- Look for reliance on fields that are known to be unreliable for certain categories (e.g., using beacon lat/lon which default to (0,0)).",
            "Step 3: Choose appropriate data structures to enforce invariants.\n- Determine what invariants your state should obey (e.g., a beacon is at most once in active-beacons, zones form a stack).\n- Replace permissive structures (like lists) with stricter ones (like sets or deques) to enforce uniqueness or ordering.\n- Update tests to assert against invariants in an implementation-agnostic way (e.g., len(container) == 0 rather than container == []).",
            "Step 4: Refactor handlers to separate specific cases from generic cases.\n- For each critical handler (e.g., _async_transition_message_enter/leave):\n  - Add early branches for most specific semantics (e.g., 'if this is a mobile beacon, handle it and return').\n  - Only fall back to generic region/GPS handling if none of the specific conditions apply.\n- Ensure mobile/derived entities don’t inadvertently trigger region logic that is meant for primary devices.",
            "Step 5: Ensure derived entities always source their location from the correct master.\n- In helper functions that update derived entities (e.g., async_see_beacons):\n  - Fetch the master entity’s state (e.g., device_tracker.<dev_id>).\n  - Derive position and accuracy fields directly from that state, ignoring the derived entity’s own GPS fields.\n  - Strip or transform unrelated fields (e.g., remove battery level when updating a beacon if it only applies to the phone).",
            "Step 6: Add comprehensive, realistic tests.\n- Build flexible message factories (e.g., build_message(overrides, defaults)) to assemble event payloads that closely match actual system behavior.\n- Create distinct test groups:\n  - GPS-only region entry/exit scenarios.\n  - Region beacon behavior (beacons named like zones).\n  - Mobile beacon behavior (beacons named unlike zones).\n  - Mixed, realistic sequences that combine GPS, region beacons, and mobile beacons, targeting previously observed bugs (e.g., sticky tags).\n- Explicitly test behavior under inaccurate or zero GPS accuracy to ensure filters behave as designed.",
            "Step 7: Rework cryptographic tests to be data-driven.\n- When testing encrypted payload handling:\n  - Write a helper to generate ciphertext from a canonical payload and a key using your crypto library (plus a mock cipher if needed).\n  - Use the generated ciphertext as test input so tests remain correct if the message structure changes.\n- Confirm that decrypt-and-dispatch paths produce the same device state as plain-text message handling.",
            "Step 8: Validate behavior through logging and manual scenarios.\n- Add targeted logging (at least temporarily) to handlers for critical events (e.g., logging current device state when updating beacons).\n- Reproduce known problematic sequences manually or via automated MQTT fire functions and verify state transitions (zone, GPS coords, active-beacons set) match expectations.",
            "Step 9: Clean up and future-proof tests and code.\n- Remove obsolete tests that assume specific data structures (like checking for [] instead of checking emptiness).\n- Document the semantics in comments (e.g., what a 'mobile beacon' vs 'region beacon' is) so future maintainers don’t accidentally unify the paths again.\n- Ensure tests describe intent (e.g., 'sticky keys beacon' regression test) and link to known bug scenarios."
        ]
    }
}
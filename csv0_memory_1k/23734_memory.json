{
    "search_index": {
        "description_for_embedding": "Fixes Home Assistant Daikin integration for AirBase units by using library-provided fan mode list, conditionally enabling away/holiday mode and outside temperature sensors based on device capabilities, and avoiding mutation of shared SENSOR_TYPES constants. Updates pydaikin to 1.4.3 to expose new capability flags.",
        "keywords": [
            "home-assistant",
            "daikin",
            "AirBase",
            "climate",
            "sensor",
            "fan_modes",
            "away_mode",
            "holiday_mode",
            "outside_temperature",
            "supported_features",
            "pydaikin==1.4.3",
            "integration bug",
            "device capabilities",
            "do not mutate constants"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Daikin integration did not correctly support Daikin AirBase units. AirBase devices expose capabilities differently from other Daikin devices: they have a different fan mode set, may not support holiday/away mode, and may not provide an outside temperature sensor.\n\nThe original climate platform code built the list of supported fan modes by inspecting the appliance's raw values and title-casing them. This did not align with how AirBase fan modes are represented by the underlying pydaikin library. Additionally, the climate entity always advertised SUPPORT_AWAY_MODE (holiday mode), even though AirBase units do not support that feature. On the sensor side, the component always created an outside temperature sensor entity based on a shared SENSOR_TYPES constant, even for devices that do not expose outside temperature. A first attempt to fix this directly popped ATTR_OUTSIDE_TEMPERATURE from SENSOR_TYPES, inadvertently mutating a module-level constant and potentially affecting other Daikin devices globally.\n\nThe fix involved several coordinated changes:\n- Use `self._api.device.fan_modes` from pydaikin instead of manually building the fan mode list, ensuring correct fan mode support for AirBase units.\n- Start with a supported_features bitmask that does NOT include SUPPORT_AWAY_MODE, and only OR in SUPPORT_AWAY_MODE if `self._api.device.support_away_mode` is true. The same pattern continues for fan mode support using `support_fan_mode`.\n- For sensors, build a per-device `sensors` list starting with `ATTR_INSIDE_TEMPERATURE` and append `ATTR_OUTSIDE_TEMPERATURE` only if `daikin_api.device.support_outside_temperature` is true. This avoids mutating the global SENSOR_TYPES constant.\n- Bump the pydaikin dependency from 1.4.0 to 1.4.3 to gain access to new properties such as `fan_modes`, `support_away_mode`, and `support_outside_temperature`.\n\nAfter these changes, AirBase units are presented in Home Assistant with only the features they actually support, fan modes are accurate, outside temperature sensors are only created when available, and shared constants remain unchanged across devices.",
        "semantic_memory": "This fix illustrates several generalizable patterns for device integrations in home automation systems and similar platforms:\n\n1. **Reflect device capabilities dynamically**: Do not assume all models support the same features. Capabilities like fan modes, away/holiday mode, or specific sensors (e.g., outside temperature) should be derived from the device or its driver/library, often via capability flags (`support_away_mode`, `support_outside_temperature`, etc.). The supported feature bitmask or advertised capabilities of an entity should be built conditionally based on those flags.\n\n2. **Use library abstractions instead of re-deriving values**: When an underlying library (here, pydaikin) exposes higher-level helpers such as `device.fan_modes`, prefer them over manually transforming raw values. Manual transformations (e.g., title-casing strings from protocol-level data) can easily diverge from actual device behavior, especially for variant device families (like AirBase vs. standard Daikin).\n\n3. **Avoid mutating shared constants/global configuration**: Module-level dictionaries or constants like SENSOR_TYPES should be treated as immutable. Mutating them at runtime (e.g., popping keys based on a specific device) introduces hidden global state, causing other instances/integrations to see modified configuration. Instead, construct a per-instance list or mapping derived from the constant without modifying it.\n\n4. **Version-align integration and library features**: When an integration relies on new properties or behavior in an external library, bump and pin the library version accordingly (e.g., `pydaikin==1.4.3`). This ensures that runtime expectations (availability of properties like `fan_modes` and capability flags) match the deployed code.\n\n5. **Capability-driven entity creation**: Only create entities (sensors, switches, features) when the underlying device supports them. This prevents broken entities, misleading UI, and false expectations for users. It also simplifies error handling and avoids polluting the system with non-functional entities.",
        "procedural_memory": [
            "When a device integration behaves incorrectly for a subclass or variant of devices (e.g., a specific model family like AirBase):",
            "Step 1: Identify mismatches between advertised features and actual device behavior. Look for entities that appear but don't work (e.g., away mode toggle does nothing, outside temperature is always unavailable) and for mode lists that don't match the device UI (fan modes, operation modes).",
            "Step 2: Inspect the underlying device library/driver (e.g., pydaikin) to see what abstractions or capability flags it exposes for that device class (e.g., `fan_modes`, `support_away_mode`, `support_outside_temperature`). Confirm the library version in use and read its changelog or documentation.",
            "Step 3: Adjust the integration's supported feature bitmask and capabilities to be capability-driven rather than hardcoded. Initialize the feature mask with only the universally supported features, then OR in additional flags conditional on the device's capability booleans (e.g., `if device.support_away_mode: features |= SUPPORT_AWAY_MODE`).",
            "Step 4: For lists of modes or options (fan modes, swing modes, operation modes), prefer using the device/library-provided lists (e.g., `device.fan_modes`) instead of reconstructing them from low-level protocol values or making assumptions like string transformations. This reduces the likelihood of mismatch, especially for specialized device variants.",
            "Step 5: When you need to tailor sensor or entity sets per device, do not modify shared constants or global dictionaries (such as SENSOR_TYPES). Instead, create a local list or copy derived from the constant. For example, initialize `sensors = [ATTR_INSIDE_TEMPERATURE]` and conditionally append `ATTR_OUTSIDE_TEMPERATURE` if the device supports it, then iterate over `sensors` when creating entities.",
            "Step 6: If your changes rely on new features from an external library, update the integration's manifest/requirements to depend on the necessary minimum version (e.g., bump `pydaikin` from 1.4.0 to 1.4.3). Regenerate aggregate requirement files if the project requires it.",
            "Step 7: Add or run tests (and local setup) for multiple device types: at least one device that supports the full feature set and one that lacks specific capabilities (e.g., AirBase without holiday mode and outside temperature). Verify that only supported entities appear and that no shared constants are modified across device setups.",
            "Step 8: Review for side effects: search for any other code paths that rely on the same constants or capability checks to ensure that your change does not unintentionally disable features for devices that do support them."
        ]
    }
}
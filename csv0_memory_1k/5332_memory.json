{
    "search_index": {
        "description_for_embedding": "Custom pylint plugin for StackStorm API models was incorrectly importing target modules at lint time, causing side effects (eventlet hangs, ImportError cascades, issues under Pants). The fix rewrites the plugin to operate purely on astroid's AST: inferring JSON-schema-based attributes from the 'schema' class variable, handling deepcopy and indirect references, and registering a proper astroid transform with tests and Makefile integration.",
        "keywords": [
            "pylint plugin",
            "astroid transform",
            "static analysis",
            "__import__ side effects",
            "eventlet hang",
            "ImportError",
            "pants",
            "schema-based dynamic attributes",
            "StackStorm",
            "api_models.py"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the custom pylint plugin used by StackStorm to teach pylint about API model classes was relying on runtime imports instead of pure static analysis. Specifically, the plugin previously used __import__ to load classes and read their 'schema' dictionaries at lint time, then derive available attributes from that schema. This violated pylint's core design: it should analyze code using astroid's AST without importing the target modules, to avoid runtime side effects. In practice, this caused subtle and severe issues: when linting more of the codebase or under Pants, the plugin tried to import modules whose transitive dependencies weren't present in the lint snapshot, leading to large cascades of ImportError and ModuleNotFoundError, and in some cases hangs related to eventlet initialization.\n\nTo fix this, the plugin was completely reworked to operate purely on astroid's AST. The new implementation:\n\n- Introduces an astroid transform (with a predicate) on ClassDef nodes whose names look like API model classes (ending in 'API' or having a 'schema' attribute), skipping known non-model classes via CLASS_NAME_SKIPLIST.\n- Uses astroid to locate the 'schema' assignment within the class and infer its value as an AST node, instead of importing the class. When the schema is uninferable (e.g., `schema = copy.deepcopy(OtherAPI.schema)`), it searches the class body for the corresponding Assign node and uses a helper `infer_copy_deepcopy` to resolve the original schema AST.\n- Handles extra dynamic modifications to the schema, such as `schema[\"properties\"][\"ttl\"] = {...}`, aggregating these into an `extra_schema_properties` map, and similar indirect patterns where properties are inserted via module-level dicts or deepcopied references.\n- Finds the `\"properties\"` dictionary within the schema and, for each property, infers its schema node and then extracts the `\"type\"` field. It supports direct types, lists/tuples of types (choosing the first), indirect references via subscripted variables, and attributes referring to other schema objects (e.g., `TriggerAPI.schema`).\n- Based on the property type (`object`, `array`, `integer`, `number`, `string`, `boolean`, `null`, or unknown), constructs the appropriate astroid node (Dict, List, builtin int/float/str/bool/None, or a dummy ClassDef) and injects a synthetic `Assign` and `AssignName` into `cls.locals`, effectively telling pylint that this class has attributes corresponding to the schema properties.\n\nThe change also improves the plugin structure by adding a `predicate` function for registering the transform with MANAGER.register_transform, adds extensive docstrings and comments explaining how and why the AST manipulation is done, and renames CLASS_NAME_BLACKLIST to CLASS_NAME_SKIPLIST. A comprehensive test suite (`pylint_plugins/api_models_test.py`) was added, using astroid.parse and pylint.testutils to validate various scenarios:\n\n- Skiplisted classes and non-API classes are not transformed.\n- Simple in-class schemas generate attributes.\n- Schemas copied via `copy.deepcopy` (both from local and imported API classes) correctly propagate attributes.\n- Indirect schemas via module-level dicts and inlined foreign schemas (`TriggerAPI.schema`) are resolved.\n- Property types map to the correct inferred AST types.\n- An integration-style test with pylint's TypeChecker confirms that an attribute defined in the schema is not flagged with `no-member`, while a missing attribute is flagged as `E1101`.\n\nFinally, the Makefile was updated so the pylint plugin tests run (via pytest) before invoking pylint in the normal linting workflow, ensuring plugin correctness is checked before it's used.\n\nAs a result, pylint can now accurately understand dynamic API model attributes without ever importing the project code, avoiding the previous side effects and making the linting infrastructure compatible with tools like Pants that provide only partial dependency snapshots.",
        "semantic_memory": "This fix encapsulates several generalizable lessons about writing static analysis plugins (especially for pylint/astroid) and working with dynamic Python patterns:\n\n1. **Avoid importing target code in static analysis tools**:\n   - Static analyzers like pylint are designed to operate without importing the code they inspect. Importing target modules can trigger side effects (e.g., eventlet monkey-patching, database connections, environment-dependent logic) and break isolation in CI or tooling environments (like Pants, Bazel, or hermetic sandboxes).\n   - Relying on imports also introduces brittle dependencies on full transitive dependency closure; when a tool only provides direct dependencies, `__import__` in plugins can fail loudly.\n\n2. **Leverage AST/astroid transforms instead of reflection**:\n   - Astroid provides rich APIs (`MANAGER.register_transform`, `ClassDef.locals`, `igetattr`, `infer`) to transform and extend the AST representation of code. This allows plugins to simulate dynamic behavior (e.g., dynamically added attributes) purely at the AST level.\n   - Using a `predicate` for transforms ensures the plugin only runs for relevant nodes, reducing complexity and avoiding accidental transformations.\n\n3. **Model dynamic attributes via synthetic AST nodes**:\n   - In codebases where classes construct attributes dynamically (e.g., from JSON schemas, configuration dicts, or metaprogramming), static analyzers will miss those attributes unless explicitly modeled.\n   - A robust pattern is: locate the source of truth (e.g., a `schema` dict), resolve any indirection (deepcopies, module-level dicts, imports), and then inject synthetic Assign/AssignName nodes into the class' locals representing the inferred attributes.\n\n4. **Handle indirections and common dynamic patterns explicitly**:\n   - Real-world code often wraps schemas in module-level dictionaries, uses `copy.deepcopy`, or reuses schemas from other modules; these patterns can still be handled statically by combining astroid's `.infer()` with custom helpers.\n   - Being explicit about these patterns (documenting them and adding tests) makes the plugin resilient to refactors and easier to evolve.\n\n5. **Test static-analysis plugins independently and early**:\n   - Because plugins modify how static analysis interprets code, regressions can be subtle and far-reaching. Adding unit tests that parse small code snippets with astroid and invoke checker logic (using pylint.testutils) is a powerful way to validate plugin behavior.\n   - Integrating plugin tests into the normal linting workflow (e.g., running pytest on the plugin directory before running pylint) ensures the plugin remains stable as the codebase evolves.\n\n6. **Use skiplists/whitelists rather than brittle naming checks alone**:\n   - When heuristically selecting classes (e.g., classes ending in 'API' or with a 'schema' attribute), there will be exceptions. Maintaining a small skiplist (or allowlist) for known special cases is more maintainable than hard-coding assumptions into the transform logic.\n\nOverall, the key principle is: when extending static analysis tools for dynamic Python code, emulate the dynamic behavior at the AST level instead of reproducing runtime behavior via imports or execution.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Detect that a static-analysis plugin is importing target code and causing side effects.\n- Symptoms include: hangs or timeouts during linting, spurious ImportError/ModuleNotFoundError, or failures when running under tools like Pants that provide partial dependency snapshots.\n- Look for plugin code that calls `__import__`, `importlib.import_module`, or otherwise imports project modules to read attributes or execute logic.",
            "Step 2: Confirm that the plugin can be rewritten using the AST only.\n- Identify what data the plugin is extracting via imports (e.g., a class' `schema` dict, dynamic attributes, configuration structures).\n- Examine the code patterns that define this data (class attributes, module-level constants, calls to functions like `copy.deepcopy`). Ensure these patterns appear in the source and can be recognized statically.",
            "Step 3: Introduce an astroid transform with a predicate.\n- In a pylint plugin module, import astroid and its MANAGER: `from astroid import MANAGER, nodes`.\n- Define a `predicate(node)` that returns True for the nodes you want to transform (e.g., `isinstance(node, nodes.ClassDef) and node.name.endswith('API')` and `'schema' in node.locals`). Include skiplists for known exceptions.\n- Define a `transform(node)` function that takes the matched node and mutates or augments it to model the dynamic behavior (e.g., injecting attributes based on a schema).",
            "Step 4: Use astroid APIs to locate and infer relevant AST nodes.\n- Use methods like `cls.igetattr('schema')` or iterating `cls.body` to find assignments of interest.\n- When a value is not a simple dict or constant, call `.infer()` on its node to let astroid resolve imports or simple expressions. Handle `astroid.Uninferable` as a signal to apply custom logic (e.g., resolving `copy.deepcopy` calls).\n- Implement helpers (like `infer_copy_deepcopy`) to pattern-match specific call shapes and return the underlying AST node.",
            "Step 5: Resolve indirections and dynamic schema construction.\n- For patterns like `schema = copy.deepcopy(OtherAPI.schema)`, find the Assign node and then apply your helper to resolve the underlying schema.\n- For patterns like `schema['properties']['x'] = {...}`, iterate over other Assign nodes in the class body to collect additional properties.\n- For module-level dict indirections (e.g., `REQUIRED_ATTR_SCHEMAS['action']`), use `cls.root().igetattr(var_name)` to find the dict and examine its items; use `.infer()` and custom helpers to resolve values.",
            "Step 6: Derive attribute types and construct synthetic AST nodes.\n- Once you have a property schema dict node, locate its `\"type\"` field and infer its value.\n- Map types to AST nodes: `object` → `nodes.Dict()`, `array` → `nodes.List()`, `integer` → builtin int class via `scoped_nodes.builtin_lookup('int')`, etc.\n- For unknown or missing types, fall back to a generic node (e.g., `astroid.ClassDef`) so pylint treats it as some object rather than failing.",
            "Step 7: Inject attributes into the class AST.\n- For each inferred property, create a synthetic assignment: `assign_node = nodes.Assign(parent=cls)` and `assign_name_node = nodes.AssignName(property_name, parent=assign_node)`; then `assign_node.postinit(targets=[assign_name_node], value=node)`.\n- Insert the AssignName into `cls.locals[property_name] = [assign_name_node]`. This is how astroid represents attributes on a class, and it allows later inference and pylint checks (like TypeChecker) to see these attributes.",
            "Step 8: Register the transform and remove runtime imports from the plugin.\n- Register the transform via `MANAGER.register_transform(astroid.ClassDef, transform, predicate)`.\n- Delete any usage of `__import__`, `importlib`, or direct imports of the target project modules from the plugin. The plugin should operate solely on astroid nodes and their inference.",
            "Step 9: Add unit tests for the plugin behavior.\n- Use `astroid.parse` or `astroid.extract_node` to parse small code samples into AST nodes.\n- Import the plugin module in the tests so its transform is registered.\n- Assert that classes now have the expected attributes in `cls.locals`, that inferred values have the correct node types, and that skiplisted or non-matching classes are unchanged.\n- For end-to-end testing, create `pylint.testutils.CheckerTestCase` tests that instantiate relevant pylint checkers (e.g., TypeChecker) and verify that messages like `no-member` are present/absent as expected when referencing attributes defined/not defined in the schema.",
            "Step 10: Integrate plugin tests into the CI/lint pipeline.\n- Update the project's Makefile or CI scripts to run `pytest` on the plugin test files before invoking pylint on the codebase.\n- This ensures any regressions in the plugin (e.g., new dynamic patterns not handled, changes in schema shapes) are caught early and do not silently affect lint results.",
            "Step 11: Re-run linting under different environments (e.g., Pants) to validate.\n- Re-run pylint in the original problematic context (e.g., within Pants with only direct dependencies provided).\n- Confirm that the previous ImportError/hang issues are gone and that pylint is successfully analyzing modules using the AST-only plugin."
        ]
    }
}
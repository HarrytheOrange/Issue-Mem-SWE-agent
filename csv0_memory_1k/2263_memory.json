{
    "search_index": {
        "description_for_embedding": "Refactor Qt theming in napari by adding an optional `theme` parameter to `get_stylesheet`, centralizing theme templating and caching. Remove `raw_stylesheet` attributes from `Window` and `QtViewer` in favor of `napari.qt.get_stylesheet(theme_name)`, move status bar styling into QSS, keep backwards compatibility via `__getattr__` with deprecation warnings, and coordinate changes with external plugin napari-console.",
        "keywords": [
            "Qt stylesheet",
            "theming",
            "get_stylesheet",
            "theme parameter",
            "raw_stylesheet deprecated",
            "napari-console compatibility",
            "QStatusBar style",
            "QSS templates",
            "LRU cache",
            "backwards compatible API change"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the napari project improved its Qt theming pipeline. Previously, theming required a repetitive pattern in multiple places: callers imported `get_stylesheet`, `get_theme`, and `template`, then manually applied the theme template to the raw stylesheet and set it on Qt widgets. This also meant that the cached stylesheet from `get_stylesheet` was not being reused in its themed form, and each consumer had to redo the templating.\n\nThe fix introduced a new API: `napari._qt.qt_resources.get_stylesheet(theme: str = None, extra: Optional[List[str]] = None)`. When `theme` is provided, the function now returns a fully themed stylesheet, applying the Jinja-like template with the appropriate theme dict (`get_theme(theme)`) and caching the result per theme using `functools.lru_cache` (cache size increased from 4 to 12). The `extra` argument for additional QSS files remains.\n\nThe `Window` and `QtViewer` classes previously kept a class attribute `raw_stylesheet = get_stylesheet()`, which external code, notably the `napari-console` plugin, depended on. This attribute was removed as an implementation detail leak: the global stylesheet isn't conceptually tied to the viewer or window, and `get_stylesheet` itself already caches its result.\n\nTo avoid breaking existing code immediately, both `Window` and `QtViewer` now implement `__getattr__` to provide a deprecated `raw_stylesheet` attribute on demand. Accessing `raw_stylesheet` triggers a `DeprecationWarning` directing users to `napari.qt.get_stylesheet` instead, and returns `get_stylesheet()` for backwards compatibility. The project maintainers coordinated with the `napari-console` plugin: the plugin was updated to prefer `get_stylesheet(viewer.theme)` but to fall back to `qt_viewer.raw_stylesheet` when running against older napari versions, and a short-lived deprecation window was agreed upon.\n\nThe theme application logic in the main window was simplified: instead of manually styling the `QStatusBar` via `template('QStatusBar {...}', **theme)`, the status bar styling was moved into the `02_custom.qss` stylesheet. The window now simply calls `self._qt_window.setStyleSheet(get_stylesheet(theme_name))` when the theme changes, letting QSS inheritance handle the status bar and other widgets. Accordingly, the window wires `viewer.events.theme` to `_update_theme`, which calls `get_stylesheet(viewer.theme)` once per theme change.\n\nIn `QtViewer`, the previous `_update_theme` method, which templated and applied the raw stylesheet (`template(self.raw_stylesheet, **theme)`) and then set `self.setStyleSheet`, was removed. `QtViewer` now focuses on canvas-specific behavior: `_update_canvas_background` sets `self.canvas.bgcolor` based on `get_theme(self.viewer.theme)['canvas']` and is connected to `viewer.events.theme`. General Qt styling is handled by the main window's stylesheet.\n\nA temporary refactor moved some canvas configuration (`ignore_callback_errors`, minimum size, depth function) into `VispyCanvas`'s `__init__`, but this was reverted in a follow-up patch. The final state restores those responsibilities to `QtViewer._create_canvas`, keeping the PR focused on theming.\n\nNet effect: the theming API became simpler and more centralized (`get_stylesheet(theme_name)`), stylesheet application is cached and less repetitive, styling for the status bar and other widgets lives in QSS instead of imperative code, and plugin authors were guided through a deprecation path away from the `raw_stylesheet` attribute.",
        "semantic_memory": "This work illustrates several generalizable patterns in GUI theming and API evolution:\n\n1. **Centralize and encapsulate theming logic**: Instead of scattering manual templating calls across different widgets (`template(raw_stylesheet, **get_theme(theme))`), provide a single helper function that gives consumers what they actually want: a fully themed stylesheet. This reduces duplicated code, removes the need for extra imports, and ensures consistent behavior across the application.\n\n2. **Cache at the right abstraction level**: It’s not enough to cache a raw, unthemed stylesheet if every caller still has to re-template it on each use. Caching the *themed* result keyed by theme name (`get_stylesheet(theme)`) avoids unnecessary work and future bugs where some components forget to reapply the theme correctly.\n\n3. **Avoid leaking internal implementation details as public attributes**: Attributes like `qt_viewer.raw_stylesheet` appear convenient, but they expose internals that aren't conceptually part of the object’s public contract. Instead, global helpers (e.g. `napari.qt.get_stylesheet`) should serve as the API for shared resources like application-wide styles.\n\n4. **Use declarative stylesheets where possible instead of imperative styling code**: Moving `QStatusBar` style from ad hoc code (`status_bar.setStyleSheet(template('...', **theme))`) into the main QSS file brings all appearance-related logic into a single declarative source. Declarative styling leverages Qt’s inheritance and is easier to reason about and maintain than scattered imperative calls.\n\n5. **Backward-compatible deprecation using `__getattr__`**: When removing attributes that external plugins may rely on, overriding `__getattr__` to dynamically supply the old attribute, emit a `DeprecationWarning`, and redirect to the new mechanism is an effective migration pattern. This gives downstream consumers time to update while allowing the core project to move toward a cleaner architecture.\n\n6. **Coordinate API changes with dependent packages**: When core changes affect external plugins (here, `napari-console`), it is important to (a) identify those dependencies, (b) propose a compatibility strategy (e.g., using `hasattr` fallbacks in the plugin), and (c) sequence releases so that plugins can support both old and new APIs concurrently. This minimizes breakage for users during upgrades.\n\n7. **Separate responsibilities between components**: `QtViewer` now handles only viewer/canvas-specific theming (like background color), while the main window applies the global stylesheet. This separation of concerns makes each class simpler and avoids confusion about where global vs. local styling should be applied.",
        "procedural_memory": [
            "When you see repeated GUI theming patterns with manual templating and multiple imports, refactor into a centralized, cache-aware helper function.",
            "Step 1: Identify repetitive theming code.\n- Search for call sites that follow the same pattern, e.g. `raw = get_stylesheet(); theme = get_theme(theme_name); widget.setStyleSheet(template(raw, **theme))`.\n- Note which modules and classes are performing this pattern and what they actually need (raw vs themed styles).",
            "Step 2: Extend the theming helper to return the higher-level result.\n- Modify the existing stylesheet loader (or add a new one) to accept a `theme` argument, e.g. `def get_stylesheet(theme: str = None, extra: List[str] = None) -> str`.\n- Internally, load and concatenate QSS files as before.\n- If `theme` is provided, import the theme system (`get_theme` / `template`) and apply templating before returning the stylesheet.",
            "Step 3: Add appropriate caching.\n- Wrap the helper in `functools.lru_cache` and choose a cache size large enough for the expected number of themes and QSS combinations.\n- Ensure the cache keys include `theme` and any other parameters that affect the resulting stylesheet (e.g., `extra` file list, or a stable representation of it).",
            "Step 4: Migrate call sites to the new helper.\n- Replace patterns like `template(get_stylesheet(), **get_theme(theme))` with `get_stylesheet(theme)`.\n- Simplify imports in these modules: many no longer need direct access to `get_theme` or `template`.\n- Ensure global/app-level components (such as main windows) call the centralized helper when the theme changes.",
            "Step 5: Move one-off imperative styling into the stylesheet where possible.\n- For widgets like `QStatusBar` that are styled via ad hoc `setStyleSheet` calls, create or update entries in the QSS files (e.g., `QStatusBar { background: {{ background }}; color: {{ text }}; }`).\n- Remove the corresponding imperative styling code and rely on QSS inheritance from the main stylesheet application.",
            "Step 6: Deprecate and remove leaking internal attributes safely.\n- Identify attributes that should not be public (e.g., `raw_stylesheet` on viewer/window classes) but may already be used by external code.\n- Implement `__getattr__` on those classes to detect access to the deprecated names.\n- In `__getattr__`, emit a `DeprecationWarning` with a clear message and return the new equivalent (`get_stylesheet()`), then plan a removal version.\n- Avoid breaking attribute access in existing plugins until after a deprecation window.",
            "Step 7: Coordinate with dependent packages and maintain compatibility.\n- Audit known plugins/extensions (like `napari-console`) for usage of deprecated attributes.\n- Submit patches to these plugins that:\n  - Prefer the new API (`get_stylesheet(theme)`).\n  - Fall back to the old attribute when running against older core versions (e.g., check `hasattr(viewer.window.qt_viewer, 'raw_stylesheet')`).\n- Release updated plugin versions before or in lockstep with the core change.",
            "Step 8: Keep responsibilities well-scoped.\n- Decide which component applies the global stylesheet (typically the main window) and which ones only handle local tweaks (e.g., canvas background color).\n- Update event wiring so that theme change events update the right properties (`Window._update_theme` sets the global stylesheet; `QtViewer` updates canvas-specific attributes).\n- Avoid setting the same stylesheet in multiple places to prevent conflicts and confusion.",
            "Step 9: Test theme switching and plugin behavior.\n- Manually run the application, switch between themes, and confirm that all widgets (including status bar, docks, and custom widgets) inherit correct styling.\n- Run tests or manual checks for dependent plugins to ensure they still function with both old and new napari versions.\n- Add or update automated tests for the new `get_stylesheet` behavior (with and without `theme`), including caching behavior if feasible."
        ]
    }
}
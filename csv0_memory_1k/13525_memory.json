{
    "search_index": {
        "description_for_embedding": "Home Assistant TP-Link device_tracker did not work with TP-Link Archer C50 V3 (Brazilian firmware) because the router exposes the DHCP client list via a different CGI endpoint and reports MAC addresses with colon separators instead of dashes. The PR adds a new TplinkArcherC50DeviceScanner that authenticates via HTTP Basic cookie, posts to the LAN_HOST_ENTRY endpoint (/cgi?5) to retrieve DHCP clients, and parses colon-formatted MACs.",
        "keywords": [
            "home assistant",
            "device_tracker",
            "tplink.py",
            "TP-Link",
            "Archer C50",
            "V3",
            "Brazil firmware",
            "DHCP client list",
            "MAC address format",
            "colon vs dash MAC",
            "router integration",
            "HTTP Basic auth cookie",
            "LAN_HOST_ENTRY",
            "/cgi?5",
            "pytplinkrouter",
            "feature addition",
            "API variant handling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a user reported that Home Assistant’s TP-Link device_tracker integration (tplink.py) did not work with a TP-Link Archer C50 V3 router using Brazilian firmware. The existing implementation supported several TP-Link models by scraping the router’s web interface, but the C50 V3 used a different internal API and MAC address formatting.\n\nSpecifically, the Archer C50 V3 firmware returns DHCP client information via an HTTP POST to `http://<router>/cgi?5` with a payload targeting the `LAN_HOST_ENTRY` object, and the MAC addresses are provided in colon-separated form (AA:BB:CC:DD:EE:FF), whereas some previous scanner implementations expected dash-separated MACs or different endpoints.\n\nTo address this, the contributor introduced a new scanner class `TplinkArcherC50DeviceScanner` and registered it in the `get_scanner` factory before the generic `TplinkDeviceScanner`. The class:\n- Initializes with `credentials` and `token` fields and a custom `parse_macs_c50` regex that matches colon-separated MAC addresses.\n- Overrides `scan_devices` to call `_update_info` and then returns `self.last_results`.\n- Overrides `get_device_name` to return `None` (no hostname lookup implemented).\n- Implements `_update_info` to:\n  - Log that DHCP clients are being loaded.\n  - Construct request metadata: URL `http://<host>/cgi?5`, Referer `http://<host>/`, and an `Authorization=Basic <base64(username:password)>` cookie (computed earlier in an intermediate version but, after linter-related edits, effectively left as an empty string in the final patch).\n  - Send a POST request with a payload requesting `leaseTimeRemaining`, `MACAddress`, `hostName`, and `IPAddress` fields from `LAN_HOST_ENTRY`.\n  - Parse MAC addresses from the response body using `parse_macs_c50` and store them in `self.last_results`.\n\nDuring iteration, the author had a helper method `_get_auth_tokens` which base64-encoded the username and password and stored the result in `self.credentials`. However, to satisfy style and linter (hound / tox) warnings about unused variables and redundant code, they removed the `_get_auth_tokens` method and the conditional that called it, leaving credentials initialization but no actual assignment, which likely broke authentication. The final version therefore contains the special-case DHCP scraping and colon-MAC parsing logic, but its auth flow is incomplete.\n\nReviewers commented that instead of adding another router-specific scanner class, the integration should be refactored to use the shared `pytplinkrouter` library, as another PR (#11827) was already aiming to modernize this component. The maintainers requested a PR that migrates to `pytplinkrouter` and avoids proliferating ad-hoc scanner classes in `tplink.py`.",
        "semantic_memory": "This case highlights several generalizable lessons about integrating with router web interfaces and maintaining Home Assistant-style device trackers:\n\n1. **Firmware- and model-specific API differences**: Even within the same vendor (TP-Link), different router models and regional firmwares may expose client lists via different URLs (e.g., `/cgi?5` vs vendor-specific paths), data schemas (different object names like `LAN_HOST_ENTRY`), and formats (colon-separated MACs vs dash-separated MACs). An integration that scrapes a web interface must be resilient to these variations.\n\n2. **MAC address parsing must be flexible**: Relying on a single MAC address format can silently break support for some devices. It is safer either to support multiple patterns (colon- and dash-separated, lowercase/uppercase) or to normalize a broader set of regex matches into a standard representation.\n\n3. **Centralizing router logic in a shared library**: Instead of adding per-model subclasses into a Home Assistant component file, it is better to rely on a dedicated external library (such as `pytplinkrouter`) that abstracts away router quirks. This keeps the HA integration thin and defers protocol/HTML/API changes to a focused library, improving testability and reuse.\n\n4. **Beware of linter-driven regressions**: Changes made just to satisfy automated style or lint tools can unintentionally remove necessary functional code. In this PR, the removal of `_get_auth_tokens` and its call avoided some unused-variable warnings but also removed the logic that actually computed the `Authorization` header, likely breaking authentication. Style fixes should be guided by tests and functionality, not the other way around.\n\n5. **Authentication via cookies and Basic auth**: Some routers require a Basic auth cookie (`Authorization=Basic <base64(username:password)>`) rather than HTTP Authorization headers. When reverse-engineering router APIs, pay close attention to how browsers authenticate (cookies vs headers, tokens vs sessions) and reproduce that precisely.\n\n6. **Ordering in factory methods matters**: In this code, `get_scanner` attempts different scanner classes in order and returns the first that initializes successfully. Adding a new scanner must be done with care so it does not preempt more specific or more correct handlers, and it must correctly detect whether it is running against a compatible router.\n\n7. **Feature additions vs architectural direction**: Even if a patch solves a real compatibility problem for a specific device, maintainers may decline or redirect the solution if it conflicts with the project’s architectural goals (e.g., preferring an external library or deprecating legacy scraping code). Aligning with ongoing refactors (like adopting `pytplinkrouter`) is often more sustainable than expanding legacy patterns.\n\nOverall, the episode reinforces best practices of: abstracting vendor quirks into shared libraries, writing robust parsers for semi-structured web APIs, and ensuring refactors for code style don’t strip out critical behavior like authentication.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving unsupported router models or firmware variants in a device_tracker:",
            "Step 1: Confirm the symptom and scope.\n- Verify that the device tracker integration (e.g., TP-Link) is configured correctly with host, username, and password.\n- Check logs to see if any errors are reported when scanning devices.\n- Confirm that the router’s web UI shows connected or DHCP clients while Home Assistant reports none.",
            "Step 2: Inspect the router’s web interface/API.\n- Log into the router using a browser.\n- Open developer tools (Network tab) and navigate to the page that lists connected or DHCP clients.\n- Observe which HTTP requests are made: URL paths (e.g., `/cgi?5`), HTTP method (GET/POST), headers (especially cookies and Authorization), and request payload.",
            "Step 3: Identify data structures and formats.\n- Capture the HTTP response that contains the client list.\n- Determine how clients are represented (JSON, text, key/value pairs, proprietary format).\n- Note field names (e.g., `LAN_HOST_ENTRY`, `MACAddress`, `hostName`, `IPAddress`).\n- Check the MAC address format (colon-separated vs dash-separated, case, any surrounding markup).",
            "Step 4: Design parsing logic.\n- If using regex, construct patterns that robustly match MAC addresses in the observed format; support both colon and dash separators where possible.\n- Consider normalizing matched MACs to a consistent canonical form (uppercase, colon-separated) used by the integration.\n- If the API is structured (JSON), prefer JSON parsing over regex scraping.",
            "Step 5: Implement or adapt a scanner.\n- Prefer contributing to or extending a shared library (e.g., `pytplinkrouter`) that already models the vendor’s API rather than adding ad-hoc code in the integration file.\n- If working inside a Home Assistant component, create a new scanner class only if strictly necessary, inheriting from the appropriate base (e.g., `TplinkDeviceScanner`).\n- In the scanner’s initialization, store configuration (host, username, password) and set up any parsers (regex for MAC addresses).",
            "Step 6: Implement authentication correctly.\n- Reproduce the authentication mechanism seen in the browser: Basic auth headers, cookies such as `Authorization=Basic <base64(user:pass)>`, tokens, or sessions.\n- Encapsulate auth logic in a helper method (e.g., `_get_auth_tokens`) that computes and stores cookies or tokens on first use.\n- Ensure calls to the router always include the necessary headers/cookies.\n- After code style changes, re-verify that auth-related functions are still called and not removed just to satisfy lint errors.",
            "Step 7: Implement the update/scan method.\n- In a method like `_update_info`, build the correct URL, headers (including Referer and auth cookie), and payload based on your network inspection.\n- Make the HTTP request (GET/POST) using the project’s HTTP utilities or `requests` as appropriate.\n- Parse the response using the designed logic, extract MAC addresses, and assign them to `self.last_results`.\n- Return a boolean indicating success, which helps higher-level code decide whether the scanner is valid.",
            "Step 8: Integrate with the scanner factory.\n- If the integration uses a factory like `get_scanner` that tries multiple scanner classes, insert your new scanner in an appropriate position so it only claims compatible routers.\n- Implement any feature detection necessary (e.g., checking a known endpoint or header) in `__init__` to set `success_init` correctly.",
            "Step 9: Test locally.\n- Run the integration against the target router and verify that connected devices now appear as expected.\n- Execute the project’s test suite (e.g., `tox`) to ensure style and tests pass.\n- Add or update unit tests where feasible, particularly around parsing logic and MAC normalization.",
            "Step 10: Avoid linter-induced functional regressions.\n- When linters complain about unused variables or methods, validate whether those elements are actually required for behavior (e.g., computing auth cookies).\n- Refactor in a way that preserves functionality (for example, use returned values or restructure code), rather than deleting important logic.\n- After any linter-driven edit, re-run functional tests against a real device or mocks.",
            "Step 11: Align with project architecture.\n- Before adding model-specific branches or classes, check open PRs and architectural plans (e.g., moving to `pytplinkrouter`).\n- If maintainers prefer using a shared library, implement the new router support in that library and then adjust the integration to consume it.\n- Document the supported router models and firmware variants and note any special requirements (e.g., region-specific firmware like BR vs EU)."
        ]
    }
}
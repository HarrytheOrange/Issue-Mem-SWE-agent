{
    "search_index": {
        "description_for_embedding": "Home Assistant Daikin integration fix: update to pydaikin 0.6, switch to the library's update_status() call instead of manual HTTP resource polling, and stop forcing default fan and swing values on devices that do not support them. This prevents errors on Daikin models where pydaikin 0.6 expects f_dir and f_rate to be absent when unsupported.",
        "keywords": [
            "Daikin",
            "pydaikin",
            "homeassistant.components.daikin",
            "homeassistant.components.climate.daikin",
            "library upgrade",
            "dependency version bump",
            "f_dir",
            "f_rate",
            "fan mode",
            "swing mode",
            "unsupported capabilities",
            "update_status",
            "HTTP_RESOURCES",
            "integration bugfix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Daikin integration was failing or misbehaving for some Daikin AC models after upgrading the underlying pydaikin library. Older integration code assumed that every Daikin device had fan (f_rate) and swing (f_dir) controls and therefore always populated default values for these attributes when they were missing: 'A' for fan mode and '0' for swing mode. This was done even when the device did not actually support fan or swing settings. However, pydaikin version 0.6 changed expectations: it treats the absence of f_dir and f_rate as a signal that the device does not support those features and does not expect them to be set. By forcibly injecting default values into device.values, the integration broke this contract, causing issues on devices without fan settings and creating inconsistencies between Home Assistant and pydaikin.\n\nThe fix had three parts:\n1) The Daikin integration requirements were updated from pydaikin==0.4 to pydaikin==0.6 in both homeassistant/components/climate/daikin.py, homeassistant/components/daikin.py, and requirements_all.txt to ensure the correct library version is used.\n2) The integration stopped manually looping over hard-coded HTTP endpoints ('aircon/get_sensor_info' and 'aircon/get_control_info') and aggregating their results. Instead it now calls device.update_status(), which is the higher-level status update method provided by pydaikin 0.6. This aligns Home Assistant with the updated library API and centralizes the update logic in the library.\n3) In the climate/daikin component, the code that initialized supported features for fan and swing was updated. Previously, if fan/swing attributes were missing from device.values, the integration would still inject default values ('A' for fan and '0' for swing). That behavior was removed. Now, the component only marks SUPPORT_FAN_MODE and SUPPORT_SWING_MODE when the relevant pydaikin attributes exist, and it no longer writes default values for unsupported options. This ensures that devices which do not support fan or swing settings are correctly treated as such, and pydaikin 0.6 is not given bogus f_dir/f_rate values.\n\nAfter these changes, the Daikin integration operates correctly with pydaikin 0.6 and works on devices that lack fan-related capabilities without causing library-level errors.",
        "semantic_memory": "This fix illustrates several general principles for integrating with third-party device libraries and hardware:\n\n1. Do not fabricate capabilities: When a library or device signals unsupported features by omitting fields or returning null/None, the integration should respect that absence. Injecting default values for unsupported features (e.g., forcing fan or swing settings on hardware that lacks them) can create invalid states and break upstream library assumptions.\n\n2. Capability detection via presence, not assumption: For heterogeneous device families (like AC units with varying feature sets), feature flags should be derived from actual capability detection (e.g., checking if keys like f_rate or f_dir exist) rather than assuming that all models support all options.\n\n3. Keep integration logic aligned with library APIs: When upgrading a dependency, review and adapt to its API changes rather than preserving outdated custom logic. If the library provides a single consolidated update method (e.g., update_status()), prefer that over manually calling internal or lower-level endpoints, thereby reducing divergence and maintenance overhead.\n\n4. Let the library enforce its own invariants: If a device library defines which attributes are valid and when, the integration should avoid mutating the library's internal state in ways that contradict those rules. Treat device.values or similar structures as owned by the library, not an arbitrary key-value store to patch with fake defaults.\n\n5. Version pinning and cross-file consistency: When bumping a dependency version, ensure all references in the codebase (component-specific REQUIREMENTS and global requirements_all.txt) are updated together to avoid mismatched or partially upgraded environments.\n\nThese patterns are broadly applicable to any integration that wraps vendor libraries or hardware APIs, especially when devices in the same family differ in supported features.",
        "procedural_memory": [
            "When diagnosing and fixing issues caused by library upgrades and unsupported device capabilities, follow steps like:",
            "Step 1: Identify symptoms and affected models. Look for error logs or malfunctioning behavior that only occurs on certain models (e.g., some Daikin AC units). Note any error messages coming from the underlying library (such as pydaikin) that reference unexpected or invalid fields (e.g., f_dir, f_rate).",
            "Step 2: Compare integration behavior with library expectations. Read the updated library documentation or source code to understand how it represents device capabilities (e.g., missing keys indicate unsupported features) and which methods it expects integrators to call (e.g., update_status()). Look for changes between the old and new library versions.",
            "Step 3: Audit the integration for assumptions about capabilities. Search for places where the integration sets default values or assumes that specific fields are always present (e.g., injecting default fan or swing modes when the attributes are missing). Identify any code that writes into the library's device state (like device.values) that might conflict with the new library behavior.",
            "Step 4: Adjust capability detection logic. Replace hard assumptions with conditional checks that only enable features when the corresponding fields exist or are explicitly indicated by the library. For example, only set SUPPORT_FAN_MODE if the Daikin fan attribute is present in device.values, and do not create that key when it is absent.",
            "Step 5: Remove or refactor manual low-level calls in favor of the library API. If the integration manually calls specific HTTP endpoints or resource paths that the library now abstracts behind a single method, refactor to use the library's official method (e.g., self.device.update_status()) rather than maintaining a list of endpoints like HTTP_RESOURCES.",
            "Step 6: Update dependency versions consistently. Ensure the component-specific REQUIREMENTS and any global requirements files reference the same, correct library version (e.g., pydaikin==0.6). This avoids running older code against new assumptions (or vice versa).",
            "Step 7: Test across device variations. After making changes, test both on devices that support advanced features (fan/swing) and those that do not. Confirm that supported devices still expose fan/swing controls and that unsupported devices no longer cause errors or attempt to send those settings.",
            "Step 8: Monitor logs and regressions. Once deployed, monitor logs for any remaining library-level warnings or errors related to the fields that were previously problematic. Use this feedback to further refine capability detection or error handling if necessary."
        ]
    }
}
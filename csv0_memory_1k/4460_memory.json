{
    "search_index": {
        "description_for_embedding": "Fixed flaky, race‑condition prone unit tests for StackStorm concurrency policies by replacing asynchronous/mock-Zookeeper coordination with a noop coordinator and a scheduling-only mock publisher. Tests now manually drain the ActionExecutionSchedulingQueue via the scheduler handler, avoid eventlet-based sleeps, and reset the global coordinator between tests to prevent cross-test contamination.",
        "keywords": [
            "flaky tests",
            "race condition",
            "concurrency policy",
            "StackStorm",
            "scheduler",
            "ActionExecutionSchedulingQueue",
            "noop coordinator",
            "zake",
            "coordination.COORDINATOR",
            "MockLiveActionPublisherSchedulingQueueOnly",
            "eventlet",
            "unit test determinism"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, unit tests for StackStorm's concurrency policies (`test_concurrency.py` and `test_concurrency_by_attr.py`) were intermittently failing and hanging. The tests relied on the real coordination layer using the `zake` driver (a Zookeeper mock) and on asynchronous, thread-based live action publishers with `eventlet.sleep` polling loops to wait for state transitions. Because the concurrency policy code uses distributed locks and schedules actions asynchronously, the tests exhibited race conditions, non-deterministic timing, and could block when the same process tried to acquire locks twice.\n\nThe fix restructured the tests to avoid relying on real coordination and uncontrolled async behavior:\n- The tests now call `st2tests.config.parse_args(coordinator_noop=True)` in `setUpClass` to configure the coordination layer to use a noop driver instead of `zake`, and explicitly set `coordination.COORDINATOR = None` so a fresh, noop coordinator is used.\n- A corresponding `tearDownClass` resets `coordination.COORDINATOR = None` again to prevent leaking this configuration into other test suites.\n- In `st2tests/st2tests/config.py`, the coordination overrides were refactored: `_override_coordinator_opts(noop=False)` sets `coordination.url` to `None` if `noop=True` (disabling external coordination) or `'zake://'` otherwise, keeping `lock_timeout` small but allowing tests to choose behavior.\n- The tests stop using `MockLiveActionPublisherNonBlocking` and `MockExecutionPublisherNonBlocking`. Instead, they patch `LiveActionPublisher.publish_state` to use `MockLiveActionPublisherSchedulingQueueOnly.publish_state`, and keep `MockExecutionPublisher` for execution events.\n- `MockLiveActionPublisherSchedulingQueueOnly.publish_state` was updated so that when the live action state is `REQUESTED`, it enqueues the execution via its `process` method; for other states, it directly invokes `worker.get_worker().process(payload)` so state transitions still flow through the worker synchronously.\n- The tests no longer rely on eventlet sleeps and background threads to drive state transitions. A helper method `_process_scheduling_queue()` was added, which iterates over all `ActionExecutionSchedulingQueue` entries and invokes `scheduling_queue.get_handler()._handle_execution(queued_req)` directly. Tests call this method deterministically whenever they want the scheduler to run.\n- All `eventlet.sleep` loops and `MockLiveActionPublisherNonBlocking.wait_all()` calls were removed in favor of explicit calls to `_process_scheduling_queue()` and existing `_wait_on_status(...)` / `_wait_on_statuses(...)` helper methods.\n- Runner invocation was stabilized using a shared `MOCK_RUN_RETURN_VALUE = (LIVEACTION_STATUS_RUNNING, NON_EMPTY_RESULT, None)` applied via `@mock.patch.object(runner.MockActionRunner, 'run', ...)` so that all action executions behave predictably.\n\nWith these changes, the concurrency policy tests no longer rely on real locking behavior or timing-sensitive async operations. They only test the concurrency decision logic (delay vs cancel vs allow) while the actual lock implementation and coordinator behavior are tested elsewhere. This separation of concerns eliminated the random test failures and hangs.",
        "semantic_memory": "Generalizable lessons from this fix:\n\n1. **Avoid real distributed coordination in unit tests when testing higher-level logic.**\n   When unit tests for business logic (e.g., concurrency policies) depend on a real or semi-real coordination backend (Zookeeper, etcd, `zake`, etc.), they can become flaky due to lock timing, network-like delays, and global state. Instead, use a noop or in-memory coordinator driver when the test is not specifically about the lock semantics.\n\n2. **Make asynchronous flows deterministic in tests.**\n   Tests that rely on background threads, green threads, or async workers (`eventlet.sleep`, time-based polling loops) tend to be race-prone. It's more reliable to:\n   - Use mocks that enqueue work into an in-memory queue (e.g., `ActionExecutionSchedulingQueue`).\n   - Expose a synchronous helper that drains the queue (`_process_scheduling_queue`) and drives the state machine directly.\n   - Only proceed after explicitly verifying that the desired state has been reached (e.g., via `_wait_on_status` / `_wait_on_statuses`).\n\n3. **Separate system concerns in tests.**\n   Here, the concurrency policy tests were accidentally validating locking behavior and coordinator interactions. The fix makes the policy tests focus strictly on policy decisions (delay, cancel, schedule) and counts of executions/state transitions. The locking mechanism is assumed correct and should be unit tested in its own dedicated suite. This separation reduces complexity and flakiness.\n\n4. **Control and reset global singletons between tests.**\n   The StackStorm coordination layer uses a global `coordination.COORDINATOR` singleton. If one test suite changes it (e.g., to a noop coordinator) and does not reset it, other suites may behave differently or fail. Explicitly resetting such globals in `setUpClass`/`tearDownClass` is important for test isolation.\n\n5. **Prefer deterministic mocks over non-blocking async mocks where possible.**\n   The original `MockLiveActionPublisherNonBlocking` depended on threads and a 'wait_all' hook to synchronize test progress, which still left timing windows. The new `MockLiveActionPublisherSchedulingQueueOnly` focuses on one responsibility: putting executions into the scheduler queue and letting the test explicitly drive scheduling. This pattern—mocks that expose explicit control points instead of background threads—generalizes to many asynchronous systems.\n\n6. **Configurable test environment via helper config modules.**\n   A central test config helper (`st2tests.config`) allows toggling between noop and real coordination via `parse_args(coordinator_noop=True)`. Making such options explicit and parameterized simplifies reusing the same test scaffolding for different scenarios and reduces hidden behavior.\n",
        "procedural_memory": [
            "How to diagnose and fix flaky unit tests involving concurrency, coordination, and scheduling:",
            "Step 1: Identify the symptoms of flakiness.",
            "- Look for tests that randomly time out, hang, or occasionally fail assertions related to counts or states of asynchronous operations (e.g., number of running actions, scheduled tasks).",
            "- Check if tests rely on `sleep`, polling loops, or 'wait_all' constructs to synchronize with background processing.",
            "",
            "Step 2: Inspect dependencies on coordination and global state.",
            "- Search for use of distributed coordination clients (Zookeeper, etcd, `zake`, etc.) in the test setup.",
            "- Identify any global singletons (e.g., a global coordinator instance) used by the code under test.",
            "- Verify whether the test suite manipulates these singletons and whether they are reset between tests or test classes.",
            "",
            "Step 3: Determine what the test is actually trying to validate.",
            "- Separate concerns: is the test verifying concurrency policy decisions (e.g., delay/cancel/execution thresholds) or the correctness of the locking mechanism itself?",
            "- If the test's purpose is high-level policy behavior, it should not depend on real coordination or lock timing; those should be tested in dedicated locking/coordination tests.",
            "",
            "Step 4: Introduce a noop or in-memory coordinator for policy-level tests.",
            "- Add configuration hooks to your test config helper (similar to `st2tests.config.parse_args(coordinator_noop=True)`) that allow switching the coordination backend to a noop or local implementation.",
            "- When setting up the test class, call this helper with the appropriate flag to disable real coordination.",
            "- Explicitly reset global coordination state in `setUpClass` and `tearDownClass`, e.g.:",
            "  - `coordination.COORDINATOR = None` before initialization, so your code obtains a fresh noop coordinator.",
            "  - `coordination.COORDINATOR = None` after tests complete, to avoid leaking noop configuration into other suites.",
            "",
            "Step 5: Replace asynchronous mocks with deterministic queue-driven behavior.",
            "- If you have mocks that spin up threads or green threads (e.g., a 'NonBlocking' publisher), consider replacing them with mocks that:",
            "  - Enqueue work into an in-memory queue or DB collection (e.g., `ActionExecutionSchedulingQueue`).",
            "  - Do not start background workers on their own.",
            "- For example, let the mock publisher:",
            "  - On 'REQUESTED' states: simply call a method that stores the request in the scheduling queue.",
            "  - On all other states: process payload synchronously via a worker object as needed.",
            "",
            "Step 6: Expose a helper to drive the scheduler synchronously.",
            "- Implement a helper like `_process_scheduling_queue()` in tests that:",
            "  - Fetches all queued scheduling requests from the queue (e.g., `ActionExecutionSchedulingQueue.get_all()`).",
            "  - Invokes the scheduler handler directly (e.g., `scheduling_queue.get_handler()._handle_execution(queued_req)`) for each entry.",
            "- Call this helper at specific points in your test instead of waiting with `sleep`.",
            "",
            "Step 7: Remove time-based sleeps and non-deterministic waits.",
            "- Delete or minimize any loops such as:",
            "  - `for i in range(...): eventlet.sleep(1); check_state()`.",
            "- Replace them with:",
            "  - Calls to your scheduler processing helper (`_process_scheduling_queue()`).",
            "  - Targeted 'wait for status' helpers that poll with short intervals and a timeout, but after you've driven the scheduler synchronously.",
            "",
            "Step 8: Stabilize the behavior of runners/executors.",
            "- If the code under test invokes task runners or executors, patch them with a fixed return value to avoid variability:",
            "  - e.g., `MOCK_RUN_RETURN_VALUE = (STATUS_RUNNING, NON_EMPTY_RESULT, None)` and mock `run` to return this consistently.",
            "- This ensures that each scheduled execution reliably goes into the same initial state.",
            "",
            "Step 9: Assert on counts and states after deterministic scheduling.",
            "- After each call to `_process_scheduling_queue()`, fetch the relevant resources (e.g., `LiveAction.get_all()`) and assert:",
            "  - The number of scheduled vs delayed vs canceled actions matches expectations.",
            "  - The number of times the publisher mock was called matches the expected state transitions (requested, scheduled, running, canceling, canceled, succeeded, etc.).",
            "- Use explicit helper methods (`_wait_on_status`, `_wait_on_statuses`) to block until the state you expect is observed, with a timeout.",
            "",
            "Step 10: Verify test isolation.",
            "- Run the full test suite (not just the modified tests) to ensure that changes to coordination and mocks do not bleed into other suites.",
            "- Confirm that global singletons (coordinator, worker, scheduler handler) are reset or reinitialized where necessary.",
            "- If other suites rely on the default coordination behavior (e.g., `zake`), they should still operate as before when your noop flag is not set.",
            "",
            "Following these steps will help you convert fragile, timing-sensitive concurrency tests into deterministic unit tests that focus on business logic and avoid real coordination side effects."
        ]
    }
}
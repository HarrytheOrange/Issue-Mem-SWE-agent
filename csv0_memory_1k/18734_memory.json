{
    "search_index": {
        "description_for_embedding": "Addition of a new Home Assistant climate platform for Systemair Savecair units, plus multiple fixes: correct async client usage, safe mapping of fan and operation modes from the device to Home Assistant, robust handling of None sensor values, proper exposure of supported features (including away mode), and cleaning up the python-systemair-savecair dependency (removing hacks, using the new SavecairClient API, and pinning version 1.0.1 in requirements).",
        "keywords": [
            "Systemair",
            "Savecair",
            "systemair_savecair",
            "climate integration",
            "homeassistant.components.climate",
            "python-systemair-savecair",
            "async_setup_platform",
            "async_update",
            "fan mode mapping",
            "operation mode mapping",
            "away mode",
            "device_state_attributes",
            "external dependency versioning",
            "requirements_all.txt",
            "package_constraints.txt",
            "websockets removal",
            "callback on_update on_connect"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced a new climate platform for Systemair Savecair ventilation units into Home Assistant and iterated on it heavily based on review feedback and upstream library changes.\n\nInitially, a simple synchronous integration was added with a direct Savecair client, websockets as a requirement, and basic mode/fan handling. Over subsequent commits, the implementation was refactored to align with Home Assistant's async climate platform expectations and the evolving python-systemair-savecair library.\n\nKey changes included:\n- Moving from a simplistic client usage to an asynchronous SavecairClient (later renamed SavecairClient from systemair.savecair) that is created in async_setup_platform and started with retry support.\n- Wiring up the library's callback hooks (on_update and on_connect, previously cb_update) to Home Assistant via async_schedule_update_ha_state so state updates propagate correctly without polling.\n- Defining feature support at module level (SUPPORT_FLAGS) to include target temperature, fan mode, operation mode, away mode, and on/off, and returning that from supported_features.\n- Converting device state into Home Assistant semantics: mapping raw fan indexes to human-readable fan modes (Off, Low, Medium, High) via SAVECAIR_FAN_MODES, and mapping device operation codes to Home Assistant operation states (AUTO, MANUAL, IDLE). The code includes the reverse mapping for setting operation modes from Home Assistant back to the device.\n- Safely handling missing or None-valued sensors: all properties now first check for key presence and None before dividing by 10 or converting to integers to avoid exceptions when data is absent or temporarily unavailable.\n- Implementing away mode behavior via async_turn_away_mode_on/off and is_away_mode_on, tying the latter to IDLE mode as defined by the device library.\n- Adjusting fan_list behavior: only exposing available fan modes when the device is in MANUAL operation mode, otherwise returning None to indicate that fan speed is not user-selectable in other modes.\n- Using device_state_attributes instead of overriding state_attributes directly, and exposing additional attributes like supply air temperature and fan speeds, plus the raw client data dict for debugging or advanced use.\n\nOn the dependency side, the python-systemair-savecair library initially contained hacks to modify Home Assistant to bypass project rules, so a very high version pin (1000000000) was temporarily added to package_constraints.txt and gen_requirements_all to effectively block that version. As the library was fixed and re-released (0.0.2 → 0.0.3 → 0.0.4 → 0.0.5 → 0.0.6 → 1.0.0 → 1.0.1), the integration was updated to match its API (client name change, new callbacks, operation mode semantics), the constraints were removed, and the final REQUIREMENTS and requirements_all.txt pin python-systemair-savecair==1.0.1.\n\nAlong the way, minor issues such as using `is` vs `==` for string comparison, returning [] vs None for fan_list, unnecessary sys.path hacking, and unused websockets requirements were corrected. The component was also added to .coveragerc omit list because of external-dependency characteristics. Documentation PR was flagged as missing and left to be handled separately.",
        "semantic_memory": "This case illustrates several general patterns and best practices for integrating external devices into Home Assistant or similar async, component-based platforms:\n\n1. **Async component design and callbacks**:\n   - When integrating with an asynchronous library, create and start the client in async_setup_platform and use callbacks from the library to trigger Home Assistant state updates via async_schedule_update_ha_state.\n   - Avoid unnecessary polling when the library can push updates; instead, wire `on_update` and/or `on_connect` (or similar hooks) to the platform's update mechanisms.\n   - Prefer async_* methods (async_set_temperature, async_set_fan_mode, async_set_operation_mode, async_turn_on/off) to integrate smoothly with the event loop.\n\n2. **Feature flags and capability description**:\n   - Compute supported_features at module scope when possible, using bitwise OR of the SUPPORT_* constants. This clearly documents what the platform supports and avoids per-instance duplication.\n   - Expose only the features actually backed by the device and library; e.g., only present fan_list when the operation mode allows manual fan speed control.\n\n3. **Mapping device semantics to platform semantics**:\n   - Many devices expose numeric or vendor-specific codes for modes and states. Use mapping dictionaries (e.g., SAVECAIR_FAN_MODES, SAVECAIR_OPERATION_MODES, and reverse mappings) to convert cleanly between device representation and Home Assistant's standardized states.\n   - Keep both directions (device→HA and HA→device) explicit and centralized so changes in the external API are easy to manage.\n\n4. **Robust handling of incomplete or transient data**:\n   - When reading from an external device, attributes may be missing or None, especially during startup or reconnection. Always check for key existence and non-None values before transforming (e.g., dividing by 10, casting to int).\n   - This prevents runtime exceptions and results in safe None values, which the platform can handle gracefully.\n\n5. **Dependency management and project rules**:\n   - External libraries should not modify the host application to work around rules. If a dependency is misbehaving, temporarily constrain it with a very high version pin in package_constraints or similar tooling to effectively block that version until the library is fixed.\n   - Once the library is corrected (e.g., new versions on PyPI and cleaned-up Git history), update the integration to use the new API, relax constraints, and ensure requirements_all.txt and REQUIREMENTS are in sync.\n   - Avoid embedding local development paths (sys.path.insert) or other non-portable hacks in production code; instead, rely on PyPI distributions and pinned versions.\n\n6. **API stability across library versions**:\n   - When a third-party library evolves (class names change, callback attributes renamed, semantics of modes adjusted), the integration must be updated to mirror those changes while preserving the public behavior of the platform component.\n   - Centralizing mappings and client interaction logic (e.g., set_fan_mode delegating to client.set_fan_mode) makes these updates easier and reduces churn in the platform-facing code.\n\n7. **Return contracts for optional lists**:\n   - In Home Assistant climate entities, `fan_list` or `operation_list` should be meaningful indicators of available options. Returning None vs [] has semantic differences: None means the feature is not supported in the current context; a non-empty list means the user can select among modes. This integration decided to return None when manual control is not available, reinforcing that the UI should hide fan control in those modes.",
        "procedural_memory": [
            "High-level procedure for adding and stabilizing a new climate integration backed by an external async library:",
            "Step 1: Model the configuration schema and constants.",
            "  - Define configuration keys (e.g., iam_id, password, name) and defaults using voluptuous and PLATFORM_SCHEMA.",
            "  - Introduce any new attributes as constants (e.g., ATTR_SUPPLY_AIR_TEMPERATURE, ATTR_SUPPLY_AIR_FAN_SPEED).",
            "  - Decide which climate features the device supports (target temperature, fan mode, operation mode, away mode, on/off) and encode them in a SUPPORT_FLAGS bitmask at module level.",
            "Step 2: Integrate the external async client correctly.",
            "  - In async_setup_platform(hass, config, async_add_entities, ...):",
            "    - Parse configuration values.",
            "    - Lazily import the external client (from systemair.savecair import SavecairClient) inside the function so it is only imported when needed.",
            "    - Instantiate the client with the event loop (loop=hass.loop) and any appropriate options (e.g., retry=True for reconnecting websockets).",
            "    - Create the ClimateDevice entity, pass it the client, and add it via async_add_entities.",
            "  - In the ClimateDevice.__init__, store the client and start it (client.start()).",
            "Step 3: Wire client callbacks to Home Assistant state updates.",
            "  - Use async_added_to_hass in your entity:",
            "    - Define an async function async_update_state() that calls self.async_schedule_update_ha_state().",
            "    - Append this function to the client's callback collections (e.g., client.on_update and client.on_connect).",
            "  - Implement async_update to call await client.update_sensors() so the platform can force a refresh when needed.",
            "Step 4: Implement entity properties safely.",
            "  - For each property (current_temperature, target_temperature, humidity, fan speeds, operation state):",
            "    - Check if the key exists in client.data; if not, return None.",
            "    - Check if the value is None; if so, return None.",
            "    - Apply any scaling (e.g., divide by 10 to convert from tenths of degrees) only after these checks.",
            "  - For temperature_unit, inspect a configuration field from the device (e.g., control_regulation_temp_unit) and fallback to a sensible default (TEMP_CELSIUS) if missing.",
            "  - Use device_state_attributes to expose supplementary attributes and include raw client data only if appropriate.",
            "Step 5: Map device modes to platform modes.",
            "  - Create dictionaries mapping device-level modes to Home Assistant modes; for example:",
            "    - SAVECAIR_FAN_MODES = {1: 'Off', 2: 'Low', 3: 'Medium', 4: 'High'}",
            "    - SAVECAIR_OPERATION_MODES/HA_OPERATION_MODES to map between numeric or library-level modes and STATE_AUTO, STATE_MANUAL, STATE_IDLE.",
            "  - In current_fan_mode and current_operation, convert raw device values via these mappings and handle unknown/None values gracefully by returning None.",
            "  - In async_set_fan_mode and async_set_operation_mode, do the reverse mapping and delegate to client methods (e.g., client.set_fan_mode(mode), client.set_operation_mode(mode)).",
            "Step 6: Implement behavior for away mode and on/off.",
            "  - Add async_turn_away_mode_on/off that call the appropriate client methods (e.g., set_away_mode, set_auto_mode).",
            "  - Implement is_away_mode_on in terms of current_operation (e.g., treat STATE_IDLE as away).",
            "  - Implement async_turn_on/off using the client’s fan or mode methods (e.g., set_fan_high, set_manual_mode + set_fan_off).",
            "Step 7: Describe available options correctly.",
            "  - operation_list should return the list of supported operation modes (e.g., [STATE_AUTO, STATE_MANUAL]).",
            "  - fan_list should return a list of fan modes only when manual control is permitted; return None otherwise to indicate that the UI should hide fan controls.",
            "Step 8: Manage external dependencies and constraints.",
            "  - Add the dependency to the component’s REQUIREMENTS list with an explicit, known-good version (e.g., python-systemair-savecair==1.0.1).",
            "  - Run script/gen_requirements_all.py and update requirements_all.txt accordingly for the component.",
            "  - If a library previously violated project rules (e.g., modified Home Assistant), temporarily block it via package_constraints.txt with a large version cap (e.g., python-systemair-savecair==1000000000.0.0) and comments explaining why.",
            "  - Once the library is fixed and re-released, remove the constraint, update REQUIREMENTS and requirements_all to the new version, and ensure there are no hacks like sys.path.insert in the code.",
            "Step 9: Ensure style, tests, and coverage compliance.",
            "  - Run linters (flake8, etc.) to fix issues like improper string comparison (use ==, not is) and unused imports.",
            "  - Add the component file to .coveragerc omit if coverage is not practical due to external dependencies.",
            "  - Run tox and any available tests to ensure everything passes before merging.",
            "Step 10: Add or update documentation.",
            "  - Create a corresponding documentation page (e.g., climate.systemair_savecair) outlining configuration options, supported features, and example configuration.",
            "  - Verify that the docs repository has a matching PR to avoid docs-missing labels."
        ]
    }
}
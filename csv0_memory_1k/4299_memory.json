{
    "search_index": {
        "description_for_embedding": "Introduced a formal Napari Advancement Proposals (NAP) system: documented scope and purpose of NAPs, defined types and lifecycle statuses, specified workflow and acceptance process (via Zulip consensus and steering council fallback), added a MyST markdown template, index, and flowchart to record major design and process decisions in the napari project.",
        "keywords": [
            "napari",
            "NAP",
            "Napari Advancement Proposals",
            "governance",
            "design proposals",
            "decision-making process",
            "process documentation",
            "MyST markdown",
            "Sphinx docs",
            "Zulip",
            "consensus",
            "proposal template"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the napari project formalized a governance mechanism for major technical and process decisions by introducing Napari Advancement Proposals (NAPs). Before this change, significant design or process decisions were scattered across GitHub PRs, issues, meetings, and chat, with no single durable, searchable record. The PR adds NAP 0 (the meta‑proposal that defines the NAP system itself), a MyST markdown template for future NAPs, an index page for the NAPs section of the docs, and a flowchart image illustrating the NAP lifecycle.\n\nNAP 0 defines what a NAP is (a design or process document for napari, its processes, or its broader environment), what kinds exist (Standards Track, Informational, Process), and when a NAP is warranted (controversial features, API breaks, governance changes, or cases where discussion and rationale need to be preserved). It clarifies that most routine changes still use the normal PR flow.\n\nThe workflow is: a champion authors a draft NAP using the provided template under docs/naps, submits it via PR with a sequential number and short title, and announces it (especially in the #naps Zulip channel and optionally image.sc). Discussion can happen across Zulip, GitHub, and community meetings; the author is responsible for summarizing arguments and keeping the NAP updated. Standards Track NAPs should have at least a prototype implementation, usually as a WIP PR.\n\nNAPs progress through statuses like Draft, Provisional, Active, Accepted, Deferred, Rejected, Withdrawn, Final, and Superseded. Acceptance is generally by consensus: when the author (or anyone) believes consensus is reached, they start a “Proposal to accept NAP #X” topic in the Zulip #naps channel, summarize key points, and allow at least 7 days for substantive objections. If none arise, the NAP is marked Accepted and the Resolution field links to the follow‑up Zulip message. If objections arise, it remains Draft and discussion continues. In exceptional cases where core devs cannot reach consensus, the napari Steering Council may decide, per governance.\n\nThe template file encodes standard sections (Abstract, Motivation and Scope, Detailed Description, Related Work, Implementation, Backward Compatibility, Future Work, Alternatives, Discussion, References, Copyright) and a YAML front‑matter with Author(s), Created date, Status, Type, Resolution, Resolved date, and Version effective. NAPs are documented as public domain / CC0 with attribution encouraged. The index page wires NAPs into the docs navigation, and an acknowledgements section credits SKIPs, NEPs, and PEPs as the basis for this process.",
        "semantic_memory": "This change captures a generalizable pattern: for mature open-source projects, it’s valuable to have a formal, lightweight proposal system to document major decisions beyond what normal pull requests and issue threads provide. Such a system:\n\n- Defines clear proposal types (e.g., Standards Track, Process, Informational) and when they should be used, so contributors know when something is “big enough” to warrant a proposal instead of just a PR.\n- Uses text files in the main repo, versioned with the code, as the durable store for design rationale, ensuring decisions and dissent are preserved and searchable.\n- Provides a standard template and required metadata (authors, status, type, dates, cross‑references, resolution link) so all proposals look similar and are easy to scan programmatically or by humans.\n- Establishes lifecycle statuses (Draft, Provisional, Accepted, Deferred, Rejected, Withdrawn, Final, Superseded, Active) that describe where a proposal is in the process and how it relates to the implemented code.\n- Recommends co‑development of at least a prototype implementation alongside design proposals to validate feasibility and surface practical issues.\n- Separates the design discussion (across meetings, chat, and GitHub) from the archival proposal document, while explicitly assigning responsibility to the author to summarize and capture key arguments and outcomes in the proposal itself.\n- Formalizes how consensus is assessed and recorded (e.g., a final comment period on a specific communication channel with a minimum duration, plus a Resolution link back to that discussion), instead of relying on vague notions of ‘rough consensus’.\n- Provides a defined escalation path for controversial decisions (e.g., to a steering council), integrated with the project’s governance model.\n- Encourages external stakeholders (e.g., maintainers of related projects) to use the proposal system when their changes materially affect the project’s users, improving cross‑project coordination.\n\nThis is a reusable governance and documentation pattern applicable to any project: adopt a PEP/NEP‑style proposal system to improve clarity, transparency, and long‑term maintainability of architectural and process decisions.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Recognize when a formal proposal process is needed.\n- Observe that major design, API, or governance decisions are recurring and contentious, and that their rationale is getting lost in scattered chat logs, meeting notes, and PR comments.\n- Identify pain points such as unclear ownership, repeated debates on the same issues, or confusion from contributors about why a decision was made.",
            "Step 2: Design a proposal system based on existing models.\n- Study established systems like Python PEPs, NumPy NEPs, and scikit-image SKIPs.\n- Decide on proposal types (e.g., Standards Track, Process, Informational) and define what each covers.\n- Define the scope of proposals: which parts of the ecosystem they apply to (core repo, org-wide tooling, related packages, etc.).",
            "Step 3: Define statuses and lifecycle.\n- Enumerate statuses: Draft, Provisional, Active, Accepted, Deferred, Rejected, Withdrawn, Final, Superseded.\n- Document what each status means in terms of implementation and how proposals move between them.\n- Specify how special cases like Provisional (provisionally accepted) and Active (long‑lived process docs) should be used.",
            "Step 4: Choose storage format and location.\n- Decide to store proposals as text files (e.g., MyST Markdown or reStructuredText) under a dedicated directory in the main repo (e.g., docs/naps/).\n- Integrate them with your documentation build system (e.g., Sphinx), adding an index page and including proposal files in a toctree.\n- Ensure the directory and naming scheme (sequential numbers plus short titles) supports easy discovery and linking.",
            "Step 5: Create a standard template.\n- Build a template file with:\n  - Front-matter fields: Author(s), Created, Status, Type, Resolution URL, Resolved date, Version effective, and any project‑specific metadata.\n  - Standard sections: Abstract, Motivation and Scope, Detailed Description, Related Work, Implementation, Backward Compatibility, Future Work, Alternatives, Discussion, References, Copyright.\n- Include guidance text under each section explaining what kind of content to put there.\n- Add licensing language (e.g., dedicated to public domain under CC0, attribution encouraged).",
            "Step 6: Document when a proposal is required.\n- Write a section explaining that most contributions should still use the normal PR flow.\n- Clarify that proposals are warranted for:\n  - New or breaking APIs.\n  - Major UX, architecture, or dependency changes.\n  - Governance and process changes.\n  - Cross‑ecosystem changes that materially affect users.\n- Mention that retrospective informational proposals can be written to document historical decisions when confusion arises.",
            "Step 7: Define the author/champion responsibilities and workflow.\n- Require a champion to:\n  - Draft a proposal using the template and save it in the proposals directory with a new sequential number and short title.\n  - Open a PR adding the proposal file (and modify the index if needed).\n  - Announce the proposal in agreed channels (e.g., dedicated chat stream, forum tag) and keep the document updated with key arguments for and against.\n- Encourage co‑development of at least a prototype implementation as a WIP PR linked from the proposal’s Implementation section.",
            "Step 8: Specify how acceptance and consensus work.\n- Establish a clear acceptance ritual:\n  - When the champion believes consensus is reached, they (or anyone) start a focused topic in a chosen channel (e.g., Zulip #naps) titled “Proposal to accept NAP #<number>: <title>”.\n  - Summarize the latest version of the proposal and major points of contention and resolution.\n  - Declare a final comment period (e.g., 7 days) and state that absent substantive objections, the proposal will be accepted.\n- Document that after the period, if no substantive objections arise, the proposal is marked Accepted, and the Resolution field is set to the acceptance message link. If objections arise, the proposal stays Draft and discussion continues.",
            "Step 9: Integrate with governance for edge cases.\n- Add a clause that if consensus cannot be reached among core maintainers, the steering council or equivalent governance body will make the final decision, according to the project’s governance rules.\n- Link to the governance document from the proposal process doc.",
            "Step 10: Maintain and evolve proposals.\n- Clarify that:\n  - Standards Track proposals are generally frozen once Final; the implementation and user docs become the primary reference.\n  - Process proposals (like the proposal system itself) may be updated over time as practices evolve, following an appropriate level of review.\n  - Proposals can be marked Superseded with pointers between old and new documents.\n- Encourage additional PRs to refine wording and keep process docs current.",
            "Step 11: For contributors: how to create a new NAP in this repository.\n- Choose a new sequential NAP number and a concise short title.\n- Copy docs/naps/template.md to docs/naps/<number>-<short-title>.md.\n- Fill in the front-matter: Author(s), Created date (yyyy-mm-dd), Status: Draft, Type (Standards Track or Process), and other fields as applicable.\n- Write content for each section (Abstract, Motivation and Scope, Detailed Description, etc.), including links to any WIP implementation PRs.\n- Add the new NAP file to docs/naps/index.md’s toctree if required.\n- Open a PR with these changes.\n- Announce the PR and NAP in the #naps Zulip channel and other relevant community channels.\n- Update the NAP over time to incorporate feedback and discussion, and later follow the acceptance procedure when ready."
        ]
    }
}
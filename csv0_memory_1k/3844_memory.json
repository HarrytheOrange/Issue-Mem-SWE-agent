{
    "search_index": {
        "description_for_embedding": "Added a new Home Assistant device_tracker platform for Bouygues Bbox routers using the pybbox library. The integration scans the router for connected and active devices, throttles scan frequency, and exposes MAC and hostnames for presence detection.",
        "keywords": [
            "device_tracker",
            "bbox",
            "Bouygues",
            "router integration",
            "pybbox",
            "Home Assistant",
            "network presence detection",
            "requirements_all.txt",
            "Throttle",
            "new platform implementation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The issue requested support for Bouygues Bbox routers in Home Assistant's device_tracker component so that these routers could be used for presence detection. Previously, there was no integration that queried Bbox devices for connected clients, leaving users of this major French ISP without native router-based tracking.\n\nTo address this, the PR introduced a new device_tracker platform module `homeassistant/components/device_tracker/bbox.py`. This module defines a `BboxDeviceScanner` that uses the external `pybbox` library to connect to the router and fetch the list of connected devices.\n\nKey implementation details:\n- A new REQUIREMENTS entry `pybbox==0.0.5-alpha` was added both in the platform module and in `requirements_all.txt` (with a comment linking it to `device_tracker.bbox`), and the bare `pybbox` package name was also added at the top section of `requirements_all.txt`.\n- The scanner is constructed via `get_scanner(hass, config)`, which instantiates `BboxDeviceScanner(config[DOMAIN])` and returns it only if `success_init` is True.\n- A `Device` namedtuple (`mac`, `name`, `ip`, `last_update`) is used to store scan results, kept in `self.last_results` inside the scanner.\n- `_update_info` is decorated with `Throttle(MIN_TIME_BETWEEN_SCANS)` (60 seconds) to avoid excessive polling of the router.\n- `_update_info` imports `pybbox` locally (lazy import), instantiates `pybbox.Bbox()`, calls `get_all_connected_devices()`, filters for `device['active'] == 1`, and builds the list of active devices, using `homeassistant.util.dt.now()` as `last_update`.\n- `scan_devices` returns a list of MAC addresses from the latest results, and `get_device_name` returns the hostname for a given MAC if known.\n- The new file `device_tracker/bbox.py` was added to `.coveragerc` under `omit` so coverage runs ignore it, consistent with other router-based device_tracker integrations.\n\nThis PR primarily represents a feature addition rather than a bug fix: it fills a functionality gap by introducing a new router integration that adheres to Home Assistant's patterns for device_tracker platforms, dependency management, and throttled scanning.",
        "semantic_memory": "This change illustrates how to add a new router-based device tracker integration in Home Assistant and, more generally, how to structure integrations that poll external devices:\n\n1. **Platform structure for device trackers**:\n   - Implement a `get_scanner(hass, config)` function that initializes and returns a scanner instance or `None` on failure. Home Assistant uses this hook to discover the platform.\n   - Provide a scanner class that implements at least:\n     - `scan_devices()` → returns a list of device identifiers (usually MAC addresses).\n     - `get_device_name(mac)` → returns a human-readable name/hostname if known.\n   - Use simple data containers (like `namedtuple` or dataclasses) to hold scan results.\n\n2. **Dependency management & lazy imports**:\n   - New external libraries should be declared via a `REQUIREMENTS` list in the platform module (e.g., `REQUIREMENTS = ['pybbox==0.0.5-alpha']`).\n   - They must also be added to `requirements_all.txt` with a comment pointing to the integration, so tooling and full installs know about them.\n   - The external library should be imported only inside the function that uses it (lazy import) to avoid import-time failures if the dependency is missing and to keep startup light.\n\n3. **Rate limiting hardware access**:\n   - Use a throttling decorator (in Home Assistant, `homeassistant.util.Throttle`) around the method that talks to the hardware or remote service.\n   - This avoids spamming the device with frequent requests, which can cause performance issues or rate limiting.\n   - Cache the last results in a member like `self.last_results`; the scanner’s public methods read from this cache.\n\n4. **Filtering and normalizing device data**:\n   - When polling a router for connected devices, results often contain both active and inactive entries. Filtering (e.g., `device['active'] == 1`) ensures only truly connected clients are reported.\n   - Normalize fields (MAC, hostname, IP) into a predictable internal representation so the rest of the system can rely on consistent data.\n\n5. **Coverage and test configuration**:\n   - For integrations that are difficult to test in CI (e.g., they require specific hardware or network environments), adding them to the omit list in `.coveragerc` avoids coverage drag.\n   - This is a pragmatic approach: you still can add manual/unit tests later, but the project won’t be blocked by untestable integration code.\n\nOverall, this PR demonstrates a pattern for safely adding a new hardware-backed integration: minimal surface area, internal caching, explicit dependency declaration, lazy imports, and adherence to the host application’s platform API.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the missing integration or feature gap\n- Confirm that the target hardware/service (e.g., a specific router) has no existing integration in the application (e.g., Home Assistant’s device_tracker platforms).\n- Gather how users will configure and use it (e.g., simple platform entry in configuration.yaml).",
            "Step 2: Research and select or build a client library\n- Check if there is a stable Python (or relevant language) library to communicate with the hardware (e.g., `pybbox` for Bouygues Bbox).\n- Verify licensing, version stability, and API methods you need (e.g., a method to list connected devices).",
            "Step 3: Declare and manage dependencies correctly\n- Add the dependency to the integration module’s `REQUIREMENTS` list with a fixed or compatible version, e.g. `REQUIREMENTS = ['pybbox==0.0.5-alpha']`.\n- Add the same dependency and version to the central `requirements_all.txt` file, ideally with a comment indicating which integration uses it.\n- If the project’s tooling requires it, also add the bare package name in the generic section of `requirements_all.txt` or equivalent, following project conventions.",
            "Step 4: Implement the platform entry point\n- Create a new module under the appropriate component namespace (e.g., `homeassistant/components/device_tracker/bbox.py`).\n- Implement `get_scanner(hass, config)` or the project-specific entry function. It should:\n  - Read the integration’s configuration from `config` (e.g., `config[DOMAIN]`).\n  - Instantiate the scanner class.\n  - Return the scanner or `None` if initialization fails.",
            "Step 5: Implement the scanner/driver class\n- Define a data structure to represent a device (e.g., a namedtuple or dataclass with fields like `mac`, `name`, `ip`, `last_update`).\n- In the scanner class:\n  - Initialize a cache (e.g., `self.last_results = []`).\n  - Call an internal update method in the constructor to set `self.success_init` based on whether the first scan succeeds.\n  - Implement `scan_devices()` to update info (respecting throttling) and return a list of device IDs (e.g., MAC addresses).\n  - Implement `get_device_name(mac)` to look up the name in `self.last_results` and return it or `None`.",
            "Step 6: Use lazy imports for external libraries\n- Inside the method that talks to the device (e.g., `_update_info`), import the external library locally: `import pybbox`.\n- This prevents module import failures during platform discovery when the dependency is not yet installed and keeps startup errors localized to actual use.",
            "Step 7: Throttle hardware or network calls\n- Add a constant defining minimum time between scans, e.g. `MIN_TIME_BETWEEN_SCANS = timedelta(seconds=60)`.\n- Use the project’s throttling mechanism (e.g., `@Throttle(MIN_TIME_BETWEEN_SCANS)` decorator) on your update method.\n- Ensure `scan_devices()` just calls the throttled update method and reads from the cached results.",
            "Step 8: Normalize and filter raw data from the device\n- Inspect the data returned by the library (e.g., dictionaries with `macaddress`, `hostname`, `ipaddress`, `active`).\n- Filter out inactive or irrelevant entries (e.g., `if device['active'] != 1: continue`).\n- Map fields into your Device structure and attach a timestamp using a common utility (e.g., `dt_util.now()`).",
            "Step 9: Update coverage and test configuration\n- If the integration cannot be reliably tested in CI (requires real hardware), add the new module to `.coveragerc`’s `omit` list alongside similar modules.\n- Optionally add unit tests that mock the external library if feasible.",
            "Step 10: Validate and document\n- Run the project’s test suite (e.g., `tox`) to ensure nothing breaks.\n- Test the integration manually with the target hardware to confirm devices are discovered and names resolve correctly.\n- Provide minimal configuration documentation (e.g., how to enable `platform: bbox` in configuration.yaml) and any prerequisites (router firmware, credentials, etc.)."
        ]
    }
}
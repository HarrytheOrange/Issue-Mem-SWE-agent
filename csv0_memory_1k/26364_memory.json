{
    "search_index": {
        "description_for_embedding": "Fix for KNX tunable white light color temperature rounding error in Home Assistant: clamp Kelvin values derived from mireds to the device's max Kelvin before computing relative color temperature, correcting a typo in the limit and reformatting with black.",
        "keywords": [
            "KNX",
            "light",
            "tunable white",
            "color temperature",
            "mired",
            "kelvin",
            "rounding error",
            "numeric bounds",
            "clamping",
            "relative color temperature",
            "homeassistant.components.knx.light",
            "off-by-one",
            "device capability limits"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant KNX integration, tunable white lights that used a relative color temperature (0–255) exhibited incorrect behavior due to rounding when converting from mireds (Home Assistant's internal unit) back to Kelvin for KNX devices. The original code converted from mireds to Kelvin with `color_util.color_temperature_mired_to_kelvin(mireds)` and then used that value directly to compute a 0–255 relative color temperature without enforcing the device's allowed temperature range. Due to rounding and boundary values, this could push the computed Kelvin slightly beyond the device's expected range, causing relative color temperature calculations to be off and resulting in wrong or unstable color temperature output. The fix adds a clamp so that the Kelvin value used for relative CT is `min(self._max_kelvin, int(color_temperature_mired_to_kelvin(mireds)))`, ensuring it never exceeds the maximum supported Kelvin. A typo in the first attempt used `self._min_kelvin` instead of `self._max_kelvin`, which was immediately corrected in a follow-up patch. Finally, the file was reformatted with `black` to satisfy project style requirements.",
        "semantic_memory": "When converting units for hardware control (e.g., mireds ↔ kelvin for color temperature, percentage ↔ device-specific ranges), rounding can push values slightly outside of a device's supported range. If those values are then fed into further calculations (e.g., mapping to a 0–255 relative scale), even small deviations can lead to incorrect behavior or edge-case bugs. To mitigate this, always clamp derived numeric values to explicitly known min/max bounds before using them in relative computations or sending them to devices. This is especially important for: (1) color temperature and brightness scaling between different ranges; (2) devices that use relative values (0–255) mapped to an absolute physical range; and (3) conversions that involve floating point math and integer casts, where off-by-one effects are common. Also, when adding clamping logic, double-check that you’re using the correct bound (min vs max) and the correct attributes. Automated formatting (like black) should be run after changes to maintain consistent style and avoid review noise.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and isolate the boundary behavior.\n- Use logs or a test setup to reproduce the problem at extreme or problematic values (e.g., min/max color temperature, specific mired values).\n- Observe the computed values (Kelvin, relative CT, etc.) just before they are sent to the device.",
            "Step 2: Inspect unit conversions and scaling logic.\n- Locate where the system converts between units (e.g., mireds to kelvin, percentage to 0–255, etc.).\n- Check if floating point results are cast to integers and whether this could cause off-by-one or out-of-range values.\n- Verify formulas that map absolute values (Kelvin) to relative ranges (0–255).",
            "Step 3: Introduce explicit bounds checking (clamping).\n- Identify the device’s supported min and max values (e.g., `self._min_kelvin`, `self._max_kelvin`).\n- After conversion, clamp the value: e.g. `value = min(max_value, max(min_value, converted_value))` depending on the direction.\n- For this pattern, ensure you use the correct bound: use `min` with the max limit to cap upper values, and `max` with the min limit to enforce lower bounds.",
            "Step 4: Correct attribute usage and avoid typos.\n- Double-check that you are referencing `_min_*` and `_max_*` attributes correctly; a swapped min/max will invert logic and create subtle bugs.\n- Add comments explaining why clamping is needed at this point in the code, referencing device behavior if helpful.",
            "Step 5: Add or update tests for edge cases.\n- Create tests for min, max, and mid-range values in the relevant units (e.g., mireds) and assert that the derived Kelvin and relative values are within expected ranges.\n- Include tests where rounding is likely to matter (values just above/below boundaries).",
            "Step 6: Run linters and formatters.\n- Run the project’s standard formatting and linting tools (e.g., `black --fast homeassistant`).\n- Ensure no functional changes are mixed with formatting-only changes in the same commit when possible, or clearly separate them.",
            "Step 7: Validate on real or simulated hardware.\n- If possible, test behavior on actual devices or a simulator to confirm the visual/functional result matches the intended color temperature or brightness.\n- Check logs to ensure no out-of-range values are being sent after the fix."
        ]
    }
}
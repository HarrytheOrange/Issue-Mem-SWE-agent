{
    "search_index": {
        "description_for_embedding": "Extends Home Assistant's Waze Travel Time sensor to support origin/destination specified as entities (device_tracker, zone, sensor), resolves entity locations via Home Assistant location helpers, and adds include/exclude route filters before selecting the optimal route from WazeRouteCalculator.",
        "keywords": [
            "Home Assistant",
            "Waze Travel Time",
            "waze_travel_time.py",
            "device_tracker origin destination",
            "zone origin destination",
            "sensor origin destination",
            "entity-based location",
            "EVENT_HOMEASSISTANT_START",
            "location.has_location",
            "route include filter",
            "route exclude filter",
            "WazeRouteCalculator",
            "homeassistant.components.sensor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The Waze Travel Time sensor in Home Assistant originally only accepted raw latitude/longitude coordinates or free-text addresses for the origin and destination config options. Users wanted to specify these fields using existing Home Assistant entities, particularly device_tracker, zone, and sensor entities (e.g., a GPS sensor or a zone like 'Home'). This pull request refactors the sensor implementation to support entity-based configuration and adds route filtering capabilities.\n\nThe setup flow was changed to delay sensor initialization until Home Assistant has started, by listening for EVENT_HOMEASSISTANT_START. This ensures that the entity registry and state machine are populated before attempting to resolve origin and destination entities.\n\nThe previous design used a separate WazeRouteData helper class that did the API call and stored results. That class was removed, and the logic was folded into the WazeTravelTime entity itself. The entity now stores the raw origin and destination config values, plus optional entity IDs if the config string refers to a trackable domain (device_tracker, sensor, zone).\n\nA new helper method _get_location_from_entity(entity_id) was added. It uses hass.states.get() to retrieve the entity and then:\n- If the entity has latitude/longitude attributes (zone or any entity with location), it builds a 'lat,long' string using ATTR_LATITUDE and ATTR_LONGITUDE.\n- If it's a device_tracker whose state matches a zone entity (zone.<state>), it resolves the zone's coordinates.\n- If it's a sensor.*, it falls back to using the entity's state as the location string (e.g., an address or lat/long stored as text).\n\nAnother helper, _resolve_zone(friendly_name), scans all states for a zone whose friendly_name matches the given string and returns its coordinates; otherwise it returns the original value. This allows users to configure a zone by friendly name as origin/destination.\n\nThe update() method now:\n- Resolves _origin and _destination from entity IDs on each update, if applicable.\n- Resolves zones by friendly name.\n- Calls WazeRouteCalculator.WazeRouteCalculator(origin, destination, region) and calc_all_routes_info() to get all routes.\n- Optionally filters routes using new config fields incl_filter and excl_filter, which are simple substring filters applied (case-insensitively) to route names: include only routes that contain incl_filter, and exclude those that contain excl_filter.\n- Selects the route with the smallest duration using sorted(routes, key=lambda key: routes[key][0])[0].\n- Stores duration, distance, and the decoded route name into self._state.\n\nThe sensor's state is now the rounded duration (in minutes), while additional attributes include duration (raw), distance, route, and attribution. The code defensively handles cases where _state is None or missing fields. Overall, the change solves the limitation of only supporting static coordinates/addresses, adds flexible route selection, and aligns the sensor more closely with other Home Assistant integrations that operate on entity locations.",
        "semantic_memory": "This change illustrates several reusable patterns for integrating external routing/transport APIs with a home automation platform:\n\n1. **Entity-based configuration instead of raw coordinates**: Rather than requiring users to specify lat/long or addresses directly, allow configuration options to accept entity IDs from relevant domains (e.g., device_tracker, zone, sensor). Resolve these entities into a location at runtime. This makes automations more robust and easier to maintain, since location changes are tracked centrally by those entities.\n\n2. **Deferred setup until system is ready**: When an integration depends on other entities being present and having state, defer initialization until the core platform has finished starting. In Home Assistant, this is done via EVENT_HOMEASSISTANT_START. This avoids errors when trying to resolve entities that are not yet registered or initialized.\n\n3. **Centralized location resolution using helpers**: The code uses a generic helper (location.has_location) and a standard pattern to unify how lat/long are obtained from different entity types:\n   - If an entity has location attributes, use them.\n   - If a device_tracker's state indicates it's in a zone, resolve the zone entity and use its location.\n   - If it's a sensor, optionally treat its state as a human-readable location string.\n   This abstraction makes it easier to add new entity types with location semantics in the future.\n\n4. **Flexible output and attributes**: The main sensor state is kept as a single numeric metric (e.g., travel time), while secondary data (route name, raw duration, distance, attribution) is exposed via attributes. The code is defensive: it checks for self._state being None and for the presence of keys before accessing them.\n\n5. **Filtering third-party API results**: When an external API returns multiple options (like multiple routes), it's often desirable to allow user-customizable filtering. Here, simple include/exclude substring filters are used on route names prior to selecting the best route by duration. The pattern is: get the full result set, filter by user criteria, then apply a deterministic selection strategy.\n\n6. **Refactoring to simplify data flow**: Removing a separate data-holder class (WazeRouteData) and folding the logic into the entity reduces indirection. The entity itself becomes responsible for fetching and holding its own data, which often matches how reactive systems like Home Assistant expect entities to behave.\n\n7. **Graceful error handling with logging**: The code catches WRCError from the WazeRouteCalculator and logs meaningful messages, returning early without setting invalid state. It also guards against KeyError when parsing the API response. This pattern ensures the integration fails gracefully and provides diagnostics without crashing the platform.",
        "procedural_memory": [
            "To add entity-based origin/destination support to a travel-time or routing integration that currently only supports raw lat/long or addresses:",
            "Step 1: Extend the configuration schema to continue accepting the existing string fields (origin, destination), but interpret those strings as either literal locations or entity IDs based on a simple heuristic (e.g., presence of a domain prefix like 'device_tracker.', 'zone.', 'sensor.').",
            "Step 2: Define a list of trackable domains (e.g., TRACKABLE_DOMAINS = ['device_tracker', 'sensor', 'zone']) and, in the component's __init__ or setup, check if origin.split('.', 1)[0] and destination.split('.', 1)[0] are in that list. If so, store them as entity IDs (e.g., self._origin_entity_id) instead of static locations.",
            "Step 3: Defer platform setup until the host system is fully initialized if you depend on other entities. In Home Assistant, wrap the sensor creation in a function (run_setup) and register it with hass.bus.listen_once(EVENT_HOMEASSISTANT_START, run_setup). This ensures hass.states and zones are available.",
            "Step 4: Implement a helper method to resolve an entity to a location string at runtime, using the platform's state access APIs. For Home Assistant:\n- Use entity = hass.states.get(entity_id).\n- If entity is None, log an error and return None.\n- If location.has_location(entity) is true, read ATTR_LATITUDE and ATTR_LONGITUDE from entity.attributes and format as 'lat,long'.\n- For device_tracker entities whose state refers to a zone (e.g., 'home'), look up 'zone.<state>' and resolve its attributes similarly.\n- For sensor entities that store a string location, fall back to using entity.state directly.",
            "Step 5: Optionally implement another helper to resolve human-friendly zone names (friendly_name) into coordinates by scanning through hass.states.all() and matching domain == 'zone' and entity.name == friendly_name. Return 'lat,long' using the same attribute helper.",
            "Step 6: In the entity's update() method, before calling the external routing API, resolve _origin and _destination by calling your helpers if you have origin/destination entity IDs. This ensures that each update uses current locations (e.g., for a moving device_tracker). Also apply the zone-friendly-name resolution if needed.",
            "Step 7: Call the external routing API (like WazeRouteCalculator) using the resolved origin and destination. Handle any API-specific exceptions (e.g., WRCError) by logging and returning early without updating state, so the integration fails gracefully.",
            "Step 8: If the API returns multiple options (e.g., multiple routes), and you want to expose route filtering:\n- Add optional config fields like incl_filter and excl_filter.\n- After getting the routes dict, filter it: first keep entries whose key (route name) contains incl_filter (case-insensitive) if incl_filter is set; then remove entries whose key contains excl_filter if excl_filter is set.\n- If any routes remain, select the best one deterministically (e.g., sorted(routes, key=lambda key: routes[key][0])[0] to pick the route with the shortest duration).",
            "Step 9: Store relevant parts of the response in the entity's internal _state dict, such as 'duration', 'distance', and 'route'. Decode any non-UTF-8 route names as needed (e.g., bytes(route, 'ISO-8859-1').decode('UTF-8')).",
            "Step 10: Implement the entity's state and attributes accessors defensively:\n- In state property, return None if self._state is None, otherwise round self._state['duration'] if it exists.\n- In device_state_attributes, always include attribution and then conditionally add duration, distance, and route only if present in self._state. This avoids KeyError and keeps attributes stable.",
            "Step 11: Test with multiple configurations:\n- Raw lat/long origin/destination.\n- Address strings.\n- Origin/destination as device_tracker entities moving between zones.\n- Origin/destination as zone entities and zone friendly names.\n- Sensors containing location strings.\n- Various incl_filter/excl_filter values to confirm routes are filtered and the fastest remaining route is chosen."
        ]
    }
}
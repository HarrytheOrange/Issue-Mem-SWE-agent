{
    "search_index": {
        "description_for_embedding": "Home Assistant logbook view was timing out on large recorder databases because logbook queried and post-filtered all events in Python. The fix moves entity/domain include/exclude filtering into the database query by precomputing the allowed entity_ids using the shared entityfilter helper and adds an index on States.entity_id, drastically speeding up logbook queries and aligning filtering semantics with other components (include overrides exclude).",
        "keywords": [
            "homeassistant",
            "logbook speedup",
            "recorder",
            "database performance",
            "SQLAlchemy",
            "States.entity_id index",
            "entityfilter.generate_filter",
            "include exclude filters",
            "timeout",
            "nginx 504",
            "MariaDB",
            "history/logbook filtering",
            "distinct entity_id",
            "schema_version 7"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant logbook feature was effectively unusable on a user’s setup (AWS free-tier MariaDB, ~40k events/day, 7 days retention). Logbook requests triggered a heavy query that scanned the recorder events and states tables, then applied include/exclude filters in Python after loading the rows. On constrained hardware, this led to very slow responses causing nginx 504 gateway timeouts and the UI showing 'No logbook entries found'.\n\nThe pull request refactors logbook’s filtering pipeline. Instead of blindly loading all events in the time range and then deciding in Python which ones to show, it first computes the set of relevant entity_ids and pushes that filter down into the SQL query:\n\n1. A helper function `_generate_filter_from_config(config)` uses `homeassistant.helpers.entityfilter.generate_filter` to build a callable `entities_filter(entity_id)` based on `include`/`exclude` domains and entities from logbook configuration.\n2. `_get_related_entity_ids(session, entities_filter)` runs a `SELECT DISTINCT states.entity_id` query and filters the results in Python by calling `entities_filter(entity_id)`, yielding only entity_ids that should be included in the logbook.\n3. `_get_events` then queries `Events` joined with `States` and adds `States.entity_id.in_(entity_ids)` to the WHERE clause, so the database only returns rows for relevant entities.\n4. `_exclude_events` is updated to take the entity filter callable instead of a bespoke filter class. For events with no explicit entity_id but a domain, it synthesizes an entity_id stub (`domain.`) to reuse the same filter semantics. If there is no entity_id, the event is always kept.\n\nAdditionally, the recorder schema gains a performance optimization: `States.entity_id` now has its own index, and migration step 7 creates that index. This index is used both by the `DISTINCT entity_id` query and by the entity_id filter in the main logbook query, reducing table and index scans.\n\nUnit tests for logbook filtering are updated to use `_generate_filter_from_config` (and thus the standard entityfilter semantics) instead of the removed custom `DomainsAndEntitiesFilter` class. One test’s expectations change: when both include and exclude are specified, include now wins (consistent with other components), so more events are retained (5 instead of 3 in the test scenario).\n\nThe result is a dramatic speed improvement: logbook requests that previously took minutes (or timed out) now complete in roughly 20–100 ms on the same dataset and hardware, and the logbook becomes usable again. There is a documented breaking change: when both include and exclude domains are configured, excluded domains are ignored in favor of the included domains, matching behavior elsewhere in Home Assistant.",
        "semantic_memory": "This fix illustrates several generalizable patterns for improving performance and consistency in event-log style components:\n\n1. **Push filtering into the database whenever possible**: Applying include/exclude logic in application code after fetching thousands of rows is inefficient and leads to timeouts on slower databases. Instead, use the database engine’s ability to filter rows by adding precise WHERE conditions (e.g., `States.entity_id.in_(...)`). When a user configuration defines which entities are relevant, convert that into a set used directly in the SQL query.\n\n2. **Precompute a focused key set, then filter by that key**: When the filtering criteria are based on high-level config (domains, groups, patterns), it can be more efficient to first compute a set of allowed entity_ids and then use that set to limit all subsequent queries. This is especially effective when the key is indexed (like entity_id) and reused across different queries.\n\n3. **Use shared filter utilities instead of bespoke logic**: Home Assistant has a central `entityfilter.generate_filter` function that encapsulates include/exclude behavior. Reusing such helpers avoids duplication, keeps semantics consistent across components (logbook, history, etc.), and reduces subtle bugs where include/exclude ordering differs.\n\n4. **Index the columns you query and filter on**: If you frequently do `WHERE entity_id IN (...)` or `DISTINCT entity_id`, ensure `entity_id` is indexed. Adding a dedicated index or marking the column as `index=True` in the ORM model can drastically reduce query time on large tables.\n\n5. **Align component configuration semantics**: When multiple components share similar configuration concepts (include/exclude lists), they should behave identically. In this case, the logbook’s behavior when both `include` and `exclude` are specified was adjusted so that excluded domains are ignored if they conflict with included domains, matching other parts of the system.\n\n6. **Handle events without explicit entity_id carefully**: Some events may only have a domain or no entity at all. When reusing entity-based filters, you must define how to treat such events: keep them always, or derive a synthetic key. The fix here ensures non-entity events (like core start/stop) remain visible while still applying entity filters to entity-related events.\n\n7. **Add instrumentation and retry logic around DB access**: Measuring query duration and logging the number of rows processed helps validate performance gains and troubleshoot regressions. Retry loops around transient SQLAlchemy errors (with a backoff) increase robustness for long-running logbook/history queries.\n\n8. **Expect and test behavior changes from refactoring filters**: Changing from custom filter logic to a central helper can slightly change edge-case behavior. Updating unit tests to reflect new, desired semantics both documents the change (like include-over-exclude) and protects against inadvertent future regressions.",
        "procedural_memory": [
            "Step-by-step guide to diagnosing and fixing slow, filter-heavy log or history views in a database-backed application:",
            "Step 1: Confirm the performance problem",
            "- Observe user reports (e.g., HTTP 504 timeouts, very slow page loads) for log/history views.",
            "- Reproduce on a representative environment or dataset. Measure query times and CPU/IO usage while loading the logbook/history.",
            "- Enable debug logging around DB queries if available to see which queries are slow and how many rows are being returned.",
            "Step 2: Inspect the current query and filtering path",
            "- Find the code that retrieves events (or log entries) from the database.",
            "- Check whether filtering (e.g., by entity, domain, user configuration) is done in SQL or in application code after loading the rows.",
            "- Look for patterns like `SELECT *` over large ranges (e.g., one week of events) followed by heavy Python-side filtering.",
            "Step 3: Identify the user-facing filtering configuration",
            "- Locate configuration options that specify what should be included/excluded (e.g., `include`/`exclude` lists of domains or entity IDs).",
            "- Check whether there is an existing shared filter helper in the codebase (like Home Assistant’s `entityfilter.generate_filter`) that other components already use.",
            "- Clarify the intended semantics when both `include` and `exclude` are present (e.g., do includes override excludes?).",
            "Step 4: Build a reusable filter function",
            "- Use or create a helper that converts configuration (included domains/entities and excluded domains/entities) into a single callable, e.g. `entities_filter(entity_id) -> bool`.",
            "- Ensure the helper’s semantics match other parts of the system to avoid surprising behavior.",
            "- Add unit tests for this helper if they do not already exist, covering combinations of include and exclude settings.",
            "Step 5: Precompute the set of allowed keys (e.g., entity_ids)",
            "- Add a function (like `_get_related_entity_ids`) that queries the DB for `SELECT DISTINCT key` (e.g., `entity_id`) from the states table.",
            "- For each row, call the filter function (`entities_filter(entity_id)`) and collect only the keys that pass into a list or set.",
            "- Wrap the query in error handling and retry logic if your environment warrants it (e.g., networked DBs, transient SQL errors).",
            "- Log timing and counts at debug level to verify performance improvements.",
            "Step 6: Push filtering to the database",
            "- Update the main events/logbook query to add a clause like `States.entity_id.in_(entity_ids)` or equivalent on your key column.",
            "- When a specific entity_id is passed from the UI, skip the precomputation and just use that one entity_id in the filter to avoid unnecessary overhead.",
            "- Ensure that the join and WHERE conditions remain correct (e.g., keeping constraints like `States.last_updated == States.last_changed` intact).",
            "Step 7: Ensure database indexes exist for the key column",
            "- Check your ORM model and DB schema to see if the key column (e.g., `States.entity_id`) is indexed.",
            "- If not, add an index (e.g., `entity_id = Column(String(...), index=True)` or an explicit Index) and bump the schema version/migration.",
            "- In migration scripts, create the index in a new version step and handle upgrades safely.",
            "Step 8: Adjust application-level event filtering logic",
            "- Modify any remaining Python-side filtering (e.g., `_exclude_events`) to use the new filter callable instead of custom domain/entity checks.",
            "- Define behavior for events that lack an entity_id but have a domain, if needed: you may synthesize a pseudo entity_id (like `domain.`) or always include them.",
            "- Ensure that non-entity events (system-level events, startup/shutdown, etc.) are treated appropriately and not accidentally filtered out.",
            "Step 9: Update and extend tests",
            "- Update unit tests to use the new filter generator instead of any removed custom classes.",
            "- Adjust expectations where semantics change (e.g., when both include and exclude are provided, include wins).",
            "- Add tests covering events with and without entity_id, and events with hidden/auto attributes or special properties relevant to your domain.",
            "Step 10: Validate performance and behavior",
            "- Re-run the log/history view on the same dataset and environment that exhibited the problem.",
            "- Measure the new query times; confirm that they are within acceptable bounds (e.g., tens of milliseconds instead of minutes).",
            "- Ensure that the visible entries in the UI still match user expectations given the configuration (no important entries missing, no extra noise).",
            "- Monitor logs for SQL errors or retry loops and confirm stability under load.",
            "Step 11: Document breaking or behavior changes",
            "- If filter semantics changed (such as include overriding exclude where previously both applied differently), document this as a breaking change.",
            "- Update component or configuration documentation to explain the new behavior and guide users on how to adjust their configs if needed.",
            "- Communicate performance improvements and any caveats so users on constrained databases (like free-tier cloud DBs) understand the benefits."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fixes a race condition in Home Assistant config entry flows where discovery/ignored flows were visible and could trigger notifications before their initial async step completed. Now flows without a current step are hidden from async_progress, discovery events/notifications are emitted only after initialization completes, and tests for Tradfri and discovery flows are updated to assert on final config entries instead of transient flow states.",
        "keywords": [
            "Home Assistant",
            "config entries",
            "data_entry_flow",
            "async_init",
            "async_progress",
            "config flow",
            "discovery flow",
            "SOURCE_DISCOVERY",
            "SOURCE_IMPORT",
            "SOURCE_UNIGNORE",
            "DISCOVERY_NOTIFICATION_ID",
            "race condition",
            "async initialization",
            "flow.cur_step",
            "flow.init_step",
            "async_post_init",
            "persistent_notification",
            "tradfri",
            "get_gateway_info",
            "mock async function",
            "flaky test",
            "integration tests"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's config entry flows had a UX and consistency problem around async initialization. When a config flow was started from discovery (or similar sources) and its initial step did not return immediately, there was a window where the flow appeared in hass.config_entries.flow.async_progress and discovery notifications could be raised even though the flow had not yet reached a usable state. The user could attempt to interact with a flow that wasn't ready, and the UI could show discovery notifications for flows that would ultimately abort.\n\nThe fix introduced a new pattern: flows are created first, but discovery events/notifications are deferred until after the initial step completes successfully. Specifically:\n\n- In homeassistant/config_entries.py, DISCOVERY_SOURCES was expanded to include SOURCE_UNIGNORE so that 'unignore' flows participate in discovery notification behavior.\n- ConfigEntries.async_create_flow now only constructs the ConfigFlow instance and sets flow.init_step from context[\"source\"]. It no longer immediately issues notifications.\n- A new ConfigEntries.async_post_init method was added, which is called after the first step completes; it is responsible for generating discovery notifications and firing the EVENT_FLOW_DISCOVERED event when appropriate.\n\nOn the data entry flow side:\n\n- In homeassistant/data_entry_flow.py, a new hook async_post_init(self, flow, result) was added to the FlowManager interface.\n- FlowManager.async_progress was changed to filter out flows where flow.cur_step is None, effectively hiding flows that have not completed their first step.\n- FlowManager.async_init records the flow into the _progress dict, runs the initial step, and then, if the result is not an abort, calls async_post_init(flow, result) before returning the result.\n\nA new test, test_partial_flows_hidden, was added in tests/test_config_entries.py to verify this behavior. It defines a TestFlow whose async_step_discovery waits on an asyncio.Event, simulating a blocked network operation. While the step is blocked, the test asserts that async_progress returns no flows and that no persistent notification for DISCOVERY_NOTIFICATION_ID exists. After unblocking, it checks that the flow becomes visible and the discovery notification is created.\n\nThese changes exposed a latent issue in the Tradfri tests. Previously, tests relied on seeing a flow in async_progress after importing configuration from JSON, and get_gateway_info was mocked as a simple function instead of an awaitable coroutine. Under the old behavior, this left a broken but present config flow in async_progress, so the tests passed despite the flawed mock. With the revised flow logic (hiding uninitialized flows and requiring the init step to complete), the tests started failing, revealing the underlying mocking bug.\n\nTo fix this:\n\n- A shared pytest fixture mock_entry_setup was moved into tests/components/tradfri/conftest.py; it patches homeassistant.components.tradfri.async_setup_entry to return an awaitable (mock_coro(True)).\n- The existing mock_entry_setup fixture in tests/components/tradfri/test_config_flow.py was removed in favor of the shared one.\n- In tests/components/tradfri/test_init.py, test_config_json_host_imported was updated. Instead of asserting that a flow exists in async_progress, it now:\n  - Mocks get_gateway_info to be an async coroutine (via mock_coro) returning a dict with host, identity, key, and gateway_id.\n  - Sets up the component with a JSON config.\n  - Asserts that async_setup_entry was called and inspects the created MockConfigEntry, checking that its domain is tradfri, source is import, and title matches the host.\n\nThis PR thus both corrects the race in exposing partially initialized flows and makes the Tradfri tests robust by using proper async mocks and asserting on final config entries instead of transient flow progress.",
        "semantic_memory": "This case illustrates several general principles about async initialization, user-facing state, and testing:\n\n1. **Avoid exposing partially initialized async flows to users.** When an async workflow (e.g., a configuration or onboarding wizard) performs I/O or other delayed work in its initial step, there is a risk of exposing intermediate state. If a flow is visible in 'in progress' lists, or generates notifications/events, before it reaches a stable step (e.g., a form or entry creation), users can interact with flows that are not ready and may ultimately abort. A more robust pattern is to only expose flows that have a current, meaningful step (cur_step) and to delay user-visible events until after initial async steps complete.\n\n2. **Separate flow creation from post-init side effects.** The fix introduces async_post_init, a hook that runs after the first step's result is known. This cleanly separates instantiation of the FlowHandler from the side effects (notifications, events) that depend on the first step succeeding. This pattern is generally useful: create objects first, then perform side-effectful registration or UI notifications once the object is actually ready.\n\n3. **Use explicit state guards in async progress reporting.** The change to async_progress to filter flows on flow.cur_step is a concrete example of using state indicators to gate visibility. In any async manager that exposes a list of tasks/flows, it is wise to filter on a 'ready' flag or state rather than assuming that tasks immediately reach a usable stage after creation.\n\n4. **Design tests to assert on final stable outcomes, not internal transient states.** The original Tradfri tests asserted that config flows appeared in async_progress, which is an internal and transient representation. When the internal behavior changed (partial flows now hidden), these tests broke and were revealed to be relying on incorrect assumptions. A better strategy is to assert on final artifacts (e.g., a created config entry, a persistent notification, or a domain state) whenever possible. This makes tests more robust to internal refactors and reduces false positives.\n\n5. **Mock async functions as coroutines, not plain callables.** The Tradfri get_gateway_info mock was originally not awaitable, leaving a flow in a broken state but appearing as if it existed. In async frameworks, any function awaited in production must be mocked with an awaitable (e.g., async def, or a helper like mock_coro) in tests. Otherwise, you risk subtle behavior differences, hangs, or false positives where flows appear to exist but cannot progress correctly.\n\n6. **Flaky tests can reveal hidden design issues or incorrect assumptions.** The mention of 'meh flaky tests' was the entry point: a seemingly flaky test was actually incorrect. When tests start failing only under certain timing or refactor conditions, it can indicate race conditions or that tests rely on side effects that are not guaranteed.\n\n7. **Handle new sources of flows consistently.** Adding SOURCE_UNIGNORE to DISCOVERY_SOURCES ensures that flows created by 'unignore' actions share the same discovery notification behavior and post-init handling as other discovery sources. This is a reminder to keep enumerations of sources or event types in sync with new UX features.\n\nOverall, the fix embodies a best practice for async, user-facing workflows: hide them until they have a defined step, signal readiness via a clear lifecycle hook, and ensure tests interact with them via stable, public-facing behavior rather than internal states.",
        "procedural_memory": [
            "Diagnosing and fixing issues with partially initialized async config flows and flaky tests in an async, event-driven system:",
            "Step 1: Identify symptoms of race conditions or partial state exposure",
            "  - Observe reports of users interacting with flows that fail or are not fully ready (e.g., clicking a discovered device that then aborts).",
            "  - Look for discovery notifications or events fired for flows that ultimately abort.",
            "  - Investigate flaky tests that assert on flow progress or discovery behavior and fail intermittently or after unrelated refactors.",
            "Step 2: Inspect flow lifecycle and state representation",
            "  - Review the FlowManager (or equivalent) responsible for creating and managing flows (e.g., data_entry_flow.FlowManager.async_init, async_progress).",
            "  - Check what state flags are available on flows (e.g., cur_step, init_step, context) and when they are set.",
            "  - Determine when user-visible artifacts (notifications, events, UI lists) are generated relative to the initial async steps.",
            "Step 3: Introduce separation between flow creation and post-init side effects",
            "  - Refactor flow creation to only instantiate and register the flow object (e.g., set flow.init_step and store it in _progress) without immediately emitting notifications or events.",
            "  - Add a post-init hook (e.g., async_post_init(self, flow, result)) that is called after the initial step returns.",
            "  - Inside async_init, run the initial step (await _async_handle_step) to get a result, and then conditionally call async_post_init if the result is not an abort.",
            "Step 4: Guard visibility of flows based on readiness",
            "  - Modify the method that reports in-progress flows (e.g., async_progress) to filter only flows that are in a meaningful state, such as having cur_step set.",
            "  - This ensures that flows stuck before the first step completes are not exposed to the user or to other parts of the system.",
            "Step 5: Move notifications and discovery events to post-init",
            "  - If there are discovery notifications or events (e.g., persistent_notification.create, EVENT_FLOW_DISCOVERED) currently triggered at flow creation time, move them into the post-init hook.",
            "  - Use the flow's context or source (e.g., SOURCE_DISCOVERY, SOURCE_IMPORT, SOURCE_UNIGNORE) to determine whether and how to notify the user.",
            "Step 6: Update tests to reflect the new lifecycle",
            "  - Add tests that simulate a slow or blocked first step using asyncio.Event or similar to control timing.",
            "  - Assert that while the first step is blocked, async_progress returns no flows and no notifications or events are emitted.",
            "  - After unblocking, assert that flows appear in async_progress and that expected notifications/events are present.",
            "Step 7: Fix async mocks to be proper coroutines",
            "  - Audit tests that mock functions called with await (e.g., get_gateway_info). Ensure they return awaitable coroutines (using async def or helpers like mock_coro).",
            "  - Replace plain function or MagicMock returns with mock_coro(...) to match real async behavior.",
            "Step 8: Prefer assertions on final outcomes over internal states",
            "  - Where tests currently assert on the presence of a flow in async_progress, consider asserting instead on the creation of a config entry, the call to async_setup_entry, or the presence of a persistent_notification/state change.",
            "  - For example, after triggering an import config flow, assert that async_setup_entry was called and inspect the created entry (domain, source, title) rather than inspecting async_progress.",
            "Step 9: Keep source enumerations in sync with UX features",
            "  - When adding new ways to create flows (e.g., 'unignore'), ensure any source lists that drive behavior (DISCOVERY_SOURCES, etc.) are updated so that all relevant flows share consistent treatment.",
            "Step 10: Re-run tests and watch for regressions",
            "  - Run the full test suite (e.g., tox) to ensure that the new lifecycle and tests pass and that flaky tests are stabilized.",
            "  - Monitor future PRs for tests that reintroduce reliance on transient internal states, and steer them toward stable, public-facing assertions."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor napari ViewerModel key bindings to avoid binding anonymous or wrapper functions. Instead of decorating small, locally-defined functions that call into viewer.dims or viewer.layers, the keybinding system now binds existing ViewerModel and sub-object methods directly. This enables using function identity for an upcoming action manager, allowing better synchronization of shortcuts, menus, and tooltips.",
        "keywords": [
            "napari",
            "ViewerModel",
            "key bindings",
            "keyboard shortcuts",
            "action manager",
            "anonymous functions",
            "wrapper functions",
            "function identity",
            "dims",
            "layers",
            "method binding",
            "decorator"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the napari project adjusted how keyboard shortcuts are bound to viewer actions. Previously, the file `napari/components/_viewer_key_bindings.py` declared many small wrapper functions decorated with `@ViewerModel.bind_key(...)`. Each wrapper accepted a `viewer` argument and simply forwarded the call to a method on `viewer.dims`, `viewer.layers`, or `viewer` itself (e.g., incrementing dimensions, selecting layers, resetting view). While this worked, it created an extra layer of anonymous or semi-anonymous wrapper functions that obscured the true action being triggered.\n\nAs the project started designing a more powerful action manager that needs to synchronize shortcuts with menu items, UI buttons, and tooltips, it became important that each bound action have a stable, meaningful function identity. With the wrapper approach, the identity was the wrapper function, not the underlying model method, making it harder to map actions across different UI elements and introspect them.\n\nThe fix removed these standalone wrapper functions and instead directly bound the existing methods on `ViewerModel` and its sub-objects. For example, instead of:\n\n- Defining `increment_dims_left(viewer)` calling `viewer.dims._increment_dims_left()` and decorating it with `@ViewerModel.bind_key('Left')`,\n\nit now uses:\n\n- `ViewerModel.bind_key('Left')(ViewerModel.dims._increment_dims_left)`.\n\nSimilar refactors were applied to keys such as 'Right', 'Alt-Up', 'Alt-Down', 'Control-E', 'Control-T', 'Control-A', 'Up', 'Down', 'Control-R', and 'V', binding them directly to methods like `ViewerModel.dims._increment_dims_right`, `ViewerModel.dims._focus_up`, `ViewerModel.layers.select_all`, `ViewerModel.layers.select_next`, `ViewerModel.reset_view`, and `ViewerModel.layers.toggle_selected_visibility`.\n\nSome bindings (like layer removal and grid toggling) still use explicit functions where necessary, but the overall pattern now prefers existing model methods as the bound callables. This refactor prepares the codebase for the future action manager by ensuring that the function identity corresponds directly to meaningful, reusable methods on the core models.",
        "semantic_memory": "When building a keyboard shortcut or action management system, it is beneficial to bind actions directly to stable, named methods on your domain models rather than to anonymous or ad-hoc wrapper functions. Using wrapper functions obscures the logical identity of the action, making it harder to:\n\n- Synchronize actions across different UI surfaces (shortcuts, menus, toolbar buttons).\n- Introspect actions for generating tooltips, labels, or documentation.\n- Maintain a one-to-one mapping between high-level user actions and underlying business logic.\n\nBy binding existing methods (e.g., methods on a `ViewerModel`, `dims`, or `layers` object) directly into the keybinding or action system, the function identity naturally becomes a meaningful, reusable identifier. This simplifies any higher-level \"action manager\" or command palette that needs to answer questions like \"what does this shortcut do?\" or \"where else is this action used?\".\n\nMore generally, avoid unnecessary indirection in event-driven or callback-based architectures when you expect to:\n\n- Track, catalog, or serialize actions.\n- Update UI to reflect changes in the action (name, tooltip, availability).\n- Share the same action across multiple triggers.\n\nInstead, keep the binding layer as thin as possible by referencing the underlying methods directly, and only use wrapper functions when there is a real need for extra logic or argument adaptation that cannot be handled otherwise.",
        "procedural_memory": [
            "When a keyboard shortcut or action manager relies on function identity (for lookup, synchronization, or introspection), prefer binding core model methods directly instead of anonymous or wrapper functions.",
            "Step 1: Identify wrapper functions in your keybinding or action-registration code. These are typically small functions decorated with something like `@Model.bind_key(...)` that merely call another method on `self` or a related object.",
            "Step 2: Verify that the underlying called method (e.g., `viewer.dims._increment_dims_left`, `viewer.layers.select_all`, `viewer.reset_view`) has the correct signature and semantics to be used directly as the action. Ensure any required context (e.g., viewer instance) will still be available when the keybinding triggers.",
            "Step 3: Replace the wrapper function + decorator pattern with a direct binding of the underlying method. For example, change:\n- `@Model.bind_key('K')\\n def some_action(viewer): viewer.something()`\n  to\n- `Model.bind_key('K')(Model.something)`\n(or the appropriate attribute/method path, e.g. `Model.layers.select_all`).",
            "Step 4: Remove the now-unused wrapper functions to reduce indirection and simplify the code. Confirm that any references to those wrapper functions elsewhere in the codebase are updated or removed.",
            "Step 5: Run tests or manual checks to ensure key bindings still work as expected. Verify that shortcuts still trigger the correct behavior and that no methods require extra arguments that the direct binding no longer supplies.",
            "Step 6: If your action manager or UI tooling uses function identity to generate menus or tooltips, confirm that you can now see the model methods directly in those registries. Use this to drive synchronization of labels, icons, and tooltips across shortcuts, menus, and toolbars.",
            "Step 7: For cases where direct method binding is not possible (e.g., you must adapt arguments or combine several operations), keep a wrapper functionâ€”but document it clearly and consider whether the combined logic itself should be promoted to a named method on a model class for consistency."
        ]
    }
}
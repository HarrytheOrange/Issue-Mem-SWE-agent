{
    "search_index": {
        "description_for_embedding": "Fix for subtle pixel shift when transitioning between multiscale image levels in napari's experimental octree renderer, caused by computing chunk geometry from per-level tile data instead of the base image. Geometry is now derived from the base image size so edge/corner tiles align exactly. Also fixes a JSON config merge bug where numeric keys were incorrectly kept as strings.",
        "keywords": [
            "pixel shift",
            "multiscale",
            "octree",
            "tile grid",
            "DZI",
            "overlap",
            "napari",
            "texture_atlas",
            "octree_level",
            "chunk geometry",
            "JSON config",
            "int key cast",
            "experimental rendering"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari's experimental octree-based image rendering showed a subtle 1–2 pixel shift when transitioning between lower- and higher-resolution levels (visible when zooming, e.g., DZI datasets via the napari-dzi-zarr plugin). Users saw objects 'jump' slightly as new tiles from a finer level were drawn. Investigation showed that while the DZI plugin had its own bug handling tile overlaps (fixed in a separate repo), napari's core experimental renderer also had an internal inconsistency: chunk geometry (position and size) for rendering was derived from the actual tile data shape and a scale factor, rather than from the logical base image geometry. For edge/corner tiles, which can be smaller due to non power-of-two dimensions or overlap trimming, this led to slight mismatches in the world-space extent of chunks between levels, manifesting as pixel shifts when blending levels.\n\nThe fix refactored how chunk geometry is represented and computed. The OctreeChunkGeom no longer stores a 'scale' vector and no longer derives size from data.shape * scale. Instead, it stores the actual world-space size directly (pos, size). octree_level._create_chunk now computes the chunk's position from the tile grid (row/col * scaled tile size) and computes the chunk's size using the base image's shape as the source of truth: it takes the remaining width/height in base image pixels from the current position and clamps to the nominal scaled tile size. This ensures edge and corner tiles align exactly with the base image extent, regardless of how big their underlying tile data array is. The visual code (texture_atlas and tile_grid) was updated to use geom.size directly instead of recomputing width/height from data.shape and scale. Texture coordinates are still precomputed for full-size tiles and computed on the fly for edge/corner tiles.\n\nAdditionally, there was a smaller bug in the experimental chunking configuration merging logic. When merging configs loaded from JSON, the keys (which should be integers) were left as strings, leading to inconsistent types and lookup issues. The merge function was updated to cast the keys back to int: {int(key): merge(config) for (key, config) in configs.items()}. A temporary debug print of data.shape added during investigation was removed before finalizing the patch.\n\nAfter these changes (and the separate DZI overlap fix in the plugin), the pixel shift between levels disappeared, and chunk outlines and textures aligned perfectly across levels.",
        "semantic_memory": "This case highlights several generalizable lessons in multiscale tiled rendering and configuration handling:\n\n1. **Derive geometry from the logical space, not from raw tile data.**\n   In multiresolution / tiled rendering (e.g., octrees, pyramids, DZI, DeepZoom), the authoritative definition of where a tile should appear is the logical image grid at a given level, not the actual array shape of the tile data. Edge and corner tiles are often smaller than the standard tile size due to non power-of-two image dimensions, overlap trimming, or encoder quirks. If you compute world-space extents from tile data shapes, you'll get off-by-one or sub-tile misalignments between levels and tiles, producing visible jitter or pixel shifts during transitions.\n\n2. **Edge/corner tiles require special handling.**\n   In tile pyramids, interior tiles are consistent and full-size, but edges and corners are partial tiles. Overlaps (like DZI's Overlap parameter) complicate this further—some sides have duplicated border pixels to avoid visual cracks. Rendering logic must compute geometry and texture coordinates for these tiles based on their grid position relative to the base image and overlap rules, not assuming a full standard tile.\n\n3. **Keep geometry and texture coordinates conceptually separate.**\n   A stable design is to:\n   - Compute chunk geometry (position + size) purely in world/image coordinates from the logical grid and base image dimensions.\n   - Compute texture coordinates from the tile's own data shape and overlap rules.\n   This separation reduces coupling and prevents data-dependent geometry glitches.\n\n4. **Type fidelity when round-tripping configuration through JSON.**\n   JSON has no integer-keyed object type; keys are always strings. When loading JSON into a configuration structure that semantically uses integer keys (e.g., IDs, indices, pool_sizes keyed by int), you must cast keys back to ints explicitly. Otherwise, lookups and merges that expect ints will silently fail or produce parallel dict entries with '1' vs 1.\n\n5. **Debugging visual misalignment benefits from exporting intermediate representations.**\n   To debug visual pixel shifts, it is useful to export raw tile data as images and overlay them in external tools (e.g., Photoshop) to verify whether misalignment is inherent to the data or caused by the renderer. That distinction guided the decision here: a plugin-level issue with overlaps versus a core geometry miscalculation.\n\n6. **Multiscale transitions are sensitive to sub-pixel differences.**\n   Even a one-pixel mismatch between levels can be perceptually obvious during zoom transitions, particularly in scientific or pathology imaging. Therefore, coordinate calculations must be consistent across levels and avoid accumulating rounding errors or data-shape-based shortcuts.\n\nThese principles apply broadly to any multi-resolution tiled visualization system (web map engines, large slide viewers, 3D/2D octree renderers) and to configuration systems that serialize to/from JSON.",
        "procedural_memory": [
            "When diagnosing and fixing pixel-shift or tile-alignment issues in multiscale tiled rendering, follow these steps:",
            "Step 1: Reproduce and characterize the alignment problem.\n- Observe the behavior during zooming or level transitions.\n- Note whether the scene appears to 'jump' or tiles appear to jiggle as new levels load.\n- Try toggling off level blending (if possible) to inspect the alignment of individual levels.",
            "Step 2: Determine if the misalignment is in the data or in the renderer.\n- Export tiles from two adjacent levels (e.g., L and L+1) as PNGs for a corresponding region.\n- Upscale the higher-level tile (e.g., 2x for one level difference) and overlay it on top of the lower-level tile in an image editor.\n- If the mismatch is visible in the exported images, it is likely inherent to the data or its pyramid generation.\n- If the exported images align perfectly but the viewer shows a shift, the bug is in the rendering code (geometry, texture coords, or overlap handling).",
            "Step 3: Inspect how tile geometry (position/size) is computed.\n- Find the code where each tile/chunk's world-space position and size are determined (e.g., OctreeChunkGeom, tile_grid, renderer layer logic).\n- Check if position/size is derived from:\n  - The logical tile grid: row/col indices, tile size per level, and base image dimensions.\n  - Or from tile.data.shape multiplied by some scale factor.\n- If geometry depends directly on tile.data.shape, especially for edge/corner tiles, consider this a red flag.",
            "Step 4: Make the base image and grid the single source of truth for geometry.\n- Compute chunk position purely from grid indices and per-level scale:\n  - pos_x = col * (tile_size * scale)\n  - pos_y = row * (tile_size * scale)\n- Compute chunk size from the base image extent:\n  - base_size = np.array(base_shape[::-1])  # width, height\n  - remain = base_size - pos\n  - size = np.minimum(remain, [scaled_tile_size, scaled_tile_size])\n- Store geometry as (pos, size) rather than (pos, scale) so rendering code does not need to recompute size from data.",
            "Step 5: Update rendering code to consume geometry directly.\n- Change any code that uses data.shape * scale to determine width/height.\n- Instead, use the size maintained in the geometry object (e.g., geom.size).\n- For outlines, hit-testing, and quad generation, always use geom.size and geom.pos.",
            "Step 6: Treat texture coordinates separately, especially for edge and corner tiles.\n- Precompute texture coordinates for full-size tiles where possible.\n- When a tile's data.shape is smaller than the nominal tile spec, compute texture coordinates on-the-fly based on the data shape and overlap rules.\n- Do not alter world-space geometry based on data shape; only adjust texture coordinates.",
            "Step 7: Verify DZI or other format-specific overlap handling.\n- Review the image pyramid format specification (e.g., DZI Overlap parameter).\n- Confirm that overlap behavior is defined per edge of a tile, not just by tile size.\n- Ensure that trimming of overlaps when converting to another storage (e.g., zarr) is implemented based on tile position (inner vs edge vs corner), not based solely on array dimensions.",
            "Step 8: Ensure configuration key types are correct after JSON round-trip.\n- For config structures that use integer keys (e.g., pool group IDs, level indices), check the merge logic after loading from JSON.\n- If you see keys as strings ('0', '1', '2'), explicitly cast them back to integers:\n  - merged = {int(key): merge(config) for key, config in configs.items()}\n- Verify all consumers expect the same key type (int) to avoid subtle mismatches or missed lookups.",
            "Step 9: Remove temporary debug prints and add targeted tests.\n- Remove ad-hoc debugging output (like print(data.shape)) before merging.\n- Add tests that:\n  - Construct a base image with non power-of-two dimensions.\n  - Build multiple levels of tiles, including edge/corner tiles.\n  - Verify that chunk positions and sizes across levels cover the same world-space region without gaps or overlaps.\n  - Optionally, test that tile outlines from adjacent levels coincide within one pixel or less.",
            "Step 10: Re-test visually with problematic datasets.\n- Reopen the original datasets that exhibited pixel shifts (e.g., DZI pyramids, pathology slides).\n- Perform slow zoom sweeps through the levels and watch for any residual jitter.\n- Compare before/after behavior where possible to confirm the fix is effective."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant light groups incorrectly forwarding color temperature commands to member lights that do not support color temperature. The group now splits the command: true color temperature is sent only to CT-capable lights, while CT is emulated via HS color for non-CT lights based on the requested color temperature.",
        "keywords": [
            "Home Assistant",
            "light group",
            "color temperature",
            "SUPPORT_COLOR_TEMP",
            "ATTR_COLOR_TEMP",
            "ATTR_HS_COLOR",
            "group.light",
            "feature aggregation bug",
            "Hue lights",
            "capability emulation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's light group platform aggregated the capabilities of all member lights and exposed a superset of features. This caused a subtle bug: when a user set a color temperature on the grouped light entity, the resulting service call forwarded ATTR_COLOR_TEMP to every member light, including those that did not support color temperature (SUPPORT_COLOR_TEMP). For example, some Hue or other non-CT lights received a 'ct' command they couldn't properly handle, leading to incorrect behavior.\n\nThe first attempted fix modified the Hue integration to emulate color temperature on non-CT Hue bulbs by converting a default 'white' HS color to XY and sending that when a CT command was received. This approach was reverted because the problem belonged in the light group logic, not in a specific platform.\n\nThe final fix was implemented in `homeassistant/components/group/light.py` within `async_turn_on`. When a color temperature is requested for a light group, the code now:\n- Builds the normal service data including `ATTR_ENTITY_ID` and `ATTR_COLOR_TEMP`.\n- Iterates over member entity IDs, inspects their current state, and reads `ATTR_SUPPORTED_FEATURES`.\n- Separates entity IDs into two sets: those that support `SUPPORT_COLOR_TEMP` and those that do not.\n- For CT-capable lights, it keeps `ATTR_COLOR_TEMP` in the service data and removes non-CT lights from that `ATTR_ENTITY_ID` list.\n- For non-CT lights, it creates a second service call where it emulates CT by converting the requested mired value to Kelvin, then to HS (`color_temperature_mired_to_kelvin` → `color_temperature_to_hs`), puts that in `ATTR_HS_COLOR`, and removes `ATTR_COLOR_TEMP` from that payload.\n- It then issues both service calls concurrently with `asyncio.gather`: one call with real CT for CT-capable lights, and one call with HS emulation for non-CT lights.\n\nAdditional safety was added to handle missing state objects before checking supported features. A new test `test_emulated_color_temp_group` verifies that:\n- A fully CT-capable light in a group receives and exposes `color_temp`.\n- A non-CT light receives only HS-based emulation of the requested temperature.\n\nA small typo in a comment in the Google Assistant trait (`Kevin` → `Kelvin`) was also fixed.",
        "semantic_memory": "This fix illustrates several generalizable patterns and best practices for systems that aggregate heterogeneous devices:\n\n1. **Do not blindly forward aggregated capabilities**: When a group or composite entity exposes the logical union of member capabilities, it must still ensure that per-device commands are compatible with each member's actual feature set. The presence of a feature at the group level does not imply all members support it.\n\n2. **Capability-aware command routing**: Before sending a command that uses a specific capability (e.g., color temperature), query each target device's supported features and split the command as needed:\n   - Devices that support the feature receive the native command.\n   - Devices that do not support it either skip the feature or use an emulation/approximation.\n\n3. **Feature emulation via color space conversion**: Color temperature can be approximated for non-CT lights by converting the requested temperature to an HS (or RGB) color using shared color utility functions. This allows a consistent user experience even when hardware differs.\n\n4. **Service call fan-out with per-subset payloads**: A single logical user action (\"set this group to color temperature X\") may need to become multiple service calls with different payloads, each targeting a subset of devices. Concurrency primitives (like `asyncio.gather`) can keep overall latency low.\n\n5. **Use platform-agnostic fixes when possible**: The bug initially appeared in the Hue integration but was actually caused by generic light group behavior. Fixing it in the grouping logic benefits all integrations and avoids platform-specific hacks.\n\n6. **Rely on standardized capability flags**: Using standardized flags such as `ATTR_SUPPORTED_FEATURES` and constants like `SUPPORT_COLOR_TEMP` enables generic logic that works across many different light platforms.\n\n7. **Testing grouped behavior explicitly**: When capabilities are aggregated (groups, scenes, composites, bridges), tests should cover combinations of devices with different capabilities to ensure no subset is mis-handled.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and narrow down the problem\n- Trigger the behavior through the highest-level entity (e.g., a light group) that users interact with.\n- Observe which member devices behave incorrectly (e.g., non-CT lights reacting badly to color temperature changes).\n- Confirm whether the problem only appears when using grouped/aggregated entities and not when controlling devices individually.",
            "Step 2: Inspect capability aggregation and command forwarding\n- Locate the code responsible for aggregating capabilities for the group (e.g., group.light deriving supported_features).\n- Inspect the method that forwards user commands from the group to member entities (e.g., `async_turn_on`).\n- Check whether the code forwards all attributes (like `ATTR_COLOR_TEMP`) to all members without checking each member’s supported features.",
            "Step 3: Use supported feature flags to segment targets\n- For each entity in the group, obtain its current state from the state registry.\n- Read `ATTR_SUPPORTED_FEATURES` (or equivalent) from the entity’s attributes.\n- Derive booleans like `supports_color_temp = supported_features & SUPPORT_COLOR_TEMP != 0`.\n- Separate entity IDs into subsets based on whether they support a given feature (e.g., CT-capable vs non-CT).",
            "Step 4: Build per-subset service payloads\n- Start with the original service data payload based on the user’s call.\n- For the subset that supports the feature, keep the original feature attribute (e.g., `ATTR_COLOR_TEMP`) and restrict `ATTR_ENTITY_ID` to only that subset.\n- For the subset that does not support the feature:\n  - Decide whether to drop the unsupported attribute entirely or emulate it.\n  - If emulating color temperature, convert mired → Kelvin → HS using shared utilities (e.g., `color_temperature_mired_to_kelvin`, then `color_temperature_to_hs`).\n  - Add the emulated attribute (e.g., `ATTR_HS_COLOR`) and remove the unsupported one (`ATTR_COLOR_TEMP`) from this payload.\n- Always create separate payloads for each subset with different capabilities.",
            "Step 5: Dispatch multiple service calls appropriately\n- Use asynchronous concurrency constructs (`asyncio.gather` or equivalent) to fire multiple service calls in parallel for the different subsets.\n- Ensure each call is properly scoped with its own `ATTR_ENTITY_ID` list and feature attributes.\n- Maintain the original blocking/awaiting semantics so higher-level logic sees a consistent completion point.",
            "Step 6: Add guards and edge-case handling\n- Guard against missing or `None` states when reading `ATTR_SUPPORTED_FEATURES` to avoid crashes.\n- Handle empty subsets gracefully: if there are no emulation-required entities, default to a single service call.\n- Consider what should happen if all entities lack a given feature (e.g., only emulate, or reject the command).",
            "Step 7: Write and refine automated tests\n- Create tests that define a group containing a mix of devices with and without the capability (e.g., some lights with `SUPPORT_COLOR_TEMP`, some without).\n- Simulate supported_features in the test states explicitly.\n- Issue a command that uses the contested feature (e.g., `color_temp` on the group) and then assert:\n  - CT-capable lights ended up with appropriate `color_temp` attributes.\n  - Non-CT lights did not receive unsupported attributes but received emulated attributes instead (e.g., `hs_color`).\n  - No exceptions were raised and all target entities reached the expected state (`on`, correct brightness, etc.).",
            "Step 8: Prefer generic fixes over platform-specific hacks\n- If the bug appears in a specific integration (Hue, Zigbee, etc.) but the root cause is in a generic grouping or orchestration layer, move the fix into the generic layer.\n- Remove or avoid platform-specific emulation logic if the generic layer can handle it based on feature flags.\n- Document in commit messages or code comments that the fix is generic and not tied to a single hardware platform.",
            "Step 9: Validate user-facing behavior and documentation\n- Confirm that from the user’s perspective, setting color temperature on a group yields consistent appearance across lights, even if some are emulating.\n- Ensure documentation (e.g., integration docs, release notes) accurately describes that non-CT lights in groups will approximate color temperature via color changes rather than true CT control."
        ]
    }
}
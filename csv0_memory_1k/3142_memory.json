{
    "search_index": {
        "description_for_embedding": "Introduced schema-based validation for trigger parameters and payloads in StackStorm, covering both system and user-defined triggers. Validation is performed when creating rules and when dispatching triggers from sensors/webhooks, controlled by new config flags `system.validate_trigger_parameters` and `system.validate_trigger_payload`. Legacy behavior is preserved by default (validation off) while adding tests and updating internal trigger schemas.",
        "keywords": [
            "StackStorm",
            "trigger validation",
            "payload_schema",
            "parameters_schema",
            "system.validate_trigger_parameters",
            "system.validate_trigger_payload",
            "sensor_wrapper",
            "validate_trigger_payload",
            "validate_trigger_parameters",
            "jsonschema",
            "rule creation",
            "backwards compatibility",
            "feature flag",
            "schema validation",
            "DDoS mitigation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "Previously, StackStorm only validated parameters for built-in system triggers (like webhook and timer) and performed no validation for trigger payloads at all. This led to poor UX (silent failures, hard-to-debug rules) and potential security / resource issues (e.g., arbitrarily large or malformed payloads). Additionally, user-defined triggers with `parameters_schema` and `payload_schema` were effectively ignored at runtime.\n\nThis pull request introduced two major improvements:\n\n1. **Trigger parameter validation for non-system triggers:**\n   - Extended `st2common.validators.api.reactor.validate_trigger_parameters` so it handles both system and user-defined triggers.\n   - For system triggers, it still uses `SYSTEM_TRIGGER_TYPES[trigger_type_ref]['parameters_schema']`.\n   - For non-system triggers, it now looks up the corresponding TriggerType in the DB via `triggers.get_trigger_type_db(trigger_type_ref)` and uses its `parameters_schema` if present.\n   - If the trigger doesn't exist in the DB or has no `parameters_schema`, validation is skipped (returns `None`).\n   - To maintain backward compatibility, validation for non-system triggers is gated behind a new config option `system.validate_trigger_parameters` (default `False`). Only when it is enabled do user-defined triggers get parameter validation, and if validation fails, rule creation fails.\n   - Additional tests were added in `st2api/tests/unit/controllers/v1/test_rules.py` together with new fixtures (`triggertype_with_parameters_2.yaml`, `rule_invalid_trigger_parameter_type.yaml`, `rule_trigger_with_no_parameters.yaml`) to verify:\n     * Invalid types are rejected when validation is enabled.\n     * The same invalid rule passes when validation is disabled.\n     * Rules with extra parameters on triggers that do not declare a schema are accepted (no schema → no validation).\n\n2. **Trigger payload validation for system and user-defined triggers:**\n   - A new function `validate_trigger_payload(trigger_type_ref, payload)` was introduced in `st2common/validators/api/reactor.py`.\n   - For system triggers, it uses `SYSTEM_TRIGGER_TYPES[trigger_type_ref]['payload_schema']`.\n   - For non-system triggers, it fetches the TriggerType from the DB and, if present, uses `payload_schema`.\n   - If no TriggerType or no `payload_schema` is found, validation is skipped.\n   - This validation is gated behind a separate config option `system.validate_trigger_payload` (default `False`). When disabled, validation is skipped for non-system triggers; when enabled, invalid payloads cause dispatch to be aborted.\n\n3. **Sensor dispatch behavior updated to use central validation:**\n   - Previously, `SensorService` implemented its own manual, recursive payload type-checking in `sensor_wrapper.py`. That custom validator was removed to avoid duplication and inconsistency.\n   - `SensorService.dispatch_with_context` now calls `validate_trigger_payload(trigger_type_ref=trigger, payload=payload)` and catches `jsonschema.ValidationError` and any other exception.\n   - If validation throws and `system.validate_trigger_payload` is `True`, the sensor logs a warning and **does not dispatch** the trigger. If validation is disabled, it logs the error but continues to dispatch, preserving old behavior.\n   - This guarantees that system and user-defined triggers share a single, consistent validation path.\n   - Old configuration `sensorcontainer.permit_invalid_payload` was removed from `st2reactor/st2reactor/sensor/config.py` and the corresponding logic was replaced with the global `system.validate_trigger_payload` flag.\n   - Sensor behavior was thoroughly tested in `st2reactor/tests/unit/test_sensor_service.py` with mocked TriggerTypes and various payloads (wrong type, missing required fields, extra fields, multiple allowed types via `anyOf`, null values, no schema, trigger not in DB). Tests confirm that:\n     * When validation is enabled and payload is invalid, dispatch is suppressed.\n     * When validation is disabled, even invalid payloads are dispatched.\n     * Triggers without schemas or absent in DB are never blocked.\n\n4. **Internal trigger schemas updated:**\n   - Several built-in trigger payload schemas were updated in `st2common/constants/triggers.py` to match actual runtime payloads, including `runner_ref`, `route`, and `action_ref` fields, and removal of obsolete fields (`content` in `st2.action.file_writen`). This avoids false positives when validating system triggers.\n\n5. **Changelog and documentation:**\n   - `CHANGELOG.rst` was updated to explain that StackStorm now supports optional validation of trigger parameters and payloads for both system and non-system triggers, controlled by `system.validate_trigger_parameters` and `system.validate_trigger_payload`, both off by default for backward compatibility.\n\nOverall, this PR unifies trigger validation across rule creation and sensor dispatch, adds feature flags to avoid surprising users, replaces ad-hoc validation logic with reusable validators, and corrects internal schemas to reflect the actual payloads.",
        "semantic_memory": "Key takeaways and generalizable concepts from this fix:\n\n1. **Centralized schema validation for inputs:**\n   - Instead of sprinkling ad-hoc validation logic in different parts of the codebase, create centralized functions (e.g., `validate_trigger_parameters`, `validate_trigger_payload`) that encapsulate the rules for how to validate input based on schemas.\n   - These central validators look up schemas (e.g., from a constants map or database), apply JSON Schema validation, and handle missing schemas by intentionally skipping validation.\n   - This prevents duplicated logic, inconsistencies, and drift between different validation paths.\n\n2. **Optional validation and feature flags for backward compatibility:**\n   - Introducing stricter validation in an existing system can break user workloads. Use configuration flags (like `system.validate_trigger_parameters` and `system.validate_trigger_payload`) to make new behavior opt-in initially.\n   - The default remains the old, permissive behavior; users can turn on validation when ready.\n   - In a future major release, the flags can be flipped to opt-out semantics (enabled by default, but can be disabled), with proper deprecation and upgrade notes.\n\n3. **Using schemas attached to domain objects:**\n   - Attach `parameters_schema` and `payload_schema` directly to TriggerType definitions (or similar domain objects) so that validation is data-driven.\n   - Validation functions can then inspect these schema attributes dynamically, allowing both system-defined and user-defined entities to leverage the same mechanism.\n\n4. **Clear separation between system and user-defined entities:**\n   - System triggers are handled via a static registry (`SYSTEM_TRIGGER_TYPES`) with known schemas.\n   - User-defined triggers are resolved via database and use their attached schemas if defined.\n   - Behavior can differ based on whether an entity is ‘system’ or ‘user-defined’, but the code path is shared and controlled via flags.\n\n5. **Fail-fast vs. permissive behavior:**\n   - At rule creation time, invalid parameters should typically hard-fail (HTTP 400) to avoid creating broken rules.\n   - At runtime (sensor dispatch), behavior can be more nuanced: you may choose to:\n     * Fail-fast (drop event, log warning/error) when validation is enabled.\n     * Allow dispatch but log validation errors when validation is disabled, retaining backward compatibility.\n   - Making this behavior configurable lets operators choose between safety and continuity.\n\n6. **Accurate schemas for internal/“system” objects matter:**\n   - When you turn on strict validation, any mismatch between the configured schema and the actual payloads (code) becomes an immediate bug.\n   - Updating system trigger schemas (e.g., adding missing fields like `runner_ref`, removing unused fields) is necessary to avoid false validation errors and reflects the reality of the system.\n\n7. **Testing validation logic thoroughly:**\n   - For schema-based validation, tests should cover:\n     * Valid payloads/parameters that should pass.\n     * Invalid types, missing required properties, and extra unexpected properties.\n     * Fields with multiple allowed types (e.g., `anyOf` scenarios).\n     * Null/None values where allowed.\n     * Behavior when schemas or DB entries are missing.\n     * Interaction with configuration flags (enabled vs. disabled).\n\n8. **Logging as a first-class part of validation:**\n   - When validation fails, log both the trigger reference and the offending input, as well as the exception message. This makes diagnosing configuration or code issues much faster.\n   - Distinguish log messages when validation is skipped or disabled from those when validation is enforced.\n\nOverall, this fix illustrates how to roll out stricter, schema-driven validation in a mature system: centralize the logic, guard with feature flags, keep schemas accurate, and thoroughly test both success and failure paths.",
        "procedural_memory": [
            "Step-by-step approach to adding schema-based validation for inputs (like triggers, events, or API payloads) with backward compatibility:",
            "Step 1: Identify where validation is needed.",
            "- Determine the two main locations where validation must occur. In this case:\n  * At **definition time** (e.g., rule creation using trigger parameters).\n  * At **runtime** (e.g., sensors dispatching trigger payloads or webhooks generating triggers).",
            "Step 2: Centralize validation logic.",
            "- Create dedicated functions to encapsulate validation, e.g.:\n  * `validate_trigger_parameters(trigger_type_ref, parameters)`\n  * `validate_trigger_payload(trigger_type_ref, payload)`\n- These functions should:\n  * Accept a reference (ID) for the entity and the data to validate.\n  * Retrieve the appropriate schema (from a static map for system entities or from a database/model for user-defined entities).\n  * If no schema or entity is found, return `None` to indicate validation is skipped.\n  * Use a common validation utility (e.g., `jsonschema` or a custom schema helper) to validate and return cleaned data or raise validation errors.",
            "Step 3: Distinguish system vs. user-defined entities.",
            "- Maintain a registry/constant map for built-in entities with known schemas (e.g., `SYSTEM_TRIGGER_TYPES`).\n- For user-defined entities, fetch the definition (e.g., TriggerType) from the database and inspect attributes like `parameters_schema` and `payload_schema`.\n- If no DB entry or schema exists, skip validation and document that such objects are not validated.",
            "Step 4: Add feature flags for new validation behavior.",
            "- Introduce configuration options to control validation behavior, e.g.:\n  * `system.validate_trigger_parameters` (for parameters at rule creation).\n  * `system.validate_trigger_payload` (for payloads at dispatch time).\n- Default these flags to `False` to preserve existing behavior.\n- In your validator functions, gate validation for non-system entities behind these flags:\n  * If `is_system_entity` → always validate.\n  * If `not is_system_entity` and flag is disabled → log a debug message and return `None` (skip validation).",
            "Step 5: Wire validation into key code paths.",
            "- At definition time (e.g., rule creation controller):\n  * Before persisting the rule, call `validate_trigger_parameters` with the rule’s trigger ref and parameters.\n  * If validation raises an error, convert it to an HTTP 400 response with a clear message.\n- At runtime (e.g., sensor dispatch):\n  * Before dispatching, call `validate_trigger_payload` with the trigger ref and payload.\n  * Catch `ValidationError` (and other relevant exceptions) and decide whether to:\n    - Drop the event (when corresponding validation flag is enabled) and log a warning.\n    - Continue dispatching but log an error/warning (when validation is disabled).",
            "Step 6: Remove or refactor legacy, ad-hoc validation.",
            "- Search for older, custom validation logic (e.g., manually checking data types, recursive schema-like checks).\n- Replace these implementations with calls to the centralized validator functions.\n- Ensure the new central functions cover all existing behaviors or clearly document differences.",
            "Step 7: Update internal schemas to match actual payloads.",
            "- Inspect where built-in/system entities are emitted and what data they include.\n- Compare actual runtime payloads against their declared schemas.\n- Add missing fields (e.g., `runner_ref`, `route`, `action_ref`), and remove obsolete ones.\n- This step is critical if you are about to enforce strict validation; mismatched schemas will otherwise cause false failures.",
            "Step 8: Add thorough tests for both validation and flags.",
            "- Unit tests for validation functions:\n  * Valid cases for both system and user-defined entities.\n  * Invalid cases: wrong types, missing required fields, extra properties, incorrect shapes.\n  * Behavior when schemas or DB entries are not present.\n  * Ensure that when flags are disabled, validation errors do not prevent operations.\n- Integration/functional tests for API endpoints (e.g., rule creation) and runtime paths (e.g., sensors):\n  * Confirm that definitions with invalid parameters fail when validation is enabled and succeed when disabled.\n  * Confirm that invalid payloads are not dispatched when payload validation is enabled.",
            "Step 9: Ensure clear logging and user feedback.",
            "- When validation fails:\n  * Log the entity reference (trigger ref) and the problematic input (parameters/payload) and the error message.\n  * For API requests, return a descriptive error (HTTP 400) with relevant validation details.\n- When validation is skipped due to configuration or missing schema, log at debug level to help diagnose why something wasn't validated.",
            "Step 10: Document the behavior and migration path.",
            "- Update changelog and docs to describe:\n  * The new validation capabilities.\n  * The configuration flags controlling them, including defaults.\n  * How and when users might want to enable these flags.\n- For future major versions, plan to invert defaults (enable validation by default) and deprecate legacy behavior, with clear upgrade notes."
        ]
    }
}
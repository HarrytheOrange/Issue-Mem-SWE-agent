{
    "search_index": {
        "description_for_embedding": "Home Assistant Google Calendar integration updated to support Google event transparency (free/busy) via a new per-entity `ignore_availability` option. Previously, the component always returned the first upcoming event, even if it was marked as 'free' (transparent), so all-day free events could incorrectly hide the next busy event. The fix increases the Google API `maxResults`, iterates through upcoming events, and, unless `ignore_availability` is true, skips transparent events, selecting the next opaque (busy) event. The schema and tests were updated accordingly.",
        "keywords": [
            "Home Assistant",
            "Google Calendar",
            "calendar.google",
            "components/google.py",
            "ignore_availability",
            "transparency",
            "free/busy",
            "transparent events",
            "opaque events",
            "next event selection",
            "optional boolean config",
            "voluptuous schema change",
            "maxResults increased",
            "Throttle",
            "test_google.py",
            "logic bug",
            "feature enhancement"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant Google Calendar integration was enhanced to respect Google Calendar event transparency (free vs. busy) when determining the 'next event' exposed by the calendar platform.\n\nOriginally, the Google Calendar integration used `maxResults: 1` and simply selected the first item from the returned events: `self.event = items[0] if len(items) == 1 else None`. This had two issues: (1) the logic unnecessarily used `len(items)` instead of a simple truthy check, and (2) more importantly, it always returned the first upcoming event regardless of its `transparency` field. As a result, all-day events marked as 'free' (transparent) could block the actual next busy event from being shown in Home Assistant.\n\nThe fix introduced several coordinated changes:\n\n1. **Improved event retrieval**: The default Google API search parameters were updated to request more events (`maxResults` increased from 1 to 5) so that multiple upcoming events are available to filter. The simple `len(items)` check was replaced by `self.event = items[0] if items else None` to safely handle empty lists.\n\n2. **New per-entity configuration flag**: A new configuration option `ignore_availability` was added to the Google component (`homeassistant/components/google.py`). This option is defined as:\n   - `CONF_IGNORE_AVAILABILITY = 'ignore_availability'`\n   - In the entity schema: `vol.Optional(CONF_IGNORE_AVAILABILITY, default=True): cv.boolean`\n\n   This value is stored in each calendar entity's configuration and forwarded to the calendar platform. Defaulting it to `True` maintains backward compatibility: by default, Home Assistant behaves as before and ignores the availability flag.\n\n3. **Propagating the flag to the calendar device**: In `homeassistant/components/calendar/google.py`, the `GoogleCalendarEventDevice` now passes both search text and the availability flag into `GoogleCalendarData`:\n   - `self.data = GoogleCalendarData(calendar_service, calendar, data.get(CONF_SEARCH), data.get(CONF_IGNORE_AVAILABILITY))`\n\n   `GoogleCalendarData`'s initializer now stores this flag as `self.ignore_availability`.\n\n4. **Filtering events based on transparency**: The `update` method in `GoogleCalendarData` now loops over the retrieved events and selects the first appropriate one:\n\n   - If `ignore_availability` is **False**, the code checks for the `transparency` key and only selects events where `transparency == 'opaque'` (busy). Transparent (free) events are skipped, so the next busy event is exposed as the calendar's current event.\n   - If `ignore_availability` is **True** (the default), the code bypasses the transparency check and selects the first returned event, preserving the original behavior.\n\n   This loop ensures that free all-day events don't hide the following busy events when the user wishes to respect availability.\n\n5. **Minor cleanup**: Typographical errors in the earlier iterations (`ignore_availablilty`, `CONF_IGNORE_AVAILABLILTY`) were corrected to `ignore_availability` and `CONF_IGNORE_AVAILABILITY`. The throttle interval was temporarily changed but ultimately kept at the original 15 minutes to avoid unnecessary API calls. Constructor defaults were cleaned up to avoid double assignment of default values.\n\n6. **Test updates**: A failing test was fixed by updating the expected calendar configuration to include the new field. In `tests/components/test_google.py`, the expected entity dictionary inside `test_get_calendar_info` now includes `'ignore_availability': True`, matching the new schema default. This confirms both that the configuration loader injects the default and that the API remains backward compatible for existing configurations.\n\nOverall, the specific incident was: users with all-day events marked as 'free' in Google Calendar would see these events treated as active events in Home Assistant, preventing them from seeing the next busy event. By adding `ignore_availability` and filtering on `transparency == 'opaque'` when requested, Home Assistant now allows users to optionally skip free events while keeping legacy behavior unchanged by default.",
        "semantic_memory": "This change demonstrates several generalizable patterns and best practices for integrating third-party calendar APIs and evolving configuration schemas:\n\n1. **Respecting domain semantics (free vs. busy)**: When integrating with calendar systems, meta-fields like `transparency`, `status`, or `availability` significantly impact user expectations. It's often not enough to display the 'next event by start time'; consumers may only care about 'busy' events. A robust integration should expose configuration that lets users choose whether to respect these semantics.\n\n2. **Making behavior changes opt-in via configuration**: When introducing new behavior that changes how a core integration behaves (e.g., skipping certain events), it's safer to expose it as an optional flag with a default value that preserves existing behavior. This reduces the risk of breaking existing setups while still allowing power users to opt into improved semantics.\n\n3. **Using optional flags with defaults in configuration schemas**: Voluptuous (or similar schema libraries) make it easy to define optional booleans with defaults: `vol.Optional(KEY, default=True): cv.boolean`. This ensures that downstream code can treat the value as always present (boolean) and simplifies logic.\n\n4. **Propagating configuration through component layers**: For multi-layer components (top-level service config -> entities -> platform-specific data classes), configuration options must be consistently propagated. In this case, `ignore_availability` is defined in the root Google component, added to the entity schema, passed down to `GoogleCalendarEventDevice`, and then into `GoogleCalendarData` where it affects the query logic.\n\n5. **Avoiding brittle single-result assumptions with external APIs**: Using `maxResults: 1` works only for trivial cases. When selection criteria become more complex (e.g., 'next event that is busy'), you should request multiple candidates (here, `maxResults: 5`) and perform selection logic on the client side. This pattern is applicable to any API where selection depends on extra fields beyond sorting.\n\n6. **Defensive event selection**: Instead of checking `len(items) == 1`, use truthiness checks like `items` to handle zero or multiple results. Then explicitly pick the correct item based on domain rules instead of assuming exactly one event.\n\n7. **Incremental, test-backed schema evolution**: When adding new configuration keys, you must:\n   - Update the schema.\n   - Update any code that instantiates or reads configuration dictionaries.\n   - Adjust tests to include the new field (especially when a default is injected by the schema).\n\n   Failing tests can be a useful indicator that your schema has changed in a way your tests didn't anticipate.\n\n8. **Preserving API call discipline**: When experimenting with update throttle intervals, remember that external APIs often have rate limits. Reverting the throttle interval back to 15 minutes maintains a balance between responsiveness and API quota usage.\n\nOverall, the key conceptual takeaway is: when external data includes fields that encode user-facing semantics (like availability), design your integration to allow filtering on those fields, and roll out such changes via configurable, backward-compatible options.\n",
        "procedural_memory": [
            "How to diagnose and fix issues where a calendar integration incorrectly treats 'free' events as blocking the next 'busy' event:",
            "Step 1: Reproduce the behavior and inspect external data\n- Enable logging or debugging of the calendar integration.\n- Fetch the raw event payloads from the third-party API (e.g., Google Calendar) around the time period in question.\n- Confirm that the problematic event(s) have `transparency: 'transparent'` (or equivalent fields indicating 'free') and that subsequent events are marked as busy/opaque.\n- Verify that the integration is selecting the first event purely by start time without considering these flags.",
            "Step 2: Identify assumptions in current selection logic\n- Locate the component responsible for determining the 'current' or 'next' event (e.g., a data class like `GoogleCalendarData.update`).\n- Check how many results are requested from the API (e.g., `maxResults: 1`) and how the result is chosen (e.g., `items[0]`).\n- Confirm whether any filtering or conditional logic is applied based on availability fields such as `transparency`.",
            "Step 3: Adjust the API request to retrieve multiple candidate events\n- Increase the number of events requested (e.g., set `maxResults` from 1 to a small, reasonable number like 5 or 10) so you have sufficient candidates to filter.\n- Keep ordering consistent (e.g., `orderBy: 'startTime', singleEvents: True`) to ensure chronological ordering.\n- Ensure that your code still handles empty result sets gracefully by checking `if items` rather than relying on `len(items) == 1`.",
            "Step 4: Implement filtering based on availability\n- Add logic to iterate over the fetched events and apply filtering rules.\n- For example:\n  - Initialize `new_event = None`.\n  - For each `item` in `items`:\n    - If respecting availability and `item.get('transparency') == 'opaque'`, select it and break.\n    - If ignoring availability, select the first item and break.\n- Ensure that you handle events without a `transparency` field (treat them as busy or according to your domain rules).",
            "Step 5: Introduce a configurable flag to control behavior\n- Define a new configuration key (e.g., `CONF_IGNORE_AVAILABILITY = 'ignore_availability'`).\n- Add it to your configuration schema as an optional boolean with a default that preserves current behavior:\n  - `vol.Optional(CONF_IGNORE_AVAILABILITY, default=True): cv.boolean`\n- Thread this configuration value through all relevant layers:\n  - Root component config.\n  - Entity config (e.g., per calendar entity).\n  - Platform-specific data classes that actually implement the filtering logic.",
            "Step 6: Apply the configuration flag in the selection logic\n- In your data class (e.g., `GoogleCalendarData`), accept the boolean flag in the constructor and store it (e.g., `self.ignore_availability`).\n- In `update`, conditionally apply the transparency filter:\n  - If `ignore_availability` is False, skip transparent events by checking `item.get('transparency') == 'opaque'`.\n  - If `ignore_availability` is True, do not check `transparency` and just select the first event.\n- This separation gives users explicit control over whether 'free' events are considered.",
            "Step 7: Update tests to cover new behavior and schema\n- Modify existing tests that validate configuration loading to expect the new field with its default value. For example, adjust expected dictionaries to include `'ignore_availability': True`.\n- Add new tests that simulate calendars with a mix of transparent and opaque events:\n  - Case 1: `ignore_availability = True` -> first event returned regardless of transparency.\n  - Case 2: `ignore_availability = False` -> free events skipped until a busy event is found.\n- Run the test suite to ensure changes are covered and no regressions are introduced.",
            "Step 8: Consider performance and rate limits\n- If you modified any throttling or polling intervals (e.g., `MIN_TIME_BETWEEN_UPDATES`), verify that they comply with the external service's rate limits.\n- Prefer conservative defaults (e.g., 15 minutes) unless there is a strong requirement for more frequent updates.",
            "Step 9: Document the new configuration option\n- Update user-facing documentation to describe the new `ignore_availability` flag, its default, and usage examples.\n- Clarify its semantics: when false, transparent 'free' events are skipped; when true (default), availability is ignored and all events are considered.",
            "Step 10: Clean up and standardize code\n- Replace brittle or verbose checks like `len(items) == 1` with idiomatic Python patterns like `if items`.\n- Fix any naming inconsistencies or typos in constants and variables to avoid confusion (e.g., `ignore_availability` instead of `ignore_availablilty`).\n- Ensure that all layers use the same constant names to reduce config propagation bugs."
        ]
    }
}
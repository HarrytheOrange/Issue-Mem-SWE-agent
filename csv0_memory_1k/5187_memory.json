{
    "search_index": {
        "description_for_embedding": "Added a Home Assistant notify.lannouncer platform that talks to the LANnouncer Android app over a raw TCP socket instead of HTTP. Initial HTTP-based implementation using requests failed because LANnouncer does not implement proper HTTP responses (no status line, just 'LANnouncer: OK'). The final solution opens a TCP connection, URL-encodes either 'speak' or 'alarm' commands with '&@DONE@', validates methods, and logs connection/response errors.",
        "keywords": [
            "homeassistant",
            "notify.lannouncer",
            "LANnouncer",
            "Android TTS",
            "notification service",
            "raw TCP socket",
            "non-HTTP protocol",
            "requests failure",
            "protocol mismatch",
            "voluptuous validation",
            "network integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduces a new Home Assistant notification platform for the LANnouncer Android app. The original idea was to use HTTP via the Python requests library to send TTS and alarm commands to a wall-mounted Android tablet running LANnouncer. However, during testing the author discovered that LANnouncer does not implement a proper HTTP server: when queried with curl (e.g., `curl -v \"http://tablet-living.local:1035/?SPEAK=test&@DONE@\"`), the app responds with a bare `LANnouncer: OK` string and does not send an HTTP status line or headers. This broke normal HTTP client behavior and required ignoring exceptions when using requests.\n\nAfter discussing with a maintainer, the author concluded that the app wasn't really speaking HTTP at all but just reading raw data from a TCP socket. A second test confirmed that sending `SPEAK=a&@DONE@` over a raw TCP socket worked, independent of HTTP semantics. The implementation was therefore switched from requests-based HTTP to a raw TCP client.\n\nThe final implementation adds `homeassistant/components/notify/lannouncer.py` and registers it in `.coveragerc`. The platform schema requires `host` and an optional `port` (default 1035). The notification service class `LannouncerNotificationService` extends `BaseNotificationService` and supports two methods via the `data` payload: `speak` and `alarm`. A `method` field in `data` selects which command to send, defaulting to `speak` if omitted. The method must be in the allowed list `['speak', 'alarm']`; otherwise it logs an error and returns early.\n\nTo send a message, the service URL-encodes a dictionary `{method: message}` using `urllib.parse.urlencode`, producing strings like `speak=Hello+world`. It then opens a TCP socket to the configured host/port, sets a 10 second timeout, and writes the encoded command followed by `\"&@DONE@\\n\"`. The service reads up to 1024 bytes from the socket and expects exactly `b'LANnouncer: OK'`. Any other response results in an error log that includes the decoded response. Connection errors are handled explicitly: `socket.gaierror` produces a 'Unable to connect to host' error, and other `socket.error` exceptions log a stack trace with 'Failed to send data to Lannnouncer'. The code was slightly cleaned up to use a bare `return` instead of `return None` in `send_message` when encountering an unknown method.\n\nThis PR also clarifies that, at the time, Home Assistant's notify platform was not yet async, so the author did not adopt asyncio/aiohttp despite suggestions; a raw blocking socket is used instead, which was acceptable given the current architecture.",
        "semantic_memory": "Key takeaways from this change revolve around interacting with third-party services that do not strictly implement standard protocols, and designing a robust notification integration around that reality.\n\n1. **Protocol reality vs. specification**: A service may claim to use HTTP (or appear to via a URL and port) but not actually implement the HTTP protocol correctly. For example, LANnouncer listens on a TCP port and accepts query-string-like commands (`SPEAK=...&@DONE@`) but does not emit valid HTTP responses (no status line, no headers). Classic HTTP clients like `requests` expect a full HTTP response and will fail, even when the underlying service is functioning correctly.\n\n2. **Choosing the right abstraction level**: When a protocol is not HTTP-compliant, it's better to communicate at the underlying TCP level instead of trying to force-fit an HTTP client. Using `socket.socket` to open a raw TCP connection, write the expected payload, and read the simple response avoids the complexity and fragility of misusing higher-level libraries.\n\n3. **Command encoding and terminators**: Even in non-HTTP protocols, it is often useful to reuse structured encoding schemes such as URL-encoded parameters (via `urllib.parse.urlencode`) to build command strings like `speak=Hello+world`. Many simple network services use a specific terminator sequence (here `&@DONE@\\n`) to mark the end of a command or message, and clients must honor that exactly.\n\n4. **Input validation and defaults**: When supporting multiple operations (here `speak` and `alarm` methods), explicitly define allowed values and a sensible default. Use a clear configuration schema (voluptuous in Home Assistant) and runtime validation to avoid mis-typed or unexpected method values. Log and fail early for unsupported methods rather than sending undefined commands to external devices.\n\n5. **Error handling with opaque services**: For services with minimal feedback, treat connection errors, address resolution errors, and unexpected responses as distinct cases. Log enough context (host, response bytes) to make remote debugging possible. When the service's response surface is small (e.g., a single 'OK' string), treat any deviation as error and surface that to the user.\n\n6. **Framework integration constraints**: If the host framework's subsystem (here, the notify platform) is not yet asyncio-based, it may not be appropriate to use asynchronous networking libraries like `aiohttp` even if they are preferred for new code elsewhere. Adapting to current platform capabilities sometimes means using blocking I/O, with the understanding that it can be refactored once the subsystem supports async.\n\n7. **Implementation style**: For methods returning `None` implicitly (e.g., side-effect methods like `send_message`), there is no functional difference between `return None` and `return`. Prefer the simpler `return` to signal early exit without implying that a specific value is used downstream.",
        "procedural_memory": [
            "When integrating with a third-party network service that behaves like HTTP but fails under HTTP clients, treat it as a potential protocol mismatch and consider falling back to raw TCP operations.",
            "Step 1: Reproduce and inspect the protocol behavior.\n- Use `curl -v`, `nc`, or `telnet` to talk to the service.\n- Examine what you send and what you receive.\n- Check if the response includes a valid HTTP status line and headers, or if it's just raw bytes (like `LANnouncer: OK`).",
            "Step 2: Determine whether an HTTP client is appropriate.\n- If responses do not conform to HTTP (no status line, malformed headers, incomplete framing), do not use high-level HTTP libraries (e.g., `requests`, `aiohttp`).\n- If the service simply reads and writes raw lines or tokens, plan to use `socket` or asyncio streams instead.",
            "Step 3: Reverse-engineer or confirm the command format.\n- Identify how commands are structured (e.g., `SPEAK=message&@DONE@`).\n- Experiment with sending raw commands via `nc` to confirm minimal required tokens and terminators.\n- Determine whether messages need URL encoding or another encoding scheme.",
            "Step 4: Implement a minimal raw TCP client.\n- Use `socket.socket(AF_INET, SOCK_STREAM)` to create a TCP socket.\n- Set a reasonable timeout (e.g., `sock.settimeout(10)`).\n- Connect to `(host, port)` from configuration.\n- Construct the command string using a consistent encoder (e.g., `cmd = urlencode({method: message})`).\n- Send the command and any required terminator (e.g., `sock.sendall(cmd.encode()); sock.sendall(\"&@DONE@\\n\".encode())`).",
            "Step 5: Read and validate the response.\n- Read a limited number of bytes (e.g., `buffer = sock.recv(1024)`).\n- Compare the raw bytes to the expected success token (e.g., `b'LANnouncer: OK'`).\n- If the response differs, log an error with the decoded response to aid debugging.",
            "Step 6: Handle connection and runtime errors robustly.\n- Catch `socket.gaierror` and log that the host could not be resolved or reached.\n- Catch `socket.error` more generally and log a stack trace that includes the context (e.g., 'Failed to send data').\n- Ensure the socket is closed in both success and error paths (either via explicit `close()` or a `with`-style wrapper/try-finally).",
            "Step 7: Design the configuration and validation layer.\n- Use a schema library (like voluptuous) to require key configuration parameters (`host`) and provide defaults for others (`port` with sensible default like 1035).\n- For runtime parameters (like `method` in a data payload), define an explicit allowed list (e.g., `['speak', 'alarm']`) and a default (e.g., `'speak'`).\n- Validate method values before sending anything; if invalid, log an error and `return` early without network activity.",
            "Step 8: Integrate into the framework's service model.\n- Subclass the framework’s base notification service class (e.g., `BaseNotificationService`).\n- Implement the `get_service` factory to instantiate your service with configuration parameters.\n- Implement `send_message(self, message=\"\", **kwargs)` to interpret `message` and `kwargs[ATTR_DATA]` (including `method` selection) and then delegate to your TCP send logic.",
            "Step 9: Observe framework constraints regarding async vs sync.\n- If the host subsystem is synchronous (e.g., Home Assistant notify at the time of this PR), stick to blocking I/O (`socket`) instead of mixing in `asyncio`/`aiohttp` unless the framework explicitly supports it.\n- Plan for a future refactor to async once the subsystem APIs (e.g., `async_setup`, async send hooks) are in place.",
            "Step 10: Clean up and polish behavior.\n- Remove unnecessary `return None` statements in void methods; use `return` for early exits.\n- Add debug logging for successful sends (e.g., 'Sending message: ...') and error logging that includes contextual data.\n- Exclude new integration files from coverage if appropriate for the project’s testing strategy, or add tests if feasible."
        ]
    }
}
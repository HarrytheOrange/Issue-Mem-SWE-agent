{
    "search_index": {
        "description_for_embedding": "Implementation of a new Home Assistant sensor platform for monitoring pyLoad via its HTTP API. The sensor reports download speed in MB/s, handles authentication, uses throttled updates, supports SSL via a boolean flag, and provides configuration options for host/port/username/password and monitored variables.",
        "keywords": [
            "home-assistant",
            "pyload",
            "sensor platform",
            "download speed",
            "HTTP API",
            "requests",
            "Throttle",
            "CONF_SSL",
            "configuration.yaml",
            "CONTENT_TYPE_JSON",
            "HTTP_HEADER_CONTENT_TYPE"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change adds a new `sensor.pyload` integration to Home Assistant to monitor pyLoad, specifically its download speed. The sensor is implemented in `homeassistant/components/sensor/pyload.py` and exposes a configurable platform where users can specify host, port, SSL usage, username, password, and which metrics to monitor (currently only `speed`). The code builds the pyLoad API base URL as `http{ssl}://{host}:{port}/api/`, where `ssl` is either an empty string or 's' depending on the `CONF_SSL` boolean. A `PyLoadAPI` helper class wraps the HTTP requests to pyLoad: it logs in (if credentials are provided) using a POST to the `login` endpoint with a 5-second timeout, sets the `Content-Type` via Home Assistant's `HTTP_HEADER_CONTENT_TYPE` and `CONTENT_TYPE_JSON` constants, and queries the `statusServer` endpoint to retrieve the current speed. The results are cached and updated using `homeassistant.util.Throttle` with a 15-second minimum interval to avoid excessive polling. The `PyLoadSensor` entity reads values from the API response, converts speed from bytes per second to megabytes per second (MB/s), and exposes this as the sensor state. The platform schema is defined with voluptuous, making `host` optional (defaulting to `localhost`), with default port 8000 and default monitored variable `speed`. Initial entity state is populated by calling `add_devices(devices, True)`. Error handling is implemented so that connection errors during setup log a clear message and abort setup, while errors during updates are logged in the API wrapper. The `.coveragerc` file is updated to omit the new sensor module from coverage. A later user comment revealed confusion about HTTPS usage when they included `https://` in the host; the code actually expects the scheme to be controlled by the `ssl` flag while `host` is just a hostname, which is an important usage detail though not directly changed in this PR.",
        "semantic_memory": "This change illustrates how to properly add a Home Assistant sensor platform that integrates with an external HTTP API. Key patterns include: defining a clear `PLATFORM_SCHEMA` with sensible defaults and optional fields (e.g., `host` defaulting to `localhost`, `port` defaulting to 8000, and a monitored variables list constrained to known types). Using a small API wrapper class (`PyLoadAPI`) helps encapsulate login logic, headers, endpoints, and error handling, keeping the entity class focused on translating API data into Home Assistant states. Authentication is performed with explicit timeouts to avoid hung requests. The integration uses Home Assistant's `Throttle` utility to limit the frequency of API calls, which is important for performance and to avoid overloading the external service. The code uses predefined Home Assistant constants like `HTTP_HEADER_CONTENT_TYPE` and `CONTENT_TYPE_JSON` instead of hard-coded strings, increasing consistency and reducing duplication. Entities are created with friendly, derived names and units of measurement and perform any necessary unit conversions before exposing state. Setup code should handle connection errors gracefully, log them, and abort platform setup when remote services are unreachable. The change also shows the practice of passing `True` as the second argument to `add_devices` so that new entities are updated immediately. Finally, making configuration options like `host` optional with well-chosen defaults enhances usability and avoids unnecessary configuration boilerplate. A subtle design point is separating protocol (HTTP vs HTTPS) from the host field; the configuration uses a dedicated SSL flag (`CONF_SSL`) rather than expecting users to embed `http://` or `https://` in the host string, which is a common pattern in such configurations.",
        "procedural_memory": [
            "When implementing a new Home Assistant sensor that talks to an HTTP-based third-party service:",
            "Step 1: Define the configuration schema using voluptuous and Home Assistant constants. Make frequently used options like host, port, and name optional with sensible defaults (`DEFAULT_HOST`, `DEFAULT_PORT`, and `DEFAULT_NAME`). Provide a `CONF_MONITORED_VARIABLES` list constrained to known metric identifiers.",
            "Step 2: In `setup_platform`, read configuration values, build the service base URL explicitly (including scheme, host, port, and base path). If you support SSL, use a dedicated boolean configuration option (e.g., `CONF_SSL`) and derive the scheme (`http` vs `https`) instead of expecting the scheme in the host string.",
            "Step 3: Create a small API wrapper class around the remote service. Store the base URL and headers (using HA constants like `HTTP_HEADER_CONTENT_TYPE` and `CONTENT_TYPE_JSON`), handle authentication (e.g., a login POST with credentials) with timeouts, and provide methods (like `post`) to call specific endpoints and return parsed JSON. Centralize logging and error handling there.",
            "Step 4: Use `homeassistant.util.Throttle` on the API update method to enforce a minimum interval between HTTP calls (e.g., 15 seconds). Inside the throttled `update`, fetch and cache the relevant data (e.g., speed metrics) from the service. Let HTTP exceptions propagate out of `post` but catch them at call sites to log and prevent crashes.",
            "Step 5: Implement an `Entity` subclass (e.g., `PyLoadSensor`) that takes the API wrapper and sensor type metadata (key, friendly name, unit). In `update`, call the API's `update` method, check for missing status data, and retrieve the relevant value (e.g., `self.api.status.get(self.type)`). Apply necessary conversions (like bytes/s to MB/s) before assigning to `self._state`.",
            "Step 6: In `setup_platform`, instantiate the API wrapper inside a try/except block so connection and HTTP errors are caught. If initialization fails, log a clear error and return `False` to abort platform setup. For each monitored variable, create a corresponding entity and collect them in a devices list.",
            "Step 7: Call `add_devices(devices, True)` to register the entities with Home Assistant and trigger an initial state update. The `True` ensures entities call `update` immediately.",
            "Step 8: Adjust `.coveragerc` to omit new integration modules if they are not yet fully covered by tests, following the project's coverage conventions.",
            "Step 9: Document the configuration in the docs repo, explaining the meaning of each option (especially how SSL is configured and that host should be a bare hostname, not a URL) and providing example `configuration.yaml` snippets.",
            "Step 10: When users report issues (e.g., HTTPS not working), verify whether the configuration matches the intended model (separate SSL flag vs scheme in host), and consider clarifying documentation or adding validation to catch common misconfigurations (such as rejecting hosts containing `://`)."
        ]
    }
}
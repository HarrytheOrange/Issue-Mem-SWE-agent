{
    "search_index": {
        "description_for_embedding": "Refactor napari layer coordinate handling by introducing a generic Transform base class and a ScaleTranslate (scale + translate) transform, replacing ad-hoc per-attribute scale/translate logic. Centralizes transformations, supports composition, slicing/padding across dimensions, and prepares for world coordinates and affine transforms, while preserving existing behavior.",
        "keywords": [
            "napari",
            "layer transforms",
            "ScaleTranslate",
            "Transform",
            "coordinate transform",
            "scale",
            "translate",
            "world coordinates",
            "composition",
            "set_slice",
            "set_pad",
            "vispy_base_layer",
            "refactor",
            "non-breaking change"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the napari team refactored how layers handle coordinates and transforms, without altering user-visible behavior.\n\nPreviously, each layer stored raw numeric properties such as `scale`, `translate`, `_scale_view`, `_translate_view`, and `_translate_grid`. These were manipulated in several places (layer base, image layer, and vispy adapters) with manual broadcasting, dimension-matching, and ad-hoc combinations (e.g., multiplying scales and adding translations). This made it hard to reason about coordinate mappings, difficult to extend to world coordinates or affine transforms, and error-prone when the number of dimensions changed.\n\nTo solve this, the PR introduces a small transform framework:\n\n1. **Transform base class** (`napari/layers/transforms.py`):\n   - Encapsulates a callable `func` mapping coordinates to coordinates (defaults to identity using `toolz.identity`).\n   - Supports an optional inverse function via the `inverse` property when provided.\n   - Defines abstract methods `set_slice(axes)` and `set_pad(axes)` for dimension-aware operations.\n\n2. **ScaleTranslate transform** (implemented as `ScaleTranslate`, previously called `STTransform` during development):\n   - Represents an n-dimensional transform combining elementwise scale and translation, applied as `scale * coords + translate`.\n   - Accepts `scale` and `translate` as 1-D arrays, and broadcasts them along leading dimensions:\n     - `scale` is broadcast to 1 in leading dimensions.\n     - `translate` is broadcast to 0 in leading dimensions.\n   - Implements:\n     - `__call__`: applies the transform, using `np.atleast_2d` internally and `np.squeeze` on output, so it works with both single and multiple coordinate points.\n     - `inverse`: returns a new `ScaleTranslate` that inverts the mapping: scale becomes `1 / self.scale` and translation becomes `-1 / self.scale * self.translate`.\n     - `set_slice(axes)`: returns a reduced transform keeping only the specified axes.\n     - `set_pad(axes)`: returns a transform with new axes inserted (scale=1, translate=0 on the new axes) so it behaves like the inverse of a corresponding `set_slice`.\n     - `compose(other)`: returns the composition of two `ScaleTranslate` transforms, so that applying the result to coordinates is equivalent to applying `other` then `self`. Composition is implemented as:\n       - `scale = self.scale * other.scale`\n       - `translate = self.translate + self.scale * other.translate`.\n\n3. **Layer model refactor** (`napari/layers/base/base.py`):\n   - The layer base class now owns three `ScaleTranslate` instances instead of separate scalar arrays:\n     - `self._transform`: data -> world-like coordinates, using the user-provided `scale` and `translate`.\n     - `self._transform_view`: view -> data coordinates, for when the displayed data is not the original (e.g., pyramid levels, downsampled textures for large images).\n     - `self._transform_grid`: world -> grid coordinates, for arranging layers side-by-side in a grid.\n   - The `scale` and `translate` properties are thin wrappers around `self._transform.scale` and `self._transform.translate`, keeping the public API backward compatible.\n   - `translate_grid` is backed by `self._transform_grid.translate`.\n   - `_update_dims` was updated to handle changes in dimensionality by manipulating transforms instead of manually padding/truncating lists. It:\n     - Uses `set_slice` when dimensionality shrinks (keep trailing axes).\n     - Uses `set_pad` when dimensionality grows (add axes at the front).\n\n4. **VisPy adapter integration** (`napari/_vispy/vispy_base_layer.py`):\n   - `_on_scale_change` now computes the composite scale used by VisPy as:\n     - `composite = layer._transform_view.compose(layer._transform)`\n     - `scale = composite.set_slice(layer.dims.displayed).scale`\n     - Then reversed to match VisPy's axis order.\n   - `_on_translate_change` similarly composes all relevant transforms:\n     - `composite = layer._transform_grid.compose(layer._transform_view.compose(layer._transform))`\n     - `translate = composite.set_slice(layer.dims.displayed).translate`, then reversed for VisPy.\n   - This replaces the previous pattern of directly multiplying and adding array attributes (`scale`, `_scale_view`, `translate`, `_translate_view`, `translate_grid`) and ensures the logic lives in the transform objects.\n\n5. **Image layer integration** (`napari/layers/image/image.py`):\n   - The image layer now updates `self._transform_view.scale` and `self._transform_view.translate` instead of raw `_scale_view` and `_translate_view` arrays when working with pyramids and large images requiring downsampling.\n   - For pyramid levels and large textures, it updates:\n     - `self._transform_view.scale` based on level downsampling and texture downsampling.\n     - `self._transform_view.translate` based on `top_left * scale * self._transform_view.scale` when tiling is applied.\n   - For non-pyramid data, it resets `self._transform_view.scale` to ones.\n\n6. **Tests** (`napari/layers/_tests/test_transforms.py`):\n   - A new test module verifies the correctness of `ScaleTranslate`:\n     - Proper application of scale+translate.\n     - Correct inverse mapping.\n     - Correct composition (`compose`).\n     - Correct behavior of `set_slice` and `set_pad`.\n     - Default identity behavior when constructed with no arguments.\n\nOverall, this PR does not fix a user-facing bug but removes technical debt: it unifies transform logic, makes coordinate handling composable and dimension-aware, and sets the stage for future features like world coordinates, transform chains, and general affine transforms.",
        "semantic_memory": "This change illustrates several generalizable design patterns and best practices around coordinate transforms and model-view separation:\n\n1. **Encapsulate transforms as first-class objects**\n   - Instead of scattering scale and translate arrays across the codebase and combining them with ad-hoc arithmetic, encapsulate the behavior in dedicated transform classes.\n   - The `ScaleTranslate` class embodies the idea that many graphical transformations can be expressed as a simple linear+offset (`scale * coords + translate`) mapping. Centralizing that logic makes it easier to reason about, test, and extend.\n\n2. **Make transforms dimension-aware (slice and pad)**\n   - Coordinate transforms often need to adapt to changes in dimensionality (e.g., from 2D to 3D or when toggling displayed axes). Implementing `set_slice(axes)` and `set_pad(axes)` on transform objects allows the rest of the system to remain agnostic about how transforms change when axes are added or removed.\n   - `set_slice` provides a way to extract a lower-dimensional view of a transform for a subset of axes.\n   - `set_pad` allows adding new axes with identity-like behavior (scale=1, translate=0) at arbitrary positions, supporting operations like toggling dimensions or stacking new axes.\n\n3. **Support composition of transforms instead of manual combination**\n   - Defining a `compose` method on transforms creates a small algebra of transformations. Two transforms can be combined into a single equivalent transform, which is powerful for both efficiency and readability.\n   - For affine-like transforms such as `ScaleTranslate`, there is a closed-form expression for composition and inversion, which can be exploited rather than maintaining chains of transforms everywhere.\n   - This pattern decouples the conceptual model (layers have base transforms, view transforms, and grid transforms) from the implementation details (how exactly these are combined to drive a renderer).\n\n4. **Keep the public API stable while refactoring internals**\n   - The refactor keeps `layer.scale` and `layer.translate` APIs unchanged, even though internally they now delegate to `self._transform`. This is a key pattern: preserve external contracts while improving internals.\n   - This enables incremental migration towards more powerful features (world coordinates, arbitrary affine transforms) while not breaking existing user code.\n\n5. **Broadcasting and shape handling as transform responsibilities**\n   - Broadcasting scale to 1 and translation to 0 for leading dimensions, plus handling single vs. multiple coordinate points (via `np.atleast_2d` and `np.squeeze`), are concerns of the transform, not of every caller.\n   - Centralizing these rules avoids repeated boilerplate and reduces the chance of subtle indexing or shape bugs around dimensionality changes.\n\n6. **Using transforms to mediate between model and view**\n   - Different parts of the system (e.g., model `Layer`, rendering backend `vispy`) can have different axis conventions. Transform objects provide a clean location to reason about the mapping and keep view-specific logic minimal (e.g., reversing axis order only at the final adapter layer).\n   - The idea of separate \n     - base transform (data -> world),\n     - view transform (viewed data -> data), and\n     - layout/grid transform (world -> grid)\n     generalizes to any visualization system that layers multiple logical transforms.\n\n7. **Test the transform algebra explicitly**\n   - Adding dedicated tests for `ScaleTranslate` (forward mapping, inverse, composition, slicing, padding, identity) ensures correctness of the mathematical core, which is critical because many other components now depend on these operations.",
        "procedural_memory": [
            "When refactoring or extending coordinate transform logic in a visualization or numerical application, follow these steps:",
            "Step 1: Identify all existing transform-related fields and usages",
            "- Search the codebase for attributes and parameters representing scale, translate, or other affine parameters (e.g., `scale`, `translate`, `_scale_view`, `_translate_view`, `translate_grid`).",
            "- Map out where these attributes are read and written (layers, rendering adapters, UI logic, tests).",
            "- Note any duplicated logic for broadcasting, dimensionality handling (padding/truncation), or manual combination of transforms (e.g., repeated patterns like `scale_total = scale * scale_view`).",
            "Step 2: Define a transform abstraction",
            "- Create a base `Transform` class that represents a mapping from coordinates to coordinates.",
            "- Provide a standard `__call__(coords)` interface and an optional `inverse` interface.",
            "- Decide what dimension-aware operations are needed (e.g. `set_slice`, `set_pad`) and define them abstractly in the base class.",
            "Step 3: Implement concrete transform types",
            "- Implement a `ScaleTranslate` (or equivalent affine) transform that encapsulates a common pattern like `scale * coords + translate`.",
            "- Ensure it handles:\n  - Broadcasting of parameters across dimensions (e.g., leading dimensions default to identity behavior: scale=1, translate=0).\n  - Different input shapes (single point vs. array of points) using tools like `np.atleast_2d` and `np.squeeze`.",
            "- Implement algebraic operations:\n  - `inverse`: return a transform that inverts the mapping.\n  - `compose(other)`: combine two transforms into a single one.",
            "Step 4: Wire transforms into domain models",
            "- Replace raw transform attributes in core models with transform objects. For example:\n  - `self._transform = ScaleTranslate(scale, translate)` for the primary mapping.\n  - `self._transform_view` for view-specific adjustments (e.g., pyramid levels, downsampling).\n  - `self._transform_grid` (or similar) for layout transforms (e.g., grids, side-by-side views).",
            "- Maintain existing properties (e.g., `scale`, `translate`) as thin wrappers around the corresponding fields of the transform objects to preserve public APIs.",
            "Step 5: Centralize dimension handling in transforms",
            "- In places where the number of dimensions can change (e.g., when switching between 2D and 3D), call `set_slice` and `set_pad` on transforms instead of manually adjusting arrays.",
            "- Implement:\n  - `set_slice(axes)`: to keep only specific axes, e.g., trailing axes or displayed axes.\n  - `set_pad(axes)`: to add identity behavior on new axes in a specific position, making it act as an inverse of `set_slice`.",
            "Step 6: Update adapters/renderers to use composed transforms",
            "- In the rendering layer or adapters (e.g. VisPy integration), replace manual combination of scales and translates with transform composition:\n  - Compute composite transforms by chaining `compose()` calls (e.g., `grid.compose(view.compose(base))`).\n  - Subset to visible axes using `set_slice(displayed_axes)`.\n  - Apply any required axis-order conversion only at the adapter boundary (e.g., reversing for different conventions).",
            "Step 7: Add focused tests for the transform behavior",
            "- Write tests that validate the algebra of your transform objects:\n  - Forward application (input -> transformed output) with known expected values.\n  - Inverse correctness: `transform.inverse(transform(coords)) == coords` within numerical tolerance.\n  - Composition: `compose(b, a)(coords) == b(a(coords))`.\n  - `set_slice` and `set_pad` behavior, especially around leading/trailing axes.\n  - Identity behavior when defaults are used (no scale/translate).",
            "Step 8: Verify behavior and maintain backward compatibility",
            "- Run existing tests for layers, rendering, and other components that depend on coordinate transforms to ensure no regressions.",
            "- Confirm that public APIs (e.g. `layer.scale`, `layer.translate`) exhibit the same behavior as before.",
            "- If visually inspecting a GUI application, verify that displays, panning/zooming, multi-resolution views, and grid layouts still behave as expected.",
            "Step 9: Document the new transform system",
            "- Add docstrings and developer-facing documentation explaining:\n  - The role of each transform (base, view, grid, etc.).\n  - How composition works.\n  - How to extend with new transforms (e.g., full affine matrices) or how to chain transforms for more complex mappings.",
            "By following these steps, you can transition from scattered, ad-hoc coordinate logic to a coherent, testable transform system that supports composition, dimensional changes, and future extensions like world coordinates and arbitrary affine transforms."
        ]
    }
}
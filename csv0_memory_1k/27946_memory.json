{
    "search_index": {
        "description_for_embedding": "Home Assistant Luci device_tracker could not connect to some OpenWrt routers using HTTPS due to certificate verification failures (e.g., self-signed certs). Fix adds a configurable verify_ssl option (default true) and bumps openwrt-luci-rpc to a version that supports disabling SSL verification.",
        "keywords": [
            "luci",
            "device_tracker",
            "openwrt",
            "openwrt-luci-rpc",
            "ssl",
            "tls",
            "https",
            "certificate verification",
            "self-signed certificate",
            "CONF_VERIFY_SSL",
            "verify_ssl",
            "Home Assistant integration config",
            "manifest.json",
            "requirements_all.txt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Luci device_tracker integration needed to communicate with OpenWrt routers over HTTPS. Some routers used self-signed or otherwise untrusted certificates, causing SSL certificate verification failures and preventing the Luci integration from working when ssl: true was enabled. The fix was to add an explicit configuration option to control HTTPS verification and update the underlying library.\n\nConcretely, the PR modified homeassistant/components/luci/device_tracker.py to import CONF_VERIFY_SSL from homeassistant.const and introduce a DEFAULT_VERIFY_SSL = True constant. The Luci PLATFORM_SCHEMA was extended with an optional verify_ssl configuration parameter, defaulting to True:\n\n  - device_tracker.luci config now accepts:\n      ssl: true/false (default false)\n      verify_ssl: true/false (default true)\n\nThe LuciDeviceScanner (or equivalent scanner class) initializer was updated to pass config[CONF_VERIFY_SSL] into the underlying Luci RPC client, relying on the newer openwrt-luci-rpc API to respect this flag when establishing HTTPS connections.\n\nTo support this new parameter, the manifest for the luci integration (homeassistant/components/luci/manifest.json) was updated to bump the dependency from openwrt-luci-rpc==1.1.1 to openwrt-luci-rpc==1.1.2, and requirements_all.txt was updated accordingly. This ensures Home Assistant installs a version of openwrt-luci-rpc that supports a verify SSL toggle.\n\nAdditionally, code ownership metadata was updated: manifest.json and the root CODEOWNERS file were changed to list both @fbradyirl and @mzdrale as codeowners for homeassistant/components/luci/*, reflecting the contributor's ongoing responsibility for this integration.\n\nAfter these changes, a user can configure a Luci device tracker in configuration.yaml as follows:\n\n  device_tracker:\n    - platform: luci\n      host: ROUTER_IP_ADDRESS\n      username: YOUR_ADMIN_USERNAME\n      password: YOUR_ADMIN_PASSWORD\n      ssl: true\n      verify_ssl: false\n\nThis preserves secure defaults (SSL verification enabled by default) while providing an explicit escape hatch for self-signed or otherwise problematic certificates.",
        "semantic_memory": "More general lessons from this fix:\n\n1. **Configurable TLS/SSL verification is important for device integrations**: Many consumer devices (routers, cameras, IoT hubs) ship with self-signed or otherwise untrusted certificates. If an integration enforces strict certificate verification with no override, users may be blocked from using HTTPS entirely. Providing a `verify_ssl` (or similarly named) configuration option allows users to balance security and practicality.\n\n2. **Maintain secure defaults**: The new `verify_ssl` option defaults to `True`. This ensures that, by default, connections use proper certificate verification, and users must explicitly opt out when they understand and accept the risk (e.g., local network, known device, self-signed cert).\n\n3. **Align integration config with shared constants and patterns**: Using shared constants like `CONF_VERIFY_SSL` keeps configuration consistent across integrations within a codebase. This aids discoverability for users (they can re-use knowledge across integrations) and reduces implementation mistakes.\n\n4. **Propagate configuration through to underlying libraries**: Adding a new config flag is not enough; it must be wired through all the layers to the actual HTTP / RPC client that performs the TLS handshake. In this PR, the Luci device tracker passes `verify_ssl` down to the openwrt-luci-rpc client, which handles the SSL verification behavior.\n\n5. **Update dependencies when adding features that rely on them**: When a new feature depends on functionality in an external library (like a new constructor parameter), the dependency version in the integration's manifest and the global `requirements_all.txt` must be updated in sync, ensuring runtime compatibility.\n\n6. **Code ownership reflects responsibility**: When a contributor becomes a de facto maintainer of an integration, adding them as a codeowner in both manifest and CODEOWNERS files helps route future reviews and issues to someone knowledgeable.\n\n7. **Document user-facing configuration changes**: Any new configuration option (like `verify_ssl`) should be documented in the integration docs, including examples and caveats (e.g., security trade-offs when disabling SSL verification). This PR indicates corresponding documentation changes.",
        "procedural_memory": [
            "How to handle HTTPS certificate verification issues in a device integration and add a verify_ssl option:",
            "Step 1: Identify the failure mode. Look for SSL/TLS-related errors when the integration connects to a device, such as certificate verification failures (self-signed certificate, expired cert, unknown CA). Confirm that the problem is due to strict certificate verification and not basic connectivity or authentication.",
            "Step 2: Decide on configuration semantics. Introduce a boolean configuration flag (commonly named verify_ssl) that controls whether to verify HTTPS certificates. Choose secure defaults (verify_ssl = True) so that normal, correctly configured environments remain secure without extra configuration.",
            "Step 3: Extend the configuration schema. In the integration module (e.g., device_tracker.py or similar), import a shared constant like CONF_VERIFY_SSL if available. Add an optional schema entry:\n  vol.Optional(CONF_VERIFY_SSL, default=True): cv.boolean\nThis should be added alongside existing SSL-related options (e.g., CONF_SSL).",
            "Step 4: Wire the configuration into the integration logic. In the integration's setup or constructor, retrieve the verify_ssl value from the config and pass it through to the underlying HTTP or RPC client that performs the HTTPS requests. Ensure method signatures and client construction support this parameter.",
            "Step 5: Update underlying dependencies. If the required behavior (e.g., a verify parameter) is provided by an external library, ensure that library is updated to a version that supports it. Bump the version in the integration's manifest (e.g., manifest.json) and any central requirements files (e.g., requirements_all.txt). Verify that the new version is compatible and has no breaking changes for your usage.",
            "Step 6: Update documentation and examples. Modify the integration's docs to describe the new configuration option, including an example configuration snippet. Explicitly warn about the security implications of setting verify_ssl to false (susceptibility to MITM attacks, etc.), especially if used outside a trusted local network.",
            "Step 7: Add or update tests. If possible, add tests that cover both verify_ssl = True and verify_ssl = False, ensuring that the underlying client is configured correctly in each case. At minimum, test that configuration parsing and object construction work with the new field.",
            "Step 8: Maintain metadata. If ownership or responsibilities change, update codeowners metadata (e.g., manifest.json codeowners field and repository-level CODEOWNERS) to include the new maintainer, ensuring future changes receive proper review.",
            "Step 9: Run the full test and validation pipeline. For Home Assistant-like projects, run tox, hassfest, and requirement generation scripts as required by project guidelines to ensure the integration and dependency changes are valid and pass CI checks.",
            "Step 10: Communicate breaking and non-breaking aspects. In PR description and release notes, clarify that the default behavior (certificate verification on) remains unchanged, and that the new configuration option provides a backwards-compatible opt-out for users with non-standard certificate setups."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Improved the StackStorm `st2` CLI behavior when invoked with no arguments by printing a custom, user-friendly usage/help message (with examples) instead of a bare argparse error, while still returning a non-zero exit code and writing to stderr. Implemented via a custom USAGE_STRING applied only to the main parser, reorganized subcommand grouping, and added tests.",
        "keywords": [
            "StackStorm",
            "st2",
            "CLI UX",
            "argparse",
            "usage string",
            "help message",
            "no arguments",
            "too few arguments",
            "stderr vs stdout",
            "exit code 2",
            "subparsers",
            "shell.py"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the StackStorm `st2` command-line client behaved poorly when run without arguments. Previously, invoking `st2` with no parameters produced the low-level argparse error `shell.py: error: too few arguments` along with a generic usage line like `usage: shell.py [-h] ... {action,action-alias,...} ...`. This was not very user-friendly for new users and didn't illustrate typical usage patterns.\n\nTo address this, the maintainer introduced a more helpful top-level usage/help message:\n- A new `USAGE_STRING` constant was added in `st2client/st2client/shell.py` describing usage as `Usage: %(prog)s [options] <command> <sub command> [options]` and including practical examples:\n  - `st2 action list --pack=st2`\n  - `st2 run core.local cmd=date`\n  - `st2 --debug run core.local cmd=date`\n- Initially, the custom usage was set directly on `argparse.ArgumentParser(...)`, but this affected all subparsers as well, overriding their own usage text. This was reverted: the main parser is now created with only `description=CLI_DESCRIPTION`.\n- In `Shell.run(self, argv)`, the code now checks `if len(argv) == 0:` and, in that case:\n  - Sets `parser.usage = USAGE_STRING` only at runtime for the main parser.\n  - Writes `parser.format_help()` to `sys.stderr` instead of printing to stdout.\n  - Returns exit code `2` to indicate an error (consistent with argparse behavior for invalid invocation), instead of previously returning `0`.\n\nAdditional improvements:\n- Subcommands were reorganized into a more logical grouping order (e.g., `run`, then `action`, `action-alias`, auth-related commands `auth`, `login`, `whoami`, then API keys, executions, keys, packs, policies, rules, webhooks, timers, runners, sensors, traces, triggers, trigger-instances, rule-enforcements, roles, and role-assignments). This improves readability of the help output but purposely does not sort commands alphabetically to keep related commands together.\n- A minor style change replaced `dict()` with `{}` when initializing `self.commands`.\n- A changelog entry was added under `Changed` documenting that `st2` now prints a more user-friendly usage/help string when no arguments are passed.\n\nUnit tests were added/updated in `st2client/tests/unit/test_shell.py` to cover the new behavior:\n- `test_commands_usage_and_help_strings` verifies that:\n  - Calling `Shell.run([])` returns `2`.\n  - The error output (stderr) contains `Usage:`, `For example:`, `CLI for StackStorm`, and `positional arguments:`.\n  - Calling `Shell.run(['--help'])` returns/raises exit code `0` and prints the same helpful usage text (including examples and positional arguments) to stdout.\n  - Invoking a subcommand without further arguments, e.g. `Shell.run(['action'])`, results in exit code `2` and prints the standard argparse error (`usage`, command list `{list,get,create,update...}`, `error: too few arguments`) to stderr.\n\nThe underlying issue (unfriendly behavior when `st2` is invoked with no arguments) is thus resolved by providing a custom top-level help message with examples, preserving proper exit codes and separation between main parser and subparsers.",
        "semantic_memory": "This fix illustrates several general best practices for designing and implementing command-line interfaces (CLIs) with argparse or similar frameworks:\n\n1. **User-friendly behavior on invalid or incomplete invocation**\n   - When a user runs a CLI with no arguments or otherwise misuses it, the tool should guide them rather than simply state that arguments are missing.\n   - Providing a concise usage line plus concrete examples helps new users quickly understand how to interact with the tool.\n   - It is still important to treat such invocations as errors (non-zero exit code), especially in scripting contexts.\n\n2. **Separation of main parser and subparser usage/help**\n   - Setting `usage=...` on the top-level `ArgumentParser` affects not only the main parser but also subparsers in some designs, potentially overwriting subcommand-specific usage text.\n   - A safer pattern is to:\n     - Initialize the main parser with a description only.\n     - Use `subparsers = parser.add_subparsers()` for subcommands, letting them define their own usage.\n     - Dynamically override `parser.usage` only at the point where you want to customize the top-level usage (e.g., on `len(argv) == 0`), avoiding side effects on subparsers.\n\n3. **Consistent exit codes and output streams**\n   - Usage/help shown due to invalid invocation (e.g., missing required args) should be considered an error, and the program should exit with a non-zero code (argparse uses `2`).\n   - Error messages and usage printed for invalid invocations should go to stderr (`sys.stderr`), not stdout, to avoid polluting normal program output and to allow tools to distinguish errors from standard output.\n   - Explicitly returning the exit code or raising `SystemExit` with the appropriate code is important for scripts and automation.\n\n4. **Help text as documentation and onboarding tool**\n   - Help output should describe not only arguments but also the domain concepts (e.g., \"action\", \"sensor\", \"rule\") in plain language.\n   - Examples are crucial: `For example:` followed by real-world commands demonstrates typical workflows, not just syntax.\n   - Grouping related commands (e.g., run/action/action-alias together, auth/login/whoami together) is often more useful than purely alphabetical ordering; it communicates relationships between commands.\n\n5. **Testing CLI behavior**\n   - CLI behavior (especially argument parsing, help/usage, and exit codes) should be covered by unit tests.\n   - Tests can capture stdout/stderr and assert on:\n     - Exit codes.\n     - Presence of key strings in help/usage output.\n     - Correct behavior of subcommands vs main command.\n   - This avoids regressions where, for example, a change to parser configuration modifies help text or exit codes unintentionally.\n\n6. **Change documentation**\n   - Even seemingly small UX changes to a widely used CLI should be recorded in the changelog, as they can affect automation that parses CLI output or depends on particular exit codes.\n\nThese principles apply to any CLI built with Python's `argparse` or equivalent libraries in other languages. They help create tools that are self-documenting, predictable in scripts, and approachable for new users.",
        "procedural_memory": [
            "To diagnose and improve CLI behavior when invoked with no or invalid arguments, follow these steps:",
            "Step 1: Reproduce and characterize the current behavior",
            "- Run the CLI with no arguments (e.g., `mycli`) and observe:",
            "  - What is printed to stdout and stderr?",
            "  - What is the exit code?",
            "  - Is the error message descriptive for a new user, or is it a low-level framework error like `error: too few arguments`?",
            "- Run the CLI with `--help` and with a subcommand lacking required arguments (e.g., `mycli sub`), and note how help/usage differ in each case.",
            "Step 2: Decide on desired UX and semantics",
            "- Define what should happen when the CLI is invoked without arguments:",
            "  - Should it display a custom usage message with examples?",
            "  - Should it be considered an error (non-zero exit code) or a neutral action (exit code 0)?",
            "- Decide where the output should go:",
            "  - For invalid invocations, plan to write usage/help to stderr.",
            "  - For explicit `--help`, plan to write to stdout.",
            "- Identify a few canonical example commands to include in the top-level help text.",
            "Step 3: Implement a custom usage/help string for the main parser",
            "- In your CLI entrypoint (e.g., `shell.py`), define a clear description and custom usage string, for example:",
            "  - `CLI_DESCRIPTION = 'CLI for <product> ...'`",
            "  - `USAGE_STRING = '''Usage: %(prog)s [options] <command> <sub command> [options]\\n\\nFor example:\\n    %(prog)s foo list\\n    %(prog)s run bar ...'''.strip()`",
            "- Create the main `ArgumentParser` with only the description:",
            "  - `parser = argparse.ArgumentParser(description=CLI_DESCRIPTION)`",
            "- Avoid passing `usage=USAGE_STRING` at initialization if you have subparsers and want them to control their own usage text.",
            "Step 4: Add logic in the main `run(argv)` function",
            "- In the method/function that orchestrates argument parsing (e.g., `Shell.run(self, argv)`):",
            "  - Check for empty arguments:",
            "    - `if len(argv) == 0:`",
            "      - Set `parser.usage = USAGE_STRING` so `format_help()` uses the custom usage.",
            "      - Write help to stderr: `sys.stderr.write(parser.format_help())`.",
            "      - Return or exit with code `2` to indicate an error, staying consistent with argparse conventions.",
            "- Only after handling the empty-arguments case, call any autocomplete hooks and parse actual arguments.",
            "Step 5: Ensure subparsers retain their own usage/help",
            "- Add subparsers using `subparsers = parser.add_subparsers()` and define each command's own branch/command class.",
            "- Verify that invoking a subcommand without required arguments still yields the standard parser error:",
            "  - `usage: mycli sub ...`",
            "  - `error: too few arguments`",
            "- Confirm that these messages are still printed to stderr and exit with code `2`.",
            "Step 6: Group and describe subcommands logically",
            "- Organize the order in which you register subcommands to group related functionality (e.g., run/action/auth together) rather than strictly alphabetically if that improves comprehension.",
            "- For each subcommand, provide a concise description in human terms, not just technical jargon (e.g., \"An invocation of an action\" instead of just \"Execution\").",
            "Step 7: Add or update unit tests for CLI behavior",
            "- Capture and assert behavior for key scenarios:",
            "  - No arguments:",
            "    - Call `run([])` (or equivalent) and assert that it returns `2` (or your chosen error code).",
            "    - Assert that stderr contains:",
            "      - The custom `Usage:` line.",
            "      - `For example:` and the example commands.",
            "      - A description string and `positional arguments:` if applicable.",
            "  - `--help` on main CLI:",
            "    - Call `run(['--help'])` and handle `SystemExit` if raised.",
            "    - Assert exit code `0` and presence of the same usage/help content on stdout.",
            "  - Subcommand with missing arguments:",
            "    - Call `run(['subcmd'])` and assert exit code `2`.",
            "    - Assert stderr contains `usage`, the subcommand's action list or options, and `error: too few arguments`.",
            "- Ensure tests differentiate between stdout and stderr as needed.",
            "Step 8: Verify exit codes and streams in practice",
            "- Manually run the CLI:",
            "  - `mycli` → confirm error-like behavior (stderr + non-zero exit).",
            "  - `mycli --help` → confirm help to stdout and exit 0.",
            "  - `mycli sub` → confirm subcommand-specific usage and error to stderr.",
            "- Optionally test in a shell pipeline or script to ensure behavior is script-friendly.",
            "Step 9: Document the change",
            "- Add a changelog entry under an appropriate section (e.g., `Changed` / `Improved`) summarizing the new behavior:",
            "  - E.g., \"Update CLI to print a more user-friendly usage/help string when no arguments are passed.\"",
            "- Note any impact on exit codes or output streams so downstream users can adapt if necessary.",
            "Step 10: Apply the pattern to other CLIs",
            "- For other projects or commands using argparse or similar tooling, reuse this pattern:",
            "  - Custom top-level usage with examples for empty invocation.",
            "  - Preserve default behavior for subcommands.",
            "  - Clear separation of stdout/stderr and consistent exit codes.",
            "  - Unit tests that lock in expected CLI UX."
        ]
    }
}
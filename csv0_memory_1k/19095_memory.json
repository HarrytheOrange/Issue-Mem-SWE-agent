{
    "search_index": {
        "description_for_embedding": "Introduced a ZHA event foundation in Home Assistant by creating a dedicated ZhaEvent listener per Zigbee cluster instead of having entities fire events directly. The fix adds an EVENTABLE_CLUSTERS list, attaches ZhaEvent listeners on those clusters, and patches the zigpy ClusterPersistingListener with a no-op zha_send_event method to prevent log flooding from missing callbacks.",
        "keywords": [
            "Home Assistant",
            "ZHA",
            "Zigbee Home Automation",
            "zigpy",
            "zha_event",
            "ClusterPersistingListener",
            "EVENTABLE_CLUSTERS",
            "event listener",
            "entity events",
            "log flooding",
            "callback not implemented",
            "binary_sensor zha",
            "integration design"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant ZHA integration was extended with an event foundation that allows Zigbee clusters to emit Home Assistant events without relying on regular entities to do so.\n\nInitially, the implementation added a zha_send_event method to ZHA entities. Binary sensor cluster listeners (e.g., OnOff, LevelControl) would call self._entity.zha_send_event(cluster, command, args), and entities would fire a 'zha_event' on the Home Assistant event bus with details like entity_id, command, and args. However, this design tightly coupled low-level cluster events with high-level entities and risked unwanted or duplicated events.\n\nAdditionally, zigpy's ClusterPersistingListener did not define zha_send_event, which meant that when zigpy's listener model attempted to call this method on listeners that didn't implement it, it produced warning logs. To avoid log flooding, the integration patched ClusterPersistingListener at runtime by attaching a no-op zha_send_event method using types.MethodType.\n\nThe approach was then refactored so that entities no longer fire events. The entity-level zha_send_event methods were changed to pass (no-op), and binary sensor cluster listeners' zha_send_event methods also became no-ops. Instead, a new ZhaEvent class was introduced. ZhaEvent instances are created per relevant cluster and registered as listeners on those clusters via cluster.add_listener(self). When a cluster triggers zha_send_event, the ZhaEvent instance now fires a 'zha_event' on the HA event bus, including a stable 'unique_id', the command, and args, using EventOrigin.remote.\n\nA new EVENTABLE_CLUSTERS list in zha.const collects cluster IDs that should generate events (such as AnalogInput, LevelControl, MultistateInput, and OnOff). During device initialization, the ZHA ApplicationListener calls _attempt_single_cluster_device for each cluster. In this helper, if the cluster ID is in EVENTABLE_CLUSTERS, a ZhaEvent instance is created and stored in a per-device _events dict keyed by the device IEEE. These events are also cleared when devices are removed.\n\nFinally, some cleanup and linting adjustments removed unused imports from ZhaEvent, eliminated an unused unique_id property, and centralized event creation logic in _attempt_single_cluster_device. The result is a cleaner, decoupled event system where specific Zigbee clusters generate 'zha_event' messages directly, entities no longer act as event emitters, and zigpy warnings about missing zha_send_event are eliminated.",
        "semantic_memory": "This PR illustrates several generalizable design lessons for event-driven integrations and third-party library interop:\n\n1. **Separate stateful entities from low-level event sources**: Instead of having high-level entities (like HA entities) directly handle or emit low-level protocol events, introduce a dedicated event abstraction (e.g., ZhaEvent) that attaches to protocol objects (clusters) and exposes events in a format the main application understands. This avoids mixing entity lifecycle and semantics with raw device communications.\n\n2. **Use dedicated listener objects for protocol events**: For systems like Zigbee that expose cluster-based listeners, create a small listener class per cluster that:\n   - Registers with the cluster via add_listener.\n   - Implements the callback methods (e.g., attribute_updated, zdo_command, cluster_command, zha_send_event) even if some are no-ops.\n   - Converts protocol-specific events into application-level events (e.g., HA's async_fire on the event bus).\n\n3. **Centralize eventable-resource definition**: Maintain a single list or mapping of which low-level resources should generate events (EVENTABLE_CLUSTERS). This is preferable to scattering conditional logic across multiple modules. It simplifies future extensions (just append new cluster IDs) and keeps the event system configurable.\n\n4. **Patch or extend third-party listeners to avoid noisy logs**: When a third-party library expects certain methods on listener objects (duck-typed interfaces) and logs warnings if they're missing, it's acceptable to patch the base listener class to add no-op implementations, as long as it's done deliberately and documented. This reduces log spam and aligns the integration with the library's expectations.\n\n5. **Use stable identifiers for events**: Events emitted for devices should provide stable and meaningful identifiers. Here, unique IDs are composed from device manufacturer, model, a tail of the IEEE address, cluster endpoint ID, and optional suffix. Even when manufacturer/model are absent, a fallback ID based on IEEE and endpoint is used. This pattern is broadly applicable when events must be correlated to devices across restarts.\n\n6. **Clean up per-device resources on removal**: When devices are removed from a network, any attached event handlers, listeners, or event bookkeeping (like the _events dict keyed by device IEEE) should be cleaned up to prevent leaks and stale references.",
        "procedural_memory": [
            "Step-by-step instructions on how to design and implement a foundation for protocol-level events in a Home Assistant-like integration:",
            "Step 1: Identify event-capable protocol components\n- Determine which low-level objects (e.g., Zigbee clusters) should be capable of generating application-level events.\n- Extract their identifiers (e.g., cluster IDs) and define them in a dedicated structure such as EVENTABLE_CLUSTERS.",
            "Step 2: Create an event listener abstraction\n- Implement a small class (e.g., ZhaEvent) that:\n  - Accepts the application context (hass), and the protocol object (cluster) in its constructor.\n  - Calls cluster.add_listener(self) to register itself.\n  - Builds a stable internal identifier (e.g., a unique_id constructed from manufacturer, model, IEEE tail, endpoint ID, and optional suffix).",
            "Step 3: Implement the callback interface\n- Implement the callback methods that the protocol layer expects, even if some are no-ops:\n  - attribute_updated(self, attribute, value)\n  - zdo_command(self, tsn, command_id, args)\n  - cluster_command(self, tsn, command_id, args)\n  - zha_send_event(self, cluster, command, args)\n- In zha_send_event (or equivalent), translate the protocol event into an application event. For Home Assistant:\n  - Call hass.bus.async_fire('zha_event', { 'unique_id': ..., 'command': command, 'args': args }, EventOrigin.remote).",
            "Step 4: Decouple entities from event emission\n- If entities previously emitted events directly:\n  - Replace their zha_send_event (or similar) implementations with no-ops to prevent duplicate or unwanted events.\n  - Ensure cluster listeners that refer to entities' zha_send_event methods are also converted to no-ops or removed.\n- The event flow should be: protocol object -> event listener class -> application bus, not entity -> bus.",
            "Step 5: Attach event listeners when provisioning protocol objects\n- During device initialization/cluster discovery, centralize event listener creation in existing setup paths:\n  - In a function like _attempt_single_cluster_device(endpoint, cluster, profile_clusters, ...), first check if cluster.cluster_id is in EVENTABLE_CLUSTERS.\n  - If yes, create a ZhaEvent(hass, cluster) and store it for bookkeeping (e.g., in a dict keyed by device IEEE).\n- Only after creating the event listener, proceed with normal cluster-to-entity mapping logic.",
            "Step 6: Handle cleanup on device removal\n- Keep a mapping from device identifiers (e.g., IEEE) to associated event listener instances or metadata (e.g., hass.data[DATA_ZHA][DATA_ZHA_CORE_EVENTS]).\n- When a device is removed:\n  - Remove its entities.\n  - Remove or clear its associated event entries (e.g., popping the device IEEE from the events dict) to avoid leaks or stale state.",
            "Step 7: Patch third-party listener classes to avoid log flooding\n- If the underlying library (e.g., zigpy) has a base listener class (ClusterPersistingListener) that expects a method like zha_send_event, but doesn't implement it:\n  - Define a local no-op implementation:\n    - def zha_send_event(self, cluster, command, args):\n        pass\n  - Attach it to the class via monkey-patching (for Python):\n    - from zigpy.appdb import ClusterPersistingListener\n    - import types\n    - ClusterPersistingListener.zha_send_event = types.MethodType(zha_send_event, ClusterPersistingListener)\n- This prevents warnings/errors when the library tries to call zha_send_event on listeners that don't implement it.",
            "Step 8: Validate the behavior\n- Verify that:\n  - 'zha_event' events are fired on the application bus when the relevant clusters receive commands.\n  - Entities are no longer directly responsible for emitting these events.\n  - No warnings or errors appear in logs about missing zha_send_event methods on zigpy listeners.\n  - Device addition/removal properly adds/removes event listeners and associated bookkeeping."
        ]
    }
}
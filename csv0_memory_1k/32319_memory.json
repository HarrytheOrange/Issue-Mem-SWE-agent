{
    "search_index": {
        "description_for_embedding": "Bug fix in Home Assistant Lovelace dashboards: when Home Assistant is in safe mode, saving or deleting the Lovelace config via the websocket API would persist the temporary safe mode UI and overwrite the real dashboard configuration in .storage. The fix adds a safe_mode check in async_save and async_delete to block these operations and raise HomeAssistantError, with tests verifying that lovelace/config/save and lovelace/config/delete fail in safe mode.",
        "keywords": [
            "Home Assistant",
            "Lovelace",
            "safe mode",
            ".storage",
            "dashboard config lost",
            "prevent saving in safe mode",
            "lovelace/config/save",
            "lovelace/config/delete",
            "HomeAssistantError",
            "websocket API",
            "state persistence guard"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, users of Home Assistant experienced data loss of their Lovelace dashboard configuration after the system entered safe mode. When configuration problems caused Home Assistant to start in safe mode, Lovelace would generate and show a minimal 'safe mode' dashboard stored via the standard Lovelace storage path (.storage/lovelace). The websocket endpoints lovelace/config/save and lovelace/config/delete remained fully functional in safe mode, so if a user attempted to save or delete their Lovelace config during that time, the temporary safe mode configuration was written to .storage and overwrote their real dashboard, or removed it entirely. \n\nThe root cause was that the Lovelace dashboard storage layer (homeassistant/components/lovelace/dashboard.py) did not check the global safe_mode flag before performing mutating operations (save/delete). The application treated safe mode as a normal runtime state regarding configuration persistence. \n\nThe fix added explicit checks in Dashboard.async_save and Dashboard.async_delete: if hass.config.safe_mode is true, these methods now raise HomeAssistantError (with messages 'Saving not supported in safe mode' and 'Deleting not supported in safe mode'). This prevents any write or delete to Lovelace config while the system is in safe mode, avoiding accidental persistence of the temporary safe mode UI and protecting the user's real configuration in .storage. \n\nTests were added in tests/components/lovelace/test_dashboard.py within test_lovelace_from_storage: after confirming config_not_found for the normal load in safe mode, the test now calls the websocket commands 'lovelace/config/save' and 'lovelace/config/delete' and asserts that both responses have success == False. This verifies that the websocket API correctly surfaces the failure caused by the new safe_mode guard logic.",
        "semantic_memory": "This fix illustrates an important pattern: when an application enters a degraded, diagnostic, or 'safe' mode, any operations that persist or destructively modify user state must be carefully controlled or disabled. If transient or fallback configurations generated during error handling are allowed to be saved as canonical state, they can overwrite valid user data and cause data loss.\n\nGeneralizable lessons:\n- Safe or recovery modes should be treated as read-only with respect to critical user configuration unless there is a very clear and well-justified exception. Write paths (save, delete, update) must explicitly check for the mode and either reject the operation or route it to a separate, non-destructive storage area.\n- State-altering APIs (e.g., config save/delete endpoints) need explicit guards for global application modes (safe_mode, maintenance_mode, readonly_mode, etc.), not just for user permissions. Relying on the UI to 'not expose' dangerous actions is insufficient; back-end enforcement is required.\n- Temporary UI or config used during error states should not share the same persistence mechanism as the primary configuration unless there is strong separation (e.g., different keys or files) or protections against overwriting.\n- When adding such protections, tests should target the public-facing API (here the websocket endpoints) and assert failure semantics when in the restricted mode, ensuring the guards are enforced end-to-end.\n\nMore broadly, this is an example of designing for failure modes: the system must remain safe for user data even when it is already in a faulty state.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the failure mode and its impact\n- Observe user reports of lost or overwritten configuration, especially correlated with a special runtime mode (e.g., safe mode, recovery mode, maintenance mode).\n- Reproduce the scenario: start the application in that special mode, perform standard user operations (save config, delete config, modify settings), and see whether transient state is being persisted to the normal storage location.",
            "Step 2: Locate the persistence layer and APIs\n- Find the code responsible for saving and deleting configuration or other critical data (e.g., async_save, async_delete, update methods, or DB write paths).\n- Identify the external interfaces that trigger these operations (REST endpoints, websocket commands, CLI, etc.). For this case, it was the Lovelace dashboard storage class and the websocket commands 'lovelace/config/save' and 'lovelace/config/delete'.",
            "Step 3: Check for mode awareness and guards\n- Inspect the write/delete operations for checks against global modes or flags (e.g., hass.config.safe_mode, app.read_only, maintenance_mode).\n- If such flags exist elsewhere in the codebase (for logging or UI changes) but are not applied in the persistence layer, this is a strong hint that writes are not properly guarded.",
            "Step 4: Implement defensive checks\n- Add explicit guards at the lowest reasonable level where state is mutated (e.g., in the storage/DAO class rather than only in the UI layer).\n- Example pattern (translated from this fix):\n  - In the save method: if safe_mode_flag: raise DomainSpecificError(\"Saving not supported in safe mode\").\n  - In the delete method: if safe_mode_flag: raise DomainSpecificError(\"Deleting not supported in safe mode\").\n- Ensure the guard executes before any mutations are made (no partial writes).",
            "Step 5: Propagate behavior through public APIs\n- Verify that higher-level APIs (websocket, REST) correctly surface these errors to clients (e.g., respond with success == false and an appropriate error code/message).\n- Do not silently ignore the operation; explicitly fail so the client can inform the user that the operation is not allowed in the current mode.",
            "Step 6: Add regression tests\n- Write tests that explicitly set the application into the special mode (e.g., mark hass.config.safe_mode = True or use the official way of entering that mode).\n- Call the external API endpoints that perform save/delete operations.\n- Assert that the responses indicate failure and that no changes occur in underlying storage (e.g., no new file content, no overwritten configuration).\n- Also keep or add tests for normal mode to ensure that save/delete still work when the mode is not active.",
            "Step 7: Review related code paths\n- Search for other write paths that might bypass the newly added guards (e.g., alternative storage implementations, migration scripts, admin-only APIs).\n- Apply the same safe-mode or read-only guards consistently, or centralize the logic in a shared abstraction.",
            "Step 8: Communicate behavior to users\n- Document that in safe/degraded mode certain operations are intentionally disabled to protect data.\n- Optionally provide guidance on how to exit safe mode, restore from backup, or manually recover configuration, to minimize frustration when users encounter the restriction."
        ]
    }
}
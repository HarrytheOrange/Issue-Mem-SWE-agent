{
    "search_index": {
        "description_for_embedding": "Home Assistant Envisalink entities were registering dispatcher callbacks in __init__, before being added to hass. This moved async_dispatcher_connect calls into async_added_to_hass and switched to using self.hass, aligning with the async entity lifecycle and avoiding side effects during construction.",
        "keywords": [
            "Home Assistant",
            "Envisalink",
            "async_dispatcher_connect",
            "async_added_to_hass",
            "entity lifecycle",
            "alarm_control_panel",
            "binary_sensor",
            "sensor",
            "dispatcher callbacks",
            "__init__ side effects",
            "SIGNAL_KEYPAD_UPDATE",
            "SIGNAL_PARTITION_UPDATE",
            "SIGNAL_ZONE_UPDATE"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Envisalink integration for Home Assistant (alarm_control_panel, binary_sensor, and sensor platforms), dispatcher callbacks were being registered inside the entity constructors (__init__). The code passed a hass instance into the constructor and immediately called async_dispatcher_connect(hass, SIGNAL_*, self._update_callback). This approach violated Home Assistant's async entity lifecycle design, where entities should avoid doing I/O or registering callbacks before they are fully added to hass. It can also lead to subtle bugs, such as callbacks referencing an entity that hass does not yet know about, or incorrect use of hass references.\n\nThe fix introduced an async lifecycle hook method, async_added_to_hass, on each relevant entity class. The dispatcher connection logic was moved from __init__ into async_added_to_hass, and the calls were updated to use self.hass instead of the constructor parameter hass. For example, async_dispatcher_connect(hass, SIGNAL_KEYPAD_UPDATE, ...) became async_dispatcher_connect(self.hass, SIGNAL_KEYPAD_UPDATE, ...). async_added_to_hass was decorated as a coroutine (@asyncio.coroutine) and documented with a simple \"Register callbacks.\" docstring. This change ensures that signal subscriptions are created only after the entity is properly registered with Home Assistant, aligning with the framework's expectations and preventing lifecycle-related issues.",
        "semantic_memory": "In asynchronous, event-driven frameworks (such as Home Assistant), entities or components have a defined lifecycle: construction, registration/addition to the main application, and teardown. Side-effectful operations like registering dispatcher callbacks, subscribing to events, or interacting with the main application object should generally not occur in the constructor (__init__). Instead, they belong in a dedicated lifecycle method that the framework invokes after the entity has been fully added to the system (e.g., async_added_to_hass in Home Assistant).\n\nKey principles:\n- Constructors should primarily initialize internal state and store references; they should avoid registering callbacks, performing I/O, or relying on the application context being fully available.\n- Framework-provided hooks (async_added_to_hass, on_start, on_mount, etc.) are the correct place to attach event listeners or dispatcher callbacks so that the entity is fully integrated before it starts reacting to events.\n- When a framework provides a canonical reference to the application object (like self.hass), prefer that over passing in an external reference during construction. This ensures consistency and makes the lifecycle and ownership clearer.\n- Moving dispatcher/event subscription out of __init__ and into the appropriate lifecycle method helps prevent race conditions, dangling references, and entities reacting to events before they are ready.",
        "procedural_memory": [
            "When diagnosing issues where entities are not updating correctly, or callbacks seem to fire at the wrong time, first inspect where event/dispatcher subscriptions are registered.",
            "Step 1: Locate any use of dispatcher/event subscription APIs (e.g., async_dispatcher_connect, signal handlers, or event bus subscriptions) in the entity or component code.",
            "Step 2: Check whether these subscriptions are being set up inside __init__ or other early construction code. If they are, note that this may violate the intended lifecycle of the framework.",
            "Step 3: Identify the framework's recommended lifecycle hook for post-addition initialization (e.g., async_added_to_hass in Home Assistant, componentDidMount in React, on_startup in other frameworks).",
            "Step 4: Create/implement that lifecycle method if it does not already exist on the entity/component. Ensure it is defined with the correct async/sync signature (e.g., @asyncio.coroutine or async def for async hooks).",
            "Step 5: Move the dispatcher/event subscription logic from __init__ into this lifecycle method. For Home Assistant, move async_dispatcher_connect calls into async_added_to_hass.",
            "Step 6: Replace any use of an externally passed application reference (e.g., hass passed into __init__) with the framework-provided instance reference (e.g., self.hass) within the lifecycle method.",
            "Step 7: Ensure the lifecycle method's docstring/comments clearly describe that it registers callbacks or other side-effectful operations, so future maintainers understand why the code is there.",
            "Step 8: Test the integration: start the system, verify that entities are created without errors, and confirm that dispatcher callbacks fire as expected (e.g., alarm keypad updates, partition updates, zone updates).",
            "Step 9: If there are cleanup requirements (unsubscribing from signals on removal), verify whether the framework provides a corresponding tear-down hook and implement symmetric cleanup there.",
            "Step 10: Apply this pattern consistently across similar entities and modules to avoid lifecycle-related bugs and keep the code aligned with the framework's best practices."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Patch release 0.96.4 for Home Assistant that fixes several climate integration bugs and updates dependencies. Netatmo climate now interpolates raw battery millivolt readings into percentage and stores the minimum battery percentage per room. Evohome climate/water_heater scheduling and hvac_action logic are corrected and optimized to avoid unnecessary I/O, with proper setpoints handling and hvac_mode mappings. Honeywell climate migration is fixed: supported_features, min/max temperatures, target temperatures, hvac_action (including fan), aux heat, and device attributes now reflect the real device capabilities using raw_* data fields. Daikin climate presets are corrected so away uses PRESET_AWAY / PRESET_NONE and the pydaikin set_holiday API is used instead of writing raw attributes. Sonos and frontend libraries are bumped (pysonos 0.0.22, frontend 20190721.1), as is pyatmo 2.1.2, and the core version is bumped to 0.96.4.",
        "keywords": [
            "Home Assistant",
            "0.96.4",
            "climate integration bugfix",
            "Netatmo battery level interpolation",
            "evohome schedule setpoints",
            "evohome hvac_action",
            "Honeywell supported_features",
            "Honeywell hvac_action fan",
            "Honeywell min_temp max_temp",
            "Daikin preset modes",
            "Daikin holiday mode",
            "pydaikin 1.5.1",
            "pysonos 0.0.22",
            "pyatmo 2.1.2",
            "frontend 20190721.1",
            "dependency bump",
            "API behavior change",
            "hvac_mode mapping",
            "current_hvac_action",
            "battery percentage conversion"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the 0.96.4 patch release, multiple small but user-visible issues across several climate integrations were addressed.\n\nFor the Netatmo climate integration, the system had been treating raw battery values (millivolts) as if they were already user-friendly values. This caused misleading battery levels in the UI. The fix introduced an interpolate() helper that maps the device-specific mV thresholds (for NA_THERM and NA_VALVE modules) to a 0–100% scale using linear interpolation between defined battery categories ('full', 'high', 'medium', 'low', 'empty'). The update loop now converts each module’s raw battery reading to a percentage and stores the lowest percentage per room as the room’s battery_level.\n\nThe evohome integration had several migration issues. Previously, setpoints were calculated every update from the live schedule, and temporary overrides used direct calls to schedule() each time, causing unnecessary I/O and some edge-case bugs. The refactor added a cached _schedule on EvoDevice, exposed a setpoints property that derives current/next setpoints from this cached schedule, and a _update_schedule() method that only refreshes the schedule when needed (e.g., when there is no schedule yet or the 'next' switchpoint has passed). Zone and water heater temporary overrides now use setpoints['next']['from'] for their until time only after ensuring _schedule is populated. The TCS hvac_modes list was corrected to be based on HA_HVAC_TO_TCS. hvac_action logic for zones was also corrected: previously, when current_temperature was equal to target_temperature, the system erroneously reported CURRENT_HVAC_HEAT; now it treats target < current as IDLE and otherwise HEAT, accounting for rounding.\n\nThe Honeywell (SomeComfort) climate migration also had inconsistencies. Supported features did not correctly reflect device capabilities, hvac_action mapping did not handle fan-only correctly, and target temperatures and min/max limits were not fully aligned with the device’s own configuration. The fix relies more consistently on device.raw_ui_data, raw_fan_data, and raw_dr_data: supported_features now include SUPPORT_PRESET_MODE, SUPPORT_TARGET_TEMPERATURE, and SUPPORT_TARGET_TEMPERATURE_RANGE by default, optionally adding SUPPORT_TARGET_HUMIDITY and SUPPORT_FAN_MODE depending on flags. hvac_modes are derived from which Honeywell modes the device actually supports. hvac_action now maps device equipment_output_status so 'off' maps to idle, 'fan' to CURRENT_HVAC_FAN, and heat/cool to their respective actions; when hvac_mode is OFF, hvac_action is None. min_temp and max_temp use the correct heat/cool limits for the active mode. target_temperature, target_temperature_low, and target_temperature_high now reflect proper values depending on whether the device is in HEAT, COOL, or HEAT_COOL. Aux heat off behavior was also corrected: instead of always forcing 'auto', it now restores HEAT if available, otherwise OFF. Additional diagnostic logging of raw data was added.\n\nFor Daikin, preset modes were misaligned with how the devices represent holiday/away state. Previously, presets used PRESET_AWAY/PRESET_HOME and wrote to the underlying attribute like any other setting. The fix changes the mapping to PRESET_AWAY/PRESET_NONE, and async_set_preset_mode now calls the pydaikin set_holiday() API with 'on' or 'off' (using new ATTR_STATE_ON/ATTR_STATE_OFF constants) instead of writing the raw parameter. The logic to read the preset from the device now compares represented 'holiday' state to determine away vs none. This updates both the behavior and the documentation assumptions about presets.\n\nAdditionally, third-party dependency versions were bumped to fix integration issues and keep compatibility: frontend to home-assistant-frontend 20190721.1, pyatmo to 2.1.2, pydaikin to 1.5.1, and pysonos to 0.0.22. Finally, the core Home Assistant version was incremented to 0.96.4 to ship these fixes.",
        "semantic_memory": "This patch embodies several general lessons about integrating with external devices and libraries.\n\n1. Raw device data must be normalized into user-friendly units. Netatmo’s raw battery millivolt readings are not useful as-is; mapping them to a consistent 0–100% scale using device-specific thresholds and linear interpolation creates a clearer UX. Similar patterns apply to any sensor where vendors expose only raw voltages, ADC counts, or other low-level metrics.\n\n2. Scheduling and setpoints benefit from caching and computed views. Evohome exposes a schedule with daily switchpoints. Rather than recompute switchpoints or hit the API every time, the integration caches the schedule (_schedule) and exposes a computed property (setpoints) that derives the current and next switchpoints. It lazily refreshes the schedule only when necessary (e.g., when the next switchpoint has passed). This pattern—cache raw data, expose computed views—reduces I/O and simplifies state management.\n\n3. hvac_mode and hvac_action are separate concepts and must be handled consistently. hvac_mode expresses the desired mode (off/heat/cool/heat_cool/auto), while hvac_action expresses current physical behavior (heating/cooling/idle/fan/off). For both evohome and Honeywell, bugs emerged from conflating these concepts or mis-mapping vendor-specific states to Home Assistant’s enums (e.g., Honeywell 'fan' should be CURRENT_HVAC_FAN, not IDLE; 'off' may still map to idle for hvac_action, with hvac_mode OFF yielding hvac_action None). Getting this mapping right avoids confusing UI states.\n\n4. Supported features and mode lists must reflect actual device capabilities. For Honeywell, not all thermostats support all modes or fan control. By deriving hvac_modes and fan modes from the device’s raw UI and fan metadata, the integration avoids advertising unsupported options and eliminates runtime errors or no-ops in the UI. This is a general best practice: feature flags coming from the device should drive which entities and options are exposed.\n\n5. Prefer vendor-provided high-level methods over direct parameter writes. The Daikin fix moves from writing a low-level attribute to using the pydaikin set_holiday() method. Leveraging the library’s higher-level API abstracts away vendor quirks and ensures that related state is updated consistently. This is applicable to any integration with a maintained client library: defer to the library for complex features instead of rolling your own protocol logic.\n\n6. Align preset/override behavior with underlying schedules and controller modes. Evohome zones inherit schedules from controllers and can have temporary or permanent overrides. Correct behavior requires understanding how the controller’s operating mode (e.g., Eco, HeatingOff) interacts with per-zone overrides and ensuring overrides use the correct 'until' times based on schedule. The pattern is: derive schedule-aware boundaries first, then apply overrides consistent with the vendor’s semantics.\n\n7. Dependency bumps are not just version churn; they may unlock or require behavior changes. Updating pydaikin, pysonos, pyatmo, and the frontend packages is part of maintaining compatibility with vendor APIs and improving stability. But these bumps may introduce new methods (e.g., set_holiday) or deprecate old behavior, so code must be updated alongside version changes.\n\nOverall, the patch emphasizes strong typing and helpers (ConfigType, HomeAssistantType), use of raw_* device data structures for accurate capabilities, thoughtful scheduling logic, and clear distinctions between desired mode, current action, and presets.",
        "procedural_memory": [
            "When climate integrations misreport battery, mode, or preset state, follow a structured debugging and fix process:",
            "Step 1: Clarify the symptom and gather raw device data.\n- Identify what is wrong from the user perspective (e.g., battery shows 100% until it suddenly drops; hvac_action displays HEAT when radiator is idle; away preset does nothing).\n- Add debug logging of the device’s raw data structures (e.g., raw_ui_data, raw_fan_data, raw_dr_data for Honeywell, or Netatmo’s raw battery readings) to compare raw values with reported Home Assistant states.",
            "Step 2: Understand the vendor’s data model and thresholds.\n- Consult the device/library documentation (Netatmo, evohome, Honeywell, Daikin) to understand how they represent states: battery thresholds, schedule structure, equipment output status, holiday/away flags, mode codes.\n- Identify vendor enums and fields that should map to Home Assistant abstractions (hvac_mode, hvac_action, presets, min/max temperature).",
            "Step 3: Normalize raw values to user-friendly units.\n- For sensors like battery voltage, define device-specific thresholds for 'full', 'high', 'medium', 'low', 'empty'.\n- Implement an interpolation function that maps raw values to 0–100%.\n- Store and expose the normalized percentage rather than raw mV/ADC values, and ensure aggregation logic (e.g., lowest module battery per room) uses percentages.",
            "Step 4: Cache schedules and expose computed setpoints.\n- For schedule-based systems like evohome, maintain a cached schedule object (e.g., _schedule) rather than calling the API for every update.\n- Implement a property like setpoints that, given the schedule, computes the current and next switchpoints.\n- Refresh the schedule only if absent or if the 'next' switchpoint is in the past, to avoid unnecessary I/O.",
            "Step 5: Correct hvac_mode and hvac_action mappings.\n- Define explicit mappings between vendor modes and Home Assistant hvac_mode/hvac_action enums.\n- Ensure hvac_modes only lists modes actually supported by the device (derived from raw UI data or capability flags).\n- Implement hvac_action such that:\n  - When hvac_mode is OFF, hvac_action is usually None.\n  - Use vendor-specific equipment status (e.g., 'heat', 'cool', 'fan', 'off') to map to CURRENT_HVAC_HEAT, COOL, FAN, or IDLE.\n  - For thermostat-style logic, consider: if target_temperature <= min_temp, treat as OFF; otherwise, compare target_temperature vs current_temperature to classify HEAT vs IDLE, taking rounding effects into account.",
            "Step 6: Align target temperatures and limits with device constraints.\n- Derive min_temp and max_temp from the device’s own configuration fields, using mode-specific bounds (e.g., CoolLowerSetptLimit vs HeatUpperSetptLimit for Honeywell).\n- In HEAT_COOL mode, expose target_temperature_low and target_temperature_high; in single-mode heating or cooling, expose only target_temperature.\n- Ensure that UI operations on temperatures respect these limits and that reported values match what the device accepts.",
            "Step 7: Ensure presets and overrides use official APIs.\n- For preset modes like 'away', avoid writing raw parameters directly when the library offers a dedicated method (e.g., pydaikin’s set_holiday('on'/'off')).\n- Map Home Assistant presets (PRESET_AWAY, PRESET_NONE/HOME) to the vendor-specific mechanisms (holiday flag, away mode, schedule overrides).\n- For temporary overrides, compute 'until' timestamps based on the next scheduled switchpoint using the cached schedule and ensure the correct formatting for the vendor API.",
            "Step 8: Reconcile supported_features and capabilities.\n- Use raw capability flags (e.g., canControlHumidification, hasFan, SwitchEmergencyHeatAllowed) to build the supported_features bitmask dynamically.\n- Only advertise fan modes, aux heat, or humidity control when confirmed supported.\n- Adjust device_state_attributes to include only meaningful diagnostic fields (e.g., fan action, demand response phase).",
            "Step 9: Validate after dependency bumps.\n- When bumping third-party libraries (pyatmo, pydaikin, pysonos, frontend), run integration tests and spot check key behaviors (authentication, state updates, control commands).\n- Confirm that new APIs (like set_holiday) are used where appropriate and that deprecated behaviors are not relied upon.",
            "Step 10: Add logging and versioning.\n- Add targeted debug logs around updated areas (e.g., log latestData/raw data after updates) to ease future debugging.\n- Bump the core version and relevant manifests so downstream systems and users can correlate observed behaviors with the code containing these fixes."
        ]
    }
}
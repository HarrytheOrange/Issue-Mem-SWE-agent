{
    "search_index": {
        "description_for_embedding": "Home Assistant PR attempting to add support for Raspberry Pi I²C GPIO expanders (MCP23017/18, PCF8574) as switch and binary_sensor platforms. Implements a custom rpi_i2c_chips abstraction, polling thread, and HAExpander mixin directly inside homeassistant/components, using smbus-cffi. PR was rejected/closed because maintainers require that device‑specific I²C driver code live in a separate, reusable library published on PyPI (or reuse existing libraries like Adafruit CircuitPython), rather than bundling a custom driver in core.",
        "keywords": [
            "Home Assistant",
            "Raspberry Pi",
            "I2C expander",
            "MCP23017",
            "MCP23018",
            "PCF8574",
            "binary_sensor",
            "switch",
            "smbus-cffi",
            "polling thread",
            "hardware integration",
            "external library",
            "PyPI requirement",
            "Adafruit CircuitPython"
        ]
    },
    "agent_memory": {
        "episodic_memory": "A contributor implemented a new Home Assistant integration to manage GPIOs connected via I²C port expanders on a Raspberry Pi, specifically MCP23018 and PCF8574 (and implicitly MCP23017 via a subclass). The PR introduced a substantial amount of new code directly under homeassistant/components:\n\n- A generic rpi_i2c_chips package with an Expander base class, concrete drivers for MCP23018 and PCF8574, a Register helper for bitfield access, and a PollWatcher thread that periodically reads all configured expanders and enqueues input changes.\n- An HA-specific rpi_i2c_ha_expanders module providing HAExpanderMixIn to map individual expander pins to Home Assistant entities (ToggleEntity for switches and BinarySensorDevice for sensors), handle mask calculations (inputs/outputs/pull-ups), and verify/reconfigure outputs if they appear reset.\n- A core component rpi_i2c_expanders that initializes the I²C bus via smbus-cffi, maintains a ManagedChips registry (per I²C address), starts the PollWatcher on home assistant start, and forwards detected input changes to binary_sensor entities via callbacks.\n- Platform modules binary_sensor.rpi_i2c_expanders and switch.rpi_i2c_expanders, which define a YAML schema with a chips: mapping (address -> { hw: MCP23018/PCF8574, ports: {pin: name}, invert_logic_ports: [...] }), look up or create managed HAExpander instances per I²C address, and create ExpanderSensor/ExpanderSwitch entities bound to specific pins. The switches drive outputs by setting entity state and calling ha_expander.update_outputs(), while binary sensors are event-driven from the poll watcher (should_poll=False).\n\nThe code followed Home Assistant style norms (Black formatting, flake8 fixes, .coveragerc updates) and pinned smbus-cffi==0.5.1 in REQUIREMENTS and requirements_all.txt. The author also debated design choices with another contributor: the PR used an external polling thread reading all pins in one I²C transaction at ~20 Hz on a Raspberry Pi 1, with output verification and automatic chip reconfiguration on perceived resets. This was contrasted with an alternative PR that relied on Home Assistant's built-in polling per pin and reconfigured the chip less aggressively. They also discussed potential future support for interrupts instead of polling, acknowledging that not all users can spare GPIO interrupt lines.\n\nDuring review, maintainers pointed out that a lot of device-specific logic lived directly in the Home Assistant repository. They requested that all low-level expander code (MCP23018/17, PCF8574, polling, register helpers) be moved into a separate Python library, published on PyPI, and then consumed by a much thinner Home Assistant integration. Another maintainer suggested reusing Adafruit's CircuitPython MCP230xx library from PyPI instead of custom drivers, which would drastically reduce the amount of in-repo code. Because this refactoring had not been done, the reviewer closed the PR with guidance: extract chip-specific code into an external library first, then reopen an HA PR that depends on it. The original author later commented they had working code locally for months and intended to revisit the integration, but this particular PR was not merged.",
        "semantic_memory": "Generalizable lessons from this PR revolve around how to structure hardware integrations and driver code in a large home-automation project like Home Assistant:\n\n1. **Driver code belongs in reusable libraries, not core app code**: Device-specific protocol handling (register layouts, bitfields, mask arithmetic, bus IO, etc.) should live in a separate, importable library (ideally on PyPI) that can be tested and versioned independently. The application (Home Assistant) should only contain a thin integration layer that:\n   - imports and configures the driver library,\n   - translates between application entities (switches, sensors) and low-level I/O operations,\n   - exposes configuration schemas and handles lifecycle events.\n   This separation improves reuse (other projects can use the driver), reduces maintenance burden on the main app, and keeps the core repo focused on integration, not hardware support.\n\n2. **Prefer existing, well-tested libraries over custom drivers**: When a reputable library already exists (eg, Adafruit CircuitPython MCP230xx for MCP23017/18 on PyPI), it's better to depend on it than to implement a custom driver. This reduces bugs, leverages community testing, and avoids re-implementing complex behavior like interrupt handling or subtle timing issues.\n\n3. **Batch operations and minimal bus traffic are important for I²C devices**: I²C bus operations are relatively slow and may be shared among many devices. Polling each pin individually (one I²C transaction per pin) is inefficient, especially on lower-powered devices like Raspberry Pi 1. Designing the driver to read or write entire GPIO port registers in a single transaction and then distributing that state to per-pin entities is more efficient and scales better.\n\n4. **Polling architecture vs event-driven interrupts**: For GPIO expanders that support interrupts (MCP23017/18, PCF8574), there is a tradeoff between continuous polling and interrupt-driven updates:\n   - Polling at a fixed interval is simpler and avoids extra wiring (no dedicated interrupt GPIO), but consumes CPU and bus bandwidth and may miss very short pulses.\n   - Interrupts provide immediate change notification, reduce bus traffic, and can latch states, but require more hardware wiring and more complex driver logic.\n   A robust design may support both, with polling as a fallback where interrupts are not wired.\n\n5. **Use a central state manager for multi-entity devices**: For multi-channel hardware like port expanders, it's useful to have an intermediate manager (ManagedChips + HAExpanderMixIn) that:\n   - tracks per-address chips and their configuration masks (inputs, outputs, pull-ups),\n   - knows which application entity is attached to which pin,\n   - applies consistent hardware configuration on startup and after resets,\n   - provides shared operations like 'update all outputs based on current entity states' and 'route input changes to the right entities'.\n   This avoids each entity independently poking at the bus and ensures coherent configuration.\n\n6. **Background threads and event delivery**: Hardware polling loops are often implemented in dedicated threads so they do not block the main event loop. These threads can publish changes via thread-safe queues to a dispatcher that calls into the application layer (here: scheduling HA state updates). Care must be taken to:\n   - avoid unbounded queues (to prevent memory growth),\n   - guard against transient I²C errors (catch OSError, decide on retry or reset),\n   - respect the host application's threading model (eg, some frameworks require state changes to be scheduled on the main thread).\n\n7. **Coding standards matter in large OSS projects**: Before a feature can be seriously reviewed, it needs to comply with repository standards: Black formatting, flake8 cleanliness, correct REQUIREMENTS pinning, coverage configuration, and adherence to architectural guidelines (no large new subsystems without discussion). Lack of architectural alignment (eg, embedding a bespoke driver stack in the core tree) is grounds for closing a PR even if the feature works locally.\n\nOverall, the core idea is that a home-automation integration should separate concerns: a small, well-bounded HA integration layer on top of an external, reusable, bus and register driver library, with efficient bus usage and thoughtful event delivery architecture.",
        "procedural_memory": [
            "Step-by-step instructions on how to design, submit, and adjust a hardware integration similar to this I²C expander case in a project like Home Assistant:",
            "Step 1: Clarify the architectural expectations of the host project.",
            "- Before writing large amounts of code, read the project's developer docs and existing hardware integrations to understand where device-specific logic is allowed to live.\n- In Home Assistant, the pattern is: low-level driver in a separate library (PyPI), thin component/platform in the HA repo.",
            "Step 2: Check for existing driver libraries.",
            "- Search PyPI and GitHub for your device (eg, 'MCP23017 Python', 'PCF8574 Python').\n- If a well-maintained library exists (eg, Adafruit CircuitPython MCP230xx), evaluate if it fits your needs.\n- Prefer using that library rather than building your own driver in the app repository.",
            "Step 3: If needed, create a separate driver library.",
            "- If no suitable library exists, create a standalone Python package (eg, `my-i2c-expanders`).\n- Implement the device-specific logic there: register maps, bitfield helpers, I²C bus operations via smbus or similar, and optional polling/interrupt support.\n- Add tests and documentation. Publish the library to PyPI with semantic versioning.",
            "Step 4: Design a clean abstraction for multi-channel hardware.",
            "- Represent multi-pin devices with a class that exposes operations in terms of bitmasks or pin indices.\n- Keep track of configuration masks (inputs, outputs, pull-ups, invert flags) and current outputs state.\n- Provide methods like `configure(outputs_mask, inputs_mask, pull_ups_mask)`, `set_outputs(mask)`, `read_inputs()`, and, optionally, `verify_outputs()`.",
            "Step 5: Use efficient bus access patterns.",
            "- Avoid per-pin I²C transactions in the application layer. Instead:\n  - Use register-level reads/writes to manipulate all pins in one or two I²C operations.\n  - Let each app-level entity (switch/sensor) work on logical pin state, while a central manager translates to/from masks.\n- If performance is an issue, profile the polling frequency vs CPU and bus usage.",
            "Step 6: Implement change detection and event delivery.",
            "- Decide between polling and interrupts:\n  - For polling: implement a background thread or async task that periodically reads inputs, compares against previous state, and computes which pins changed.\n  - For interrupts: configure the chip's interrupt registers, wire an interrupt line to the host, and handle notifications by reading the expander's latched state.\n- Use a thread-safe queue or callback mechanism to forward detected changes to the main application, where entity states are updated.",
            "Step 7: Map device pins to application entities.",
            "- In the integration layer, provide configuration that lets the user map I²C address and pin numbers to entity IDs / names.\n- Maintain a registry (eg, `ManagedChips`) that:\n  - Ensures only one device instance per I²C address,\n  - Records which entity is on which pin,\n  - Computes masks for inputs/outputs/pull-ups based on entity types.\n- After assembling the mapping, call the driver’s `configure` once per chip and, if necessary, set initial outputs to match the entities’ initial states.",
            "Step 8: Align lifecycle with the host application.",
            "- Hook into the application's startup and shutdown signals (eg, EVENT_HOMEASSISTANT_START/STOP in Home Assistant).\n- On start: initialize the I²C bus, create the chip manager, start polling threads or configure interrupts, and perform initial hardware configuration.\n- On stop: cleanly stop background threads, join them, and release hardware resources as needed.",
            "Step 9: Ensure code quality and compliance before submitting a PR.",
            "- Run auto-formatting (eg, Black) and linting (eg, flake8) locally.\n- Update dependency declarations (REQUIREMENTS in the component and global requirements files if required by the project).\n- Exclude non-essential files from coverage if the project mandates it (eg, .coveragerc updates for hardware-specific modules).\n- Add or update tests where feasible, especially for logic that doesn’t require real hardware (mask calculations, register helpers).",
            "Step 10: Iterate based on reviewer feedback.",
            "- If reviewers ask to move code into a separate library or to use an existing one, prioritize that refactor rather than trying to argue for in-repo drivers.\n- Reduce the integration PR to the minimal glue code: configuration schema, entity classes, and calls into the external driver library.\n- Be prepared to adjust architecture (eg, replacing custom polling logic with the host’s standard async/polling mechanisms) to align with project conventions.",
            "Step 11: Diagnosing functional issues with similar integrations.",
            "- If your I²C-based entities aren't updating:\n  - Verify that the polling thread or interrupt handler is running and not blocked.\n  - Check that masks (inputs/outputs/pull-ups) are configured correctly; a misconfigured pin may never change or may read as constant.\n  - Ensure the pin-to-entity mapping matches the hardware wiring (correct I²C address, pin numbers).\n  - Log I²C read/write errors (OSError) and decide whether you need to reset the bus or reconfigure the chip.\n  - If outputs 'forget' their state (eg, due to chip reset), implement and test an `verify_outputs()`+reconfigure path similar to the one attempted in this PR.",
            "Step 12: Reviewing existing alternative implementations.",
            "- When there is another integration or PR addressing the same hardware (eg, a simpler MCP23017-only integration), compare:\n  - How state updates are triggered (HA polling vs external thread vs interrupts).\n  - How many I²C transactions are performed per poll cycle.\n  - How the code quality and architecture align with project guidelines.\n- Use this comparison to refine your own design, borrowing patterns that are more acceptable to maintainers."
        ]
    }
}
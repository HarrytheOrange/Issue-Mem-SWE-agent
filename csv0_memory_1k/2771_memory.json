{
    "search_index": {
        "description_for_embedding": "Fixes a bug where, after session re-login in PokemonGo-Bot, the API signature/encryption library was not re-activated, causing 'Possibly searching too often' / API errors. The fix reinitializes the ApiWrapper and calls api.activate_signature with an OS-detected encryption library path, and replaces a deprecated direct logger.info call with event_manager.emit to avoid exceptions.",
        "keywords": [
            "session stale",
            "re-login",
            "ticket_expire",
            "ApiWrapper",
            "api.activate_signature",
            "encryption library",
            "encrypt.so",
            "get_encryption_lib",
            "Possibly searching too often",
            "PokemonGo-Bot",
            "event_manager.emit",
            "deprecated log call",
            "api_error event",
            "Python",
            "reinitialization bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident (Issue #2698), the PokemonGo-Bot experienced errors after an authentication session expired and the bot re-logged in. Users observed behavior consistent with the 'Possibly searching too often' error, which stems from the API requests not being correctly signed after the session refresh. The existing `check_session` logic detected when the auth ticket was about to expire (`remaining_time < 60`), logged a 'Session stale, re-logging in' message, and then re-created the ApiWrapper and called `login()`. However, it did not re-activate the signature/encryption library for the newly created API instance. As a result, after re-login, requests were sent without a properly configured signature, triggering server-side throttling or errors.\n\nThe fix added a call to `self.api.activate_signature(...)` after `self.login()` inside `check_session`. Initially this was hard-coded as `\"encrypt.so\"`, but it was then updated to use the OS-detected loader introduced in another PR: `self.api.activate_signature(self.get_encryption_lib())`. This ensures the correct encryption library (DLL/SO) is loaded on all platforms after every re-login.\n\nAdditionally, the code previously used a deprecated logging call: `self.logger.info(\"Session stale, re-logging in\", 'yellow')`. This was replaced with the standardized event-based logging mechanism:\n\n```python\nself.event_manager.emit(\n    'api_error',\n    sender=self,\n    level='info',\n    formatted='Session stale, re-logging in.'\n)\n```\n\nThis avoids exceptions caused by the deprecated logger API and routes the message through the unified event system. During the discussion, there was some confusion about indentation errors and manual changes to `__init__.py` on Windows, but the root fix was to re-activate the signature library on each re-login using the cross-platform `get_encryption_lib()` helper and to use the correct event-based logging API.",
        "semantic_memory": "This fix highlights two generalizable patterns:\n\n1. **Reinitialization Requires Re-attaching All Dependencies**: When a component is re-created at runtime (e.g., a new API client after re-login, reconnect, or refresh), any associated configuration or external resources (encryption/signature libraries, auth tokens, interceptors, middleware) must be re-applied to the new instance. It is insufficient to assume that global state or prior configuration persists across re-instantiations; initialization side effects must be repeated in every code path that constructs a new instance.\n\n2. **Avoid Deprecated APIs by Centralizing Logging and Error Handling**: Replacing direct logging calls with an event-based mechanism avoids runtime errors when older logger interfaces are removed or changed. Centralized event emitters or logging adapters provide a stable API and allow the rest of the codebase to remain loosely coupled to the actual logging implementation. Using a structured event (e.g., `event_manager.emit('api_error', level='info', formatted=...)`) enables consistent formatting, routing, and handling of messages, including non-error informational events.\n\nMore broadly, the episode demonstrates:\n- **Session lifecycle management**: When a session is refreshed (auth ticket renewed), both authentication and request-signing layers must be coherent; missing any layer can lead to subtle server-side errors.\n- **Cross-platform resource loading**: Hardcoding platform-specific filenames (e.g., `encrypt.so`) is fragile. A helper like `get_encryption_lib()` that encapsulates OS/arch detection and path resolution is more robust and should be reused in all places that need the library.\n- **Consistency across code paths**: Initialization logic should be encapsulated (e.g., a `_setup_api()` or `init_api()` method) and called in all paths where the component is created or reset. Divergent code paths that partially initialize objects are a common source of bugs.\n\nThese lessons apply to any system that: (1) maintains long-lived sessions requiring periodic refresh, (2) uses native libraries or plugins, or (3) relies on shared infrastructure like event-based logging.",
        "procedural_memory": [
            "When diagnosing errors or inconsistent behavior after a session refresh or re-login, verify that all initialization steps for the new client instance are performed exactly as they are during the initial startup.",
            "Step 1: Identify where session expiry is detected and where the client is re-created.\n- Search for logic that compares token expiry or `ticket_expire` against the current time.\n- Locate the code path that instantiates a new API/client object (e.g., `self.api = ApiWrapper()`) and calls the login/authentication method.",
            "Step 2: Compare re-login initialization with initial startup.\n- Find the initial setup function (e.g., `_setup_api`, `init_client`, or constructor logic) used when the application first starts.\n- List all actions performed there (e.g., `activate_signature`, set timeouts, attach middleware, configure logging handlers, set headers).",
            "Step 3: Ensure re-login path repeats all necessary initialization steps.\n- In the re-login / refresh code path, check that each of those steps is also executed for the new instance.\n- If any initialization call is missing (e.g., `self.api.activate_signature(...)`), add it immediately after the client is re-created and authenticated.",
            "Step 4: Abstract platform-specific resource selection.\n- If the code currently hardcodes library filenames (e.g., `\"encrypt.so\"`), replace this with a helper function (e.g., `get_encryption_lib()`) that chooses the correct library based on OS/architecture.\n- Use this helper consistently in all places where the library is loaded, including re-login paths.",
            "Step 5: Replace deprecated logging or error-reporting calls with the current event/logging interface.\n- Search for direct calls to deprecated logger methods or ad-hoc printing in the affected code.\n- Replace them with the standard event/logging mechanism, for example:\n  - `event_manager.emit(event_name, sender=self, level='info'|'error', formatted='message')`.\n- Verify that message semantics (level, category/event name) match existing conventions.",
            "Step 6: Add or run tests around session expiry behavior.\n- Create a test or repro scenario where the session/token is close to expiration.\n- Force a re-login and confirm that: (a) the new client instance functions correctly, (b) all necessary libraries (e.g., encryption/signature) are active, and (c) no errors like 'Possibly searching too often' occur.",
            "Step 7: Validate on multiple platforms if native libraries are involved.\n- Confirm that the helper (e.g., `get_encryption_lib()`) correctly resolves the path for Windows, macOS, Linux, and 32/64-bit variants as applicable.\n- Run a quick functional test on each supported OS to ensure the library loads correctly after both initial startup and re-login.",
            "Step 8: Refactor for future maintainability.\n- If multiple places construct the API client, consider centralizing creation and initialization logic in a single method (`create_api_client()` or `_setup_api()`), and reuse it in both startup and re-login paths.\n- Document in code comments that any changes to initialization must be reflected in the re-login/refresh path."
        ]
    }
}
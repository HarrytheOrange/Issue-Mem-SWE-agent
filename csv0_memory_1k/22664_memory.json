{
    "search_index": {
        "description_for_embedding": "Home Assistant change adding attribute_templates support to template binary_sensors, allowing custom state attributes defined via Jinja templates. Refactors template handling to include attribute templates, defaults config to empty dict, iterates templates safely, and logs TemplateError without breaking the entity.",
        "keywords": [
            "Home Assistant",
            "template binary sensor",
            "binary_sensor",
            "attribute_templates",
            "custom attributes",
            "Jinja2 templates",
            "TemplateError",
            "MATCH_ALL",
            "async_setup_platform",
            "device_state_attributes",
            "homeassistant.components.template.binary_sensor",
            "test_binary_sensor",
            "logging errors rendering templates",
            "schema validation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, a new feature was added to Home Assistant's template binary_sensor platform to support custom attributes via an attribute_templates configuration option. Previously, template binary sensors could only define a value_template, icon_template, and entity_picture_template. Users wanted to attach arbitrary attributes (e.g., distance, latitude/longitude, derived state) similar to what the RESTful sensor already supports.\n\nThe implementation updated SENSOR_SCHEMA to include an optional attribute_templates mapping of string keys to templates. In async_setup_platform, the code now collects the value, icon, entity_picture, and attribute templates into a single iteration using itertools.chain. It sets template.hass and extracts referenced entities from all templates, ensuring that attribute templates participate in entity tracking and in the 'MATCH_ALL' safety checks that warn when no entities can be derived. A subtle bug was avoided by initializing attribute_templates to an empty dict (device_config.get(CONF_ATTRIBUTE_TEMPLATES, {})) so chain(...) always has a valid mapping to iterate over.\n\nThe BinarySensorTemplate entity was extended to store self._attribute_templates and expose them via device_state_attributes. In _async_render, the entity first renders the value_template and sets the boolean state. It then builds a templates dict for _icon and _entity_picture, renders those, and separately loops over self._attribute_templates to render each attribute's template. Any TemplateError during attribute rendering is caught; an error is logged (\"Error rendering attribute %s: %s\") and that attribute is simply omitted/left unchanged, avoiding a hard failure of the entity. Similarly, errors on icon or entity_picture templates are logged with a descriptive message but do not break the binary sensor.\n\nSeveral tests were added/updated in tests/components/template/test_binary_sensor.py:\n- test_attribute_templates verifies that attribute_templates are evaluated and that updates to dependent entities cause the attribute value to change.\n- test_no_update_template_match_all was extended with a template that only uses attribute_templates; it confirms that sensors with templates that match all entities (MATCH_ALL) and no explicit entity_ids log appropriate warnings and only update on manual update.\n- test_invalid_attribute_template ensures that when an attribute template fails to render (referencing nonexistent attributes), an error is logged and the rest of the entity remains usable.\n\nAlong the way, smaller fixes were made: correcting a dict.update comprehension, Black-formatting, fixing test structures, and cleaning up imports and unused constants. The final result is consistent attribute template support for template binary sensors with robust error handling and full test coverage.",
        "semantic_memory": "This change illustrates a general pattern for safely extending templated entities with custom attributes while integrating into an existing reactive system.\n\nKey concepts:\n\n1. **Unified template handling**: When an entity uses multiple templates (for state, icon, picture, attributes, etc.), treat them uniformly during setup so that:\n   - All templates bind to the same execution context (e.g., template.hass = hass).\n   - All templates participate in entity extraction, so the system knows what other entities to track. This ensures consistent reactivity and avoids subtle bugs where attributes do not update because their dependencies were not registered.\n\n2. **Schema-driven configuration of attribute templates**: Adding attribute_templates as a mapping from string keys to templates lets users define arbitrary attribute names with Jinja2 expressions. Wrapping this in a validation schema (vol.Schema({cv.string: cv.template})) ensures correct types and early configuration errors.\n\n3. **Graceful degradation on template errors**: Templates can fail at runtime (missing entities, bad attributes, syntax issues). Instead of failing the entire entity update, catch TemplateError around each non-critical template (icon, picture, custom attributes), log a clear error message, and continue. The primary state (value_template) may be treated as more critical, but even there, catching and logging avoids crashing the whole system.\n\n4. **Default-safe collections**: When you plan to iterate over a mapping (like attribute_templates) and combine it with others (e.g., via itertools.chain), default to an empty dict rather than None (config.get(key, {})). This removes conditional complexity and prevents runtime errors when no configuration is provided.\n\n5. **Consistent entity tracking for performance and correctness**: For reactive platforms like Home Assistant, you must extract referenced entities from all templates (state, icon, picture, attributes) to build a proper dependency graph. If templates reference all entities (MATCH_ALL) and you cannot derive specific entity_ids, log a warning and consider limiting automatic updates (e.g., only update on manual update or startup). This avoids unnecessary global subscriptions and confusing behavior.\n\n6. **Test-first for edge cases**: When adding new templated capabilities, it is important to test:\n   - Happy path: attributes evaluate correctly and update when dependencies change.\n   - Edge cases: templates referencing nonexistent entities/attributes, templates that match all entities, and error logging behavior. These tests guard against regressions and ensure that the behavior is understandable for users.\n\nThese patterns are applicable whenever you add template-based configuration and dynamic attributes to entities in any reactive or event-driven system, not just Home Assistant.",
        "procedural_memory": [
            "When adding or debugging template-based custom attributes on entities in a reactive system, follow these steps:",
            "Step 1: Extend the configuration schema to support attribute templates.\n- Add an optional attribute_templates field to the entity's config schema.\n- Make it a mapping from string keys (attribute names) to template objects (eg, Jinja2 templates).\n- Example (voluptuous): vol.Optional(CONF_ATTRIBUTE_TEMPLATES): vol.Schema({cv.string: cv.template}).",
            "Step 2: Load attribute templates during platform setup.\n- In async_setup_platform (or equivalent), read attribute_templates from device_config using a default empty dict: attribute_templates = device_config.get(CONF_ATTRIBUTE_TEMPLATES, {}).\n- Avoid returning None; defaulting to {} simplifies iteration and chaining.",
            "Step 3: Initialize and prepare all templates.\n- Build a dict of your core templates (value_template, icon_template, entity_picture_template, etc.).\n- Use itertools.chain or equivalent to iterate over both the core templates and attribute_templates:\n  - for tpl_name, template in chain(core_templates.items(), attribute_templates.items()):\n    - if template is None: continue\n    - bind execution context (e.g., template.hass = hass)\n    - extract referenced entities via template.extract_entities() to populate tracking entity_ids.\n- If extraction returns MATCH_ALL and no explicit entity_ids are provided, store the field name in an invalid_templates list and later log a warning that the entity has no specific entities to track.",
            "Step 4: Store attribute templates on the entity.\n- In the entity class __init__, accept attribute_templates and store them as self._attribute_templates.\n- Initialize an attribute storage dict, e.g., self._attributes = {}.\n- Implement device_state_attributes (or equivalent) to return self._attributes so the system exposes them as state attributes.",
            "Step 5: Render templates safely during state updates.\n- In your entity's render/update method (e.g., _async_render):\n  1. Render the value_template first to determine the primary state, catching TemplateError and logging if it fails.\n  2. Prepare a dict for non-attribute templates (icon, entity_picture) and render each in a try/except TemplateError block; set the corresponding properties on the entity and log clear error messages without raising.\n  3. For attribute templates:\n     - Initialize a local attrs = {}.\n     - For each key, tpl in self._attribute_templates.items():\n       - Try to render tpl.async_render().\n       - On success, set attrs[key] = rendered_value.\n       - On TemplateError, log an error like 'Error rendering attribute %s: %s'.\n     - After the loop, assign self._attributes = attrs.",
            "Step 6: Ensure entity tracking and MATCH_ALL behavior are correct.\n- After processing template.extract_entities(), if entity_ids == MATCH_ALL and no explicit entity_ids are configured:\n  - Log a warning listing which template fields (value, icon, entity_picture, attribute names) caused MATCH_ALL.\n  - Optionally, design the entity so it doesn't automatically update on every state change, but can still be updated manually or at startup.\n- This prevents accidental global subscriptions and clarifies unusual configuration to the user.",
            "Step 7: Add tests covering normal and error paths.\n- Write tests that:\n  - Configure a templated entity with attribute_templates and confirm the attribute appears on the state and updates when dependent entities change.\n  - Configure a template with attribute_templates that reference non-existent entities/attributes, update the entity, and assert that:\n    - The system logs 'Error rendering attribute <name>' (or equivalent).\n    - The entity remains registered and usable.\n  - For MATCH_ALL behavior, ensure that:\n    - Sensors using templates that reference all entities but have no explicit entity_ids log appropriate warnings.\n    - State changes behave as expected (eg, not re-rendering on every state change unless explicitly configured).",
            "Step 8: Run style and formatting tools and fix small issues early.\n- Apply project-standard formatters (e.g., Black) and linters.\n- Fix dictionary comprehension mistakes (e.g., using dict.update with a generator of dicts instead of a single mapping).\n- Clean up imports and unused constants to keep the module maintainable.",
            "Step 9: Use this pattern to extend other templated entity types.\n- For any other template-based platform (sensor, switch, light, etc.), reuse this pattern:\n  - Add attribute_templates to the schema.\n  - Include those templates in setup-time entity extraction.\n  - Render them with robust error handling into device_state_attributes.\n- This keeps behavior consistent across entity types and reduces future maintenance."
        ]
    }
}
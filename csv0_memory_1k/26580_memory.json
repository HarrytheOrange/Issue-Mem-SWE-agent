{
    "search_index": {
        "description_for_embedding": "Home Assistant GTFS sensor returned departures in the wrong timezone because it used datetime.now() instead of the timezone-aware dt_util.now(). The fix replaces datetime.now() with dt_util.now().replace(tzinfo=None) to use Home Assistant’s configured timezone while keeping a naive datetime expected by existing code.",
        "keywords": [
            "GTFS sensor",
            "wrong timezone",
            "datetime.now",
            "dt_util.now",
            "timezone-aware datetime",
            "naive datetime",
            "Home Assistant",
            "schedule calculation",
            "next departure",
            "offset handling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant GTFS integration, the function get_next_departure calculated the current time using Python’s datetime.datetime.now() and then added an offset. This led to departures being computed in the wrong timezone relative to Home Assistant’s configured timezone, especially in environments where the system timezone differed or when HA’s timezone configuration was not aligned with the system clock. Home Assistant has a standard utility, dt_util.now(), that returns a timezone-aware datetime aligned with HA’s configured timezone. The rest of the GTFS sensor code, however, expects naive datetimes (no tzinfo). The fix changed the code from using datetime.datetime.now() to using dt_util.now().replace(tzinfo=None) before adding the offset. This preserves the correct local time according to Home Assistant’s timezone while maintaining a naive datetime object, avoiding breakage in the existing date/formatting logic. After this change, GTFS next departure times are calculated in the correct timezone and align with the user’s configured timezone in Home Assistant.",
        "semantic_memory": "Time-related bugs often stem from mixing different notions of \"current time\" and different datetime types (naive vs timezone-aware). In platforms like Home Assistant, there is usually a central time utility (e.g., dt_util.now()) that returns a timezone-aware datetime in the application’s configured timezone, which may differ from the system’s timezone. Using bare datetime.datetime.now() bypasses this abstraction and can cause subtle timezone discrepancies when computing schedules or timestamps. Another common pattern is legacy code that expects naive datetime objects (no tzinfo), while newer utilities return aware datetimes. In such cases, a clean approach is to use the central utility to get the correct wall-clock time, and then explicitly convert to the expected format (e.g., dropping tzinfo) when necessary. More generally: (1) always use the framework’s time utilities instead of raw datetime.now(), (2) be explicit about whether code expects naive or timezone-aware datetimes, and (3) avoid silently relying on the system timezone when an application-level timezone setting exists.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of a timezone bug. Look for reports that scheduled events, sensors, or next-occurrence calculations are off by a fixed offset (e.g., exactly one time zone difference, DST inconsistencies, or behaving differently on different hosts/containers).",
            "Step 2: Locate all uses of current time in the relevant component. Search the code for datetime.now(), date.today(), or direct time module calls in the affected integration or module (e.g., GTFS sensor).",
            "Step 3: Check framework conventions for time handling. In Home Assistant, prefer dt_util.now() (timezone-aware, in HA’s configured timezone) and dt_util.utcnow(). Verify whether the project has a standard time utility and what its guarantees are.",
            "Step 4: Determine whether the surrounding code expects naive or timezone-aware datetimes. Inspect downstream uses (comparisons, formatting, database storage) to see if tzinfo is ever set or assumed. Mixed aware/naive comparisons raise errors in Python, but naive usage might still silently give the wrong timezone if built from datetime.now().",
            "Step 5: Replace raw datetime.now() with the framework’s time utility. Use dt_util.now() in Home Assistant code to align with the configured timezone. If the rest of the code expects a naive datetime, explicitly convert: correct_time = dt_util.now().replace(tzinfo=None).",
            "Step 6: Preserve existing behavior that depends on naivety. Before changing from naive to aware datetimes globally, assess whether existing formatting or comparisons would break. If they do, keep the naive interface but source its value from the correct timezone-aware utility, then strip tzinfo explicitly.",
            "Step 7: Re-run calculations and add tests. Create tests that simulate different timezones or offsets (e.g., compare results when HA is configured for UTC vs a non-UTC timezone) and verify that schedule-related outputs (next departure, next trigger time) match expectations.",
            "Step 8: Document the pattern for future changes. Note in code comments or contribution guidelines that all new time calculations should use the central time utility (dt_util.now() in Home Assistant) and explicitly address naive vs aware datetime handling.",
            "Step 9: Review other similar components. After fixing one instance (such as GTFS sensor), scan related integrations or modules that perform similar date/time calculations to ensure they also use the approved time utilities and timezone handling patterns."
        ]
    }
}
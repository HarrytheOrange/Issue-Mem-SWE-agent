{
    "search_index": {
        "description_for_embedding": "Adds support in Home Assistant's Z-Wave integration for renaming Z-Wave value labels that determine entity_ids. Introduces a new REST API endpoint to list primary values per node, a new `rename_value` service to change a value's label (persisted via zwcfg.xml), and internal tracking of entity value objects. Also adjusts code to update shared entity-values lists in a thread-safe manner.",
        "keywords": [
            "Z-Wave",
            "zwave",
            "rename value",
            "value label",
            "entity_id customization",
            "Home Assistant",
            "DATA_ENTITY_VALUES",
            "ZWaveNodeValueView",
            "rename_value service",
            "REST API",
            "frontend integration",
            "zwcfg.xml persistence",
            "thread safety",
            "shared list mutation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set implements support for renaming Z-Wave value labels in Home Assistant so that users have more control over resulting entity_ids. Previously, users could only rename Z-Wave nodes, not individual values that often drive entity_id names. The PR introduces several key components.\n\nInternally, a new constant `DATA_ENTITY_VALUES` is added and initialized as an empty list in `homeassistant/components/zwave/__init__.py`. This list holds `ZWaveDeviceEntityValues` instances representing the primary values used by entities. The `value_added` callback is updated to iterate over `hass.data[DATA_ENTITY_VALUES]` when checking whether a new value should be tracked by existing entities. When adding a new `ZWaveDeviceEntityValues` object, the code now creates a new list (`new_values = hass.data[DATA_ENTITY_VALUES] + [values]`) and reassigns it back to `hass.data[DATA_ENTITY_VALUES]`, rather than mutating the list in place. This is done so that the main thread can safely iterate over the list without seeing concurrent modifications.\n\nOn the service layer, a new schema `RENAME_VALUE_SCHEMA` is added, and the `rename_value` service handler is implemented. It accepts `node_id`, `value_id`, and `name`, retrieves the corresponding `node` and `value` from the Z-Wave network (`network.nodes[node_id].values[value_id]`), and sets `value.label = name`. This label change is persisted by OpenZWave via `zwcfg.xml`, allowing renamed labels to survive restarts. The service is exposed as `zwave.rename_value` and described in `homeassistant/components/zwave/services.yaml` with documentation showing how to obtain value IDs from a new API endpoint.\n\nOn the HTTP API side, `ZWaveNodeValueView` is introduced in `homeassistant/components/zwave/api.py`. It exposes `GET /api/zwave/values/{node_id}` and returns a JSON mapping of primary value IDs to their labels for the specified node. The view reads from `hass.data[DATA_ENTITY_VALUES]` and filters entries whose `primary.node.node_id` matches the requested `node_id`. Only primary values used for entities are returned, not all raw Z-Wave values, to keep the UI focused on values that affect entity_ids. The view is registered in the frontend setup path when the Z-Wave panel is available.\n\nTests are added and improved. `test_get_values` in `tests/components/zwave/test_api.py` constructs two mock nodes and values but asserts that the API only returns values for the requested node, verifying the filtering. `test_rename_value` in `tests/components/zwave/test_init.py` sets up a `MockNode` and `MockValue`, calls the new `zwave.rename_value` service, and asserts that the value's label has changed from 'Old Label' to 'New Label'. These tests ensure that the new service and API behave as expected.\n\nThere was some discussion about potential conflicts with discovery schemas that rely on labels. The concern was that renaming labels might break schema matching. However, it was clarified that primary values used to derive entity_ids do not currently match based on label, and that the labels are persisted in zwcfg.xml, which is a per-installation configuration, not global for all users of a device. With these clarifications and the secured tests, the PR was accepted and cherry-picked for release 0.46.1.",
        "semantic_memory": "This change illustrates several general patterns and best practices for building extensible, user-friendly integrations and APIs in a home automation context:\n\n1. **Expose underlying library capabilities cleanly:** If a lower-level library (like OpenZWave) supports per-value naming and persists those names in its own configuration (zwcfg.xml), it's often better to expose that capability directly to users rather than building complex workarounds in the higher-level system (e.g., Home Assistant). This gives users direct control and reduces opaque, framework-specific hacks.\n\n2. **Use service schemas and dedicated endpoints for targeted configuration:** Introducing a specific service (`rename_value`) with a clear schema (`node_id`, `value_id`, `name`) and a focused API endpoint (`/api/zwave/values/{node_id}`) leads to a precise, discoverable configuration surface. It is preferable to overloading existing services or endpoints with optional behaviors.\n\n3. **Persist user configuration at the right layer:** Renamed value labels are saved in `zwcfg.xml` by OpenZWave. This aligns with where device-level configuration logically belongs and keeps the home-automation application layer simpler. The application doesn't need its own redundant mapping if the underlying system already persists and applies the naming.\n\n4. **Maintain thread-safe shared state:** When a list or collection is shared across callbacks and possibly across threads (for example, a list of `ZWaveDeviceEntityValues` that can be iterated by the main thread while callbacks append to it), mutating the list in place can cause concurrency issues (e.g., `RuntimeError: list changed size during iteration`). Replacing the list with a new one (`new_values = old + [item]` then reassign) is a simple functional pattern that keeps iteration safe and avoids subtle concurrency bugs.\n\n5. **Filter API data to match user-facing use cases:** The values endpoint only returns primary values that are actually tied to entities, not every raw Z-Wave value. This keeps the UI manageable and aligns with the feature goal (renaming values that influence entity_ids). APIs should return data that matches user workflows rather than raw, low-level data whenever that separation adds clarity.\n\n6. **Testing UI/HTTP endpoints with mocks:** The tests for `ZWaveNodeValueView` show how to use mock nodes, values, and entity-value wrappers to validate that an endpoint filters correctly and returns the expected JSON structure. Similarly, the service test validates that calling a service leads to the expected mutation of the underlying object. This pattern is broadly applicable when testing integrations that sit on top of external systems.\n\n7. **Separating concerns between node and value naming:** Node renaming and value renaming are handled by separate services (`rename_node` vs `rename_value`). This separation makes it explicit that nodes and their individual values are distinct configuration entities, improving clarity and making it easier to evolve each capability independently.",
        "procedural_memory": [
            "To add or debug functionality for renaming resource-specific attributes (like Z-Wave value labels) and exposing them to a UI, follow these steps:",
            "Step 1: Identify the underlying capability and persistence mechanism.\n- Confirm the low-level library supports renaming (e.g., OpenZWave value labels).\n- Verify where the change is stored (e.g., zwcfg.xml) and that it persists across restarts.\n- Determine which attributes (node, value, index, label) you must address to perform the rename safely.",
            "Step 2: Introduce or extend internal data structures to track relevant objects.\n- Add a dedicated container (like `DATA_ENTITY_VALUES`) in the application-wide data store.\n- Populate it at appropriate lifecycle events (e.g., `value_added` callbacks), ensuring only the relevant subset of objects (e.g., primary values for entities) are stored.\n- When modifying shared collections from asynchronous callbacks or multiple threads, avoid in-place mutations; instead, create a new list including the new element and reassign the reference.",
            "Step 3: Implement the backend service for renaming.\n- Define a validation schema (e.g., with voluptuous) for the service data: `node_id`, `value_id`, and `name`.\n- In the handler, resolve the network, locate the node (`network.nodes[node_id]`), then the value (`node.values[value_id]`).\n- Set the appropriate attribute (e.g., `value.label = name`) and log the change for observability.\n- Register the service with a clear name (e.g., `rename_value`) and link it to documentation in the service descriptions file.",
            "Step 4: Provide an API endpoint for UI consumption (if needed).\n- Implement a view class (e.g., `ZWaveNodeValueView`) that receives a path parameter like `node_id`.\n- Access the shared data structure (e.g., `hass.data[DATA_ENTITY_VALUES]`) and filter objects by the requested node.\n- Return a minimal JSON structure containing only what the UI needs (e.g., `value_id` -> `{ label: ... }`), excluding irrelevant low-level details.\n- Register the view in the HTTP / frontend setup flow.",
            "Step 5: Wire the endpoint and service into the UI.\n- Update the frontend to call the new endpoint (e.g., `/api/zwave/values/{node_id}`) to list values.\n- Allow the user to select or enter a new label and send it through the backend service (`zwave.rename_value`) or a dedicated HTTP call.\n- Ensure the UI updates entity_ids or displays the new label appropriately, respecting any existing discovery schemas.",
            "Step 6: Add targeted tests.\n- For the HTTP view, use mock nodes, values, and entity-value containers to simulate the backend data structure.\n- Assert that the endpoint filters by `node_id` and only returns the relevant primary values.\n- For the service, create a mock node and value, call the service, and assert that the label or other renamed attribute changed as expected.\n- Include edge cases such as multiple nodes and values to verify that no unintended data is returned or modified.",
            "Step 7: Consider interactions with discovery and ID generation.\n- Review how entity_ids or discovery schemas are generated to ensure renaming does not break them.\n- Prefer matching on stable identifiers (e.g., value index or ID) rather than labels if labels can be user-modified.\n- Clearly document how renaming impacts entity_ids and any potential conflicts, so users can manage naming conflicts intentionally rather than through hidden workarounds."
        ]
    }
}
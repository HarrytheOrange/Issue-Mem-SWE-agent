{
    "search_index": {
        "description_for_embedding": "Fix screenshot-based z-order tests in napari that failed on high-DPI displays due to using an even-sized data array with no exact center, causing the rendered point to miss the screenshot center pixel. The fix uses odd-sized image data and adjusts point size so the blue point is correctly detected at the center of the captured screenshot across different DPI settings.",
        "keywords": [
            "napari",
            "screenshot test",
            "high DPI",
            "HiDPI",
            "retina",
            "z order",
            "center pixel",
            "even vs odd dimensions",
            "image grid alignment",
            "test_with_screenshot.py",
            "GUI testing",
            "rendering mismatch",
            "half-pixel alignment"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, several screenshot-based tests in napari (`test_with_screenshot.py`) were intermittently failing on a high-DPI M1 MacBook Pro but not in CI or on other laptops. The tests render a red image with a blue point and then capture a screenshot, checking that the center of the screenshot has the expected color (e.g., blue in front of red) to verify z-order correctness.\n\nThe original tests used a 10x10 numpy array for the image (`np.ones((10, 10))`) and placed a point at coordinate `[5, 5]`. Because 10x10 is even-sized, there is no single exact center pixel in the data grid; the coordinate `[5, 5]` lies conceptually between four pixels and slightly to the lower-right when mapped onto the rendered image. On high-DPI screens, this subtle half-pixel alignment/rounding difference meant the point's drawn radius did not overlap the exact center pixel of the screenshot (computed as `center = round(screenshot.shape[:2] / 2)`), so the test sometimes failed as the center pixel didn't show the expected blue color.\n\nThe fix was to change the test data arrays from 10x10 to 11x11 (`np.ones((11, 11))`), ensuring there is a true central pixel in the data that aligns cleanly with the logical center of the render and screenshot. Additionally, in the `test_z_order_image_points_after_ndisplay` test, the point size was adjusted from `size=10` to `size=5`, refining how the point is rendered relative to the screenshot's center and z-order expectations. After this change, the screenshot tests passed reliably on the high-DPI Mac, while still passing in CI and on other machines. No production code was modified; only the test setup and parameters were updated to be robust against DPI-related rendering differences.",
        "semantic_memory": "GUI and rendering tests that rely on exact pixel positions are highly sensitive to subtle alignment and scaling differences, especially on high-DPI (HiDPI/retina) displays. When you use an even-sized grid (e.g., 10x10) and refer to its 'center', there is no single central pixel; the nominal center lies between pixels, which can result in half-pixel offsets during rendering. Different backends, DPI settings, and scaling factors will round and rasterize these coordinates differently, causing mismatches between logical coordinates (e.g., data index `[5, 5]`) and the pixel chosen as the 'center' of a screenshot.\n\nTo avoid such fragility, tests should ensure that key reference points (like the center of an image or a point feature) correspond to actual pixel centers in the rendered output. Using odd-sized arrays (e.g., 11x11) provides a unique central pixel, easing alignment. When verifying visuals via screenshots, it's safer to use tolerant or structural checks (e.g., verifying that a certain colored region exists in an approximate area or counting pixels) rather than asserting a single pixel must have an exact color. This reduces susceptibility to rounding, anti-aliasing, half-pixel translations, and DPI scaling quirks.\n\nMore broadly, visual regression tests should be designed to: (1) minimize dependencies on platform-specific rasterization details; (2) make geometric choices (dimensions, coordinates) that align cleanly with pixel grids; and (3) use assertions that are robust to small rendering variations rather than assuming deterministic per-pixel equality across all environments.",
        "procedural_memory": [
            "When screenshot-based GUI tests fail only on some machines (e.g., high-DPI displays), suspect coordinate and pixel alignment issues rather than logic errors in the application.",
            "Step 1: Reproduce in the problematic environment.\n- Run the failing screenshot or visual test on the high-DPI or otherwise problematic machine.\n- Confirm that failures are related to assertions on specific pixel values or locations in the screenshot.",
            "Step 2: Inspect the rendered output.\n- Save the screenshot used by the test to disk.\n- Use an image viewer or plotting tool (e.g., `matplotlib.pyplot.imshow`) to visualize the screenshot.\n- Mark the pixel position(s) being asserted (e.g., the computed center) and check whether the expected feature (e.g., a colored point) actually covers that pixel.",
            "Step 3: Check data and coordinate geometry.\n- Examine the size of the underlying data arrays (e.g., 10x10 vs 11x11) used in the test.\n- Determine the logical \"center\" in data coordinates and how it maps to pixel coordinates.\n- Identify whether you are relying on a center point for an even-sized grid (leading to a half-pixel or between-pixel center).",
            "Step 4: Align logical centers with real pixel centers.\n- Prefer odd-sized dimensions (e.g., 11x11, 101x101) when you need a single, unambiguous central pixel.\n- Adjust coordinates of points or shapes so that they map to well-defined pixel centers rather than relying on fractional or ambiguous positions.\n- If necessary, adjust the size/radius of graphical markers so that they clearly cover the intended pixel(s), accounting for high-DPI scaling.",
            "Step 5: Make assertions more robust.\n- Instead of checking a single pixel, consider checking a small region: e.g., verify that within a window around the center, some pixels meet the color criteria.\n- Alternatively, count pixels of a certain color and assert they form an approximate shape or appear in an approximate area (e.g., a roughly circular blue region near the center).\n- Add tolerances for color comparisons if anti-aliasing or blending is involved.",
            "Step 6: Validate across environments.\n- Run the updated tests in CI and on a variety of local machines (low-DPI, high-DPI, different OSes and GPUs) to ensure that the fix generalizes.\n- If possible, add comments in the test explaining the reasoning (odd-sized arrays for exact centers, DPI considerations) to prevent accidental regression.",
            "Step 7: Prefer structural testing when possible.\n- Where feasible, isolate logic (like z-order, layer order, or visibility states) into unit tests that do not depend on rendered screenshots.\n- Use screenshot tests more as integration/regression checks and design them with geometry and robustness in mind (odd dimensions, tolerant assertions, minimal dependence on pixel-perfect outputs)."
        ]
    }
}
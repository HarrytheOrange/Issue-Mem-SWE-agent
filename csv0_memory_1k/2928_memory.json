{
    "search_index": {
        "description_for_embedding": "Home Assistant statsd component migrated its configuration validation from manual parsing (homeassistant.util.convert) to voluptuous-based CONFIG_SCHEMA. This changed how required fields and defaults (host, port, prefix, rate, log_attributes) are handled, which initially broke statsd tests. The fix defined a proper voluptuous schema with defaults and range checks, and updated tests to validate the new schema behavior and expectations.",
        "keywords": [
            "Home Assistant",
            "statsd",
            "configuration validation",
            "voluptuous",
            "CONFIG_SCHEMA",
            "default values",
            "unit tests broken",
            "schema migration",
            "cv.port",
            "vol.Invalid"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant `statsd` component was refactored to use voluptuous for configuration validation instead of manual conversion with `homeassistant.util.convert`. A new `CONFIG_SCHEMA` was introduced, using standard constants (`CONF_HOST`, `CONF_PORT`, `CONF_PREFIX`) and helpers from `homeassistant.helpers.config_validation` (e.g., `cv.string`, `cv.port`, `vol.All(vol.Coerce(int), vol.Range(min=1))`). The schema made `host` required and provided defaults for `port`, `prefix`, `rate`, and `log_attributes`.\n\nThe component's `setup` function was simplified: instead of manually applying defaults and conversions, it now assumes the config has already been validated and normalized by `CONFIG_SCHEMA`, and simply reads values with `conf.get(...)` and initializes `statsd.StatsClient(host=host, port=port, prefix=prefix)`.\n\nAfter this migration, the existing tests for the statsd component broke. The tests were still assuming the old behavior where `setup` itself provided default values and tolerated missing or malformed configuration. Under the new design, invalid config should be rejected by the schema with `vol.Invalid`, and defaults should be injected by the schema rather than in `setup`.\n\nTo fix this, the author updated `tests/components/test_statsd.py`:\n- Added `test_invalid_config` to assert that `statsd.CONFIG_SCHEMA(None)` and `statsd.CONFIG_SCHEMA` with a malformed config (`host1` instead of required `host`) both raise `vol.Invalid`.\n- Updated `test_statsd_setup_defaults` to explicitly set `statsd.CONF_PORT` and `statsd.CONF_PREFIX` to `statsd.DEFAULT_PORT` and `statsd.DEFAULT_PREFIX` respectively, mirroring what the schema would provide, and adjusted expectations to `port=8125` and `prefix='hass'`.\n- Updated event-listener tests (`test_event_listener_defaults`, `test_event_listener_attr_details`) to ensure `statsd.CONF_RATE` is set to `statsd.DEFAULT_RATE`, again matching what the schema would normally inject.\n\nWith these changes, the tests correctly reflect the new configuration validation model and pass again, while the component now benefits from centralized, declarative validation with voluptuous.",
        "semantic_memory": "This case illustrates a common pattern when migrating from ad-hoc, inline configuration parsing to a centralized schema-based validation system such as voluptuous:\n\n1. **Shift validation responsibility to the schema**: Instead of performing defaulting, type conversion, and bounds checking inside the runtime logic (e.g., in a `setup` function), these concerns are expressed declaratively in a schema (`CONFIG_SCHEMA`). The runtime code can then assume that incoming configuration is already valid and normalized.\n\n2. **Use shared validation helpers and constants**: In a larger framework like Home Assistant, using shared constants (`CONF_HOST`, `CONF_PORT`, `CONF_PREFIX`) and validation helpers (`cv.port`, `cv.string`, `vol.Coerce`, `vol.Range`) centralizes behavior and prevents configuration drift across components.\n\n3. **Tests must follow the new validation flow**: When the framework is expected to apply the schema before calling component setup, unit tests that directly invoke `setup` must either:\n   - Explicitly run the schema on the test config, or\n   - Manually mimic the final, schema-processed config (i.e., with all required keys and defaults already applied).\n   Otherwise, tests may fail because config is missing fields that the runtime now assumes are present.\n\n4. **Invalid configurations should fail early**: Using voluptuous makes it clear which configurations are invalid (e.g., wrong key names, missing required keys, values out of range). Writing tests that explicitly assert `vol.Invalid` for malformed configurations helps lock in these guarantees.\n\n5. **Default values and ranges become part of the contract**: Defaults (`DEFAULT_PORT`, `DEFAULT_PREFIX`, `DEFAULT_RATE`) and constraints (`rate` must be an integer >= 1) should appear both in the schema and in tests, ensuring the behavioral contract remains stable even as implementation details change.\n\nMore broadly, this demonstrates that whenever logic is refactored so that configuration is validated earlier in the pipeline (e.g., at load time rather than at use time), you must re-align both code and tests around the new responsibilities and assumptions.",
        "procedural_memory": [
            "When migrating a component from manual configuration parsing to voluptuous (or any schema validation system), follow these steps:",
            "Step 1: Identify existing configuration fields and behavior.",
            "  - List all configuration keys currently supported (e.g., host, port, prefix, rate, log_attributes).",
            "  - Note which keys are required and which have default values.",
            "  - Record any type conversions and constraints (e.g., port must be an integer; rate must be >= 1).",
            "Step 2: Define a voluptuous CONFIG_SCHEMA that matches existing behavior.",
            "  - Use `vol.Schema({ DOMAIN: vol.Schema({...}) }, extra=vol.ALLOW_EXTRA)` or the framework’s convention.",
            "  - For required keys, use `vol.Required(CONF_HOST, default=DEFAULT_HOST)` or `vol.Required(CONF_HOST)` depending on whether a default exists.",
            "  - For optional keys with defaults, use `vol.Optional(KEY, default=DEFAULT_VALUE): <validator>`.",
            "  - Express type and range checks via helpers: `cv.string`, `cv.port`, `vol.Coerce(int)`, `vol.Range(min=1)`, etc.",
            "Step 3: Simplify the component setup to assume validated config.",
            "  - Remove manual calls to util/convert functions and inline default logic.",
            "  - Replace with direct access to config (e.g., `conf = config[DOMAIN]`, `host = conf.get(CONF_HOST)`).",
            "  - Initialize dependencies (e.g., `statsd.StatsClient`) using these values.",
            "Step 4: Adjust or add tests for configuration validation.",
            "  - Add tests that call `CONFIG_SCHEMA` directly with invalid configs and assert that `vol.Invalid` is raised.",
            "  - Add tests that call `CONFIG_SCHEMA` with minimal configs and verify the resulting dict contains all expected default values.",
            "Step 5: Update existing tests that call setup directly.",
            "  - Either run the schema in your tests before calling setup: `validated = statsd.CONFIG_SCHEMA(raw_config)`; `setup(hass, validated)`,",
            "  - Or manually augment the test config to include keys and defaults that the schema would normally inject (e.g., set `CONF_PORT`, `CONF_PREFIX`, `CONF_RATE` to their defaults).",
            "  - Update expected calls to clients (e.g., `StatsClient`) to match explicit default values (e.g., port=8125, prefix='hass').",
            "Step 6: Rerun tests and inspect failures for missing defaults or changed assumptions.",
            "  - If tests fail due to `KeyError` or unexpected `None` values, it’s a sign that config defaults are now expected to be supplied by the schema.",
            "  - Ensure the runtime code never silently relies on missing fields; either make them required or give them defaults in the schema.",
            "Step 7: Document the new configuration contract.",
            "  - Update component docs to make clear which fields are required vs optional, their types, defaults, and valid ranges.",
            "  - Include an example `configuration.yaml` that reflects the new schema (e.g., showing host, port, prefix, rate, log_attributes)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant flux switch bug where calling turn_on multiple times created orphaned time trackers, breaking turn_off's ability to cancel scheduled updates. Fix makes turn_on idempotent by checking current state, using the subscription handle (unsub_tracker) as the source of truth for is_on, and preventing duplicate track_time_change registrations.",
        "keywords": [
            "Home Assistant",
            "flux switch",
            "time tracker",
            "scheduler",
            "track_time_change",
            "idempotent turn_on",
            "duplicate subscription",
            "resource leak",
            "state management",
            "unsub_tracker"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant flux switch component, there was a bug in how the switch handled repeated calls to turn_on. The switch managed periodic color temperature updates using a scheduled callback created via track_time_change, and it stored an 'unsub_tracker' function to later cancel this schedule in turn_off. The component also kept a separate boolean _state to represent whether the switch was on.\n\nThe problem occurred when turn_on was called while the switch was already on. The code would unconditionally register a new time-based callback via track_time_change, overwriting self.unsub_tracker with the new unsubscribe function. The original scheduled callback continued running (becoming 'orphaned') because there was no longer any reference to its unsubscribe function. As a result, a subsequent call to turn_off would only cancel the most recently registered tracker, leaving the original one still active and causing continued periodic updates even though the switch was turned off. This could manifest as lingering behavior, time-based updates still firing, and potential resource leaks.\n\nThe fix was implemented in two steps. First, turn_on was modified to avoid registering a new time tracker when one already existed: it only called track_time_change if self.unsub_tracker was None, preventing orphaned trackers. Then the code was cleaned up: the explicit _state attribute was removed, and the is_on property was redefined to derive the on/off state from the presence of self.unsub_tracker (is_on returns True if unsub_tracker is not None). With this new source of truth, turn_on gained an entry guard: if self.is_on is already True, it returns immediately and does nothing, making turn_on idempotent. When turning on from off, turn_on performs a single initial flux_update, then registers a new track_time_change callback and stores its unsubscribe handle in self.unsub_tracker. turn_off checks if unsub_tracker is set, calls it to cancel the scheduled updates, clears unsub_tracker, and schedules a state update. This ensures that repeated calls to turn_on do not leak timers and that turn_off correctly cancels all scheduled updates.",
        "semantic_memory": "This fix illustrates several generalizable patterns around stateful components and scheduled tasks:\n\n1. **Idempotent start/stop operations**: Methods like turn_on/turn_off should be safe to call multiple times without causing unintended side effects (e.g., duplicating tasks or leaking resources). An early-return guard in turn_on based on the current state is a common and robust pattern.\n\n2. **Single source of truth for state**: Maintaining both a separate boolean state flag (e.g., _state) and an operational handle (e.g., unsub_tracker) for the same conceptual state is error-prone. Instead, derive is_on from the presence or absence of the active resource (here: the unsubscribe handle). This reduces the risk of state desynchronization.\n\n3. **Managing scheduler/timer handles**: When using schedulers, timers, or event handlers (track_time_change, setInterval, cron jobs, etc.), always keep and manage the handle needed to cancel them. Never overwrite the handle without first cleaning up the previous scheduled job, or you may orphan a task and lose control over it.\n\n4. **Guarding against duplicate registrations**: Before registering a new listener or periodic task, check if one is already active. If so, either reuse it or no-op. This prevents duplicate events, unexpected multiple triggers, and resource leaks.\n\n5. **State derived from resources, not vice versa**: When 'being on' logically means 'a resource is allocated' (e.g., a timer exists, a connection is open, a subscription is active), the existence of that resource can and often should define the state. This is more reliable than maintaining a separate flag that must be manually kept in sync.\n\n6. **Consistent cleanup patterns**: The teardown method (turn_off) should always fully undo what the setup method (turn_on) did: if turn_on registers a callback and stores an unsubscribe function, then turn_off must call that function and clear its reference. The code should never leave the system with hidden or unmanageable background tasks.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the problem by calling the start/turn_on method multiple times.\n- In logs or behavior, look for signs that multiple timers, callbacks, or background tasks are being created (e.g., duplicated log messages, multiple triggers per expected event, CPU usage spikes, or behavior continuing after stop/turn_off).",
            "Step 2: Inspect the state management in the component.\n- Identify what variables track the component's on/off state (e.g., `_state`, `is_running`).\n- Identify what resources represent 'being on' (timers, subscriptions, file handles, network connections) and how their handles are stored (e.g., `unsub_tracker`, `timer_id`).\n- Check if there are multiple representations of state (a boolean flag plus a handle). Note potential desynchronization.",
            "Step 3: Examine the start/turn_on implementation.\n- Look for unconditional creation of timers/schedulers/subscriptions (e.g., always calling `track_time_change`, `setInterval`, `add_listener`).\n- Check whether existing handles are cleaned up before overwriting them. If a handle is simply reassigned, the older resource may become orphaned.\n- Verify whether there is any early-return guard that prevents re-initialization when already on.",
            "Step 4: Examine the stop/turn_off implementation.\n- Verify that stop/turn_off calls the correct cleanup function (e.g., unsubscribe, cancel, dispose) using the stored handle.\n- Confirm that it clears the handle after cleanup (e.g., setting it to `None`) so that the code can accurately detect the 'off' state later.\n- Ensure that stop/turn_off works correctly even if called when the component is already off (defensive programming).",
            "Step 5: Refactor to use a single source of truth for on/off state.\n- If possible, remove redundant state flags like `_state` and instead define `is_on`/`is_running` based on whether the operational handle is present (e.g., `return self.unsub is not None`).\n- Update any logic that previously checked the old state flag to use the new property derived from the handle.",
            "Step 6: Add an idempotent guard in the start/turn_on method.\n- At the top of `turn_on`, add a check: `if self.is_on: return`.\n- Ensure that any subsequent resource allocation (e.g., creating timers via `track_time_change`) happens only after this guard.\n- Optionally, perform any necessary initial update once, right before registering the recurring task.",
            "Step 7: Ensure resources are created and destroyed symmetrically.\n- In `turn_on`, create the timer or subscription and store the handle.\n- In `turn_off`, use that handle to cancel/unsubscribe and then clear the reference.\n- Verify that after `turn_off`, `is_on` reflects the off state because the handle is now `None`.",
            "Step 8: Re-test under repeated calls.\n- Call `turn_on` multiple times in succession and confirm that any underlying scheduler/timer is created only once (e.g., log inside the scheduler callback to ensure one firing per interval).\n- Call `turn_off` multiple times and confirm there are no errors and that no scheduled tasks remain.\n- Optionally, add unit tests to assert that `turn_on` is idempotent and that no additional handlers are registered on subsequent calls.",
            "Step 9: Add comments or documentation for future maintainers.\n- Document that the presence of the handle (e.g., `unsub_tracker`) is the canonical representation of the on/off state.\n- Note that `turn_on` is intentionally idempotent and must not re-register trackers when already on.\n- This helps prevent reintroduction of similar bugs in future refactors."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant python_script integration now supports loading user-defined service descriptions from <config>/python_scripts/services.yaml, in addition to the integration’s built-in services.yaml. The helper that loads service descriptions was updated to special-case the python_script domain, merge core and user YAML definitions without overriding core services, and add tests covering missing, valid, and invalid user YAML files.",
        "keywords": [
            "homeassistant",
            "python_script",
            "services.yaml",
            "service descriptions",
            "service registry",
            "helper _load_services_file",
            "user configuration",
            "YAML parsing",
            "HomeAssistantError",
            "mypy path handling",
            "test_service.py",
            "patch_yaml_files"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the goal was to extend Home Assistant’s python_script integration so that user-defined service descriptions could be loaded from a configuration-level YAML file located at <config>/python_scripts/services.yaml. Previously, service descriptions were only loaded from each integration’s own services.yaml file inside the integration package. This meant python_script services (which are dynamically discovered from scripts in the config directory) had no easy way for users to define descriptions and field metadata.\n\nTo implement this, the helper function async _load_services_file in homeassistant/helpers/service.py was modified. It now imports the python_script integration constants (DOMAIN and FOLDER) and introduces a special-case branch: when the requested domain is PYTHON_SCRIPT_DOMAIN, the function first loads the integration’s own services.yaml (if present) into a services dict. Then it tries to load a user-provided YAML file from \"{config_dir}/{PYTHON_SCRIPT_FOLDER}/services.yaml\". The two dictionaries are merged with user_services.update(services), so the built-in integration definitions take precedence over any conflicting user entries, thereby avoiding accidental overriding of core service definitions. Error handling for FileNotFoundError and HomeAssistantError returns whatever partial services dictionary was successfully loaded, instead of always returning an empty dict, so that valid built-in data is not lost if the user file is missing or invalid.\n\nThe test suite in tests/helpers/test_service.py was extended to cover three scenarios specific to the python_script domain:\n1) No user-provided services.yaml file: only the dynamically discovered python_script services exist, and they have empty descriptions/fields.\n2) A valid user-provided services.yaml file: the has_description service receives the description and field metadata from the YAML file, while a script without an entry in the YAML still has empty metadata.\n3) An invalid user-provided services.yaml file: parsing fails and is handled gracefully, leaving the python_script service descriptions empty instead of breaking the entire description retrieval.\n\nThe tests use patching to simulate the python_script folder being present, to mock glob.iglob returning specific python_script files, and patch_yaml_files to inject fake YAML contents for the user services.yaml file. A small code adjustment switched path concatenation from string + to \"{}/{}/services.yaml\" .format(...) for clearer typing and to appease mypy. Ultimately, this PR was closed in favor of a successor PR, but it demonstrates the approach of augmenting the service description loader to support both core and user-defined YAML sources.",
        "semantic_memory": "This fix illustrates several generalizable patterns:\n\n1. **Extending metadata via user-provided configuration files**: When an integration has built-in metadata (like service descriptions) but users also need to customize or supplement it, a common approach is to define a well-known file path under the user’s configuration directory (e.g., <config>/python_scripts/services.yaml) and load that alongside the integration’s built-in definitions.\n\n2. **Merging core and user definitions safely**: When combining built-in and user-defined configuration, you often want to preserve core integrity while allowing customization. The pattern here is to load the base (integration) config and then update it with user config or vice versa, depending on which should take precedence. In this case, the integration’s services.yaml overrides conflicting entries from the user’s YAML to avoid breaking core-defined services. In other contexts, the opposite may be desired (user overrides core), but the key idea is to explicitly control precedence and merge order.\n\n3. **Domain-specific behavior in shared helpers**: The service loader is a generic helper used by many integrations, but python_script had unique needs (services discovered from user files and needing user metadata). Rather than duplicating logic, the helper introduces a domain-specific branch keyed off the integration’s DOMAIN constant. This is a common pattern in large systems: central helpers with clean, minimal domain-specific conditions to support special cases.\n\n4. **Graceful degradation on configuration errors**: When loading configuration from multiple sources, it’s important not to discard valid data if one source fails. The revised error handling returns the partially loaded services dictionary (possibly from the integration file) even if the user YAML is missing or invalid. This pattern—falling back to whatever is valid and logging a warning—improves robustness and user experience.\n\n5. **Testing with filesystem and YAML stubs**: The tests demonstrate how to simulate filesystem-based integrations using patches for os.path.isdir, glob.iglob, and a dedicated patch_yaml_files utility. This is a good template when testing code that loads from real paths: abstract file access behind helpers and use targeted patches to inject test data.\n\n6. **Type-safety and path handling for static analysis**: Minor but instructive, the change from ad-hoc string concatenation to a structured format string for paths is motivated by type-checking (mypy). This underscores a best practice: construct paths in a clear and consistent way that static analyzers can understand, or better yet, use pathlib, to reduce bugs and typing issues.",
        "procedural_memory": [
            "To diagnose and implement similar functionality—allowing user-defined metadata (e.g., service descriptions) that augments core integration data—follow these steps:",
            "Step 1: Identify the existing metadata loading path.\nLocate the helper or function responsible for loading the integration’s metadata (e.g., service descriptions, schemas) from the integration package. In this case, it was async _load_services_file in homeassistant/helpers/service.py, which loads services.yaml from integration.file_path.",
            "Step 2: Determine domain-specific needs.\nDecide which domain(s) need special support for user-provided metadata (e.g., python_script). Import the relevant constants (DOMAIN, folder paths) so you can compute the correct user configuration file location, such as <config>/<folder>/services.yaml.",
            "Step 3: Add a domain-specific branch in the loader.\nWithin the shared loader, introduce a conditional on the domain. For the target domain:\n- Load the integration’s built-in YAML first into a base dict (e.g., services).\n- Attempt to load the user’s YAML from the configuration directory.\n- Merge the two dicts in a deliberate order that reflects precedence. For core precedence, use user_services.update(services) and return user_services; for user precedence, invert the update.",
            "Step 4: Handle missing and invalid user files gracefully.\nWrap YAML loading in try/except blocks catching FileNotFoundError and generic parsing errors (like HomeAssistantError). On failure, log an informative warning and return whatever valid data you have (e.g., the built-in services dict). Avoid raising unless the configuration is truly unrecoverable.",
            "Step 5: Standardize path construction.\nBuild file paths using a consistent method that works well with type checkers and cross-platform environments. Prefer pathlib.Path / operator or at least format strings like \"{config_dir}/{folder}/services.yaml\" over ad-hoc concatenation. This reduces subtle bugs and satisfies static analysis tools such as mypy.",
            "Step 6: Write focused tests for each scenario.\nCreate tests that:\n- Mock filesystem behavior (os.path.isdir, glob.iglob) to simulate discovered resources for the special domain.\n- Use helpers like patch_yaml_files to inject specific YAML content for core and user services.yaml files.\n- Cover scenarios: no user file, valid user file, and invalid user file. Assert that descriptions and fields are set correctly when valid and that the system falls back gracefully with empty or base metadata when invalid.",
            "Step 7: Verify integration with the higher-level API.\nCall the public-facing method that uses the loader (e.g., service.async_get_all_descriptions(hass)) and assert that its output includes the new user-defined metadata for the special domain while leaving other domains unaffected.",
            "Step 8: Run static analysis and adjust types.\nRun mypy or your static analyzer. If it reports issues (e.g., about path types or possible None values), refine function annotations, path handling, and error branches so that all code paths are type-safe and clear.",
            "Step 9: Document user-facing behavior.\nUpdate any relevant documentation to explain where users should put their metadata file (e.g., <config>/python_scripts/services.yaml), what format it must follow, and how it interacts with core integration definitions (e.g., which side wins on conflicts)."
        ]
    }
}
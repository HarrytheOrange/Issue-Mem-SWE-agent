{
    "search_index": {
        "description_for_embedding": "Added an absolute candy limit for buddy Pokemon and fixed a potential crash when the current buddy evolves and no other Pokemon of that family exist. The new config `candy_limit_absolute` stops using a buddy once the family-wide candy threshold is reached, and buddy selection now safely handles missing Pokemon and is case-insensitive by name.",
        "keywords": [
            "buddy_pokemon",
            "candy_limit_absolute",
            "absolute candy limit",
            "PokemonGo-Bot",
            "buddy system",
            "pokemon family candy threshold",
            "buddy evolution crash",
            "None reference",
            "inventory validation",
            "case-insensitive name lookup"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the PokemonGo-Bot project, the existing buddy system supported a per-buddy `candy_limit` based on the number of candies awarded while that buddy is active. However, users wanted a way to stop farming candies for a Pokemon family once an absolute threshold (e.g., enough candies to evolve) was reached. Additionally, there was a potential crash scenario: if a current buddy evolved and there were no remaining Pokemon of that family in the inventory, the code assumed a Pokemon instance existed and accessed its attributes, which could result in a `None` dereference.\n\nTo address this, the `BuddyPokemon` task was extended with a new configuration option `candy_limit_absolute`. This value represents an absolute limit on the total candies for the buddy's Pokemon family. When the inventory's candy count for that family reaches or exceeds this limit, the bot will move on to the next buddy in the configured `buddy_list`. The new parameter was added to all example config files and documented in `docs/configuration_files.md` with its behavior and use case.\n\nIn the worker implementation (`pokemongo_bot/cell_workers/buddy_pokemon.py`), the `initialize` method now reads `candy_limit_absolute` from the config. The `work` method was updated so that:\n- It first resolves the current buddy to an inventory Pokemon via `_get_pokemon_by_id` and `_get_pokemon_by_name`.\n- If the buddy cannot be found (e.g., it evolved away or was transferred), the logic treats this as a condition to force a buddy change instead of continuing and potentially crashing.\n- It uses a new helper `_check_candy_limit_absolute(pokemon)` to determine if the absolute family candy limit has been reached for the current buddy.\n\nWhen deciding a new buddy, the loop over `buddy_list` now:\n- Skips entries where `_get_pokemon_by_name` returns `None` (no such Pokemon in inventory), and\n- Skips entries whose family has already reached the `candy_limit_absolute`, using the same helper.\n\nAdditionally, `_get_pokemon_by_name` was made case-insensitive (`p.name.lower() == name.lower()`), improving robustness against casing differences in configuration. A later commit refactored the absolute limit check into `_check_candy_limit_absolute` to avoid duplication and simplified conditional logic.\n\nOverall, this PR both introduced the `candy_limit_absolute` feature and hardened the buddy selection logic to prevent crashes when a buddy Pokemon is no longer present in the inventory.",
        "semantic_memory": "This fix illustrates several generalizable patterns and best practices:\n\n1. **Separate relative vs. absolute thresholds**: When designing systems driven by counters or rewards, it's often useful to support both an incremental limit (e.g., `candy_limit` per buddy session) and an absolute limit (e.g., `candy_limit_absolute` for the entire Pokemon family). This allows users to control behavior based on total accumulation, not just per-session activity.\n\n2. **Configuration-driven behavior with safe defaults**: Adding a new configuration parameter (`candy_limit_absolute`) with a clear default (`0` meaning \"no limit\") is a robust pattern. This avoids breaking existing configurations while enabling advanced users to opt into new behaviors.\n\n3. **Guard against missing entities before attribute access**: The crash risk here arose from assuming the current buddy's corresponding Pokemon always existed in inventory. The fix explicitly checks if the resolved Pokemon is `None` and handles that case gracefully, rather than dereferencing attributes unconditionally. This is a broadly applicable practice: always validate that external or dynamic references (inventory items, DB records, external API results) exist before using them.\n\n4. **Centralize complex condition checks**: Refactoring the repeated absolute limit check into `_check_candy_limit_absolute(pokemon)` simplifies logic and reduces duplication. Encapsulating non-trivial conditions in helper methods makes code easier to read, test, and maintain.\n\n5. **Robust identifier handling (case-insensitive names)**: Allowing case-insensitive matching for user-specified names (`p.name.lower() == name.lower()`) improves resilience against configuration errors. For any user-entered identifiers (names, tags, keys), it is often preferable to normalize them (e.g., to lower-case) before comparison.\n\n6. **Filtering candidate entities based on constraints**: When selecting the next entity (buddy) from a list, the code now filters out candidates that are unavailable (no Pokemon in inventory) or that have already met the configured resource threshold. This pattern—filter candidates first, then operate only on the remaining valid set—is widely applicable when scheduling or rotating tasks/resources.\n\n7. **Avoiding repeated side-effect calls by abstracting over state**: Using the helper `_check_candy_limit_absolute(pokemon)` encapsulates the logic to query `inventory.candies()` and compare against a limit. This reduces the risk of copy-paste errors and ensures the logic stays consistent across all call sites.\n",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify behavioral requirements beyond existing limits.\n- Review current limit mechanisms (e.g., per-session `candy_limit`) and gather user requirements for any absolute or global thresholds (e.g., total family candies).\n- Confirm whether current configuration options can express the desired behavior; if not, plan a new parameter.",
            "Step 2: Design and add a new configuration parameter.\n- Choose a descriptive name for the new parameter (e.g., `candy_limit_absolute`).\n- Define clear semantics and default behavior (e.g., `0` means no limit, so existing behavior is preserved).\n- Add the parameter to all relevant configuration examples and documentation, explaining how it interacts with existing options.",
            "Step 3: Wire the new configuration into initialization.\n- In the component's initialization (`initialize` or constructor), read the new config value and store it on the instance.\n- Comment the default behavior (e.g., `# 0 = No Limit`) to aid future maintainers.",
            "Step 4: Integrate the new limit into decision logic safely.\n- Locate the main decision point(s) where the existing limit is used (e.g., where buddy changes are triggered based on `candy_limit`).\n- Extend the condition to include the new absolute threshold logic.\n- If the logic is complex or used multiple times, extract it into a helper method (e.g., `_check_candy_limit_absolute(pokemon)`).",
            "Step 5: Prevent crashes from missing or invalid entities.\n- Audit the code paths where dynamic entities are looked up (e.g., inventory lookups via `_get_pokemon_by_name`).\n- Ensure these functions can return `None` and that callers explicitly check for `None` before accessing attributes.\n- In decision logic, treat a missing entity as a signal to choose an alternative (e.g., force a buddy change) instead of continuing blindly.",
            "Step 6: Filter candidate entities according to constraints.\n- When selecting the next entity from a list (e.g., `buddy_list`), first filter out:\n  - Entries that cannot be resolved to actual entities (`pokemon is None`).\n  - Entries that already satisfy the absolute limit (`_check_candy_limit_absolute(pokemon)` is true).\n  - Entries recently used or cached if applicable.\n- Operate only on the filtered list; handle the case where no valid candidates remain (e.g., clear cache and exit gracefully).",
            "Step 7: Normalize user-specified identifiers.\n- For name-based lookups, normalize both stored and input names (e.g., convert both to lower-case) before comparison.\n- Update helper methods such as `_get_pokemon_by_name` to perform case-insensitive matching, and ensure callers no longer depend on exact casing.",
            "Step 8: Refactor repeated logic into helper functions.\n- Identify duplicated conditionals (e.g., checks against `inventory.candies().get(...)` and the absolute limit).\n- Move this logic into a dedicated function with a clear name.\n- Replace all inline checks with calls to the helper to keep behavior consistent and future-proof.",
            "Step 9: Test standard and edge-case behaviors.\n- Test normal behavior without setting the new parameter (ensure backwards compatibility).\n- Test with `candy_limit_absolute` set below current candy count (buddy should change immediately).\n- Test with `candy_limit_absolute` set above current count, and verify that candy collection continues until the threshold.\n- Test the edge case where the current buddy evolves or is removed from inventory to confirm no crashes and that a new buddy is selected or handled gracefully.",
            "Step 10: Update documentation and example configs.\n- Verify that the new option is documented in user-facing docs, including examples of common values and use cases.\n- Ensure all sample configuration files contain the new parameter with default values so users discover it easily."
        ]
    }
}
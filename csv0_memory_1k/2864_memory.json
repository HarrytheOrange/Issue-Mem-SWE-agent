{
    "search_index": {
        "description_for_embedding": "Home Assistant gpmdp media_player integration was broken because it did not implement the Google Play Music Desktop Player PIN-based pairing flow and handled the WebSocket protocol incorrectly. The fix adds a configurator-based PIN entry, persists the authorization code to a JSON config file, performs the proper WebSocket 'connect' handshake with the code, and updates playback state/track metadata by parsing the asynchronous event stream with robust error handling.",
        "keywords": [
            "gpmdp",
            "Google Play Music Desktop Player",
            "media_player",
            "homeassistant",
            "websocket-client",
            "PIN pairing",
            "CODE_REQUIRED",
            "configurator",
            "authorization code",
            "playback state",
            "track metadata",
            "lyrics channel sentinel",
            "JSON config file",
            "ws://address:5672",
            "STATE_PLAYING",
            "STATE_PAUSED"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The gpmdp media_player platform in Home Assistant never worked for the reporter. Investigation showed that the integration did not implement the current Google Play Music Desktop Player (GPMDP) WebSocket pairing and state protocols. GPMDP requires a PIN-based pairing process where the desktop app displays a PIN, the client sends it via the 'connect' namespace, and GPMDP returns a persistent authorization code. The original code tried to connect without handling 'CODE_REQUIRED', did not use a configurator to collect the PIN, did not persist the authorization code, and assumed a very simplistic WebSocket message pattern (e.g., a single boolean payload indicating play/pause). As a result, the component never successfully authorized or correctly parsed playback state.\n\nThe fix introduces a full pairing and state-handling implementation:\n- A new configuration flow using Home Assistant's configurator is added via request_configuration(). When no code is available, it opens a WebSocket connection to ws://<address>:5672, sends a 'connect' request without a code, waits for a 'connect' channel message with payload 'CODE_REQUIRED', then prompts the user in the UI to enter the PIN shown in the desktop player. Once the PIN is submitted, it sends another 'connect' request with the PIN, receives an authorization code, and validates it (retrying if GPMDP still returns 'CODE_REQUIRED').\n- The retrieved authorization code is persisted to a JSON file (gpmpd.conf) using _save_config(), so future startups can connect without re-pairing. _load_config() reads this file on setup_platform() to retrieve the stored code.\n- setup_platform() and setup_gpmdp() are refactored to: (1) load the code from the stored JSON if available; (2) if no code is available and there is discovery, trigger the configurator-based pairing; and (3) once a code exists, create a GPMDP instance wired to the proper WebSocket URL (ws://address:5672).\n- The GPMDP entity now stores the WebSocket URL and authorization code. In get_ws(), when a WebSocket is first created it immediately sends a JSON 'connect' message including 'Home Assistant' and the persisted authorization code. Connection errors (socket timeout, refused, reset) are caught, and _ws is set to None so update() can handle the offline state.\n- The update() method is rewritten to handle the asynchronous event stream instead of assuming a single boolean payload. It loops over websocket.recv(), parsing JSON messages by 'channel': 'playState' updates the HA state to STATE_PLAYING/STATE_PAUSED; 'track' updates title, artist, and albumArt; 'lyrics' is used as an end-of-now-playing sentinel to break the loop. WebSocket timeout/protocol/payload exceptions are caught and cause update() to return without crashing.\n- media_play() is corrected to set the internal status to STATE_PLAYING after sending the playPause command.\n- Miscellaneous refactors: use a URL string instead of address+port in multiple places, handle configurator request_done() when pairing completes, and move websocket.create_connection imports into the narrowest scopes (request_configuration, GPMDP.__init__).\n\nAfter these changes, the gpmdp platform can successfully pair with GPMDP using the PIN, remember the authorization code, connect reliably on subsequent starts, and correctly control playback and display track metadata.",
        "semantic_memory": "This fix illustrates several general integration patterns and best practices for WebSocket-based media players and external apps that use PIN or code-based pairing:\n\n1. **Implement the full auth/pairing protocol, not just a bare connection.** Many desktop apps and devices that expose local APIs require a pairing flow: the app displays a PIN or code, the client submits it, and the app returns a persistent token or authorization code. A client that simply opens a socket without implementing the pairing steps will appear 'connected' but won't be authorized to control playback or receive full state.\n\n2. **Use a configuration UI to capture secrets or one-time codes.** When pairing requires user interaction (e.g., copy a PIN from a screen), surface this via a proper configuration flow (like Home Assistant's configurator) instead of expecting static YAML. This makes the integration more user-friendly and permits dynamic negotiation with the external app.\n\n3. **Persist authorization tokens to avoid re-pairing.** Once an authorization code or token is issued, store it locally (e.g., in a small JSON file) and load it on startup. That lets the integration reconnect silently on subsequent runs. Design your loader/writer functions to handle empty files, I/O errors, and invalid JSON without crashing.\n\n4. **Handle asynchronous WebSocket event streams instead of assuming a strict request/response pattern.** Media players often push multiple events in sequence (play state, track info, additional metadata). A robust client should loop over incoming messages, dispatch logic based on message type or 'channel', and know when it has enough data to update its internal state (e.g., using a 'lyrics' or similar event as a sentinel). Code that assumes a single recv() call equals 'current state' will break when the server protocol evolves.\n\n5. **Gracefully handle WebSocket errors and disconnections.** Networked integrations must anticipate timeouts, protocol errors, payload errors, and closed connections. Catch exceptions from recv(), treat errors as transient, and avoid crashing the main loop. Maintain a None or disconnected state for the socket so update() can recognize when the device is offline.\n\n6. **Keep integration logic modular.** This fix separates concerns: pairing/configuration (request_configuration, setup_gpmdp), connection management (get_ws), and state parsing (update). It also encapsulates persistence in _load_config and _save_config. This modularity makes it easier to update pieces as the remote protocol evolves.\n\n7. **Use structured JSON and avoid building complex payloads as raw strings.** Where possible, build JSON via json.dumps and only fall back to string literals for simple static messages. This avoids subtle formatting bugs and makes code easier to audit when the protocol changes.\n\nThese principles apply broadly to any smart-home or local-network integration with a desktop app, media player, or IoT device that uses local WebSocket APIs and requires user-mediated authorization.",
        "procedural_memory": [
            "When a Home Assistant or similar integration 'never worked' for a WebSocket-based media player, follow these steps:",
            "Step 1: Reproduce and inspect basic connectivity.",
            "- Confirm that the target service (e.g., GPMDP) is running and listening on the expected host/port (e.g., ws://<address>:5672).",
            "- Try a minimal WebSocket client (or logs) to ensure you can connect and receive messages.",
            "- Enable verbose logging for the integration to see if initial connection attempts or auth errors are reported.",
            "Step 2: Understand the remote protocol and pairing requirements.",
            "- Review the external app's API or protocol docs, or capture traffic using a test client.",
            "- Identify whether there is a pairing flow: look for messages like 'CODE_REQUIRED', guidelines that the app shows a PIN, or mention of authorization codes/tokens.",
            "- Determine the exact sequence: what message you must send first, how the PIN is submitted, and what form the returned token/authorization code takes.",
            "Step 3: Implement or repair the pairing flow in the integration.",
            "- Add logic to send the initial 'connect' or equivalent handshake request without a code and interpret the server's 'CODE_REQUIRED' response.",
            "- Integrate with the host system's configuration UI (e.g., Home Assistant configurator) to prompt the user for the PIN displayed by the external app.",
            "- Once the user provides the PIN, send the appropriate 'connect' message including the PIN and consume the response that contains the persistent authorization code.",
            "- Handle retries if the server returns 'CODE_REQUIRED' again (invalid PIN or race condition).",
            "Step 4: Persist the authorization code or token.",
            "- Write helper functions to save/load a small JSON config file (e.g., gpmpd.conf) in the application's config directory.",
            "- On save, use json.dumps with proper error handling (IOError, TypeError), and log any failure.",
            "- On load, handle empty or missing files by returning a default (e.g., {}), and catch JSON parsing errors; treat them as a recoverable condition, not a crash.",
            "- At startup (in setup_platform or equivalent), check this file for an existing code and use it to skip the pairing flow.",
            "Step 5: Refactor platform setup to use the stored code.",
            "- In setup_platform or equivalent initialization, call your load_config function and extract the stored authorization code (if any).",
            "- If a code is present, create the device/entity instance with that code and connect directly.",
            "- If no code is available, and the integration is being set up (either via config or discovery), trigger the configuration/pairing flow and postpone entity creation until pairing succeeds.",
            "- Mark any ongoing configuration in a module-level structure (e.g., _CONFIGURING) and call configurator.request_done() once pairing finishes.",
            "Step 6: Robustly manage the WebSocket connection in the device/entity.",
            "- Store the WebSocket URL and authorization code on the entity.",
            "- Implement a get_ws() helper that lazily creates the WebSocket connection when needed, sends the 'connect' message including the authorization code, and caches the WebSocket object.",
            "- Catch connection-related exceptions (timeouts, refused connections, resets) and set the connection reference to None so the rest of the code knows the device is offline.",
            "- Avoid constantly closing and reopening the WebSocket on every update; reuse the connection where appropriate and only recreate on failure.",
            "Step 7: Correctly parse the asynchronous event stream for state and metadata.",
            "- In the update() loop or equivalent, call websocket.recv() in a loop and parse each JSON message.",
            "- Dispatch based on top-level fields (e.g., 'channel'): handle 'playState', 'track', 'lyrics', etc.",
            "- For 'playState' (or equivalent), update the entity's state to playing/paused/off based on the payload.",
            "- For 'track' events, extract title, artist, and albumArt (or their equivalents) and update the entity's attributes.",
            "- Decide when you have enough information to stop reading (e.g., using a known sentinel like 'lyrics' to mark end of the now-playing batch) and exit the loop.",
            "- Catch WebSocket exceptions around recv() (timeout, protocol, payload issues) and return gracefully without crashing the integration.",
            "Step 8: Ensure command methods reflect the correct state.",
            "- Update media_play, media_pause, and other control methods to send the correct WebSocket commands (e.g., 'playback' namespace with 'playPause').",
            "- After sending a command, update the local state optimistically (e.g., set status to STATE_PLAYING when playPause is invoked from a paused state) or rely on the next update() call to reflect the change.",
            "- Call update_ha_state() (or equivalent) when appropriate to sync the UI.",
            "Step 9: Validate end-to-end behavior.",
            "- Run the integration and follow the pairing flow: trigger configuration, enter the PIN shown in the external app, ensure an authorization code is saved to the config file, and confirm that subsequent restarts skip the PIN step.",
            "- Confirm that playback controls from Home Assistant (or the host platform) affect the media player and that track metadata updates correctly.",
            "- Simulate disconnections (closing GPMDP, network failure) to ensure the integration fails gracefully and recovers when the app is back.",
            "Step 10: Document the configuration requirements for users.",
            "- Provide an example configuration snippet (e.g., media_player: platform: gpmdp, address: 192.168.1.100) and explain the pairing process.",
            "- Note where the authorization file is stored and that users generally do not need to edit it manually once pairing is complete."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor napari layer interaction code to deprecate `layer.displayed_coordinates` and `Shapes.expand_shape`, move shape movement logic out of the Shapes layer into mouse/key bindings, and update all shape/point interaction code to use full nD `layer.coordinates` plus `layer._dims_displayed`. Adds DeprecationWarnings and docstring guidance for alternative code paths.",
        "keywords": [
            "napari",
            "displayed_coordinates deprecation",
            "expand_shape deprecation",
            "shapes layer",
            "points layer",
            "mouse bindings",
            "key bindings",
            "dims_displayed",
            "nD coordinates",
            "DeprecationWarning",
            "API migration",
            "selection box",
            "shape editing",
            "refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the napari team addressed a design/API problem around how layers depend on viewer dimension state. Historically, many interaction routines (especially for Shapes and Points layers) used `layer.displayed_coordinates`, a 2D projection of the cursor position based on the currently displayed dimensions, and Shapes used `expand_shape` to expand 2D vertex coordinates back into full nD coordinates. This tightly coupled layers to the concept of 'displayed dimensions', making it harder to evolve the dims API and reason about nD data.\n\nThe fix proceeds in several steps:\n\n1. **Move shape movement logic out of the Shapes layer into mouse bindings**: The logic previously implemented as `Shapes._move` is moved into helper functions `_move` and `_drag_selection_box` in `napari/layers/shapes/_shapes_mouse_bindings.py`. The Shapes class no longer owns the movement code; mouse/key bindings call these helpers. References to `self._move` on the Shapes instance are replaced with module-level `_move(layer, coordinates)` calls.\n\n2. **Replace `displayed_coordinates` with `coordinates + _dims_displayed`**: Instead of using `layer.displayed_coordinates` inside event handlers, the code now uses `layer.coordinates` (full nD coordinates in data space) and slices it down to the displayed dimensions with `[layer.coordinates[i] for i in layer._dims_displayed]` when a 2D coordinate is needed. For example, selection-box drag handling in both Points and Shapes now computes `coord = [layer.coordinates[i] for i in layer._dims_displayed]` instead of using `layer.displayed_coordinates`.\n\n3. **Stop using `expand_shape` in Shapes interactions**: Shapes previously used `expand_shape` to convert 2D vertices into full nD coordinates (e.g., when adding rectangles, ellipses, lines, or editing vertices). The PR removes most uses of `expand_shape`, storing and editing vertices directly in full nD data arrays (`layer._data_view.shapes[index].data`). Mouse and key bindings update these full nD arrays instead of manipulating `displayed_vertices` and then expanding them. The only remaining use of `expand_shape` is in the deprecated method itself for backwards compatibility.\n\n4. **Add deprecations with clear guidance**:\n   - `BaseLayer.displayed_coordinates` now emits a `DeprecationWarning` and has an updated docstring explaining it will be removed in 0.4.9 and that consumers should instead use `[layer.coordinates[d] for d in viewer.dims.displayed]`.\n   - `Shapes.expand_shape` similarly emits a `DeprecationWarning` and explains that code should work directly with full nD shape data instead of expanding 2D projections.\n\n5. **Adjust creation of new shapes to be nD aware**: When adding lines, rectangles, and ellipses, the initial geometry is now created in full nD coordinates. For example, `add_line` builds a `full_size` vector with non-zero entries only in the displayed dimensions and adds it to `layer.coordinates`; rectangles and ellipses do the same using `size_h` and `size_v` aligned to the two displayed dimensions. The shapes are added directly via `layer.add(data, shape_type=...)` without calling `expand_shape`.\n\n6. **Misc interaction fixes and consistency**:\n   - Vertex insert/remove for shapes now use `layer._data_view.shapes[index].data` instead of `displayed_vertices` plus `expand_shape`.\n   - The path/polygon creation flow (`add_path_polygon`, `_finish_drawing`) is updated to work on the full nD `shapes[index].data` arrays and to append/trim vertices without intermediate expansion.\n   - In Points selection, drag-box creation is corrected so that `_drag_box` uses `layer._drag_start` and current `coord` consistently.\n\nOverall, this episode is about decoupling layer internals from viewer dims, pushing interaction logic into the mouse/key binding modules, and providing a clean deprecation path for public APIs (`displayed_coordinates`, `expand_shape`) while leaving existing code functional but noisy via warnings.",
        "semantic_memory": "This change illustrates several generalizable practices around API evolution, multidimensional data handling, and GUI interaction design:\n\n1. **Decouple model state from view-specific concepts**: Layers represent n-dimensional data and should not need to know which subset of dimensions is currently being displayed in a viewer. Coupling layers to 'displayed dims' (e.g., via `displayed_coordinates`) makes it hard to reuse layer models in contexts without a viewer and complicates future changes to the dims API. A better pattern is for the layer to expose canonical, full nD state (`layer.coordinates`, shape vertices in nD), and for the view/controller layer (mouse bindings, key bindings, viewer) to perform the projection to displayed dimensions as needed.\n\n2. **Deprecate API thoughtfully with clear alternatives**: When removing or redesigning public interfaces, it's important to (a) keep the old entry points functional for at least one deprecation cycle, (b) emit `DeprecationWarning` with a version schedule, and (c) describe the migration path directly in the warning and docstring (e.g., 'use `[layer.coordinates[d] for d in viewer.dims.displayed]` instead'). This helps downstream users update their code proactively.\n\n3. **Work with full nD data in core models**: For nD visualization tools, keeping shapes/points representations in full nD makes interactions (rotate, scale, translate) more consistent and extensible. Projections down to 2D should happen at the rendering or interaction boundary, not in the core data model, which avoids brittle `expand_shape` logic that depends on current view state.\n\n4. **Centralize interaction logic in controller modules**: Moving `_move` and selection-logic out of the Shapes class into `_shapes_mouse_bindings.py` aligns with MVC-style separation. The layer becomes a relatively thin data model with methods like `shift`, `scale`, `rotate`, and the controller (mouse/key binding files) orchestrates how user events transform shapes. This makes it easier to reason about interactions and reduces inter-module coupling.\n\n5. **Be explicit when converting between coordinate spaces**: The refactor makes coordinate transformations explicit: full nD `coordinates` are sliced using `layer._dims_displayed` to produce 2D coordinates for selection boxes or shape manipulation. This explicitness avoids hidden state and clarifies what space each variable lives in (data-space vs. view-space), which reduces subtle bugs in nD interaction code.\n\n6. **Cleaning up legacy helper methods**: Helpers like `expand_shape` that encode legacy assumptions (e.g., 'shapes are inherently 2D and need expansion') can become obstacles once requirements shift to true nD support. Deprecating these methods and replacing them with direct nD operations simplifies the code path and makes future features (e.g., arbitrary slicing, 3D interactions) more straightforward.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving deprecating view-coupled APIs and migrating to nD-aware interaction logic:",
            "Step 1: Identify view-coupled APIs and data flows",
            "Scan the code for properties and methods that depend on viewer state, such as 'displayed_coordinates', 'displayed_vertices', or any logic that assumes a fixed 2D representation.",
            "Check where these APIs are used (especially in mouse/key bindings, layer methods, and plugin APIs) to understand the coupling between model and view.",
            "Step 2: Introduce or standardize a canonical nD representation",
            "Ensure each relevant model (e.g., layer, shape, point) exposes a single source of truth for nD data: full coordinates, vertex arrays, etc.",
            "If necessary, add or document attributes like `layer.coordinates` that represent cursor position or object positions in full data space, independent of the current view.",
            "Step 3: Refactor interaction code to use the nD representation",
            "In mouse/key binding code, stop using view-specific helpers (like `displayed_coordinates`) directly.",
            "Replace uses of such helpers with explicit transformations of the nD state, e.g.: `coord = [layer.coordinates[d] for d in layer._dims_displayed]` for 2D interactions.",
            "For object editing (translation, scaling, rotation), operate on full nD vertex arrays (`shape.data`) instead of 2D projections plus conversion functions like `expand_shape`.",
            "Step 4: Move controller logic out of model classes where appropriate",
            "If a layer class contains large methods for handling user interactions (e.g., `_move`, selection-box handling), move that logic into dedicated controller modules (like `_shapes_mouse_bindings.py`).",
            "Transform instance methods into helper functions that take the layer instance as a parameter, and update all callers to use the new helpers.",
            "This keeps the layer models focused on state and transformations (shift/scale/rotate) while controllers handle event sequences.",
            "Step 5: Add deprecation wrappers for legacy APIs",
            "Keep the old properties/methods (e.g., `displayed_coordinates`, `expand_shape`) as thin wrappers that emit `DeprecationWarning` and call the new logic if needed.",
            "In the warning message and docstring, specify:",
            "- The version in which the API will be removed.",
            "- Why it is deprecated (e.g., layers should not know displayed dims).",
            "- The exact alternative code path (e.g., `[layer.coordinates[d] for d in viewer.dims.displayed]`, or 'work with full nD shape data').",
            "Set `stacklevel` appropriately (e.g., 2) so warnings point to the caller's location, not the wrapper itself.",
            "Step 6: Update all internal call sites",
            "Systematically replace internal uses of the deprecated APIs with the new approach:\n- Replace `layer.displayed_coordinates` with explicit slices from `layer.coordinates`.\n- Replace uses of `expand_shape` + `displayed_vertices` with direct edits to full nD `shape.data` arrays.",
            "Ensure that all mouse/key bindings and layer methods now operate only on the new model without relying on deprecated helpers.",
            "Step 7: Verify behavior for nD data and edge cases",
            "Test interactions (selection box, move, scale, rotate, vertex insert/remove, path/polygon drawing) in datasets with >2 dimensions to confirm coordinate handling is correct.",
            "Pay special attention to:\n- Selection-box coordinates (start vs. current).\n- Shapes added in higher dimensions (ensure offsets are applied only in displayed dimensions).\n- Vertex operations that previously used `displayed_vertices` and now use `shape.data`.",
            "Step 8: Add or update tests to lock behavior in",
            "Add tests for the deprecated properties to ensure they still function but emit warnings.",
            "Add tests for the new interaction paths (e.g., creating and editing shapes via full nD data) and confirm they produce expected vertices and selection boxes.",
            "Step 9: Communicate migration to downstream users",
            "Include deprecation notes in the public docs and changelog.",
            "Show small code examples demonstrating how to replace `layer.displayed_coordinates` and `expand_shape` in user plugins and scripts.",
            "Step 10: Plan removal in a future release",
            "Once the deprecation window has elapsed (e.g., 0.4.9 in this case), remove the deprecated APIs and any legacy paths that rely on them, relying solely on the nD-aware interactions and controller-level coordinate handling."
        ]
    }
}
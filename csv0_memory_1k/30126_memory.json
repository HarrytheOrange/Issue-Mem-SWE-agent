{
    "search_index": {
        "description_for_embedding": "Attempted change to Home Assistant's Alexa smart_home integration to log directive namespace, name, and payload at INFO level instead of only having full messages at DEBUG. The change was rejected because it would duplicate existing debug logging and flood logs with large, frequent payloads, making INFO logs too verbose.",
        "keywords": [
            "logging level",
            "INFO vs DEBUG",
            "Alexa smart_home",
            "directive payload logging",
            "log verbosity",
            "Home Assistant",
            "duplicate logging",
            "integration logs"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a contributor proposed an enhancement to the Home Assistant Alexa smart_home integration. The existing behavior logged the entire Alexa message and request at DEBUG level, which contained a lot of data. The contributor wanted easier access to just the directive name and payload without enabling full DEBUG logs, particularly while developing Alexa-related features for a Samsung TV. They added an INFO-level log inside async_handle_message right before calling the handler:\n\n_LOGGER.info(\"Processing %s.%s Payload: %s\", directive.namespace, directive.name, directive.payload)\n\nThis meant every Alexa directive handled would now emit an INFO log with the namespace, directive name, and the full payload. Reviewers raised concerns that this is still too verbose for INFO, especially for high-frequency directives like SendReport, and that it duplicates information already available at DEBUG level, leading to flooded logs for users. The maintainer (balloob) ultimately closed the PR, stating that the payloads are large, the logging is not truly simplified, and developers using DEBUG would now see similar information twice. No code was merged; the component behavior remained unchanged.",
        "semantic_memory": "This case highlights best practices around logging levels and log design in event-heavy integrations:\n\n1. INFO vs DEBUG semantics: INFO should generally represent high-level, infrequent events that are useful in normal operation (e.g., \"integration started\", \"device discovered\", \"action completed\"). DEBUG should contain detailed, often verbose data useful for troubleshooting and development (e.g., full request/response payloads, internal state dumps).\n\n2. Log volume and user impact: In high-traffic components (like voice assistant integrations handling many directives per day), even small per-event logs at INFO level can create huge log volume. This can overwhelm users, obscure important messages, and increase storage or performance overhead.\n\n3. Avoid redundant logging: Logging substantially the same information at multiple levels (e.g., payload at DEBUG and again at INFO) reduces signal-to-noise and makes it harder for developers to interpret logs. Each log level should add incremental value.\n\n4. Payload size matters: Even if a log entry seems conceptually 'simpler' (just the payload instead of an entire envelope), the payload itself may still be large. Logging large structures at INFO can be almost as problematic as logging the full message.\n\n5. Developer convenience vs. global behavior: Convenience for a specific development workflow (e.g., wanting to see payloads without turning on full DEBUG logging) must be weighed against the impact on all users. Changes to log levels should consider typical use cases, not just developer debugging needs.\n\n6. Prefer configurability over raising log levels: When detailed information is helpful only in certain scenarios, it's often better to rely on DEBUG logging or configuration-based log level overrides rather than promoting verbose logs to INFO globally.",
        "procedural_memory": [
            "When considering changes to logging behavior in an integration, especially one that handles frequent requests/events:",
            "Step 1: Identify the exact information missing from existing logs. Determine whether that information is truly absent, or already available at DEBUG or another log level.",
            "Step 2: Assess log frequency and payload size. Estimate how often the new log would fire (e.g., per message, per request, per second) and how large the log message will be. For high-frequency paths, be conservative with INFO/WARN logs.",
            "Step 3: Map the information to appropriate log levels. Use INFO for concise, high-level state changes and significant events; use DEBUG (or TRACE) for detailed payloads and diagnostic information. Avoid placing large payloads at INFO.",
            "Step 4: Check for duplication with existing logs. If the same or similar data is already logged at another level, reconsider adding another log. Instead, consider improving or clarifying the existing log message.",
            "Step 5: Consider configuration-based solutions. If developers need richer logs temporarily, rely on per-module log level configuration (e.g., setting the specific integration to DEBUG) rather than globally increasing verbosity at INFO.",
            "Step 6: Gather maintainer and user feedback. For contentious logging changes, solicit opinions from codeowners or maintainers who understand typical deployment patterns and support load.",
            "Step 7: Prototype and measure. Run the modified component in a realistic environment, collect logs over time, and inspect their volume and readability. Confirm that important messages are not drowned out.",
            "Step 8: Adjust or revert as needed. If feedback indicates excessive verbosity or redundancy (e.g., payloads are large and are now logged twice), revert the INFO changes and keep detailed logs at DEBUG, or refine the content and conditions for the logs."
        ]
    }
}
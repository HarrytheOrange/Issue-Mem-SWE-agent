{
    "search_index": {
        "description_for_embedding": "Home Assistant OpenSky sensor updated to add an optional altitude filter configuration and to include altitude metadata in entry/exit events. The sensor now filters tracked flights by distance and altitude, while keeping backward compatibility by defaulting altitude to 0 (no altitude filtering).",
        "keywords": [
            "Home Assistant",
            "OpenSky",
            "opensky sensor",
            "altitude filter",
            "configuration option",
            "optional config",
            "entry/exit events",
            "event metadata",
            "backwards compatibility",
            "radius and altitude based filtering"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant OpenSky sensor was enhanced to support altitude-based filtering and richer event metadata while preserving existing behavior. Originally, the sensor only filtered flights by geographic radius and tracked them by callsign, firing entry/exit events with limited information (no altitude). The issue requested adding altitude options and exposing altitude in event data.\n\nTo implement this, the developer first extended the OpenSky API field mapping to explicitly include 'altitude' as an attribute and added an ATTR_ALTITUDE constant. The configuration schema for the opensky platform was updated to accept a new optional 'altitude' parameter, with a default value of 0. A default of 0 means \"no altitude limit\", preserving existing behavior so current users are unaffected.\n\nInternally, the sensor now stores the configured altitude threshold (_altitude) in meters. During each update, it maps each OpenSky API state into a 'flight' dict, builds a metadata map keyed by callsign, and skips entries with missing callsigns or missing location. It continues to filter flights by distance within the specified radius. Additionally, it filters out flights whose reported altitude is greater than the configured altitude when the configured altitude is non-zero; when altitude is 0, all altitudes are accepted.\n\nThe tracking logic was also refactored. Previously, the sensor stored flight dicts or callsigns directly in the currently_tracked set. The new code keeps a set of callsigns and a separate metadata dictionary (callsign -> flight dict). Entry and exit sets are computed as before, but the event handler _handle_boundary() now takes the set of callsigns and the metadata dict, looks up altitude if present, and fires events containing both the callsign and altitude. If a flight's metadata is missing (e.g., it has landed and disappeared from the OpenSky feed), the code assumes altitude 0.\n\nFinally, to keep scope localized, CONF_ALTITUDE was moved from the global homeassistant.const module into the opensky platform module as a local constant. There were also minor cleanups: unused imports (math) were removed, and imports were reformatted for style. The result is an opensky sensor that can be configured with a radius and an altitude ceiling, emits richer entry/exit events, and remains backward compatible with existing configurations.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices:\n\n1. **Adding optional configuration while preserving backward compatibility**: When introducing new behavior (here, altitude filtering), make the new configuration optional, provide a sensible default that matches prior behavior, and ensure existing configurations remain valid. In this case, `altitude` defaults to 0, and 0 is interpreted as \"no altitude limit\".\n\n2. **Separating identity from metadata**: For tracking entities over time, it's often better to store identifiers (e.g., callsigns) in sets for comparisons (entries/exits) and maintain a separate mapping from identifier to metadata (flight details). This makes set operations cheap and clear, while still having access to full metadata when firing events or building responses.\n\n3. **Enriching event payloads without breaking consumers**: When you enhance events with new fields (like adding altitude to entry/exit events), keep the existing fields intact and add new ones in a backward-compatible way. Consumers relying on the old schema continue to work, while new consumers can use the additional data.\n\n4. **Using sentinel configuration values to denote special behavior**: The use of `0` as a special value meaning \"no altitude filtering\" is a common pattern. It avoids extra flags while keeping the configuration compact. This must be clearly documented and consistently enforced in code.\n\n5. **Localizing configuration constants**: Not all configuration keys need to be global. Keeping platform-specific configuration keys (like `altitude` for the OpenSky sensor) in the platform module instead of a global constants module reduces global namespace bloat and makes it easier to reason about ownership of configuration options.\n\n6. **Defensive handling of missing external data**: When consuming external APIs, values may be missing (e.g., null latitude/longitude or missing altitude). The code explicitly checks for missing data and skips or falls back appropriately (skip flights without location; assume altitude 0 for flights not present in metadata when firing exit events). This avoids runtime errors and inconsistent behavior.\n\n7. **Consistent mapping of external API fields**: Using a fixed list of API fields (OPENSKY_API_FIELDS) and `zip` to map the array responses into dictionaries is a clean pattern for structuring external data. When new fields (such as altitude) are needed, they should be added to the mapping list so that downstream code can access them by semantic keys rather than index.",
        "procedural_memory": [
            "When you need to add a filter or new metadata to an existing integration while keeping it backward compatible, follow a structured process:",
            "Step 1: Identify the new requirement and its scope.\nDetermine what additional data or behavior is needed. In this case, users wanted altitude-based filtering and altitude included in entry/exit events for the OpenSky sensor.",
            "Step 2: Extend the data model from the external API.\nIf the external API already provides the needed data (altitude), ensure your code maps that field from the API response into your internal representation. For list-based API responses, add the new field to any field-name list used with zip() so downstream code can access it via a named constant.",
            "Step 3: Introduce an optional configuration parameter with a safe default.\nAdd a new configuration option (e.g., `altitude`) to the relevant platform/schema. Use the configuration validation library to define its type and default value. Choose a default that preserves existing behavior (altitude = 0 interpreted as \"no altitude limit\").",
            "Step 4: Wire the configuration into the entity initialization.\nUpdate the platform's `setup_platform` function to read the new config value and pass it into the entity constructor. Update the entity's `__init__` signature and store the value in an instance attribute (for example, `self._altitude`).",
            "Step 5: Update the filtering logic to respect the new parameter.\nIn the periodic update method, after applying existing filters (e.g., location/radius, on-ground), add logic to filter out entities that do not meet the new criterion. For altitude, this means skipping flights whose altitude is greater than the configured threshold, unless the threshold is 0 (special value meaning no filtering).",
            "Step 6: Refactor tracking to cleanly separate identifiers and metadata.\nKeep a set of identifiers (e.g., callsigns) for set-based operations (entries/exits), and a separate dictionary mapping identifiers to full metadata collections. This pattern simplifies computing differences between current and previous tracked entities while still allowing rich event data.",
            "Step 7: Enhance event firing to include new metadata.\nUpdate any event handlers (e.g., entry/exit events) to accept the metadata mapping and use it to populate additional fields in the event payload (such as altitude). Handle missing metadata defensively, providing a reasonable default (e.g., altitude 0 if a flight disappeared from the current metadata).",
            "Step 8: Ensure constants are defined in the right scope.\nDetermine whether new config keys or attributes should be global or platform-specific. If the key is only used in one integration, define it within that module rather than in a global constants module to reduce clutter.",
            "Step 9: Clean up imports and unused code.\nRemove unused imports introduced during experimentation (like math) and reformat imports for clarity and style consistency.",
            "Step 10: Test backward compatibility and new behavior.\nVerify that existing configurations (without the new option) still work exactly as before. Then test configurations using the new option, ensuring filtering/rules behave as expected, and that events contain the new metadata fields. Run the test suite (e.g., tox) to catch regressions."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant MPD media_player integration PR that attempted to show songs of a selected playlist via media_player.source_list. Implementation added a _currentplaylistsongs buffer, overloaded source_list to return either playlists or songs, used '..' as a back entry, and added a list_playlist wrapper calling MPD's listplaylist. Reviewers rejected this because source_list is meant for inputs/services/playlists, not queue contents; songs should be exposed as a state attribute instead.",
        "keywords": [
            "Home Assistant",
            "mpd",
            "media_player",
            "source_list",
            "playlist items",
            "queue exposure",
            "MPD listplaylist",
            "integration design",
            "state attributes vs sources",
            "UI semantics"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this Home Assistant PR for the MPD media_player integration, the contributor wanted the UI to show the individual songs in a selected MPD playlist, not just the list of playlists. The idea was: when the user selects a playlist from media_player.source_list, the list of sources would switch to the songs in that playlist, plus a special '..' entry to return to the playlist list. Selecting a song would start playback of that specific song. To implement this, a new instance variable _currentplaylistsongs was added. The source_list property was changed to return _currentplaylistsongs if present, otherwise the list of playlists. The select_source method was modified to: clear _currentplaylistsongs when '..' is selected (going back); play an individual track via MEDIA_TYPE_MUSIC when a song is selected and _currentplaylistsongs is active; otherwise, when a playlist is selected, populate _currentplaylistsongs with ['..'] + list_playlist(source) and play the playlist via MEDIA_TYPE_PLAYLIST. A helper method list_playlist(name) was added to wrap self._client.listplaylist(name). Logging and the play_media docstring were generalized from 'playlist' to 'item'. During review, a maintainer pointed out that media_player.source_list is intended for high-level sources such as inputs, services, radio stations, or playlistsâ€”not individual items in the playback queue. They recommended exposing the items (songs in the playlist) as a state attribute instead of overloading source_list. The contributor asked how to surface that in the UI, but the discussion did not progress further, and the PR was closed without merging. The core issue was not a bug in MPD or Home Assistant, but a mismatch between the desired UX and the intended semantics of the media_player platform API.",
        "semantic_memory": "This incident illustrates a few general principles for integration and platform design:\n\n1. **Respect platform semantics and contracts**: Framework-level abstractions (like Home Assistant's media_player.source_list) have defined meanings. Overloading them to represent different concepts (e.g., using source_list for both playlists and tracks) can be confusing to users, UI developers, and other integrations. Such changes might work technically but are likely to be rejected or cause long-term maintainability issues.\n\n2. **Separate high-level sources from playback queue contents**: In media player integrations, there is a conceptual difference between **sources** (inputs, accounts, services, playlists) and **items in the playback queue** (tracks, radio streams). Sources are typically stable and small in number; queue contents are dynamic and potentially large. APIs and UIs often treat these differently and should not be conflated.\n\n3. **Use state attributes for additional structured data**: When the core entity model does not explicitly support a particular UI or data concept (like listing playlist contents), the recommended pattern is often to expose that data as extra state attributes (e.g., `queue`, `playlist_items`) rather than altering the semantics of existing core properties. This preserves compatibility while still making data available to advanced users or custom UIs.\n\n4. **Hierarchical navigation in flat lists is a UX/API smell**: Introducing pseudo-items such as '..' to represent navigation in an otherwise flat list is a workaround indicating that the underlying API might not be the right place to model hierarchical state. It can be useful in prototypes, but in a well-designed system, hierarchy should be modeled explicitly or handled at the UI level.\n\n5. **Thin wrappers around third-party APIs**: The addition of list_playlist as a simple wrapper to the MPD client's listplaylist method is a common pattern to encapsulate third-party API calls. However, when exposing such data, it still must respect the higher-level platform's conventions and contract.\n\n6. **PRs can be technically correct yet conceptually misaligned**: This PR likely worked locally and passed tests, but was still rejected because it didn't fit the conceptual model of the media_player platform. Maintaining a coherent platform sometimes means saying no to helpful but misaligned contributions.\n",
        "procedural_memory": [
            "When designing or modifying an integration that plugs into a framework (like Home Assistant's media_player), first confirm the intended semantics of each platform property (e.g., source_list, state, attributes) and align your design accordingly.",
            "Step 1: Identify the user-facing requirement clearly (e.g., 'show songs in a selected playlist from an MPD server in the UI'). Determine whether this is about sources, queue contents, metadata, or control actions.",
            "Step 2: Review the platform's developer documentation for the relevant entity type (e.g., Home Assistant media_player docs). Note what each property and method is meant to represent (source_list = inputs/services/playlists, attributes = additional data, etc.).",
            "Step 3: Map your requirement onto existing abstractions. If the requirement is about dynamic, potentially long lists of content (queue, playlist items), prefer exposing this as one or more state attributes rather than repurposing core properties that have established semantics.",
            "Step 4: If you need to expose playlist or queue contents, add an attribute at the entity level (e.g., `self._playlist_items`) and return it via the entity's `device_state_attributes`/`extra_state_attributes` property (or equivalent for the platform). This keeps core properties intact while making the info available.",
            "Step 5: Avoid encoding navigation or hierarchy into flat lists of items via synthetic entries like '..' unless you control the UI and intentionally design around that pattern. Instead, model hierarchy explicitly (e.g., separate entities, attributes, or custom UI components).",
            "Step 6: If you need new UI capabilities (e.g., a list widget for playlist items), consider whether the platform already supports them. If not, propose UI-level enhancements rather than bending the integration API to fit an unsupported UX.",
            "Step 7: When wrapping third-party APIs (like MPD's listplaylist), create thin, clearly named helper methods on the integration that return clean, framework-agnostic data structures (e.g., lists of track IDs or objects). Keep these wrappers decoupled from UI decisions.",
            "Step 8: Before finalizing the implementation, seek early feedback from maintainers in areas that may touch core semantics (e.g., changing behavior of source_list). This can prevent implementing solutions that will later be rejected for conceptual reasons.",
            "Step 9: Write tests that validate both technical behavior (e.g., list_playlist returns expected songs) and adherence to platform contracts (e.g., source_list only contains high-level sources). If a test would need to assume semantics contrary to the docs, reconsider the design.",
            "Step 10: If a PR is rejected for conceptual misalignment, extract the reusable parts (e.g., MPD API wrappers, playlist parsing logic) and refactor them into an approach that uses state attributes or custom entities, consistent with platform guidelines."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix napari's bundled-app detection that crashed under cProfile and yappi. The function running_as_bundled_app() called importlib.metadata.metadata(app_module) where app_module came from __main__.__package__. When profiling via `python -m cProfile file.py` or yappi, __main__.__package__ did not correspond to an installed package, causing importlib.metadata.PackageNotFoundError and aborting startup. The fix is to catch PackageNotFoundError and return False (not a bundled app), which also generalizes to any non-installed __main__.",
        "keywords": [
            "napari",
            "running_as_bundled_app",
            "__main__.__package__",
            "cProfile",
            "yappi",
            "importlib.metadata.metadata",
            "importlib.metadata.PackageNotFoundError",
            "profiler",
            "briefcase",
            "bundled app detection",
            "PackageNotFoundError",
            "runtime environment detection"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari failed to run when invoked under profilers like cProfile and yappi using a command such as `python -m cProfile -o file.pstat file.py`. The error raised was importlib.metadata.PackageNotFoundError. The root cause was in napari.utils.misc.running_as_bundled_app(): it attempted to determine whether it was running as a briefcase-bundled app by reading `app_module = sys.modules['__main__'].__package__` and then calling `importlib_metadata.metadata(app_module)`. Under profiling, `__main__.__package__` did not correspond to an installed distribution, so importlib.metadata.metadata raised PackageNotFoundError. An initial fix special-cased cProfile and yappi by inspecting `sys.modules['__main__'].__spec__.name` and returning False early, but this was refined into a more general solution: wrap the metadata lookup in a try/except block. The final code does `app_module = sys.modules['__main__'].__package__` and then `try: metadata = importlib_metadata.metadata(app_module) except importlib_metadata.PackageNotFoundError: return False`. Only if metadata is successfully loaded does it check `'Briefcase-Version' in metadata`. This prevents crashes under cProfile, yappi, and any other execution environment where `__main__.__package__` is not an installed package, while correctly identifying briefcase bundles.",
        "semantic_memory": "When code inspects package metadata at runtime to infer its execution environment (e.g., to detect if it is running from a bundled application), it must be robust to contexts where the 'main' module is not an installable package. Using importlib.metadata.metadata() with a name that does not correspond to an installed distribution raises PackageNotFoundError, which will crash the program unless handled. Instead of special-casing specific tools like cProfile or yappi, a better pattern is to catch PackageNotFoundError and fall back to a safe default (e.g., assume 'not bundled'). More generally, any environment detection logic based on __main__.__package__, __spec__, or package metadata must treat missing or non-standard values as normal conditions rather than exceptional errors. Defensive checks (hasattr, try/except) and generic handling of metadata lookup failures are preferable to tool-specific conditionals and make the code more future-proof across debuggers, profilers, and alternate launch methods.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the error in the specific execution context (e.g., under a profiler or alternate launcher). Run the application with the same command the user used, such as `python -m cProfile -o out.pstat script.py`, and capture the full traceback.",
            "Step 2: Inspect the traceback to identify where importlib.metadata (or similar environment/metadata APIs) are called. Note the arguments passed to metadata() or similar functions and the exact exception type (e.g., importlib.metadata.PackageNotFoundError).",
            "Step 3: Examine how the code derives the package name or module identifier passed to metadata(). Common sources include __main__.__package__, __name__, or sys.modules['__main__'].__spec__.name. In the failing environment, print or log these values to see if they are empty, None, or otherwise non-installable as distributions.",
            "Step 4: Decide on a safe fallback behavior for when package metadata is unavailable. For example, for bundled-app detection, the safe fallback is usually to return False (assume not bundled) rather than crash. Document why this fallback is acceptable.",
            "Step 5: Implement robust guards around the metadata lookup. Options include:\n  - Use try/except around importlib.metadata.metadata(name) and catch PackageNotFoundError, returning the fallback behavior when caught.\n  - Optionally validate that the package name is non-empty and well-formed before attempting the lookup.\nAvoid hard-coding checks for specific tools (like 'cProfile', 'yappi') unless absolutely necessary.",
            "Step 6: Remove or simplify any tool-specific workarounds that were added as an initial fix if a more general mechanism (e.g., catching PackageNotFoundError) now covers those cases. This reduces maintenance and makes the code more generic.",
            "Step 7: Add or update tests to cover multiple execution scenarios: normal invocation, invocation under profiling/debugging, and potentially in a bundled environment. Where full integration tests are hard, at least unit-test the helper function with mocked sys.modules['__main__'] and importlib.metadata to simulate missing packages.",
            "Step 8: Run the full test suite and manually verify that the application starts correctly under the previously failing contexts (e.g., cProfile, yappi) and still behaves correctly when truly running as a bundled app. Confirm that the exception no longer occurs and that environment detection returns the expected values.",
            "Step 9: Document the behavior in developer notes or code comments, explaining that metadata lookup can fail in non-standard runtimes and that the code intentionally treats PackageNotFoundError as 'not bundled' or an analogous default."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant startup and entity update tasks were scheduled directly on the asyncio event loop with loop.create_task instead of via hass.async_add_job / hass.add_job. Because Home Assistant only waits for tasks registered through async_add_job, some startup/update work could run outside the tracked lifecycle and not be awaited at startup. The fix replaces loop.create_task with async_add_job in most components (alarm_control_panel, climate, cover, fan, light, lock, remote, switch, Kodi media_player, rflink, entity_component) and corrects DSMR sensor to pass a coroutine instead of a function. Long‑running background jobs (like the DSMR reconnect loop) and the core async_stop on KeyboardInterrupt still use loop.create_task as they are not intended to be tracked as startup jobs.",
        "keywords": [
            "Home Assistant",
            "asyncio",
            "event loop",
            "hass.async_add_job",
            "hass.add_job",
            "loop.create_task",
            "startup blocking",
            "lifecycle management",
            "entity update",
            "DSMR sensor",
            "background tasks",
            "KeyboardInterrupt shutdown",
            "async_update_ha_state"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's startup model expected all important startup tasks to be added using hass.async_add_job so that the system could properly wait for them before declaring startup complete. Historically, not all code followed this pattern because async_add_job had only recently been changed to return a yieldable Task object; previously, developers often used hass.loop.create_task directly. As a result, some startup and entity-update tasks ran outside the tracked job system, meaning they were not accounted for in startup completion and potentially could race with other operations.\n\nThe pull request tackled this by systematically replacing direct event loop scheduling (self.loop.create_task or hass.loop.create_task) with hass.add_job / hass.async_add_job in most places where tasks represent Home Assistant work that should be tracked:\n\n- alarm_control_panel, climate, cover, fan, light, lock, remote, switch components now schedule async_update_ha_state(True) via hass.async_add_job instead of hass.loop.create_task. These are entity service handlers that, when called, may need to poll and update entity state asynchronously. Using async_add_job ensures those updates are integrated into Home Assistant's job tracking.\n- entity_component._update_entity_states now wraps entity.async_update_ha_state(True) in hass.async_add_job rather than accessing the loop directly, for entities that implement async_update.\n- media_player.kodi schedules its websocket connect loop and websocket loop using hass.hass.async_add_job instead of hass.loop.create_task, keeping those tasks in the framework's tracking where appropriate.\n- rflink's repeated send command logic now stores the repetition task as hass.async_add_job(...) instead of hass.loop.create_task(...), again making it a tracked job.\n- The DSMR sensor integration had a subtle bug: it previously called hass.async_add_job(device.async_update_ha_state) without invoking the coroutine. This passed the callable instead of the coroutine object, so the framework would not run the expected async update. The fix changes this to hass.async_add_job(device.async_update_ha_state()), correctly scheduling the coroutine for execution. While updating that area, a comment typo (\"asycnio\") was corrected to \"asyncio\", and a new clarifying comment notes that the long‑running connect_and_reconnect loop cannot use hass.async_add_job because it runs forever.\n\nIn core.py, HomeAssistant.start previously used self.loop.create_task(self.async_start()) to kick off the async startup. This was changed to self.add_job(self.async_start()), aligning startup with the tracked job model. For KeyboardInterrupt handling, the code initially mirrored this change by using self.add_job(self.async_stop()), but a follow‑up patch adjusted it back to self.loop.create_task(self.async_stop()). The likely reasoning is that async_stop, triggered by Ctrl+C after the loop is already running, should be scheduled directly on the loop and not be treated as a startup job; using create_task here avoids entangling shutdown with the startup job tracking mechanism.\n\nOverall, the fix synchronizes Home Assistant's async patterns: framework-level work is scheduled via hass.async_add_job/hass.add_job so that startup and lifecycle management can observe and await those tasks, while long-lived or shutdown-only tasks that should not block startup remain scheduled via loop.create_task.",
        "semantic_memory": "This change illustrates key best practices in async application frameworks, particularly where there is a central orchestrator like Home Assistant:\n\n1. **Use the framework's task scheduler, not the raw event loop, for lifecycle-relevant tasks.**\n   When a framework provides APIs such as `hass.async_add_job` or `hass.add_job`, those typically wrap `loop.create_task` but also associate metadata, tracking, or lifecycle hooks with the created tasks. Scheduling important work directly via `loop.create_task` bypasses this tracking, which can break startup synchronization, shutdown ordering, or error reporting. The general pattern is: use the framework's job API for anything that should be accounted for in startup/shutdown, and reserve direct `loop.create_task` for framework-internal or truly \"fire-and-forget\" tasks.\n\n2. **Startup completion often depends on knowing all scheduled startup tasks.**\n   Systems that \"wait until all startup tasks are done\" must have a way to know which tasks count as startup tasks. If some tasks are scheduled outside of the framework's registration mechanism, the startup manager can't see them and may proceed too early. This leads to subtle timing bugs where components appear not fully initialized despite the system reporting that startup completed.\n\n3. **Always schedule coroutines, not callables, when a scheduler expects a coroutine object.**\n   In the DSMR sensor module, passing `device.async_update_ha_state` instead of `device.async_update_ha_state()` resulted in the scheduler receiving a function instead of a coroutine. This is a common asyncio mistake: if an API expects a coroutine (or is documented to accept `awaitable`), you almost always need to *call* your async function to obtain the coroutine object before passing it on.\n\n4. **Long-lived or never-ending tasks may need different handling.**\n   Some jobs (like a reconnect loop that runs until Home Assistant stops) intentionally never finish. Including them in the set of tasks that startup waits for would deadlock startup. The DSMR reconnect loop is an example: it is explicitly documented as a job that runs forever and is therefore scheduled directly with `loop.create_task` instead of `hass.async_add_job`. More generally: not all tasks should be \"startup tasks\".\n\n5. **Shutdown paths may bypass startup-specific scheduling.**\n   In the core loop, `async_stop` scheduled via `loop.create_task` on KeyboardInterrupt avoids entangling shutdown with the startup-job tracking system. This suggests a design where startup completion and shutdown signals are conceptually separate; mixing them through the same scheduler may cause unexpected behavior (for instance, trying to await shutdown as if it were part of startup).\n\nThese patterns generalize to other async frameworks: prefer framework-specific scheduling/utilities over raw event-loop operations whenever you care about lifecycle coordination, error handling, and observability; carefully distinguish between one-off tasks that should be awaited and long-running tasks that should not; and ensure you're always passing the correct types (coroutine vs. function) into scheduling APIs.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the framework's intended async scheduling API.\n- Review framework documentation (e.g., Home Assistant's developer docs) to understand how async tasks should be scheduled. Look for functions like `async_add_job`, `add_job`, or similar utilities.\n- Determine which tasks are considered part of startup, which should be tracked, and which are long-lived background processes.",
            "Step 2: Search for direct event-loop scheduling that may bypass tracking.\n- In the codebase, search for usages of `loop.create_task`, `asyncio.ensure_future`, or direct event-loop calls (`hass.loop.create_task`, `self.loop.create_task`).\n- Cross-reference these sites with framework guidelines: are these tasks meant to be part of startup, entity updates, service handlers, or other lifecycle-sensitive operations?",
            "Step 3: Decide which tasks should use the framework scheduler vs. raw event loop.\n- For tasks that:\n  - update entity state (e.g., `entity.async_update_ha_state`),\n  - perform initialization/startup work,\n  - or represent discrete jobs that should be awaited or tracked,\n  prefer the framework scheduler (e.g., `hass.async_add_job(coro)` or `hass.add_job(coro)`).\n- For tasks that:\n  - intentionally run forever (e.g., a reconnect loop),\n  - or are shutdown-only signals (e.g., `async_stop` triggered by CTRL+C),\n  it may be appropriate to keep `loop.create_task` or another fire-and-forget mechanism, as they should not participate in startup completion.",
            "Step 4: Ensure you pass coroutine objects, not plain functions.\n- When calling the framework scheduler (e.g., `hass.async_add_job`), verify the expected parameter: does it accept a coroutine or a callable?\n- If it expects a coroutine/awaitable, always call the async function: use `device.async_update_ha_state()` instead of `device.async_update_ha_state`.\n- Consider adding tests to catch these mistakes: for example, unit tests that assert a coroutine is awaited and side effects happen as expected after scheduling.",
            "Step 5: Refactor the code to use the appropriate scheduler.\n- Replace patterns like `hass.loop.create_task(coro)` with `hass.async_add_job(coro)` where the job should be tracked.\n- In methods similar to Home Assistant's core start, replace `self.loop.create_task(self.async_start())` with the framework-specific job method (e.g., `self.add_job(self.async_start())`) if startup tracking depends on it.\n- For special cases (e.g., infinite loops or shutdown handlers), keep or introduce `loop.create_task` and document why they are not using the tracked scheduler.",
            "Step 6: Consider lifecycle and startup behavior at a system level.\n- Verify that startup now correctly waits for all relevant tasks by checking logs, tests, or any startup status APIs.\n- Confirm that no infinite or long-running tasks are mistakenly marked as startup jobs, which would block startup indefinitely.\n- For shutdown, ensure that tasks like `async_stop` are scheduled in a way that works even when the event loop is in a special state (e.g., after KeyboardInterrupt).",
            "Step 7: Add or update tests to enforce the pattern.\n- Add tests that verify startup completion only after certain async jobs are finished.\n- Add tests for components that call `async_update_ha_state` or similar methods, ensuring that those updates are actually scheduled and executed.\n- If possible, add static checks or linters to discourage direct `loop.create_task` in high-level components where `async_add_job` should be used.",
            "Step 8: Document the guidelines for future contributors.\n- Update developer documentation or CONTRIBUTING guides to specify:\n  - When to use the framework scheduler vs. raw `loop.create_task`.\n  - The necessity to pass coroutine objects (not functions) to async APIs.\n  - Any exceptions (e.g., long-lived reconnect loops, shutdown handlers).\n- This helps prevent regressions where new code reintroduces direct event loop scheduling in places that should be tracked."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix/workaround for StackStorm Orquesta workflows getting stuck in 'canceling' when canceling a workflow that has a subworkflow. The change makes action cancellation idempotent: if a LiveAction is already in CANCELING state, a repeated cancellation request transitions it to CANCELED and updates the corresponding ActionExecution. Workflow cancellation logic is adjusted so that cascading cancellation from subworkflow to parent workflow correctly drives state changes.",
        "keywords": [
            "StackStorm",
            "Orquesta",
            "workflow cancellation",
            "subworkflow",
            "LiveAction",
            "ActionExecution",
            "WorkflowExecution",
            "canceling state",
            "stuck execution",
            "idempotent cancel",
            "services/action.py",
            "services/workflows.py"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, canceling a StackStorm Orquesta workflow that launched a subworkflow could leave the root workflow execution stuck in the 'canceling' state. The unit test scenario invoked `ac_svc.request_cancellation(lv_ac_db, requester)` on the root LiveAction. Orquesta internally treated the workflow as canceled, but StackStorm's LiveAction remained in 'canceling', and the cascading cancellation to the parent workflow (`ac_svc.request_cancellation(root_lv_ac_db, None)`) was not triggered as expected. As a result, the workflow never transitioned to 'canceled', effectively hanging.\n\nThe developer first tried to distinguish between parent and child actions in `services/action.py:request_cancellation` and `services/workflows.py:request_cancellation` to handle the root LiveAction differently, but that broke other tests. The final approach was a pragmatic workaround: make cancellation idempotent at the action level and adjust workflow cancellation behavior.\n\nIn `st2common/services/action.py`, `request_cancellation` was updated so that if a LiveAction is already in `LIVEACTION_STATUS_CANCELING`, a subsequent `request_cancellation` call forcibly transitions it to `LIVEACTION_STATUS_CANCELED`, updates the database via `update_status`, fetches the corresponding `ActionExecution` (`ActionExecution.get(liveaction__id=str(liveaction.id))`), and returns the pair `(liveaction, execution)`. This allows an operator to run `st2 execution cancel` a second time to push a stuck execution from 'canceling' to 'canceled'.\n\nIn `st2common/services/workflows.py`, `request_cancellation(ac_ex_db)` was adjusted. Some log messages were corrected from 'cancelation' to 'cancellation'. More importantly, the direct `conductor.request_workflow_state(states.CANCELED)` call that applied unconditionally was removed. Instead, when a cancellation for a subworkflow needs to cascade up (`root_ac_ex_db != ac_ex_db` and root is not already in a cancel state), the code now logs the cascade, calls `conductor.request_workflow_state(states.CANCELED)`, and then looks up the root LiveAction (`lv_db_access.LiveAction.get(id=root_ac_ex_db.liveaction['id'])`) and calls `ac_svc.request_cancellation(root_lv_ac_db, None)`.\n\nA new unit test `test_cancel_workflow_cascade_down_to_subworkflow_while_still_launching` in `contrib/runners/orquesta_runner/tests/unit/test_cancel.py` reproduces the scenario where a main workflow with a subworkflow is running. After issuing a cancellation, the root LiveAction enters `CANCELING`. The test then re-runs `ac_svc.request_cancellation` and asserts that this second call transitions the root LiveAction to `CANCELED`. This validates the workaround: a stuck 'canceling' workflow can be resolved by rerunning the cancel command.",
        "semantic_memory": "This fix demonstrates several generalizable patterns around workflow and action cancellation in distributed or asynchronous systems:\n\n1. **Idempotent cancellation operations**: Cancellation is often requested multiple times (e.g., user retries `cancel`, system retries after errors). Cancellation handlers should be written to be idempotent and to gracefully handle states like 'cancel requested' or 'canceling'. An idempotent handler can safely be invoked again to drive the resource into a final 'canceled' state if it was previously stuck.\n\n2. **Clear separation of intermediate and terminal states**: Having an intermediate 'canceling' state is useful for tracking in-progress cancellation, but the system must ensure a reliable transition to a terminal state ('canceled' or 'failed') and avoid indefinite residence in the intermediate state. When the system detects that no further progress is possible or necessary, it should complete the transition.\n\n3. **Consistency between orchestration and execution layers**: In this case, Orquesta (the workflow engine) and StackStorm's action/execution models were not fully synchronized. Orquesta believed the workflow was canceled while the StackStorm LiveAction remained 'canceling'. This illustrates the importance of ensuring that workflow-engine state, execution records, and user-facing models are updated consistently and atomically where possible.\n\n4. **Cascading cancellation across parent-child relationships**: Complex workflows with subworkflows and task executions require cancellation to propagate correctly up and down the execution tree. Parent cancellation should propagate to children, and cancellations triggered in subworkflows may need to cascade up to parent workflows. Centralizing this logic and making it explicit (e.g., via `get_root_execution` and explicit cascade calls) helps avoid partial cancellation.\n\n5. **Operational escape hatches**: Sometimes a perfect fix is difficult, but a safe operational workaround can greatly improve reliability. Here, allowing an operator to rerun `st2 execution cancel` to push a stuck execution to 'canceled' is a pragmatic mitigation. Providing such escape hatches (with well-defined semantics) can be valuable in long-running systems where occasional inconsistencies are inevitable.\n\n6. **Testing race conditions and lifecycle edge cases**: The repro test focuses on a workflow with a subworkflow that is still launching when cancellation occurs. This is a typical race-condition scenario (cancel during startup). Adding unit tests that cover cancellation at different lifecycle points (before start, while starting, while running, while finishing) is crucial to harden the cancellation logic.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving workflows or actions stuck in an intermediate 'canceling' state:",
            "Step 1: Reproduce or capture the stuck state",
            "- Identify an execution that is stuck in an intermediate cancellation state (e.g., 'canceling').",
            "- If possible, write or run a test that mimics the scenario: a parent workflow with one or more subworkflows or tasks, where cancellation is requested while the subworkflow is launching or running.",
            "- Collect the related records: LiveAction, ActionExecution, WorkflowExecution, TaskExecution, and any engine-specific conductor/state objects.",
            "",
            "Step 2: Map the state across all layers",
            "- For the stuck execution, inspect:",
            "  - LiveAction status (e.g., RUNNING, CANCELING, CANCELED).",
            "  - ActionExecution status corresponding to that LiveAction.",
            "  - WorkflowExecution status in the workflow engine.",
            "  - Any workflow conductor state (e.g., Orquesta's `conductor.get_workflow_state()`).",
            "- Check if any of these disagree (e.g., workflow engine says CANCELED while LiveAction says CANCELING). Inconsistencies point to missing or broken transition logic.",
            "",
            "Step 3: Analyze the cancellation flow",
            "- Locate the main cancellation entry points in the code (e.g., `services/action.py:request_cancellation`, `services/workflows.py:request_cancellation`).",
            "- Understand the intended flow:",
            "  - What states are allowed to be canceled (a set like `LIVEACTION_CANCELABLE_STATES`)?",
            "  - What happens when cancellation is requested: do we set state to CANCELING first, then to CANCELED later?",
            "  - How does cancellation propagate from workflows to task executions and subworkflows, or vice versa?",
            "- Look for early returns or conditions that prevent cascading cancellation (e.g., missing parent calls when the context has no `parent` key, or guard conditions around `get_root_execution`).",
            "",
            "Step 4: Make cancellation idempotent and safe",
            "- Introduce explicit handling for already-canceling resources:",
            "  - If the action/workflow is in a 'canceling' state and a new cancellation request arrives, treat it as an opportunity to complete cancellation rather than as an error.",
            "  - For example, in a function like `request_cancellation(liveaction, requester)`, add logic at the top:",
            "    - If `liveaction.status == LIVEACTION_STATUS_CANCELING`:",
            "      - Transition it to `LIVEACTION_STATUS_CANCELED`.",
            "      - Persist the change (`update_status`) and ensure the linked execution record is updated/fetched.",
            "      - Return the updated objects.",
            "- Ensure this behavior is safe (e.g., external workers check the status and will stop work or are already stopped).",
            "",
            "Step 5: Fix or explicitly manage cascading cancellation",
            "- For workflows with subworkflows:",
            "  - Use a helper like `get_root_execution` or equivalent to identify the root of the execution tree.",
            "  - Decide how cancellation propagates:",
            "    - From root workflow to all children: when the root is canceled, propagate cancellation to all subworkflows/tasks.",
            "    - From subworkflow to parent: when a subworkflow failure or cancellation should cancel the entire workflow, cascade up to the root.",
            "- In the workflow cancellation handler (e.g., `request_cancellation(ac_ex_db)`):",
            "  - Ensure you update the workflow engine's conductor state appropriately (request CANCELED when appropriate).",
            "  - Look up the associated root LiveAction and call the action cancellation handler to keep the user-facing state in sync.",
            "- Add clear logs when cascading (e.g., 'Cascading cancellation request to parent workflow') to help with future debugging.",
            "",
            "Step 6: Synchronize workflow engine and execution models",
            "- Whenever the workflow engine changes workflow state (e.g., to CANCELED), ensure the corresponding execution and LiveAction records are updated in the same logical flow.",
            "- Avoid updating only the workflow engine state without reflecting that change in the LiveAction/ActionExecution models.",
            "- If atomicity is hard, at least ensure that repeated calls (due to retries) move the system toward a consistent final state (CANCELED or FAILED), not keep it stuck in an intermediate state.",
            "",
            "Step 7: Provide an operator-friendly workaround",
            "- If a fully automatic fix is complex or risky, provide a safe manual or operational workaround:",
            "  - Example: Make the `cancel` operation idempotent so an operator can rerun `cancel` on a stuck execution to force a transition from CANCELING to CANCELED.",
            "  - Clearly document this behavior: 'If an execution is stuck in CANCELING, run the cancel command again to complete cancellation.'",
            "",
            "Step 8: Add regression tests for edge cases",
            "- Add unit or integration tests that cover:",
            "  - Canceling a workflow with a subworkflow while the subworkflow is still launching.",
            "  - Canceling a workflow while tasks are running, and ensuring both parent and child executions are canceled.",
            "  - Re-running cancellation on an execution in CANCELING state and verifying it transitions to CANCELED.",
            "- Use these tests to protect against future refactors breaking the cancellation flow.",
            "",
            "Step 9: Monitor and log",
            "- Enhance logging around cancellation:",
            "  - Log when cancellation is requested, what state transitions occur, and when cascading happens.",
            "  - Use consistent terminology (e.g., 'cancellation' vs 'cancelation') to ease searching.",
            "- In production, monitor metrics or alerts for executions stuck in intermediate states and use the idempotent cancellation behavior as a remediation tool."
        ]
    }
}
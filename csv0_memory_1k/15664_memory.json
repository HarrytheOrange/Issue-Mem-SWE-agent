{
    "search_index": {
        "description_for_embedding": "Added a new Home Assistant sensor platform `sensor.noaa_tides` that fetches NOAA Tides & Currents prediction data via the `py_noaa` library instead of manual HTTP requests. The sensor exposes upcoming high/low tide times and heights for a configured station, supports timezone and unit configuration, uses SCAN_INTERVAL for hourly polling, and includes attribution handling and proper error guards.",
        "keywords": [
            "NOAA",
            "tides",
            "sensor.noaa_tides",
            "py_noaa",
            "Home Assistant",
            "tide predictions",
            "SCAN_INTERVAL",
            "Pandas DataFrame",
            "station_id",
            "timezone",
            "units"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, a new Home Assistant sensor integration was introduced to expose NOAA tide information. Initially, the sensor implementation did manual HTTP calls to the NOAA Tides & Currents API using `requests` and parsed the JSON predictions directly, computing state strings like 'High tide at HH:MM' and attributes for next high and low tides.\n\nDuring review, the maintainers suggested using the existing `py_noaa` library instead of rolling custom HTTP and parsing logic, even though `py_noaa` pulls in Pandas (a relatively heavy dependency). After discussion, they accepted the dependency. The implementation was refactored to import `py_noaa.coops.get_data`, request a two‑day window of tide predictions, and rely on the returned Pandas DataFrame.\n\nThe final sensor (`homeassistant/components/sensor/noaa_tides.py`) defines:\n- Config schema with `station_id` (required), `name`, `timezone` (one of `gmt`, `lst`, `lst_ldt`), and `units` (`english`/`metric`), defaulting units from Home Assistant's global units when not specified.\n- `SCAN_INTERVAL = timedelta(minutes=60)` to update hourly instead of using `Throttle` on `update()`.\n- `update()` calls `coops.get_data()` with `product='predictions'`, `datum='MLLW'`, `interval='hilo'`, and uses `head()` to keep the first few rows. It logs the fetched data and the query start time at debug level.\n- `state` interprets the first row of the DataFrame: if `hi_lo[0]` is `H` it returns 'High tide at <time>', if `L` then 'Low tide at <time>', otherwise `None`.\n- `device_state_attributes` adds `ATTR_ATTRIBUTION` and, if data is present, looks at rows 1 and 2; it assigns `high_tide_time`/`height` and `low_tide_time`/`height` based on whether `hi_lo[1]` is `H` or `L`. All times come from the DataFrame index (datetime) formatted as `%I:%M %p`.\n\nAlong the way, there were a couple of housekeeping fixes: the `.coveragerc` path was initially written as `sensor/noaa-tide.py` and later corrected to match the module name `sensor/noaa_tide.py`, ensuring coverage config is consistent. Style and linting issues (indentation, logging formatting, returning `None` instead of `STATE_UNKNOWN` for non‑numeric sensor state) were also resolved.",
        "semantic_memory": "Generalizable lessons from this change:\n\n1. **Prefer dedicated libraries over ad-hoc HTTP parsing**: When integrating a third-party API, it's often better to use a maintained PyPI library (e.g., `py_noaa`) rather than writing custom `requests` calls and parsing logic. This centralizes API quirks, parsing behavior, and future changes in one place.\n\n2. **Align polling with platform conventions**: In Home Assistant, the canonical way to control entity update frequency for a platform is `SCAN_INTERVAL`. Use it instead of (or in addition to) `Throttle` unless you have a specific reason to throttle a shared client across multiple entities.\n\n3. **Handle configuration defaults smartly**: For unit configuration, it's useful to allow an optional `units` setting, but fall back to the system-wide units (`hass.config.units.is_metric`). Similarly, optional fields like `name` and `timezone` should have sensible defaults while still allowing user override.\n\n4. **Robustness around external data**: When relying on a DataFrame or any structured response from a remote service, always guard against `None` or unexpected content before indexing. The final code checks `if self.data is not None` before accessing rows and columns.\n\n5. **State vs. attributes semantics**: For a sensor, keep the primary `state` concise and human-readable, and expose richer details (like next high and low tide times and heights) via attributes. This pattern makes the sensor easier to use in UI and automations while retaining detailed data.\n\n6. **Logging best practices**: Use debug-level logging for verbose data dumps (`_LOGGER.debug('Data = %s', self.data)`) and avoid info-level spam for normal periodic operations. Use `%s` placeholders in logging calls to avoid formatting overhead when logging is disabled.\n\n7. **Consistency in ancillary configs**: When adding new modules, ensure ancillary configuration like `.coveragerc` paths exactly match filenames to avoid subtle tooling issues (e.g., coverage ignores not applying).",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix or implement similar API-driven sensors using a third-party library:",
            "Step 1: Identify whether an existing Python client library exists for the target API (e.g., `py_noaa` for NOAA Tides & Currents). Evaluate the trade-offs of additional dependencies (size, transitive requirements) vs. maintenance burden of custom HTTP calls.",
            "Step 2: Define the platform configuration schema:\n- Use `PLATFORM_SCHEMA.extend` to add required and optional fields.\n- For string options with limited choices (e.g., timezones, units), use `vol.In([...])`.\n- Provide sensible defaults (`DEFAULT_NAME`, `DEFAULT_TZ`) and derive defaults from global config where appropriate (e.g., units from `hass.config.units.is_metric`).",
            "Step 3: In `setup_platform`, read configuration values, resolve derived defaults (like units based on metric/imperial), and instantiate your Entity class with all necessary parameters. Call `add_devices([...], True)` to perform an immediate initial update.",
            "Step 4: Implement the Entity:\n- Store the configured values in instance variables.\n- Implement `name`, `state`, and `device_state_attributes` properties. Keep `state` concise; push detailed or secondary info into attributes.\n- In attribute and state accessors, always guard against missing or invalid data (`if self.data is not None`).\n- When working with complex structures like DataFrames, verify indexes and keys before accessing specific rows or columns, and decide what to do if the expected shape isn't present (return `None` or omit attributes).",
            "Step 5: Implement `update()` using the third-party library:\n- Translate your sensor’s configuration into appropriate parameters for the client call (e.g., station ID, start/end dates, product type, units, timezone).\n- Use a reasonable time window to limit payload size (e.g., `now` to `now+2 days`).\n- Catch and log exceptions from the client (ValueError, network errors) and set `self.data` to `None` on failure to avoid stale or partial data.\n- Log the raw or summarized data at debug level for troubleshooting, not at info level.",
            "Step 6: Control update frequency:\n- Define `SCAN_INTERVAL = timedelta(...)` at the module level so Home Assistant knows how often to call `update()`.\n- Avoid using `Throttle` unless there's a shared client across multiple entities that needs rate limiting more strictly than per-entity scanning.",
            "Step 7: Update dependency manifests:\n- Add the new library to `REQUIREMENTS` inside the component/module.\n- Add the same pinned version to `requirements_all.txt` (and `requirements_test_all.txt` if needed).\n- If a library requires special handling (e.g., C extensions), consider whether it should be commented out in global requirements and rely only on component-level installation.",
            "Step 8: Keep tooling configuration in sync:\n- If you need to exclude the new module from coverage or other tools, update `.coveragerc` with the correct file path and verify there are no typos (e.g., `noaa_tides.py` vs `noaa-tide.py`).",
            "Step 9: Verify style and behavior:\n- Run linters (flake8, pylint) and fix indentation, import order, and logging styles.\n- Test with realistic configurations to ensure the sensor returns expected state strings and attributes, and that it behaves gracefully when the upstream API is unreachable or returns unexpected data."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant tilt-based garage door controller implemented as a switch platform. Initial version blocked the event loop with time.sleep, imported core directly, and managed state incorrectly, which could leave the relay stuck ON and misreport door status. The fix refactored it into a proper switch platform using Home Assistant services, non-blocking timers, configuration constants, and robust state/relay management (including forcing the relay OFF at startup and after the run_time).",
        "keywords": [
            "Home Assistant",
            "switch.tilt",
            "tilt sensor",
            "garage door",
            "relay switch",
            "blocking I/O",
            "time.sleep",
            "threading.Timer",
            "platform setup",
            "entity state management",
            "relay stuck ON",
            "CONF_TILT_SENSOR",
            "CONF_SWITCH"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, a contributor added a Home Assistant integration that combines a binary tilt sensor with a relay switch to control a garage door or motorized gate. The original implementation was a standalone component and then moved under homeassistant/components/switch/tilt.py as a SwitchDevice. Initially, it imported homeassistant.components as core and used core.turn_on/turn_off, called time.sleep within entity logic to simulate a momentary relay, and directly computed state via helper methods. This design raised several issues: blocking I/O in the entity (time.sleep) could stall Home Assistant; importing core was discouraged (reviewers asked to use hass.services or component helper APIs); and there was a risk that the relay remained stuck ON, leaving the garage door opener inoperable. Also, state handling was ad-hoc and not clearly tied to the tilt sensor entity.\n\nOver multiple iterations, the author refactored the implementation. The code was converted into a proper switch platform with setup_platform(hass, config, add_entities, discovery_info=None) and device configuration read from a 'switches' mapping. Constants were introduced for config keys (CONF_TILT_SENSOR, CONF_SWITCH, CONF_CONTACT_DELAY, CONF_CONTACT_RUN_TIME) and default values. The time.sleep call was removed, replaced by two threading.Timer instances: one to turn the relay OFF after contact_delay (momentary contact behavior) and another to mark the end of run_time (the period during which the door is assumed to be moving). The component now uses homeassistant.components.switch helper functions switch.turn_on/turn_off instead of importing core. To prevent the relay from remaining ON unexpectedly, an _insure_relay_is_off() helper was added and is called after the run_time timer fires. The entity keeps an internal _running flag to indicate door movement and a _state value (STATE_ON/STATE_OFF) initialized to assume a closed door. The update() method reads the tilt sensor entity state only when not running; otherwise it trusts the internal state. The turn_on/turn_off handlers set _state (STATE_ON/STATE_OFF), trigger _toggle (which pulses the relay via timers), and schedule HA state updates. Throughout the process, the code was adjusted to satisfy PEP8/pylint and reviewer guidance (removing unused imports, comments, and debug noise, updating setup signatures, avoiding direct core imports, and preparing for eventual async patterns).",
        "semantic_memory": "This PR illustrates several generalizable patterns for building device abstractions and composite entities in Home Assistant or similar event-driven frameworks:\n\n1. **Avoid blocking the event loop in entity methods**: Operations such as time.sleep inside entity callbacks (turn_on/turn_off/update) block the main loop and degrade responsiveness. Instead, use timers, asynchronous callbacks, or framework scheduling mechanisms to implement delays (e.g., simulating momentary contacts or run-times).\n\n2. **Use framework-sanctioned APIs instead of core imports**: Directly importing a monolithic 'core' or global module is discouraged. Use domain-specific helpers (e.g., homeassistant.components.switch.turn_on/turn_off) or hass.services.call/async_call so code remains decoupled, testable, and consistent with framework conventions.\n\n3. **Model composite devices using configuration-driven platforms**: When an entity is logically built from other entities (here, a garage door is composed of a binary tilt sensor and a relay switch), expose it as a platform under the most appropriate domain (switch or cover) and configure it via YAML with clear constants (CONF_TILT_SENSOR, CONF_SWITCH, CONF_CONTACT_DELAY, CONF_CONTACT_RUN_TIME). This improves discoverability, reuse, and configuration validation.\n\n4. **Separate device state from hardware control and respect external sensors**: Maintain an internal state (e.g., STATE_ON/STATE_OFF) that represents the logical entity status, but reconcile it with sensor input (tilt sensor) in update() or equivalent. When the device is in a transitional state (moving), it is often better to rely on an internal flag (_running) and assumed state until the movement period ends, then sync from sensors.\n\n5. **Defensive control of actuators**: For actuators like relays, especially those emulating momentary contacts, always ensure they are returned to a safe state (e.g., OFF). Implement startup checks (e.g., _insure_relay_is_off()) and post-action safeguards (turn OFF after run_time) to mitigate misconfigurations or hardware glitches that might leave the actuator stuck.\n\n6. **Use configuration constants and consistent naming**: Defining CONF_* constants and DEFAULT_* values improves readability, maintainability, and makes it easier to later attach schema validation (e.g., voluptuous), especially when multiple similar devices are configured under a single platform.\n\n7. **Encapsulate timing logic into helper methods**: Grouping related timed actions (_toggle, _stop_delay_timer, _stop_run_timer) into clearly named internal methods clarifies behavior and allows easier future refactoring to async or other timing mechanisms.\n\nThese patterns apply across many integrations where a virtual entity composes or orchestrates multiple underlying entities with timing-dependent behavior.",
        "procedural_memory": [
            "When implementing or fixing a composite Home Assistant entity that orchestrates other entities (e.g., tilt sensor + relay for garage door control), follow these steps:",
            "Step 1: Identify blocking operations and remove them.\n- Search for time.sleep or other blocking calls in entity methods (turn_on, turn_off, update, callbacks).\n- Replace these with non-blocking alternatives: threading.Timer, async calls, or Home Assistant's scheduling helpers.\n- Ensure the entity's logic works correctly when actions are deferred via callbacks rather than performed inline.",
            "Step 2: Use proper platform APIs and avoid importing core modules.\n- Confirm that you are implementing a platform under the correct domain (e.g., switch, cover, sensor).\n- Implement setup_platform(hass, config, add_entities, discovery_info=None) with the correct signature.\n- Use domain-specific helpers (e.g., homeassistant.components.switch.turn_on/turn_off) or hass.services.call instead of importing and using a generic 'core' object.",
            "Step 3: Design a clear configuration schema.\n- Define CONF_* constants for all configuration keys (e.g., CONF_TILT_SENSOR, CONF_SWITCH, CONF_CONTACT_DELAY, CONF_CONTACT_RUN_TIME).\n- Provide sensible DEFAULT_* values for optional parameters.\n- Read configuration using properties.get(CONF_*, default) and prepare the code so that voluptuous validation can be added later if needed.",
            "Step 4: Separate internal state management from I/O.\n- Maintain an internal _state that represents the logical device status (e.g., STATE_ON for open, STATE_OFF for closed).\n- Use an internal flag (e.g., _running) to mark transitional periods when the device is moving and sensor readings may not be stable.\n- Implement update() to read from the underlying sensor (tilt sensor) only when appropriate (e.g., when not _running) and update _state accordingly.",
            "Step 5: Implement safe actuator control with timers.\n- Encapsulate actuator control in methods like _toggle() that handle all timing:\n  - Immediately turn the relay ON via switch.turn_on(self.hass, relay_entity_id).\n  - Start a timer for contact_delay to turn the relay back OFF via switch.turn_off.\n  - Start a second timer for run_time that marks the end of movement (set _running to False, perform any final safety actions).\n- Ensure that these timers are stored in attributes (_delay_timer, _run_timer) if you need to cancel or inspect them later.",
            "Step 6: Guard against stuck actuators.\n- Implement a helper like _insure_relay_is_off() that forces the relay entity OFF using the appropriate API.\n- Call this helper on startup (e.g., in __init__ after attributes are set) or at the end of the run_time timer to make sure the relay is not left ON.\n- Consider logging when this corrective action is taken for easier debugging.",
            "Step 7: Integrate state changes with Home Assistant.\n- Implement the is_on property to derive from _state (e.g., return self._state == STATE_ON).\n- In turn_on/turn_off, set _state first, then call _toggle(), and finally schedule_update_ha_state() so HA can update the UI and automations.\n- Ensure update() uses hass.states.get(tilt_sensor_id) to read the current sensor state and synchronize _state when not running.",
            "Step 8: Clean up and align with style/quality checks.\n- Remove unused imports and commented-out code once behavior is settled.\n- Ensure logs are informative but not overly verbose; use _LOGGER.debug for development details.\n- Run linters (pylint, pep8) and test suite (tox) locally and fix any style or functional issues reported before submitting or merging.\n\nBy following these steps, a developer can reliably implement or fix similar composite entities that require timed actuation, defensive safety mechanisms, and proper integration with an event-driven home automation framework."
        ]
    }
}
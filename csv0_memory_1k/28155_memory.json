{
    "search_index": {
        "description_for_embedding": "Home Assistant ISY994 integration was logging 'Unsupported node' warnings for a keypad dimmer and smoke sensor after upgrade. Root cause: the node filter lists didn’t include new ISY node definition IDs (KeypadDimmer, KeypadDimmer_ADV, BinaryAlarm_ADV). Fix: extend the ISY994 component’s node_def_id filters for lights and binary_sensors to include these nodeDefIds so the devices are properly discovered and no longer reported as unsupported.",
        "keywords": [
            "homeassistant",
            "isy994",
            "insteon",
            "unsupported node",
            "node filter",
            "node_def_id",
            "BinaryAlarm_ADV",
            "BinaryAlarm",
            "KeypadDimmer",
            "KeypadDimmer_ADV",
            "binary_sensor",
            "light",
            "device discovery",
            "integration bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "After upgrading Home Assistant to version 0.100.3, a user with an ISY994 (firmware v5.0.15) started seeing warnings like `Unsupported node: Driveway Lights, type: 1.66.67.0` and `Unsupported node: SmokeBridge-Smoke, type: 16.10.67.0` in the logs from the `homeassistant.components.isy994` integration. Inspecting `/rest/nodes` on the ISY revealed that these nodes had nodeDefIds `KeypadDimmer_ADV` (for the keypad dimmer controlling 'Driveway Lights') and `BinaryAlarm_ADV` (for the smoke sensor 'SmokeBridge-Smoke').\n\nThe ISY994 integration determines which ISY devices to map into Home Assistant entities using filter structures that specify `node_def_id` lists and `insteon_type` prefixes per platform (e.g., `binary_sensor`, `sensor`, `light`). The existing configuration only included `BinaryAlarm` for binary_sensors and did not list keypad dimmer nodeDefIds at all, so any nodes reporting as `BinaryAlarm_ADV` or `KeypadDimmer_ADV` were skipped and logged as unsupported.\n\nTo fix this, the PR updated `homeassistant/components/isy994/__init__.py`:\n- For the `binary_sensor` filter, the `node_def_id` list was expanded from `[\"BinaryAlarm\"]` to `[\"BinaryAlarm\", \"BinaryAlarm_ADV\"]`. This allows the smoke bridge smoke sensor (exposed as `BinaryAlarm_ADV`) to be recognized as a binary sensor instead of being treated as unsupported.\n- For the `light` (Insteon dimmer) filter, the `node_def_id` list was extended to include `\"KeypadDimmer\"` and `\"KeypadDimmer_ADV\"` alongside the existing entries, with `insteon_type` still matching `\"1.\"`. This causes keypad dimmers to be discovered as light entities.\n\nThere were follow-up commits to satisfy formatting checks by running `black --fast` and to clean up minor trailing comma formatting. No other logic changes were made. After this change, the ISY994 integration correctly imports these keypad dimmer and smoke sensor devices without logging 'Unsupported node' warnings.",
        "semantic_memory": "Device integrations that rely on static filter tables (e.g., by `node_def_id`, model, or type code) can silently drop new or variant devices when firmware introduces new identifiers. For ISY/Insteon specifically, node definitions often have 'advanced' variants (e.g., `BinaryAlarm_ADV`, `KeypadDimmer_ADV`) that behave like their base counterparts (`BinaryAlarm`, `KeypadDimmer`) but carry different nodeDefIds.\n\nA robust integration must:\n- Treat related nodeDefIds as belonging to the same functional class (e.g., both `BinaryAlarm` and `BinaryAlarm_ADV` should map to a binary_sensor) and keep the filter lists synchronized with firmware evolution.\n- Prefer pattern- or capability-based detection where possible, or at least group and document all known variants.\n- Log clearly when a node is skipped (as here with 'Unsupported node: ... type: ...') so developers and users can map new node types back into the integration.\n\nThis PR illustrates the pattern: when faced with 'unsupported' devices after an update, check the raw API (here `/rest/nodes`) to identify the nodeDefId and type; then extend the mapping/filter tables to associate those identifiers with the correct Home Assistant platform. Formatting tools like Black may be required to satisfy CI, but they are orthogonal to the functional fix.\n\nIn general, for integrations with type-based discovery:\n- New hardware revisions or firmware updates often introduce variants with suffixes (e.g., `_ADV`, `_PLUS`) or slightly different type strings.\n- These must be added to the integration’s mapping logic or generalized by pattern matching to maintain compatibility.\n- Maintaining a tight feedback loop between log warnings and code filters is a best practice to keep device support up to date.",
        "procedural_memory": [
            "When an integration logs 'unsupported' device warnings, use the platform’s raw API to inspect the device metadata (IDs, types, nodeDefIds) and compare that to the integration’s mapping/filter tables.",
            "Step 1: Observe and capture the warnings.\n- Check the application logs (e.g., Home Assistant logs) for messages like `Unsupported node: <name>, type: <typecode>` coming from the integration module (here `homeassistant.components.isy994`).\n- Note the device names and type codes from the log entries.",
            "Step 2: Inspect the device definition in the upstream controller.\n- For ISY994, open its REST API endpoint, e.g. `http://<isy-ip>/rest/nodes`.\n- Locate the problematic node by the name or address.\n- Record key fields: `nodeDefId`, `type`, `enabled`, and any relevant properties.",
            "Step 3: Compare with the integration’s filter/mapping configuration.\n- In the integration source (here `homeassistant/components/isy994/__init__.py`), find the mapping structure that classifies nodes into platforms (e.g., dictionaries keyed by `\"binary_sensor\"`, `\"light\"`, etc.).\n- Look at the `node_def_id` lists and any `insteon_type` or similar type checks used for classification.\n- Check whether the observed `nodeDefId` (e.g., `BinaryAlarm_ADV`, `KeypadDimmer_ADV`) is present in the relevant list, and whether the `type` prefix matches the expected `insteon_type` filter (e.g., `\"16.\"` for binary alarms, `\"1.\"` for dimmers).",
            "Step 4: Extend the filter lists to include new or variant nodeDefIds.\n- If a new variant behaves like an existing, supported type (e.g., `BinaryAlarm_ADV` behaves like `BinaryAlarm`), add it to the same `node_def_id` list for the appropriate platform.\n  - Example: change `\"node_def_id\": [\"BinaryAlarm\"]` to `\"node_def_id\": [\"BinaryAlarm\", \"BinaryAlarm_ADV\"]` in the binary_sensor filter.\n- Similarly, add new keypad dimmer nodeDefIds (`KeypadDimmer`, `KeypadDimmer_ADV`) to the light/dimmer filter list alongside other dimmer node definitions.",
            "Step 5: Run tests and code formatting.\n- Run the project’s unit tests or integration tests to ensure no regressions.\n- Apply the project’s code formatter (e.g., `black --fast homeassistant`) and commit only relevant formatting changes or as required by project guidelines.",
            "Step 6: Redeploy and verify behavior.\n- Restart or reload the integration.\n- Confirm that the previously unsupported nodes now appear as entities of the correct type (e.g., the smoke bridge as a binary_sensor, keypad dimmer as a light).\n- Ensure the log no longer shows 'Unsupported node' warnings for these devices.",
            "Step 7: Generalize for future changes.\n- Document which nodeDefIds map to which entity classes, including `_ADV` or similar variants.\n- If feasible, refactor the integration to use more generic classification (e.g., patterns like `nodeDefId.startswith(\"BinaryAlarm\")`) instead of enumerating each variant, to reduce future maintenance."
        ]
    }
}
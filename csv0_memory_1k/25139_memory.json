{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant evohome integration where persistent storage (app_storage) was None on first run, causing AttributeError during setup. The fix initializes app_storage to an empty dict and normalizes storage load results before accessing keys, preventing catastrophic startup failure.",
        "keywords": [
            "evohome",
            "homeassistant",
            "Home Assistant",
            "app_storage",
            "persistent storage",
            "async_load",
            "NoneType has no attribute 'get'",
            "AttributeError",
            "initialization bug",
            "first run failure",
            "component setup failure",
            "climate-1.0",
            "storage.Store",
            "critical bugfix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant evohome integration, a critical bug occurred during the initial setup on a fresh installation. The component used Home Assistant's storage helper to load persistent data:\n\n    store = self.hass.helpers.storage.Store(STORAGE_VERSION, STORAGE_KEY)\n    app_storage = self._app_storage = await store.async_load()\n\nThe code then immediately called `app_storage.get(CONF_USERNAME)` assuming `async_load()` returned a dictionary. On a new install, however, `async_load()` returns `None` because no storage file exists yet. This caused an `AttributeError: 'NoneType' object has no attribute 'get'` in `_load_auth_tokens`, which prevented evohome from completing setup. Since evohome never successfully started once, subsequent attempts also failed, effectively breaking the integration for all new users.\n\nThe fix had two parts:\n1. Initialize `self._app_storage` to an empty dictionary in the broker's `__init__` instead of `None`:\n\n   - Before: `self._app_storage = None`\n   - After:  `self._app_storage = {}`\n\n2. After loading from storage, normalize a `None` result to an empty dict:\n\n   - Before:\n        app_storage = self._app_storage = await store.async_load()\n        if app_storage.get(CONF_USERNAME) == self.params[CONF_USERNAME]:\n           ...\n\n   - After:\n        app_storage = self._app_storage = await store.async_load()\n        if app_storage is None:\n            app_storage = self._app_storage = {}\n        if app_storage.get(CONF_USERNAME) == self.params[CONF_USERNAME]:\n           ...\n\nThese changes ensure that `app_storage` is always a dictionary before `.get()` is called, eliminating the AttributeError and allowing evohome to start correctly on first run. The fix was flagged as critical and requested for cherry-pick into the 0.96 release because it was a showstopper for the evohome integration.",
        "semantic_memory": "This incident highlights a common class of bugs in systems that use lazy-created or optional persistent storage: assuming that a storage load operation always returns a fully initialized object. In many frameworks, a storage read on first use returns `None` or a similarly empty sentinel when no prior data exists. If the code then directly calls methods like `.get()` or indexes the result, it will crash with a `NoneType` or similar error on new installations.\n\nKey generalizable points:\n- Always normalize the result of a storage or cache load before using it. If the absence of data is represented by `None`, immediately convert it to an appropriate empty data structure (e.g., `{}` for dict, `[]` for list, or a dedicated default object).\n- Set safe default values for instance attributes that will later be used as mappings or collections. Initializing them to `None` can cause subtle bugs when later code assumes they are collection types.\n- New-install or first-run scenarios must be explicitly tested; bugs that only appear when no prior data exists are easy to miss if tests are run only against upgraded or already-initialized environments.\n- For integrations that load auth tokens or configuration from persistent storage, the code must handle the 'no tokens yet' case gracefully, rather than treating it as an error.\n- A component's setup path is extremely sensitive: crashes there can create a permanent failure loop until the underlying initialization bug is fixed. Defensive coding is especially important around `setup()` and `init_client()` logic.\n\nIn short, never assume persistence-backed objects exist or are non-null; always guard or normalize them, especially in first-run flows and authentication/token management code.",
        "procedural_memory": [
            "When diagnosing and fixing similar issues where storage-backed state causes crashes on first run, use the following steps:",
            "Step 1: Reproduce the issue in a truly 'fresh' environment.",
            "- Remove or rename any existing storage/config files for the integration or component under test (e.g., clear the integration's storage key or simulate a new install).",
            "- Start the application and watch the logs, focusing on stack traces during component setup or initialization.",
            "- Confirm that the error appears only on first run or when no previous state exists (e.g., `NoneType has no attribute 'get'`).",
            "Step 2: Inspect the failing code path around storage or cache loading.",
            "- Locate where persistent data is loaded (e.g., calls to `async_load`, `load_state`, or similar helper methods).",
            "- Check what type is expected (e.g., dict, list, or custom object) and how it is subsequently used (methods like `.get()`, indexing, iteration).",
            "- Identify whether the loader can return `None` or another sentinel when there is no saved state.",
            "Step 3: Add normalization and safe defaults.",
            "- Ensure instance attributes that represent storage-backed mappings or collections are initialized to safe empty values in `__init__` (e.g., `self._app_storage = {}` instead of `None`).",
            "- Immediately after loading from storage, normalize `None` to an appropriate empty structure. For example:\n  `data = await store.async_load()`\n  `if data is None: data = {}`",
            "- Only then proceed to call methods like `.get()` or perform indexing on the normalized object.",
            "Step 4: Consider both in-memory and persistent fields.",
            "- If you keep both an attribute (e.g., `self._app_storage`) and a local variable (e.g., `app_storage`), keep them consistent after normalization (assign the normalized value back to both if needed).",
            "- Avoid leaving any references that can still be `None` while other parts of the code assume they are dictionaries or lists.",
            "Step 5: Add or update tests to cover first-run behavior.",
            "- Write tests that simulate an empty storage state (e.g., mock `async_load` to return `None`).",
            "- Assert that the component's setup completes successfully without raising, and that any tokens or config defaults are handled gracefully.",
            "- If possible, add a regression test that triggers the exact previously failing line (e.g., calling `_load_auth_tokens` with empty storage).",
            "Step 6: Validate against upgrade and normal runs.",
            "- Also test with a non-empty storage response to ensure the normalization logic does not alter valid data.",
            "- Confirm that both fresh installs and existing installs behave correctly and that tokens/config are respected when present.",
            "Step 7: Document and backport if it is a showstopper.",
            "- If the failure prevents a component from starting at all, classify it as a critical bug.",
            "- Request backport/cherry-pick into relevant release branches and update release notes to mention the initialization/storage fix."
        ]
    }
}
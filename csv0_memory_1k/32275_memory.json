{
    "search_index": {
        "description_for_embedding": "Home Assistant Hue integration was throwing uncaught aiohttp client exceptions (e.g., ServerDisconnectedError/ClientError) when talking to the Hue bridge, especially after exhausting retry attempts. The fix broadens exception handling to catch more Hue/network errors, converts them into UpdateFailed for coordinators, increases backoff when the Hue hub is busy, and logs when retries are exhausted.",
        "keywords": [
            "Home Assistant",
            "Hue",
            "Philips Hue",
            "aiohttp",
            "ServerDisconnectedError",
            "ClientError",
            "ClientResponseError",
            "retry logic",
            "UpdateFailed",
            "DataUpdateCoordinator",
            "HUB_BUSY_SLEEP",
            "network error handling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the Home Assistant Hue integration was updated to handle more network-related errors from the Hue bridge. Previously, HueBridge.async_request_call retried on aiohttp.ClientOSError and ClientResponseError up to three times with a very short HUB_BUSY_SLEEP of 0.01 seconds. Some errors, particularly aiohttp.client_exceptions.ServerDisconnectedError and other ClientError variants, were not caught, leading to unhandled exceptions and unstable behavior when the Hue bridge disconnected or was overloaded. The fix introduces logging and more robust error handling: HUB_BUSY_SLEEP is increased from 0.01 to 0.5 seconds to give the bridge more time when it is busy. A module-level logger is added, and async_request_call now also catches ServerDisconnectedError together with ClientOSError and ClientResponseError. When the maximum of three retries is reached, it logs an error ('Request failed %s times, giving up.') and re-raises the exception instead of silently continuing. The logic for HTTP status codes is clarified: retries are only attempted for server-side errors (â‰¥500), and any 4xx ClientResponseError is raised immediately with no retry. In the light and sensor paths, async_safe_fetch in light.py and async_update_data in sensor_base.py were previously only catching asyncio.TimeoutError and aiohue exceptions; this could allow raw aiohttp client errors to bubble up and break the update loop. The patch adds aiohttp.client_exceptions.ClientError to the caught exceptions, converting these network issues into UpdateFailed signals, which DataUpdateCoordinator can handle gracefully. Overall, the incident revealed gaps in exception coverage around Hue bridge communication, and the fix broadened the caught error set, improved retry behavior, and ensured failures surface as controlled update failures rather than hard crashes.",
        "semantic_memory": "When integrating with networked devices or services (like a Hue bridge) using aiohttp, retry and error-handling logic must account for the full range of client-side exceptions, not just timeouts or a library-specific base exception. aiohttp groups many network-related failures under ClientError and more specific subclasses such as ClientOSError, ClientResponseError, and ServerDisconnectedError; robust code should catch these where appropriate. Retry mechanisms should only treat server-side or transient conditions as retryable (e.g., HTTP 5xx, temporary disconnects) while propagating client-side or configuration errors (e.g., HTTP 4xx) immediately. It is also important to tune backoff intervals for 'device busy' conditions: too short a sleep can hammer the device and exacerbate instability, while a modest delay reduces load and improves success rates. In frameworks like Home Assistant that use a DataUpdateCoordinator pattern, low-level network or protocol errors should typically be converted to a domain-level 'update failed' signal (such as UpdateFailed) rather than allowed to bubble up as raw transport exceptions; this lets the system degrade gracefully, retry later, and avoid taking down the entire integration. Adding explicit logging when retries are exhausted provides observability and makes it much easier to diagnose intermittent network issues or misconfigured error handling.",
        "procedural_memory": [
            "When diagnosing unstable behavior or crashes in an integration that communicates with a device/service over HTTP, first inspect logs for uncaught aiohttp exceptions (e.g., ServerDisconnectedError, ClientError, ClientResponseError) and note under what conditions they occur.",
            "Step 1: Identify the I/O boundary. Locate all functions that perform network I/O to the external device/service (e.g., bridge request methods, data fetch helpers, DataUpdateCoordinator update callbacks).",
            "Step 2: Enumerate current exception handling. For each I/O function, list which exceptions are currently caught (timeouts, library-specific errors like AiohueException, etc.) and which are not. Compare that list to aiohttp's exception hierarchy (ClientError, ClientOSError, ClientResponseError, ServerDisconnectedError, etc.).",
            "Step 3: Decide which errors are retryable vs fatal. Treat server-side errors (HTTP 5xx, temporary disconnects) and generic ClientError network disruptions as retryable candidates. Treat client-side/configuration errors (HTTP 4xx, Unauthorized, invalid credentials) as non-retryable and propagate them appropriately.",
            "Step 4: Implement robust retry logic. In the low-level request function, wrap the I/O in a loop with a bounded number of retries. Catch relevant aiohttp exceptions (ClientOSError, ClientResponseError, ServerDisconnectedError, and possibly broader ClientError), and only retry if the error is considered transient (e.g., status >= 500 or no status). Break and re-raise immediately for non-retryable 4xx errors.",
            "Step 5: Tune backoff delays. Introduce or adjust a backoff constant (like HUB_BUSY_SLEEP) to a reasonable value (e.g., 0.5 seconds instead of 0.01) so that repeated retries do not overload the device. Optionally consider exponential backoff if needed.",
            "Step 6: Add logging at failure boundaries. Before giving up after the final retry, log an error including the number of attempts and relevant context so operators can see that the integration is failing consistently and not just silently retries.",
            "Step 7: Convert low-level errors to framework-level signals. In higher-level update or fetch methods (e.g., DataUpdateCoordinator.update callbacks), catch aiohttp.ClientError, aiohue-specific exceptions, and asyncio.TimeoutError, then raise a framework-specific UpdateFailed (or equivalent) instead of letting raw exceptions propagate and crash the integration.",
            "Step 8: Preserve special handling for auth errors. Catch Unauthorized or similar authentication/authorization exceptions separately so that you can trigger re-auth flows or mark the config entry as needing attention, rather than treating them as generic network hiccups.",
            "Step 9: Test under failure conditions. Simulate device unavailability, server disconnects, and both 4xx and 5xx HTTP responses to verify that: (a) transient errors are retried with appropriate delay, (b) 4xx errors fail fast without retry, (c) the system logs a clear error when retries are exhausted, and (d) the integration surfaces failures as controlled update failures rather than unhandled exceptions.",
            "Step 10: Monitor coverage and regressions. Add or update tests to cover the new exception handling branches (including ServerDisconnectedError and generic ClientError) so that future refactors do not reintroduce unhandled error paths."
        ]
    }
}
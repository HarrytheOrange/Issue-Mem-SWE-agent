{
    "search_index": {
        "description_for_embedding": "Home Assistant UPnP/IGD integration refactor: discovery moved from a custom config flow to the component using async_upnp_client.async_discover, port mapping options removed from the UI and controlled via YAML only, sensors now link to a device in the device registry, and async_upnp_client upgraded to 0.13.7 to enable async discovery and fix SSL/non-SSL connection issues.",
        "keywords": [
            "homeassistant",
            "upnp",
            "igd",
            "port mapping",
            "config flow",
            "DiscoveryFlowHandler",
            "config_entry_flow.register_discovery_flow",
            "async_upnp_client==0.13.7",
            "SSL required with non-SSL services",
            "device registry",
            "CONNECTION_UPNP",
            "sensor device_info",
            "migration from config_flow to discovery flow"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant UPnP/IGD integration was reworked to address multiple issues: discovery behavior, configuration UX, and a library-level SSL bug.\n\nOriginally, UPnP/IGD devices were discovered via the generic discovery component and a custom config_flow (UpnpFlowHandler). The UI let users select a router and choose whether to enable traffic sensors and automatic port mappings. Port mappings could thus be enabled directly from the UI. Over time, this approach had downsides: it duplicated discovery logic outside the UPnP library, exposed a sensitive option (port mapping) in an easy-to-misuse UI, and was tightly coupled to specific translation keys and flow steps.\n\nThe PR removes the custom upnp.config_flow and its tests, and instead registers a discovery flow using `config_entry_flow.register_discovery_flow(DOMAIN, 'UPnP/IGD', Device.async_discover, CONN_CLASS_LOCAL_POLL)`. The new `Device.async_discover` method delegates discovery to `async_upnp_client.igd.IgdDevice.async_discover()`, enriching results with a UDN and SSDP description. The user-facing flow is now a simple confirmation dialog (strings.json updated accordingly), and sensitive options are no longer exposed there.\n\nConfiguration is now driven by YAML for behavior such as enabling sensors and port mappings. `async_setup` seeds `hass.data[DOMAIN]` with `config`, `devices`, `local_ip`, and `ports` and triggers a config entry import flow when `upnp:` is present. `async_setup_entry` uses a new helper `async_discover_and_construct` to rediscover or match the device by UDN, builds a `Device`, stores it in `hass.data[DOMAIN]['devices']`, and updates the config entry with the device UDN. It then:\n- Registers a device in the device registry using the new `CONNECTION_UPNP` connection type and the device's manufacturer and name.\n- Forwards the entry to the sensor platform if `CONF_ENABLE_SENSORS` is enabled in YAML.\n- If `CONF_ENABLE_PORT_MAPPING` is enabled, computes the local IP and ports (substituting the Home Assistant HTTP port as needed) and calls `device.async_add_port_mappings`, with a shutdown hook to remove mappings on `EVENT_HOMEASSISTANT_STOP`.\n\nOn unload, `async_unload_entry` now always removes port mappings and dispatches `SIGNAL_REMOVE_SENSOR` to clean up sensors for that device, regardless of previous config_entry flags.\n\nSensors were also updated: `sensor/upnp.py` now resolves the UDN either from `config_entry.data['udn']` (new entries) or falls back to \"any\" UPnP device for older entries. Sensors expose `device_info` tied to the UPnP device via identifiers and `via_hub`, fully integrating into the device registry.\n\nThe async_upnp_client dependency was upgraded across the UPnP and DLNA DMR integrations from 0.13.2 to 0.13.7, enabling async discovery and incorporating a fix for connections where SSL was previously incorrectly required to talk to non-SSL-enabled services. The `Device.manufacturer` property was updated to use the library's public attribute instead of a private field. Tests were adjusted: config-flow tests were removed, and init tests were updated to patch the new discovery and setup paths, including `Device.async_discover` and `get_local_ip` from the new module location.\n\nOverall, this PR makes UPnP/IGD discovery more robust, aligns it with Home Assistant's discovery flow patterns, removes UI exposure of port mapping creation, integrates devices into the device registry, and fixes an SSL-related bug by upgrading the underlying async_upnp_client library.",
        "semantic_memory": "Generalizable lessons from this fix:\n\n1. **Prefer library-native discovery over ad-hoc discovery and flows**\n   - When a third-party library offers a robust discovery mechanism (e.g., `async_upnp_client.igd.IgdDevice.async_discover()`), use it instead of reimplementing SSDP/discovery yourself in the app/framework. This centralizes protocol-specific knowledge and keeps the integration thin and maintainable.\n   - Wrapping the library's discovery output in a small adapter (e.g., enriching results with UDN, SSDP description, and source) makes it easy to plug into the host framework's discovery APIs.\n\n2. **Use standardized framework helpers for configuration flows**\n   - In Home Assistant, `config_entry_flow.register_discovery_flow` and `DiscoveryFlowHandler` reduce boilerplate and complexity compared to custom `config_flow` classes. They offer a common pattern for \"discover & confirm\" flows, which is sufficient for many integrations.\n   - Custom flows should be reserved for truly complex scenarios. When the UI is only meant to confirm that a discovered device should be set up, a discovery flow with a simple \"confirm\" step is enough.\n\n3. **Separate sensitive or advanced options from simple UI flows**\n   - Automatically exposing powerful or security-relevant features like UPnP port mappings in a simple point-and-click UI can lead to accidental misconfiguration and security risks.\n   - A good pattern is: keep the UI flow minimal (e.g., just enabling the integration), and put advanced/sensitive options (like enabling port mapping and which ports to expose) into more explicit configuration (YAML, advanced options, or admin-only areas). This PR specifically removes the ability to configure port mappings via the UI, while still allowing them via YAML.\n\n4. **Integrate devices and entities with a central device registry**\n   - When an integration represents a physical or logical device, always register it in a device registry (with stable identifiers such as UDN, MAC, or serial) and attach entities (like sensors) to that device via `device_info` and `via_hub`.\n   - Introduce explicit connection-type constants (e.g., `CONNECTION_UPNP`) to standardize how integrations describe their connectivity. This simplifies cross-integration reasoning, diagnostics, and UI presentation.\n\n5. **Config entry data should store stable identifiers, not configuration knobs**\n   - Config entries should primarily store the minimal, stable identity of the device (e.g., UDN) and any immutable discovery data. Behavioral/feature flags (enable sensors, enable port mapping) are better derived from configuration or options flows.\n   - This PR shifts behavior flags out of `config_entry.data` and into the component's configuration (`hass.data[DOMAIN]['config']`), while ensuring `config_entry.data` has the authoritative `udn` to re-associate the device on restart.\n\n6. **Handle migrations and incomplete data gracefully**\n   - When changing how an integration identifies or stores devices, older entries may be missing new keys (e.g., `udn` in `config_entry.data`). Code needs fallback paths (like picking any available device) to remain backward compatible or at least fail gracefully.\n   - Discovery helpers should handle the case of no devices found and multiple devices found, logging clearly and aborting setup when necessary.\n\n7. **Upgrade third-party libraries to fix protocol-level bugs, and reflect API changes in your wrapper**\n   - Protocol libraries (like async_upnp_client) often fix subtle issues such as SSL misconfiguration, connection handling, or protocol compliance. Upgrading to a fixed version can resolve hard-to-debug runtime issues in the integration (e.g., SSL being required for non-SSL endpoints).\n   - When upgrading, update your wrapper code to use the public API (e.g., `igd_device.manufacturer` instead of touching private attributes), and adjust tests to mock new methods such as `async_discover`.\n\n8. **Tests must follow the new integration boundaries**\n   - After replacing a custom config flow with a discovery flow, tests that exercise the removed flow are no longer valid and should be removed or rewritten to target the new API surface (setup, discovery, and teardown behaviors). This keeps the test suite relevant and reduces maintenance burden.\n",
        "procedural_memory": [
            "How to diagnose and fix similar issues involving discovery, config flows, and sensitive options in a Home Assistant-like integration:",
            "Step 1: Identify the pain points in the current flow",
            "- Look at user reports and issues: Are users confused by the configuration UX? Are sensitive options (e.g., port mappings, security toggles) too easily enabled from the UI? Are there bugs in discovery or connection handling (e.g., SSL vs non-SSL)?",
            "- Inspect the existing config flow: If there's a custom flow class with a lot of logic and checklists, ask whether the framework now provides a simpler alternative (e.g., discovery flows).",
            "",
            "Step 2: Check for library support for discovery and device metadata",
            "- Review the third-party library used by the integration to see if it provides built-in discovery (e.g., async SSDP discovery) and stable identifiers (UDN, UUID, etc.).",
            "- If the library has an `async_discover` or similar, prefer it over custom discovery logic. Plan to expose a thin adapter method (e.g., `Device.async_discover`) that returns discovery info in your framework's expected shape.",
            "",
            "Step 3: Design the new discovery & config flow",
            "- In Home Assistant: choose `config_entry_flow.register_discovery_flow` if you only need a \"we found X, set it up?\" flow, and avoid writing a custom `config_flow` class.",
            "- Decide which options belong in the UI flow and which should be moved to YAML or an options flow. Sensitive/advanced settings (like port mappings) should generally be moved out of the main UI confirmation step.",
            "- Update translation strings (e.g., config/step/abort messages) to reflect the new, simpler flow (e.g., a single `confirm` step with abort reasons like `single_instance_allowed` and `no_devices_found`).",
            "",
            "Step 4: Implement a discovery helper and device wrapper",
            "- Implement a classmethod like `Device.async_discover(hass)` that calls into the underlying library (e.g., `IgdDevice.async_discover()`), logs results, and enriches them with:",
            "  - A stable ID (e.g., `udn` from `usn.split('::')[0]`),",
            "  - The SSDP description or location URL (`ssdp_description`),",
            "  - Optional metadata like `source` for debugging.",
            "- Ensure your `Device` wrapper exposes properties needed by the framework: name, manufacturer, unique ID, etc., using public attributes from the library rather than private fields.",
            "",
            "Step 5: Refactor setup and config entry handling",
            "- In `async_setup`:",
            "  - Load the component's YAML config and store it in `hass.data[DOMAIN]['config']` along with data structures like `devices`, `local_ip`, and `ports`.",
            "  - Derive `local_ip` (e.g., via `get_local_ip`) and honor any configured overrides.",
            "  - If the integration is present in YAML, trigger a config-entry import flow (`hass.config_entries.flow.async_init(DOMAIN, context={'source': SOURCE_IMPORT})`).",
            "- In `async_setup_entry`:",
            "  - Use a helper like `async_discover_and_construct(hass, udn=None)` to rediscover and construct a `Device` for the entity, optionally matching an existing `udn` from `config_entry.data`.",
            "  - If no matching device is found, log and return False to abort setup cleanly.",
            "  - Store the device in `hass.data[DOMAIN]['devices'][device.udn]`.",
            "  - Update `config_entry.data` to include the canonical unique identifier (e.g., `udn`) and call `async_update_entry`.",
            "",
            "Step 6: Integrate with the device registry and entities",
            "- Register the device with the device registry using stable identifiers and connections, e.g.:",
            "  - `connections={(CONNECTION_UPNP, device.udn)}`,",
            "  - `identifiers={(DOMAIN, device.udn)}`,",
            "  - `name=device.name`, `manufacturer=device.manufacturer`.",
            "- Update entities (e.g., sensors) to expose `device_info` that references this device via identifiers and optionally `via_hub`.",
            "- In entity setup, account for old config entries that might lack new fields (like `udn`), and include fallback logic (e.g., choose the first device) while logging appropriately.",
            "",
            "Step 7: Control sensitive behavior via config, not basic UI",
            "- Move options like `enable_port_mapping` and `ports` into the component's configuration (`hass.data[DOMAIN]['config']`) instead of storing them in `config_entry.data`.",
            "- On setup entry, read these behavior flags from YAML config and act accordingly:",
            "  - When port mapping is enabled, compute ports (substituting placeholders such as 'hass' with the actual HTTP port) and call a method like `device.async_add_port_mappings(ports, local_ip)`. Log clearly which mappings are created.",
            "  - Register an `EVENT_HOMEASSISTANT_STOP` listener that always calls `device.async_delete_port_mappings()` to clean up dynamically created mappings.",
            "",
            "Step 8: Implement teardown correctly",
            "- In `async_unload_entry`, look up the device via the stored unique ID (`udn`) and:",
            "  - Always call `device.async_delete_port_mappings()` to remove any mappings that might exist.",
            "  - Dispatch a removal signal (e.g., `SIGNAL_REMOVE_SENSOR`) for sensors/entities to unregister themselves.",
            "- Optionally clear the entry from `hass.data[DOMAIN]['devices']` if appropriate for your integration.",
            "",
            "Step 9: Upgrade and adapt to third-party library changes",
            "- Upgrade the underlying protocol library to a version that fixes known bugs (e.g., SSL enforcement issues) and supports the required async APIs (e.g., async discovery).",
            "- Adjust your wrapper code to use the library's public interfaces after the upgrade (e.g., `igd_device.manufacturer` instead of `_device.manufacturer`).",
            "- Update requirement pins both in the integration module (REQUIREMENTS) and any global requirements list (like `requirements_all.txt`).",
            "",
            "Step 10: Update and simplify tests",
            "- Remove tests that target now-deleted flows (like custom config_flow tests) since they are no longer relevant.",
            "- Update remaining tests to patch and assert against the new code paths:",
            "  - Patch `Device.async_discover` to return deterministic discovery info.",
            "  - Patch `Device.async_create_device` to return a mock device with the expected interface.",
            "  - Patch `get_local_ip` from the correct module when testing setup.",
            "- Verify that:",
            "  - Devices are correctly stored in `hass.data[DOMAIN]['devices']`.",
            "  - Port mappings are created only when configured and are removed on shutdown.",
            "  - Sensors and device registry entries are created and cleaned up correctly."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor Home Assistant ffmpeg integration to remove hass.data entity registry and route start/stop/restart via dispatcher signals. FFmpeg entities now self-register using async_added_to_hass, services broadcast dispatcher signals with optional entity_id filtering, and binary_sensor ffmpeg_motion/ffmpeg_noise were updated accordingly. Tests were converted to async style and extended.",
        "keywords": [
            "ffmpeg",
            "Home Assistant",
            "dispatcher",
            "async_dispatcher_send",
            "async_dispatcher_connect",
            "hass.data",
            "entity registry",
            "binary_sensor",
            "ffmpeg_motion",
            "ffmpeg_noise",
            "async services",
            "EVENT_HOMEASSISTANT_START",
            "EVENT_HOMEASSISTANT_STOP",
            "async_added_to_hass",
            "refactor",
            "service routing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the ffmpeg integration in Home Assistant was refactored to remove direct entity management from the ffmpeg manager and instead use the dispatcher to route start/stop/restart commands.\n\nPreviously, the FFmpegManager kept a list of entities in hass.data['ffmpeg'].entities. The ffmpeg services (start/stop/restart) iterated over this list, manually calling each entity's async_start_ffmpeg, async_stop_ffmpeg, or async_restart_ffmpeg, and then updating their HA state. Entities were registered using manager.async_register_device, which also set up EVENT_HOMEASSISTANT_START/STOP listeners to auto-start or stop processes.\n\nThis design tightly coupled the manager with all ffmpeg entities and required explicit registration. It also mixed service routing logic with entity storage, making it harder to extend and more fragile in asynchronous contexts.\n\nThe fix replaced this with an event-driven dispatcher pattern:\n- New dispatcher signals were introduced: SIGNAL_FFMPEG_START, SIGNAL_FFMPEG_STOP, SIGNAL_FFMPEG_RESTART.\n- The ffmpeg service handler no longer iterates over manager.entities; it simply calls async_dispatcher_send(hass, SIGNAL_FFMPEG_*, entity_ids), passing through the optional entity_id list from the service call.\n- FFmpegBase was redesigned: instead of taking hass in __init__, it now only takes initial_state and overrides async_added_to_hass. In async_added_to_hass, each entity:\n  - Registers its own callbacks with the dispatcher via async_dispatcher_connect for start/stop/restart signals.\n  - Registers EVENT_HOMEASSISTANT_STOP to call _async_stop_ffmpeg(None) when Home Assistant stops.\n  - Optionally (if initial_state is True) registers EVENT_HOMEASSISTANT_START to auto-start ffmpeg and schedule async_update_ha_state.\n- The _async_start_ffmpeg, _async_stop_ffmpeg, and _async_restart_ffmpeg methods now receive a list of entity_ids (or None) and early-return if the current entity does not match. Restart is implemented by awaiting stop then start.\n- ffmpeg_motion and ffmpeg_noise binary sensors were updated: they no longer call manager.async_register_device. Their base class no longer requires hass in the constructor; instead, they call super().__init__(config.get(CONF_INITIAL_STATE)) and rely on Entity’s lifecycle (async_added_to_hass) to hook into the dispatcher and events. Their _async_start_ffmpeg implementations became proper coroutines that check entity_ids, configure the underlying haffmpeg SensorMotion/SensorNoise, and yield from open_sensor.\n- Synchronous helper functions ffmpeg.start/stop/restart were renamed to async_start/async_stop/async_restart and decorated with @callback. They use hass.async_add_job to schedule hass.services.async_call for the appropriate ffmpeg service.\n\nTests were heavily updated to align with the new design:\n- The ffmpeg component tests now use async_setup_component and explicit coroutines, rather than run_callback_threadsafe/run_coroutine_threadsafe.\n- A MockFFmpegDev now extends FFmpegBase without taking hass in __init__. Instead, it saves hass manually and must call async_added_to_hass() in tests to hook up dispatcher and event listeners.\n- New tests verify:\n  - async_added_to_hass registers the correct number of EVENT_HOMEASSISTANT_START/STOP listeners based on initial_state.\n  - ffmpeg.async_start/async_stop/async_restart cause the mocked device’s _async_start_ffmpeg/_async_stop_ffmpeg to be called, both globally and when filtered by entity_id.\n  - For binary_sensor.ffmpeg_noise and binary_sensor.ffmpeg_motion: entities are created, start on Home Assistant start, and their state transitions from 'off' to 'on' when the haffmpeg callback indicates detection. The initial tests were adjusted so that the entity’s state is 'unavailable' right after startup until the process reports back.\n\nOverall, the pull request decoupled service handling from entity storage, embraced the dispatcher pattern, and modernized the async patterns, while updating tests to cover the new behavior.",
        "semantic_memory": "This change showcases several generalizable patterns and best practices in an async, event-driven Python application such as Home Assistant:\n\n1. **Decoupling service routing from entity storage**\n   Instead of keeping an explicit list of registered entities in a central manager and iterating over them to handle services, a dispatcher (pub-sub) mechanism is used. Services emit generic signals (e.g., 'ffmpeg.start'), and entities choose to subscribe or ignore them. This reduces coupling, avoids manual entity registration in a global registry, and scales better as new entity types are added.\n\n2. **Using dispatcher signals for targeted actions**\n   Dispatcher signals can carry parameters like `entity_ids`. Entities implement a pattern where each signal handler accepts `entity_ids` and exits early unless it applies (e.g., `if entity_ids is not None and self.entity_id not in entity_ids: return`). This allows global or targeted operations with the same signal and improves reusability of service handlers.\n\n3. **Leaning on entity lifecycle hooks (`async_added_to_hass`)**\n   Instead of performing side effects in `__init__`, entities use the framework lifecycle method `async_added_to_hass` to set up event and dispatcher subscriptions. This ensures that the entity is fully registered with the system before hooking into services and avoids needing hass in the constructor. It also makes testing easier since you can explicitly call `async_added_to_hass` to simulate integration.\n\n4. **Clear coroutine semantics and callback decoration**\n   - Methods that must be awaited are explicitly marked as coroutines and use `yield from` / `await` to interact with async APIs.\n   - Service helper functions (like async_start/stop/restart) that simply schedule async work on the loop are decorated with `@callback` and use `hass.async_add_job`. This makes their usage safe from both sync and async contexts and clarifies that they themselves are not coroutines.\n   - Docstrings explicitly state \"This method is a coroutine\" to aid maintainers and tooling.\n\n5. **Clean start/stop handling on application lifecycle**\n   Each entity registers for application start/stop events (e.g., `EVENT_HOMEASSISTANT_START`/`STOP`) to automatically manage its underlying process. The initial_state flag controls whether an entity auto-starts on application startup. This pattern is widely applicable to any resource that needs to be brought up or down with the application.\n\n6. **Improved testability via async patterns**\n   Tests were updated to:\n   - Use async-friendly helpers (`async_setup_component`, `hass.async_block_till_done`) instead of thread-safe wrappers.\n   - Directly patch underlying async calls (haffmpeg Test.run_test, SensorNoise.open_sensor, SensorMotion.open_sensor) with `mock_coro` to control behavior.\n   - Explicitly drive the entity lifecycle (calling async_added_to_hass) and simulate callbacks to verify state updates.\n   This reinforces the idea that async behavior should be modeled explicitly in tests to avoid relying on hidden side effects.\n\n7. **Avoiding global mutable state to maintain cohesion**\n   Removing the manager.entities list reduces global mutable state and makes the code easier to reason about. Each entity is responsible for its own integration with services and lifecycle events via the dispatcher and event bus, which is a generally sound architectural pattern for large, plugin-based systems.\n\nThese patterns are applicable to any asynchronous, event-driven system: use pub-sub/dispatcher instead of central registries, let components self-register via lifecycle hooks, clearly separate coroutines from callbacks, and design tests to exercise the async behaviors explicitly.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify tight coupling or global registries in your service handling logic.\n- Look for managers or components maintaining explicit lists of entities or handlers (e.g., manager.entities) that are iterated over for each service call.\n- Check if entities must be manually registered/unregistered with the manager and if this leads to brittle logic or hard-to-test code.",
            "Step 2: Introduce dispatcher (pub-sub) signals for service routing.\n- Define dispatcher signals (e.g., SIGNAL_COMPONENT_START/STOP/RESTART) in a central module.\n- In your service handler, instead of iterating over entities, broadcast signals using something like async_dispatcher_send(hass, SIGNAL_COMPONENT_START, entity_ids).\n- Pass through relevant context, such as a list of entity_ids, so subscribers can filter themselves.",
            "Step 3: Move entity registration logic into lifecycle hooks.\n- Remove explicit registration calls like manager.async_register_device(entity).\n- In your base entity class, override a lifecycle hook like async_added_to_hass (or the equivalent in your framework).\n- Inside this hook, register dispatcher listeners using async_dispatcher_connect or similar.\n- Also register application start/stop event listeners for resource management (e.g., stop processes on shutdown, optionally start on startup based on initial_state).",
            "Step 4: Implement entity-side signal handlers with filtering.\n- In the base class, define coroutine handlers like _async_start_ffmpeg(self, entity_ids), _async_stop_ffmpeg(self, entity_ids), _async_restart_ffmpeg(self, entity_ids).\n- In each handler, implement filtering: if entity_ids is not None and self.entity_id not in entity_ids: return.\n- For restart, just await stop then start with entity_ids=None to ensure the same entity restarts regardless of the original filter.",
            "Step 5: Keep constructor (__init__) lightweight and avoid requiring the application object.\n- Only store configuration and static flags (like initial_state) in __init__.\n- Avoid passing the global application object (like hass) into __init__ unless strictly necessary; instead, use the lifecycle hook where `self.hass` is guaranteed to exist.\n- If existing code requires hass in __init__, gradually migrate logic to async_added_to_hass.",
            "Step 6: Clarify coroutine vs callback semantics.\n- Mark handlers that must be awaited as coroutines using async/await or @asyncio.coroutine and document them accordingly.\n- For helper functions that simply schedule work (like async_start/async_stop that call hass.services.async_call), decorate them with @callback and use hass.async_add_job instead of making them coroutines.\n- Update any callers to either `await` the coroutine or, for callbacks, call them directly without await.",
            "Step 7: Update and extend tests to cover the new async and dispatcher behavior.\n- Switch to async setup helpers (e.g., async_setup_component) and drive the event loop with hass.async_block_till_done.\n- When mocking entities, explicitly call their lifecycle hook (e.g., yield from ffmpeg_dev.async_added_to_hass()) inside tests.\n- Patch underlying async APIs (open_sensor, run_test, etc.) with coroutines (mock_coro) to simulate success/failure.\n- Add tests that:\n  - Verify that dispatcher callbacks are registered (e.g., async_listen_once call counts for START/STOP).\n  - Ensure global and per-entity ffmpeg async_start/async_stop/async_restart calls trigger the expected handlers.\n  - Validate state transitions when callbacks from the underlying library (e.g., haffmpeg) fire.",
            "Step 8: Verify lifecycle and state behavior end-to-end.\n- Start the application or test harness and confirm that entities with initial_state=True register for startup and automatically initiate their processes.\n- Ensure entities correctly stop their processes on application shutdown.\n- Confirm that entity states behave as expected: initial state (often 'off' or 'unavailable'), and transitions (e.g., to 'on') when the process reports detection or success via callback.\n- Adjust tests and documentation to reflect any change in initial or intermediate states.",
            "Step 9: Remove obsolete manager-side entity lists and registration methods.\n- Once entities self-register via dispatcher and lifecycle events, delete manager.entities and any async_register_device or similar API.\n- Remove any service logic that depended on manager.entities and replace it fully with dispatcher send calls.\n- Ensure no other code still relies on the old registry; if it does, migrate those usages to the dispatcher pattern as well."
        ]
    }
}
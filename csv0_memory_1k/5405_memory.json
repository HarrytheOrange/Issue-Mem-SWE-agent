{
    "search_index": {
        "description_for_embedding": "Home Assistant Roku media_player integration mis-detected the IDLE state when non-default Roku screensavers were used. The original code matched specific app names like 'Default screensaver', which failed for other screensavers. The fix upgrades the python-roku dependency to 3.1.3 and uses the new is_screensaver API plus a 'Power Saver' name check to reliably detect IDLE state.",
        "keywords": [
            "Home Assistant",
            "Roku",
            "media_player.roku",
            "IDLE state detection",
            "screensaver detection",
            "is_screensaver",
            "python-roku 3.1.3",
            "integration bug",
            "device state mapping",
            "dependency bump"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Roku media_player component incorrectly handled the Roku IDLE state when users configured non-default screensavers. The original implementation marked the Roku as IDLE only when the current app name exactly matched a small set of known strings (e.g., 'Power Saver', 'Default screensaver'). Because many Roku screensavers use different app names, the integration never reported STATE_IDLE for those cases, leaving the device in an incorrect state (e.g., appearing as if it was still running a normal app).\n\nThe first attempt to fix this expanded the logic to search for the substrings 'Screensaver' or 'screensaver' in the app name. Review discussion then pointed out a better solution: the underlying python-roku library exposes an is_screensaver property on the current app, which can be used for reliable detection without brittle string matching. To enable this, the dependency on python-roku was updated from version 3.1.2 to 3.1.3 in both the component's REQUIREMENTS and requirements_all.txt.\n\nThe final fix changes the Roku state computation to:\n- Return STATE_UNKNOWN if current_app is None.\n- Return STATE_IDLE if the current app name is 'Power Saver' or current_app.is_screensaver is true.\n- Return STATE_HOME if the current app name is 'Roku'.\n\nThis resolves the mis-detection of IDLE state for any Roku screensaver (including custom ones), while explicitly handling the 'Power Saver' app and removing the need for special-case string checks like 'Roku Digital Clock'.",
        "semantic_memory": "This case illustrates several generalizable lessons about integration development and state detection:\n\n1. **Prefer semantic library APIs over string matching:** When determining device states, relying on app names or other fragile string values is error-prone and hard to maintain. A dedicated API field (e.g., is_screensaver) is more robust and future-proof, especially when third-party apps vary or expand over time.\n\n2. **Update dependencies to leverage better semantics:** When an upstream library introduces more expressive or accurate properties, it can be worth bumping the dependency version and refactoring integration logic to use those properties, reducing custom heuristics in the application code.\n\n3. **Handle platform-specific special cases explicitly:** Some behaviors (e.g., Roku 'Power Saver' being functionally equivalent to IDLE) may not be captured by generic flags. These should be handled explicitly, but minimized to only truly special cases.\n\n4. **Avoid hardcoded lists of dynamic external values:** Hardcoding specific app names or strings from an external platform does not scale and easily misses edge cases (e.g., new screensavers). Instead, prefer feature flags or capabilities exposed by the platform API.\n\n5. **Align state mapping with actual device behavior:** High-level states (IDLE, HOME, PLAYING, etc.) in an integration should mirror the device's real-world behavior. Misalignment (like not recognizing screensavers as idle) leads to confusing UX and can break automations.\n\nOverall, when integrating with external devices, design state detection around stable, semantic indicators provided by the device API, and be willing to adjust dependencies to take advantage of those indicators.",
        "procedural_memory": [
            "Diagnosing and fixing incorrect device state detection (e.g., IDLE) for an external integration:",
            "Step 1: Reproduce the issue. Configure the external device (here, a Roku) in multiple realistic configurations (e.g., default and custom screensavers) and observe the states reported by the integration (e.g., in Home Assistant Developer Tools). Confirm that the state is incorrect (e.g., never becomes IDLE).",
            "Step 2: Inspect current state-mapping logic. Locate the code that maps the device API (current_app, app name, flags) to the integration's abstract states (STATE_IDLE, STATE_HOME, etc.). Look for hardcoded string lists, brittle checks, or assumptions about specific app names.",
            "Step 3: Review the upstream library/API capabilities. Check the documentation and source for the underlying client library (here, python-roku) or device API to see if there are semantic flags or properties that better represent the concept you're trying to detect (e.g., is_screensaver for detecting screensaver/idle state).",
            "Step 4: If a better API exists in a newer version, bump the dependency. Update the integration's dependency version (e.g., python-roku 3.1.2 â†’ 3.1.3) in all relevant locations (component REQUIREMENTS, global requirements file). Ensure the new version indeed exposes the needed property.",
            "Step 5: Refactor detection logic to use semantic flags. Replace string-based heuristics with checks against the new API fields. In this case, change the IDLE detection to: if current_app.name == 'Power Saver' or current_app.is_screensaver: return STATE_IDLE.",
            "Step 6: Preserve minimal necessary special cases. Identify any platform-specific cases not covered by the new API (e.g., 'Power Saver' behaving like idle), and keep those as explicit conditions while removing unnecessary name lists (like multiple screensaver names).",
            "Step 7: Add or update tests (if present). Create or adjust unit/integration tests to cover different app states: normal app, platform home app, default screensaver, third-party screensaver, and power-saving modes. Verify that the IDLE and HOME states are mapped correctly.",
            "Step 8: Re-test against real devices. Deploy the updated integration and test with multiple Roku configurations (various screensavers and modes) to confirm that the IDLE state is now correctly detected in all scenarios and that no regression occurs for HOME or PLAYING states.",
            "Step 9: Document the behavior. Optionally add code comments or documentation explaining why a certain field (e.g., is_screensaver) is used and why specific app names like 'Power Saver' are handled specially, to prevent future regressions or reintroduction of brittle string matching."
        ]
    }
}
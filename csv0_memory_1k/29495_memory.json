{
    "search_index": {
        "description_for_embedding": "Home Assistant iperf3 integration had a race condition because upload and download sensors reused a single iperf3 Client instance concurrently. The fix is to store host configuration instead of a client object and generate a new iperf3 client for each test run, avoiding shared mutable state and race conditions.",
        "keywords": [
            "iperf3",
            "Home Assistant",
            "race condition",
            "shared client instance",
            "concurrent sensors",
            "upload download sensors",
            "Client.run",
            "network performance",
            "integration bugfix",
            "create client per request"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant iperf3 integration, both the download and upload sensors were using the same iperf3.Client instance. The integration periodically triggered both sensors, which caused them to update and run tests at nearly the same time. Since iperf3.Client is stateful (properties like reverse, duration, server_hostname, etc.), sharing a single client object created a race condition: one sensor could change client.reverse or other fields while the other was already running or about to run, leading to incorrect or inconsistent test results and errors.\n\nThe original setup code created a single iperf3.Client per configured host and stored that client in hass.data[DOMAIN][host_name]. The Iperf3Data object then reused that client, mutating its properties and calling client.run() for both upload and download tests.\n\nThe fix changes the design so that Iperf3Data stores the host configuration dict instead of a pre-built client instance. A new helper method, create_client(), was introduced that constructs a fresh iperf3.Client each time a test is run: it sets duration, server_hostname, port, num_streams, protocol, and verbose based on the stored host configuration. In _run_test(), instead of mutating self._client, the code now creates a local client = self.create_client(), sets client.reverse according to whether it is a download or upload test, and calls client.run(). The protocol, host, and port properties were updated to read from the host config instead of the client instance.\n\nThis fully eliminates the shared mutable iperf3.Client object between the upload and download sensors, removing the race condition. The PR also adds the maintainer (@rohankapoorcom) as code owner for the iperf3 component in CODEOWNERS and manifest.json, and adjusts a docstring to use imperative mood (\"Create\" instead of \"Creates\"). A community member confirmed that manually calling the service works correctly with this change.",
        "semantic_memory": "When multiple concurrent operations share a single mutable client object (especially a network or IO client), race conditions and subtle bugs are likely. If different operations mutate attributes on a shared client (e.g., toggling a reverse flag, changing host, port, or other settings) while the client is in use, they can interfere with each other and produce incorrect or flaky results.\n\nA robust pattern is to avoid shared mutable state across concurrent tasks whenever the underlying object is not explicitly designed to be thread-safe or reentrant. Instead, store immutable configuration (like host, port, duration, protocol) and construct a fresh client instance for each operation. This functionally isolates each call: it has its own configuration, its own runtime state, and cannot be corrupted by other concurrent operations.\n\nIn periodic sensor systems like Home Assistant integrations, it is easy to accidentally share a single client between multiple entities (e.g., upload and download sensors). While this can seem efficient, it often trades performance for correctness and reliability. A small overhead of creating a client per run is usually acceptable compared to the risk of race conditions.\n\nAbstract lessons:\n- Do not share a single stateful client instance across multiple concurrent or scheduled tasks unless it is explicitly safe to do so.\n- Prefer \"client factory\" patterns: keep configuration as data and create a new client object per request or per operation.\n- Accessor properties that expose things like host/protocol should read from stable configuration state, not from transient mutable client objects that may change per call.\n- When fixing concurrency issues, refactoring to reduce or eliminate shared mutable state is often simpler and safer than adding locks or synchronization.\n- Small cleanups (like correct docstring tense, proper CODEOWNERS) improve maintainability and clarify ownership, which makes future bug discovery and fixing easier.",
        "procedural_memory": [
            "To diagnose and fix similar race conditions involving shared client instances, follow these steps:",
            "Step 1: Identify symptoms of concurrency issues",
            "  - Look for intermittent or inconsistent behavior when multiple sensors, services, or tasks run close together or at the same time.",
            "  - Check logs for errors that appear only under concurrent load (e.g., when both upload and download are measured simultaneously).",
            "  - Note if manual, isolated runs work fine, but periodic or concurrent runs fail or behave oddly.",
            "Step 2: Inspect how clients are created and stored",
            "  - Search the integration or module for where network/IO client objects are instantiated (e.g., iperf3.Client(), HTTP clients, DB connections).",
            "  - Check whether a single client instance is stored in some shared container (e.g., hass.data, a singleton, a module-level variable) and reused by multiple entities or services.",
            "  - Determine if different operations mutate properties on this shared instance (e.g., flags like reverse, URLs, headers, or authentication).",
            "Step 3: Confirm non-thread-safe or stateful behavior",
            "  - Review the client library documentation to see if it is thread-safe or reentrant. Most such clients are not.",
            "  - Examine usage: if the code repeatedly changes fields on the same instance before each run, that is a sign of statefulness and potential race issues.",
            "Step 4: Reproduce the race condition",
            "  - Trigger multiple operations that share the client at the same time (e.g., enabling multiple sensors, calling services concurrently).",
            "  - Add temporary logging around the shared client usage (e.g., log when properties are set, when run() is called, and in which context).",
            "  - Look for overlapping usage where one operation changes client state while another is running.",
            "Step 5: Refactor to avoid sharing mutable clients",
            "  - Change the data model so that you store only configuration data (host, port, duration, protocol, etc.) in long-lived objects like entity data wrappers.",
            "  - Introduce a helper or factory method (e.g., create_client()) that constructs a new client instance each time an operation is performed, using the stored configuration.",
            "  - Update the code paths that perform operations (e.g., _run_test) to call the factory method, configure only operation-specific flags (like reverse), and then run the operation on the newly created client.",
            "Step 6: Update property accessors and dependencies",
            "  - If properties like host, port, or protocol previously read from the client object, update them to read from the stored configuration instead.",
            "  - Ensure no remaining code depends on a persistent client instance; everything should work based on configuration data and per-call clients.",
            "Step 7: Test under concurrent and periodic workloads",
            "  - Run unit tests and, if possible, integration tests that trigger multiple sensors or services concurrently.",
            "  - Verify that repeated periodic runs (e.g., Home Assistant scan intervals) do not cause errors or inconsistent measurements.",
            "  - Confirm that manual invocation (e.g., calling a service from UI or CLI) still behaves correctly.",
            "Step 8: Clean up and document ownership",
            "  - Remove any dead code related to the old shared client approach.",
            "  - Add or update CODEOWNERS and manifest metadata to reflect current maintainers for easier future triage.",
            "  - Optionally, improve docstrings and comments to clarify that a new client is created per operation and why (to avoid race conditions)."
        ]
    }
}
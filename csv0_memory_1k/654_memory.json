{
    "search_index": {
        "description_for_embedding": "Prototype implementation of a remote napari viewer synchronized over Dask distributed using a Pub/Sub pattern. Introduces a headless Viewer mode (`is_remote=True`) that runs without a Qt window, and a `DaskRemoteViewer` + `RemoteTopic` abstraction to synchronize viewer properties (e.g. title) between a remote process and a local GUI, handling asyncio + Qt event loop integration via `qapp.processEvents()`.",
        "keywords": [
            "napari",
            "remote viewer",
            "dask distributed",
            "Pub/Sub",
            "asyncio",
            "Qt event loop",
            "headless mode",
            "ViewerModel",
            "Jupyter integration",
            "event loop interoperability"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR explored how to connect a remote napari viewer (running on a compute cluster) to a local GUI viewer (running on a laptop) using Dask distributed's publish/subscribe mechanism. The core idea was that users could call `viewer.add_image(big_data)` on the remote cluster and see the result in their local napari window, while interacting with the viewer as if everything were local.\n\nTo enable this, the author introduced a new module `napari._dask` containing two main pieces:\n\n1. `RemoteTopic` (in `napari/_dask/util.py`):\n   - Wraps Dask distributed `Pub`/`Sub` around a named topic.\n   - Creates a Dask `Client` pointed at a scheduler address.\n   - Provides `put(value)` to publish values, guarded by a `block_put` context manager to avoid echoing back values that originated from local updates.\n   - Implements an async `sub()` method that uses an asynchronous Dask `Client` and `Sub` to `await sub.get()` in a loop, and emits a custom `value` event via an `EmitterGroup` when new data arrives.\n   - On each received message, it calls `self.events.value(value=value)` and, if a Qt application instance is available (`qapp`), triggers `qapp.processEvents()` to keep the GUI responsive.\n   - `connect()` wires this subscriber loop into the current asyncio event loop with `asyncio.get_event_loop().create_task(self.sub())`.\n\n2. `DaskRemoteViewer` (in `napari/_dask/dask_remote_viewer.py`):\n   - Bridges a `ViewerModel` instance and a `RemoteTopic`.\n   - Accepts a `viewer`, a Dask `address`, and optionally a Qt application (`qapp`).\n   - Constructs a `RemoteTopic('viewer_title', address, qapp=qapp)` to synchronize the viewer's title.\n   - Listens to `viewer.events.title` and publishes updates via `RemoteTopic.put(self.viewer.title)`.\n   - Subscribes to `RemoteTopic.events.value` and, on update, sets `self.viewer.title = event.value`, closing the loop between local and remote viewer titles.\n   - Exposes a `connect()` method that simply calls `self.title.connect()` to start the async subscription.\n\nThe `Viewer` class (`napari/viewer.py`) was extended to support remote/headless operation:\n\n- New arguments: `is_remote=False` and `address=None`.\n- When `is_remote` is `False` (normal local GUI):\n  - Ensures a Qt application instance exists, with a clear error message if not.\n  - Initializes `ViewerModel` with title, ndisplay, order, and axis_labels.\n  - Creates a `QtViewer` and a top-level `Window`, and wires console and (in earlier version) screenshot functionality.\n- When `is_remote` is `True` (headless/remote):\n  - Skips all Qt initialization so the viewer can run on a non-GUI environment (e.g. EC2, remote cluster) but still use the same `ViewerModel` API.\n  - Initializes `ViewerModel` with the same arguments but does not create a window; `app` is set to `None`.\n- Regardless of `is_remote`, if `address` is provided, the viewer creates a `DaskRemoteViewer(self, self.address, qapp=app)` and exposes it as `self.remote`, allowing a local or remote process to call `viewer.remote.connect()` to start synchronizing the title property via Dask.\n\nIn use, the envisioned workflow was:\n\n- Remote notebook:\n  - Create a Dask `LocalCluster` and `Client`.\n  - Create `viewer = napari.Viewer(is_remote=True, address=cluster.scheduler.address)`.\n  - Call `viewer.remote.connect()` to start syncing.\n- Local notebook:\n  - Use `%gui qt5` to start the Qt event loop.\n  - Create `viewer = napari.Viewer(address='tcp://...')`.\n  - Call `viewer.remote.connect()`.\n  - Changing `viewer.title` on either side would propagate to the other.\n\nDuring experimentation, the author encountered difficulties integrating Dask's asyncio-based APIs with Jupyter and Qt event loops: `asyncio.get_event_loop().create_task(self.sub())` behaved differently in headless remote mode, local Qt, and Jupyter/IPython. Quamash/asyncqt were considered for a proper `QEventLoop` but not adopted due to dependency concerns. The PR ultimately remained a proof-of-concept and was closed without being fully merged or generalized beyond synchronizing the viewer title.\n\nA later merge fix adapted the `Viewer` constructor to new `ViewerModel` arguments (e.g. `axis_labels`), split the initialization paths for remote and non-remote modes more cleanly, and ensured the `DaskRemoteViewer` still receives the correct Qt app reference (`app`) when available.",
        "semantic_memory": "This work illustrates several generalizable patterns and lessons about integrating remote computation, GUIs, and asynchronous frameworks:\n\n1. **Headless vs GUI separation in applications**\n   - A clean architectural separation between a core data/model layer and the GUI layer makes it much easier to support remote or headless operation.\n   - In this case, `Viewer` inherits from `ViewerModel`. When `is_remote=True`, the code skips creating Qt widgets and windows but still instantiates the full model. This allows remote code to call the same API (`viewer.add_image`, etc.) while deferring visualization to a different process.\n   - This pattern generalizes to many GUI applications: keep the core logic/models GUI-agnostic, and layer UI-specific components on top conditionally.\n\n2. **Using Dask distributed Pub/Sub for state synchronization**\n   - Dask's `Pub`/`Sub` mechanism can be used for simple, topic-based synchronization of state between processes (local and remote) with minimal wiring.\n   - A `RemoteTopic` abstraction encapsulates the concerns of:\n     - instantiating clients (`Client`),\n     - defining a topic name,\n     - providing `put` operations, and\n     - running an async subscription loop that emits local events when data arrives.\n   - This pattern is applicable to synchronizing other models/properties, not just a viewer title. Layers, settings, or other metadata could be mapped onto named topics.\n\n3. **Guarding against echo loops in bidirectional synchronization**\n   - When both sides publish and subscribe on the same topic, updates can \"echo\" back and forth or cause redundant processing.\n   - A simple pattern is a reentrancy guard (e.g., `_block` flag with a context manager `block_put`) that disables publishing while handling an inbound update. This prevents the receiver from re-publishing the same value.\n   - This idea is broadly useful in any bidirectional sync or replicated-state scenario (CRDTs, mirrored UIs, collaborative editing tools).\n\n4. **Asyncio and GUI event loop integration**\n   - Many GUI toolkits (like Qt) have their own event loop, which must cooperate with Python's `asyncio` loop.\n   - Directly calling `asyncio.get_event_loop().create_task(...)` from a GUI application or Jupyter can be fragile, because Jupyter/IPython may already be managing the asyncio loop, and Qt has its own loop.\n   - One mitigating approach is to:\n     - run asynchronous network code in the asyncio loop, and\n     - on each inbound message, schedule or directly call GUI event processing (`qapp.processEvents()` or dispatch to the main thread) so the UI updates.\n   - Libraries like Quamash/asyncqt offer a combined `QEventLoop` that integrates Qt with asyncio. Even if not used directly in this code, the general lesson is: when mixing asyncio with a GUI, consider a unified event loop or carefully mediate between them.\n\n5. **Incremental serialization and diffs for remote state**\n   - For large data (e.g., big images as Dask arrays), it is impractical to send entire state blobs on every small property change (like a colormap change).\n   - Dask's `Client.scatter`/`gather` can handle large arrays efficiently, and then higher-level structures (e.g. viewer metadata) can be serialized and diffed with libraries like `jsondiff` to send only what changed.\n   - More generally, when synchronizing complex state across network boundaries, design for:\n     - separating heavy data blobs (large arrays) from lightweight metadata,\n     - referencing large blobs via stable identifiers or futures, and\n     - using diffs or targeted updates instead of full-state snapshots.\n\n6. **Designing extensible synchronization layers**\n   - Starting with a single property (like `viewer.title`) provides a minimal end-to-end proof-of-concept.\n   - A scalable design should anticipate:\n     - adding topics for additional properties and layers,\n     - creating/destroying topics as layers are added/removed,\n     - and versioning or namespacing topics for plugins and new UI features.\n   - This PR hints at the need for a higher-level abstraction that maps the viewer model graph onto a set of sync channels, rather than manually wiring each property.\n\nOverall, the feature demonstrates patterns for turning a local GUI application into a networked, remote-controllable system: decouple core models from GUI, use a messaging layer (Dask Pub/Sub) to synchronize state, manage reentrancy and echo, and carefully integrate async network I/O with GUI event loops.",
        "procedural_memory": [
            "Step-by-step approach to building and debugging a remote, Dask-backed GUI viewer (or similar application):",
            "Step 1: Separate core model from GUI components\n- Identify the core data and behavior (e.g., ViewerModel) that should work in both local and remote/headless modes.\n- Refactor the application so that the GUI-specific elements (Qt windows, widgets) are optional and layered on top of this model.\n- Introduce a flag (like `is_remote`) or separate entry point to instantiate the model without creating any GUI elements. Ensure all core operations (add layers, change properties) work in this headless mode.",
            "Step 2: Define a remote connection contract\n- Decide which properties or actions must be synchronized between remote and local processes (e.g., viewer title, list of layers, layer metadata, etc.).\n- For each property/feature, define how it will be represented over the wire (e.g., JSON, dicts with futures for big arrays, etc.).\n- Start small: synchronize a simple property (like a string title) as a round-trip proof-of-concept before generalizing.",
            "Step 3: Wrap Dask Pub/Sub into a reusable abstraction\n- Create a helper class like `RemoteTopic` to hide Dask-specific implementation details:\n  - Accept a `topic` name and scheduler `address`.\n  - Create a Dask `Client` connected to the remote cluster.\n  - Instantiate `Pub(topic)` and `Sub(topic)` as needed.\n  - Provide a `put(value)` method that publishes values.\n- Add an event mechanism (like an `EmitterGroup` with a `value` event) so GUI or model code can subscribe to inbound updates.",
            "Step 4: Implement an async subscription loop\n- In the helper class, define an `async def sub(self):` method that:\n  - Creates an asynchronous Dask client (`Client(..., asynchronous=True)`).\n  - Instantiates a `Sub(topic)`.\n  - Enters an infinite loop and uses `await sub.get()` to receive new values.\n  - On each value, emits a local event (`self.events.value(value=value)`).\n- Add a `connect()` method that schedules this coroutine on the current event loop (e.g., `asyncio.get_event_loop().create_task(self.sub())`).\n- Be aware that this assumes a running asyncio loop, which is managed differently in plain Python, IPython, Jupyter, and GUI applications.",
            "Step 5: Prevent echo loops in bidirectional synchronization\n- When both the local GUI and the remote model publish updates on the same topic, implement a guard to avoid echoing the same value back and forth.\n- Add a flag like `self._block` and a context manager `block_put()`:\n  - In `put()`, return early if `_block` is True.\n  - In the subscription handler, wrap event emission and local property updates with `with self.block_put():` so that handling a remote update does not trigger a new `put()`.",
            "Step 6: Bridge the model and remote topic with a thin adapter\n- Implement an adapter (like `DaskRemoteViewer`) that:\n  - Stores a reference to the core model (`viewer`) and the Dask address.\n  - Creates one or more `RemoteTopic` instances for the properties you want to sync (e.g., `RemoteTopic('viewer_title', address, qapp=app)`).\n  - Connects model events (e.g., `viewer.events.title`) to `RemoteTopic.put()`.\n  - Connects `RemoteTopic.events.value` to model setters (e.g., `_on_title_update` that sets `viewer.title = event.value`).\n  - Exposes a simple `connect()` method to start the subscription(s).",
            "Step 7: Integrate async network code with the GUI event loop\n- Recognize that in GUI applications, the main thread is usually owned by the GUI event loop (Qt, etc.), and async tasks must not directly block it.\n- When you receive network updates in the async loop, schedule GUI-safe updates:\n  - If you have a reference to the Qt app (`qapp`), call `qapp.processEvents()` after applying the update, or use Qt signals/slots to dispatch updates to the main thread.\n  - Alternatively, use a library that integrates Qt and asyncio (e.g. asyncqt) to run a unified event loop.\n- In Jupyter/IPython, be aware that IPython manages its own asyncio loop; consult IPython's `autoawait` documentation and test both in IPython CLI and Jupyter notebooks.",
            "Step 8: Wire remote connection into the main Viewer (or application) API\n- Extend your main Viewer/application constructor with parameters like `is_remote` and `address`:\n  - If `is_remote` is False, initialize the GUI normally and pass the Qt app object to the remote adapter.\n  - If `is_remote` is True, skip GUI creation and run headless, but still create the model.\n- If an `address` is provided, instantiate your remote adapter (`DaskRemoteViewer`) and expose it as `viewer.remote`.\n- Document how users should start local and remote instances (e.g., start Dask scheduler, pass address, call `viewer.remote.connect()`).",
            "Step 9: Plan for scaling beyond one property\n- Once basic sync works for a simple property, design a scheme to synchronize more complex state:\n  - Decide whether to use one topic for the entire viewer state or multiple topics per property/layer.\n  - For large numerical data (e.g., images), use `Client.scatter`/`gather` and send only references/futures in the metadata.\n  - Consider using a JSON diff library (e.g. `jsondiff`) so you can send only the changes instead of full state snapshots.\n- Ensure the design can adapt to new UI elements and plugins without brittle, property-by-property wiring.",
            "Step 10: Debug event loop issues systematically\n- When you see odd behavior (e.g., async tasks not running, GUI freezing, inconsistent updates):\n  - Verify what event loops are running (asyncio, Qt, tornado in Jupyter).\n  - Test in different environments (pure Python script, IPython CLI, Jupyter notebook) to isolate environment-specific issues.\n  - For Jupyter, pay attention to IPython's async REPL behavior and autoawait configuration.\n  - Consider logging or printing when the subscription loop runs, when events are emitted, and when GUI updates are applied.\n- If needed, reduce the system to a minimal example: a single remote topic, a single property, and a simple print-based GUI or CLI to validate the async pipeline.",
            "Step 11: Iterate towards a robust, maintainable design\n- Start with a minimal, working proof-of-concept (as in this PR with just the viewer title).\n- Gather feedback, measure performance, and understand event loop behavior under load.\n- Refactor the sync code into a coherent layer that:\n  - Is decoupled from specific viewer properties.\n  - Can be extended by plugins.\n  - Handles reconnection, error states, and version mismatches gracefully.\n- Only then commit to a stable public API for remote synchronization."
        ]
    }
}
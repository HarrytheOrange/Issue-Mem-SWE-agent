{
    "search_index": {
        "description_for_embedding": "Home Assistant Amcrest integration refactor that adds Amcrest-specific camera services (enable/disable recording, audio, motion recording, PTZ preset, PTZ tour, color mode), exposes camera attributes for these states, deprecates old switch-based configuration, and moves service handling to the Amcrest domain using dispatcher and proper permission checks.",
        "keywords": [
            "home-assistant",
            "amcrest",
            "camera",
            "integration",
            "services",
            "switch deprecation",
            "motion detection",
            "motion recording",
            "continuous recording",
            "audio stream",
            "PTZ preset",
            "PTZ tour",
            "color_bw",
            "services.yaml",
            "dispatcher",
            "hass.data",
            "permissions",
            "POLICY_CONTROL",
            "Unauthorized",
            "ENTITY_MATCH_ALL"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Amcrest integration for Home Assistant was extended and refactored to align with core design guidance and to remove legacy patterns.\n\nOriginally, Amcrest-specific camera operations (enabling recording, motion recording, audio, PTZ moves, etc.) were implemented as `camera`-domain services with names like `camera.amcrest_xxx`. Additionally, some of these camera behaviors were exposed as `switch` entities (e.g., motion_detection, motion_recording) that controlled camera settings indirectly. This design created redundancy and did not match the desired pattern where device-specific features are exposed via domain-specific services and attributes rather than separate switch entities.\n\nThe PR implemented several key changes:\n\n1. **New Amcrest camera services**:\n   - New services were defined under the `amcrest` domain, documented in `homeassistant/components/amcrest/services.yaml`:\n     - `amcrest.enable_recording` / `amcrest.disable_recording`\n     - `amcrest.enable_audio` / `amcrest.disable_audio`\n     - `amcrest.enable_motion_recording` / `amcrest.disable_motion_recording`\n     - `amcrest.goto_preset` (with `preset` argument)\n     - `amcrest.set_color_bw` (with `color_bw` argument: `auto`, `color`, or `bw`)\n     - `amcrest.start_tour` / `amcrest.stop_tour`\n   - These services now operate directly on `camera.amcrest_*` entities but are invoked through the `amcrest` domain, rather than hijacking the `camera` domain.\n\n2. **Camera attributes instead of switches**:\n   - The `AmcrestCam` entity (`amcrest/camera.py`) was extended to expose new state attributes:\n     - `audio`: `on`/`off` based on audio streaming state.\n     - `motion_recording`: `on`/`off` based on whether motion-triggered recording is enabled.\n     - `color_bw`: one of `auto`, `color`, `bw` based on the camera's day/night mode.\n   - `motion_detection_enabled` is tracked internally, but the motion detection status is no longer exported as its own attribute; motion detection is still controllable via methods on the entity.\n   - Previously used Amcrest switches (`motion_detection`, `motion_recording`) are now deprecated; users are encouraged to use the new services and attributes instead and, if needed, recreate switches via template switches.\n\n3. **Configuration schema updates and deprecation warnings**:\n   - The Amcrest config schema (`AMCREST_SCHEMA` in `__init__.py`) was updated:\n     - Uses `cv.ensure_list` instead of `cv.ensure_list_csv` for `binary_sensors`, `sensors`, and `switches`.\n     - Adds `_deprecated_sensor_values` to warn if the old `sensors` option contains `motion_detector`, instructing users to use `binary_sensors: motion_detected` instead.\n     - Adds `_deprecated_switches` to warn if the `switches` option is used, indicating that it is deprecated in favor of camera services and attributes.\n     - Ensures unique names across configured Amcrest devices with `_has_unique_names`.\n\n4. **Refactoring of internal structure**:\n   - `hass.data[DATA_AMCREST]` was reorganized to:\n     - `{'devices': {<name>: AmcrestDevice}, 'cameras': [<camera_entity_id>, ...]}`.\n     - `AmcrestDevice` now holds `api` (low-level Amcrest camera API), `authentication`, `ffmpeg_arguments`, `stream_source`, and `resolution`. The `name` was removed from `AmcrestDevice`, and the caller passes the name explicitly.\n   - The Amcrest camera platform now gets the device via `hass.data[DATA_AMCREST]['devices'][name]` and creates `AmcrestCam(name, device, ffmpeg)`.\n   - Direct low-level `self._camera` references in entities (binary_sensor, sensor, switch, camera) were renamed to `self._api` for clarity.\n\n5. **Service handling moved and modernized**:\n   - Service definitions and registration were moved from `amcrest/camera.py` into `amcrest/__init__.py`.\n   - A central `CAMERA_SERVICES` mapping in `camera.py` now defines, per service name, the service schema, the handler method name, and any argument keys.\n   - `__init__.py`:\n     - Registers each Amcrest service with Home Assistant using the appropriate schema.\n     - Implements `async_service_handler` that:\n       - Resolves the target entity_ids from the call (honoring `entity_id` and `ENTITY_MATCH_ALL`).\n       - Enforces user permissions based on `POLICY_CONTROL`. If a user lacks permission, it raises `Unauthorized`; if the user cannot be resolved, it raises `UnknownUser`.\n       - Extracts any additional call arguments defined for the service (e.g., `preset`, `color_bw`).\n       - Uses the dispatcher (`async_dispatcher_send`) to send a per-entity service signal (`amcrest_<service>_<entity_id>`) with the arguments.\n   - `amcrest/helpers.py` provides `service_signal(service, entity_id=None)` to consistently encode the dispatcher signal string.\n   - `AmcrestCam.async_added_to_hass()` subscribes to these service signals via `async_dispatcher_connect` and routes them to instance methods, then registers its `entity_id` in `hass.data[DATA_AMCREST]['cameras']`. Correspondingly, `async_will_remove_from_hass()` unsubscribes and removes the entity from the list.\n\n6. **Other behavioral details and fixes**:\n   - Stream source handling was normalized:\n     - `STREAM_SOURCE_LIST` is now a list of strings (`'snapshot'`, `'mjpeg'`, `'rtsp'`), and configuration uses those values directly.\n     - MJPEG streaming uses `CAMERA_WEB_SESSION_TIMEOUT` constant instead of a magic number.\n   - Certain operations enforce a consistent camera state relationship:\n     - When disabling video stream, the code ensures recording is turned off first, because the entity's `is_on` state is derived from both streaming and recording.\n     - When enabling recording, the code ensures streaming is enabled first.\n   - Binary sensor, sensor, and switch platforms were updated to use the new `DATA_AMCREST` structure and constants from `const.py`.\n\nThrough review iterations, additional changes were made: permission checking was added for services; service methods were converted from callbacks that scheduled jobs to async coroutines that use `hass.async_add_executor_job`; service handling was moved from per-platform modules to the component init; `cv.ensure_list_csv` usage was corrected; and dispatcher-based service routing was implemented for better decoupling. The end result is a cleaner, more consistent Amcrest integration that surfaces camera-specific functionality via proper services and attributes and deprecates the old switch-based interface.",
        "semantic_memory": "This PR illustrates several generalizable patterns and best practices for Home Assistant integrations (and more broadly, for any modular service-oriented architecture):\n\n1. **Use domain-specific services instead of misusing other domains**\n   - Vendor- or integration-specific operations should live under that integration's own domain (e.g., `amcrest.enable_recording`), not hijack other domains (like `camera.amcrest_enable_recording`). This keeps service discovery and documentation consistent and avoids polluting generic domains with vendor-specific logic.\n   - Services should be documented in a `services.yaml` file in the integration's directory to ensure they appear in the developer tools and docs.\n\n2. **Prefer services and entity attributes over synthetic entities (like switches)**\n   - Exposing device settings (e.g., motion detection, motion recording) as fake `switch` entities is often redundant when the primary entity (e.g., `camera`) can perform the action directly via services and report state via attributes.\n   - By using services and attributes, the UI can still present these controls as switches via template entities if necessary, but the backend API remains clean and closer to the real device model.\n\n3. **Deprecation with warnings, not abrupt removal**\n   - When removing or changing configuration options, the integration should:\n     - Keep accepting the old options for some time.\n     - Log clear deprecation warnings that explain what to change and why.\n     - Provide concrete migration guidance (e.g., use `binary_sensors: motion_detected` instead of `sensors: motion_detector`; use camera services instead of `switches`).\n   - This minimizes breakage and gives users a path to update their config.\n\n4. **Centralized service registration and dispatcher-based routing**\n   - Service registration is best done at the integration `__init__` level rather than inside platform modules, so that all platforms share consistent service handling logic.\n   - The dispatcher (signal bus) is a powerful pattern to decouple service calls from entity instances:\n     - The service layer resolves `entity_id`s and permissions.\n     - It emits signals like `amcrest_<service>_<entity_id>` with any required parameters.\n     - Entities subscribe to their own service signals and handle the actual work.\n   - This separation makes service routing more flexible and easier to reason about and test.\n\n5. **Respect user permissions for service calls**\n   - When an architecture supports user-based permissions, service handlers should:\n     - Identify the calling user from `call.context.user_id`.\n     - Enforce entity-level permission checks (e.g., `POLICY_CONTROL`) and raise clear exceptions (`Unauthorized`, `UnknownUser`) when violated.\n     - Filter out unauthorized entities when `entity_id: all` or multiple entity_ids are involved.\n   - This helps maintain security and multi-user correctness for service invocations.\n\n6. **Consistent internal data structures and naming**\n   - Keep a well-defined structure in `hass.data` for each integration:\n     - For example, `{'devices': {...}, 'cameras': [...]}` distinguishes low-level device APIs from entity identifiers.\n   - Use clear attribute names such as `api` instead of `device` or `camera` for the low-level API object to avoid confusion with entities.\n   - Use dedicated `const.py` and `helpers.py` modules for shared constants and helper functions across platform modules.\n\n7. **Async patterns and executor usage**\n   - Entity methods that perform I/O-bound device calls should be executed using `hass.async_add_executor_job` from async service handlers to avoid blocking the event loop.\n   - Service handlers should be `async def` coroutines and should not directly perform blocking I/O.\n\n8. **State modeling that enforces logical constraints**\n   - When entity states are derived from multiple device properties, state changes should enforce logical consistency. For example:\n     - If `is_on` is defined as \"streaming OR recording\", then:\n       - Disabling streaming should also disable recording if recording was on and streaming is being turned off.\n       - Enabling recording should automatically enable streaming if it was off.\n   - This keeps the model intuitive and avoids inconsistent or confusing UI states.\n\n9. **Small reusable abstractions for cross-module patterns**\n   - The `service_signal(service, entity_id)` helper that encodes a unique dispatcher signal name is reusable across multiple service types and platforms.\n   - Using simple structures like `CAMERA_SERVICES` mapping service names to `(schema, handler_name, arg_names)` makes it straightforward to add new services without repeating boilerplate.\n\nOverall, the change shows how to evolve an integration from a prototype-style design (spread-out service definitions, synthetic switches, direct cross-module coupling) to a more maintainable, consistent, and secure architecture using central service registration, dispatcher routing, permission checks, and clear configuration/deprecation patterns.",
        "procedural_memory": [
            "How to extend a Home Assistant integration with domain-specific services, expose state via attributes, deprecate legacy config structures, and route services to entities safely and cleanly.",
            "Step 1: Define clear service semantics and arguments",
            "  - Identify the device-specific operations that should be controllable (e.g., enable/disable recording, audio, motion recording, PTZ operations, color mode).",
            "  - Choose service names under the integration's own domain (e.g., `amcrest.enable_recording`) instead of hijacking another domain like `camera`.",
            "  - For each service, define the arguments it needs (e.g., `preset`, `color_bw`).",
            "Step 2: Create service schemas and declaration structures",
            "  - Import `CAMERA_SERVICE_SCHEMA` (or an appropriate base schema) and extend it for additional fields:",
            "    - Example for a numeric argument:",
            "      - `vol.Required('preset'): vol.All(vol.Coerce(int), vol.Range(min=1))`",
            "    - Example for a constrained string argument:",
            "      - `vol.Required('color_bw'): vol.In(['auto', 'color', 'bw'])`",
            "  - Build a central mapping (e.g., `CAMERA_SERVICES`) that maps service names to tuples of `(schema, handler_method_name, (arg_keys, ...))`.",
            "Step 3: Refactor `hass.data` to cleanly separate devices and entities",
            "  - Define a top-level integration data structure in `__init__.py` like:",
            "    - `hass.data.setdefault(DATA_AMCREST, {'devices': {}, 'cameras': []})`",
            "  - Create a lightweight device wrapper class (e.g., `AmcrestDevice`) that holds:",
            "    - The low-level API object (e.g., `.api`).",
            "    - Configuration details needed by entities (authentication tokens, ffmpeg args, resolution, stream_source).",
            "  - Populate `devices[name]` during setup after successfully connecting and validating `api.current_time`.",
            "Step 4: Implement entity classes that use the device API",
            "  - For each platform (camera, binary_sensor, sensor, switch):",
            "    - Obtain the device via `device = hass.data[DATA_AMCREST]['devices'][name]`.",
            "    - Store `self._api = device.api` instead of embedding the whole device or using ambiguous names.",
            "    - Keep I/O methods (e.g., `snapshot`, `record_mode`, `audio_enabled`) on the low-level API object and call them from entity methods.",
            "  - For camera entities, add attributes reflecting the new services:",
            "    - Track and expose fields like `audio`, `motion_recording`, and `color_bw` in `device_state_attributes`.",
            "Step 5: Register services in `__init__.py` with permission checks",
            "  - Implement a helper `have_permission(user, entity_id)` that checks `user.permissions.check_entity(entity_id, POLICY_CONTROL)`.",
            "  - Write an `async_extract_from_service(call)` that:",
            "    - Resolves the user from `call.context.user_id` and raises `UnknownUser` if needed.",
            "    - Handles `entity_id: 'all'` by returning all relevant entity_ids that the user is allowed to control.",
            "    - For specific entity_ids, uses `async_extract_entity_ids` and filters unauthorized ones, raising `Unauthorized` if any.",
            "  - Implement `async_service_handler(call)` that:",
            "    - Extracts any service-specific arguments from `call.data` using the keys defined in `CAMERA_SERVICES[call.service][2]`.",
            "    - Gets target entity_ids via `async_extract_from_service(call)`. ",
            "    - For each entity_id, sends a dispatcher signal via `async_dispatcher_send(hass, service_signal(call.service, entity_id), *args)`. ",
            "  - Register each service with Home Assistant:",
            "    - Iterate over `CAMERA_SERVICES.items()` and call `hass.services.async_register(DOMAIN, service_name, async_service_handler, schema)`.",
            "Step 6: Wire entities to services via dispatcher",
            "  - In the entity class (e.g., `AmcrestCam`), implement `async_added_to_hass` to:",
            "    - For each service in `CAMERA_SERVICES`, subscribe with:",
            "      - `async_dispatcher_connect(self.hass, service_signal(service_name, self.entity_id), getattr(self, handler_method_name))`.",
            "    - Store the unsub functions in a list (e.g., `_unsub_dispatcher`) and add the `entity_id` to `hass.data[DATA_AMCREST]['cameras']`.",
            "  - Implement `async_will_remove_from_hass` to:",
            "    - Remove the `entity_id` from `hass.data[DATA_AMCREST]['cameras']`.",
            "    - Call each unsub function to disconnect from signals.",
            "  - Define async service handler methods on the entity that match the names in `CAMERA_SERVICES` (e.g., `async_enable_recording`, `async_goto_preset`).",
            "    - These should use `await self.hass.async_add_executor_job(self._low_level_method, args...)` to perform device I/O.",
            "Step 7: Implement low-level device control methods and keep state consistent",
            "  - On the entity (camera), provide private synchronous methods that talk to the API and update local state/attributes:",
            "    - `_enable_video_stream(enable)`",
            "    - `_enable_recording(enable)` (ensures streaming is on when enabling recording).",
            "    - `_enable_motion_detection(enable)`.",
            "    - `_enable_audio(enable)`.",
            "    - `_enable_motion_recording(enable)`.",
            "    - `_goto_preset(preset)`.",
            "    - `_set_color_bw(color_bw)`.",
            "    - `_start_tour(start)`.",
            "  - Wrap all device I/O in try/except around `AmcrestError`, and log errors with context but do not crash the entity.",
            "  - After a successful operation, update internal state fields (e.g., `_is_recording`, `_audio_enabled`, `_color_bw`) and call `self.schedule_update_ha_state()`.",
            "Step 8: Deprecate old configuration options safely",
            "  - In the config schema, keep accepting old keys like `CONF_SENSORS` and `CONF_SWITCHES`, but wrap their validators with deprecation functions:",
            "    - `_deprecated_sensor_values` that logs a warning if `motion_detector` is used, directing users to `binary_sensors: motion_detected`.",
            "    - `_deprecated_switches` that logs a warning if `switches` is defined, pointing to camera services and attributes instead.",
            "  - Use `vol.All` to compose schema validation and deprecation wrappers.",
            "  - Ensure that the config schema enforces valid values via `vol.In` and `cv.ensure_list`.",
            "Step 9: Normalize constants and shared structures",
            "  - Move shared constants (domain string, timeouts, scan intervals) to `const.py`.",
            "  - Maintain scan intervals in constants (e.g., `BINARY_SENSOR_SCAN_INTERVAL_SECS`, `SENSOR_SCAN_INTERVAL_SECS`, `CAMERA_WEB_SESSION_TIMEOUT`) and reference them in each platform.",
            "  - Keep structured lists and maps (e.g., `STREAM_SOURCE_LIST`, sensor and switch definitions) in the appropriate platform module or a shared module if used widely.",
            "Step 10: Test and iterate based on review",
            "  - Verify that service calls work for single and multiple entities, including `entity_id: 'all'`.",
            "  - Confirm that permission checks block unauthorized users and allow authorized ones, and that errors are logged or raised appropriately.",
            "  - Ensure deprecated config produces clear warnings but still functions until fully removed in a future breaking change.",
            "  - Validate that new attributes appear on the camera entities and that they update correctly when services are invoked.",
            "  - Confirm that binary sensors, sensors, and switches still function correctly with the refactored `hass.data` structure and constants."
        ]
    }
}
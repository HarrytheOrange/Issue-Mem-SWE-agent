{
    "search_index": {
        "description_for_embedding": "Home Assistant automation event helpers (state change, time point, and time pattern triggers) were converted to asyncio coroutines. A new hass.async_add_job helper was added so event-loop callbacks can schedule follow-up work without blocking the loop and while correctly handling coroutine vs regular callables. Automation event triggers now use async_add_job instead of calling actions synchronously, improving performance and aligning with the asyncio-based core.",
        "keywords": [
            "Home Assistant",
            "asyncio",
            "automation",
            "event trigger",
            "helpers.event",
            "track_state_change",
            "time pattern trigger",
            "time point trigger",
            "coroutine",
            "async_add_job",
            "add_job",
            "event loop",
            "non-blocking",
            "performance"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the project had already moved its core to asyncio, but several popular automation helpers were still using synchronous patterns that could block the event loop or interacted poorly with the new async architecture. The relevant pieces were the automation event trigger component and the helper functions in homeassistant/helpers/event.py: track_state_change, track_point_in_utc_time, and time pattern-based triggers.\n\nPreviously, these listeners would execute user actions directly or via hass.add_job without being declared as coroutines, and hass.add_job itself was designed primarily for posting work to a thread pool from outside the event loop. This mismatch could lead to inefficiencies and unnecessary context switching, and it made it harder to properly schedule coroutine-based actions.\n\nThe fix consisted of several coordinated changes:\n- The automation event trigger handle_event was turned into a coroutine (@asyncio.coroutine), and instead of calling the action directly, it now schedules it with hass.async_add_job, passing along the trigger context (platform 'event' and the event object).\n- The helpers track_state_change, track_point_in_utc_time, and the time pattern listener functions were also decorated as coroutines. Instead of invoking actions directly, they now schedule them via hass.async_add_job (for actions that may be coroutine functions) or hass.add_job as appropriate. For example, track_state_change now calls hass.async_add_job(action, entity_id, old_state, new_state) when the state transition matches the criteria.\n- A new core API, hass.async_add_job, was introduced. From within the event loop, this helper checks whether the target is a coroutine function. If it is, it uses loop.create_task(target(*args)) to schedule it on the main loop; if it is a regular callable, it delegates to hass.add_job to run it via the existing job pool. This reconciles async and sync code scheduling in a single, consistent entry point.\n- The point-in-time trigger logic was adjusted so that when the time condition is met, it sets a run flag and then schedules a single fire_action function via hass.add_job. fire_action removes the listener and then calls the action(now). This groups cleanup and action execution together in one scheduled job, avoiding duplicated scheduling and making the call site clearer.\n\nAfter these modifications, automation event-based and time-based helpers align with the asyncio-driven core, schedule actions in a non-blocking way, and correctly handle both coroutine and regular actions via the new async_add_job helper.",
        "semantic_memory": "When a codebase migrates to asyncio, synchronous event listeners and callbacks that directly invoke user actions can become performance bottlenecks or interact incorrectly with the event loop. A best practice is to:\n- Express event listeners as coroutines when they are running on the asyncio event loop.\n- Avoid running potentially slow or blocking user actions directly inside event loop callbacks.\n- Provide a unified scheduling helper that understands both coroutine functions and regular callables and dispatches them appropriately.\n\nIn this case, the new hass.async_add_job function encapsulates that pattern: it inspects the target; if it's a coroutine function, it uses loop.create_task to schedule it on the main loop; otherwise, it delegates to an existing thread-pool-based add_job. This pattern can be generalized to any async system that must support both async/await-style handlers and legacy synchronous handlers.\n\nAnother important pattern is keeping event listeners small and fast. The listeners in state-change and time-based triggers simply:\n- Check whether the incoming event satisfies trigger criteria.\n- If so, schedule the actual work (user action) via async_add_job instead of executing it inline.\n\nThis decouples event dispatching from work execution, keeps the event loop responsive, and avoids subtle races or deadlocks when mixing sync and async code. Additionally, when performing cleanup (like removing listeners) combined with executing actions, grouping them into a single scheduled function can simplify lifecycle management and avoid ordering issues.",
        "procedural_memory": [
            "When migrating event-driven code to asyncio or fixing performance issues due to blocking callbacks, follow these steps:",
            "Step 1: Identify synchronous listeners or callbacks that run on the asyncio event loop and directly call user-provided actions or heavy logic. Common places include event bus subscribers, state change listeners, and time-based triggers.",
            "Step 2: Convert these listeners into coroutines if they run in the event loop context. In Python 3.4 style, use @asyncio.coroutine; in modern code, use 'async def'. Ensure they remain lightweight (filtering, simple state checks) and avoid performing heavy work directly.",
            "Step 3: Introduce or use a central scheduling helper for follow-up work (like hass.async_add_job). This helper should:\n- Detect whether the target is a coroutine function and schedule it with loop.create_task.\n- Otherwise, offload it to a thread pool or appropriate executor using an existing add_job-like mechanism.",
            "Step 4: Update all listener code paths to call this scheduling helper instead of invoking actions directly. For example, replace 'action(...)' with 'async_add_job(action, ...)' once trigger conditions are met.",
            "Step 5: For time-based or one-shot triggers with cleanup logic, encapsulate cleanup and action in a single scheduled function. Example: define fire_action() that removes the listener then calls the action, and schedule fire_action via the job scheduler, instead of scheduling remove and action separately.",
            "Step 6: Ensure that any code that is called from outside the event loop continues to use the non-async add_job (or equivalent) so that it runs in the appropriate thread/executor, while code inside the event loop uses async_add_job.",
            "Step 7: Add or update tests to verify that triggers still fire under the right conditions and that actions can be coroutine functions or regular callables. Specifically test that listeners do not block the event loop (e.g., by measuring responsiveness or using mock coroutines).",
            "Step 8: Run the full test suite (e.g., tox) and, if possible, perform performance measurements or profiling to confirm that event handling and automations now run more efficiently under asyncio."
        ]
    }
}
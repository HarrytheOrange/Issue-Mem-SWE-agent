{
    "search_index": {
        "description_for_embedding": "Implemented a new Home Assistant notification integration for Signal Messenger using the external signal-cli REST API, encapsulated behind a dedicated PyPI library (pysignalclirestapi). The integration is named signal_messenger, validates required configuration (sender number, recipients, REST API URL), supports optional file attachments, and follows Home Assistant conventions for manifests, requirements, code ownership, and coverage configuration.",
        "keywords": [
            "signal_messenger",
            "signalmessenger",
            "Signal Messenger integration",
            "Home Assistant notify",
            "notification platform",
            "signal-cli",
            "Signal CLI REST API",
            "pysignalclirestapi",
            "BaseNotificationService",
            "PLATFORM_SCHEMA",
            "voluptuous",
            "manifest.json requirements",
            "requirements_all.txt",
            "CODEOWNERS",
            "coveragerc",
            "integration naming convention",
            "dependency via PyPI wrapper",
            "external docker service"
        ]
    },
    "agent_memory": {
        "episodic_memory": "A contributor wanted Home Assistant to support Signal Messenger notifications. Signal itself has no official REST API, but an existing command line tool (signal-cli) and a community REST wrapper (signal-cli-rest-api) existed, often run in Docker. The contributor initially wrote a Home Assistant notify platform that talked directly to the REST API via requests and base64-encoded attachments, with configuration for sender number, recipients, and REST API URL. There were questions about whether depending on a Docker container was acceptable, and reviewers suggested that a separate PyPI package should encapsulate service-specific logic. The contributor created the pysignalclirestapi library to wrap the REST API communication and refactored the Home Assistant integration to call this library instead of using raw HTTP. \n\nOver several iterations, the code was aligned with Home Assistant standards: the manifest was updated to include the documentation URL, a codeowner, and the pysignalclirestapi==0.1.4 requirement. The REQUIREMENTS constant in the module was removed in favor of manifest-managed requirements. requirements_all.txt was updated with the new dependency. The configuration schema was tightened by using vol.Required for the sender number, REST URL, and recipients instead of vol.Optional, and get_service now uses direct dict access (config[...]) once validation guarantees presence. The notify service class now receives a pre-initialized SignalCliRestApi client and catches the library-specific SignalCliRestApiError instead of generic exceptions. Logging was adjusted from info to debug for routine send operations. \n\nNaming and project structure were also corrected: the integration directory was renamed from signalmessenger to signal_messenger per Home Assistant naming conventions (domains use snake_case), and the manifest domain/name fields, documentation URL, CODEOWNERS entry, requirements_all comment, and .coveragerc omit paths were all updated to match the new signal_messenger domain. The final integration provides a notify service that sends Signal messages (optionally with attachments) via signal-cli-rest-api, configured through configuration.yaml with a sender number, one or more recipient numbers, and the REST API URL.",
        "semantic_memory": "This PR demonstrates several reusable patterns for adding an external-service-based notification integration to Home Assistant (or similar platforms):\n\n1. **Encapsulate service-specific logic in a dedicated library**: Instead of embedding all REST/API details directly in the Home Assistant component, the author created a PyPI library (pysignalclirestapi) that handles communication with the signal-cli REST API, including error types (SignalCliRestApiError) and message sending semantics. The Home Assistant integration becomes a thin adapter, which makes testing, reuse, and maintenance easier, and keeps platform code focused on platform concerns (config, lifecycle, logging).\n\n2. **Use the platform’s configuration validation and manifest mechanisms correctly**: Required configuration fields should be expressed with vol.Required in PLATFORM_SCHEMA. Once validated, code can safely index into config rather than using dict.get and manual error checks. Runtime errors due to missing config are reduced, and error messages are standardized. Similarly, Python dependencies should be declared in the integration’s manifest.json and in requirements_all.txt, not via a module-level REQUIREMENTS constant, aligning with Home Assistant’s dependency management patterns.\n\n3. **Follow naming conventions and keep domain consistency**: Home Assistant integration domains and directories use snake_case (signal_messenger rather than signalmessenger or signal). Names should reflect the brand while avoiding overly generic single words (signal would be ambiguous). Changing the domain requires synchronized changes to the directory name, manifest (domain, name, documentation URL), CODEOWNERS, requirements_all comments, and coverage configuration.\n\n4. **Catch library-specific exceptions and log appropriately**: Instead of catching generic Exception, the integration catches the specific SignalCliRestApiError thrown by the library. This makes error handling more precise and avoids masking unrelated failures. Logging routine operations at debug level (rather than info) avoids log noise in normal operation while still providing traceability when debugging.\n\n5. **Treat external Dockerized services as network dependencies**: When the underlying functionality lives in a Docker container (signal-cli-rest-api), the integration can treat it as a remote HTTP service. This avoids requiring Docker support in the host platform itself. It also allows running the service on a different host and keeps the Home Assistant container clean. If necessary, a Hass.io add-on can later provide a one-click Docker-backed deployment while the core integration remains generic.\n\nOverall, the pattern is: wrap external tools in a dedicated API library, define a thin, well-validated integration that talks to that library, comply with platform conventions (naming, manifests, ownership, coverage), and use targeted error handling and logging.",
        "procedural_memory": [
            "When adding or refactoring a Home Assistant integration that talks to an external service or tool (e.g., a CLI with a REST wrapper), follow these steps:",
            "Step 1: Decide on integration scope and naming.",
            "  - Choose a domain name that follows platform conventions (snake_case, brand-specific where possible), e.g., `signal_messenger` rather than a generic `signal`.",
            "  - Create the component directory under `homeassistant/components/<domain>/` and add minimal `__init__.py` and platform files (e.g., `notify.py`).",
            "Step 2: Encapsulate external API communication in a separate library.",
            "  - If the external service (e.g., signal-cli-rest-api) has non-trivial semantics, create or use a dedicated PyPI library to handle HTTP calls, error mapping, and data encoding/decoding.",
            "  - Implement clear methods in the library (e.g., `send_message(message, recipients, filename=None)`) and define specific exception types (e.g., `SignalCliRestApiError`) instead of using generic Exception.",
            "  - Publish or reference the library on PyPI so it can be declared as a runtime requirement for the integration.",
            "Step 3: Declare integration metadata and dependencies.",
            "  - In `manifest.json` for the integration, set `domain`, `name`, `documentation`, `dependencies`, `codeowners`, and `requirements` correctly. For example:\n    {\n      \"domain\": \"signal_messenger\",\n      \"name\": \"signal_messenger\",\n      \"documentation\": \"https://www.home-assistant.io/integrations/signal_messenger\",\n      \"dependencies\": [],\n      \"codeowners\": [\"@yourusername\"],\n      \"requirements\": [\"pysignalclirestapi==0.1.4\"]\n    }",
            "  - Add the same requirement with a comment to `requirements_all.txt` in the correct alphabetical location, e.g.:\n    # homeassistant.components.signal_messenger\n    pysignalclirestapi==0.1.4",
            "Step 4: Define a strict configuration schema.",
            "  - Use `PLATFORM_SCHEMA` with `vol.Required` for fields that must be present, and typed validators like `cv.string` or `vol.All(cv.ensure_list, [cv.string])` for lists. For example:\n    PLATFORM_SCHEMA = PLATFORM_SCHEMA.extend({\n        vol.Required(CONF_SENDER_NR): cv.string,\n        vol.Required(CONF_SIGNAL_CLI_REST_API): cv.string,\n        vol.Required(CONF_RECP_NR): vol.All(cv.ensure_list, [cv.string]),\n    })",
            "  - After this, in `get_service`, access configuration values via direct indexing (e.g., `config[CONF_SENDER_NR]`) instead of `config.get`, since validation guarantees their presence.",
            "Step 5: Build the service class as a thin adapter.",
            "  - In `get_service`, construct and validate your client once: `SignalCliRestApi(url, sender_nr, api_version=1)`.",
            "  - Pass the client and any static configuration (e.g., recipient list) into your notification service class: `SignalNotificationService(recp_nrs, signal_cli_rest_api)`.",
            "  - In the service class (`BaseNotificationService` implementation), implement `send_message` to:\n    - Extract optional data (e.g., `ATTR_DATA` and `attachment` filename) from kwargs.\n    - Call the library method (e.g., `self._signal_cli_rest_api.send_message(message, self._recp_nrs, filename)`) rather than performing HTTP logic directly.\n    - Log at debug level for routine operations and catch only the library’s specific exception types.",
            "Step 6: Handle errors in a targeted way.",
            "  - Catch and log specific exceptions from the library, e.g.:\n    try:\n        self._signal_cli_rest_api.send_message(...)\n    except SignalCliRestApiError as ex:\n        _LOGGER.error(\"%s\", ex)\n        raise\n  - Avoid catching bare `Exception`, which can hide programming errors and make debugging harder.",
            "Step 7: Align supporting files with the new domain.",
            "  - Add a matching entry to `CODEOWNERS` for ownership, e.g.: `homeassistant/components/signal_messenger/* @yourusername`.",
            "  - Update `.coveragerc` to omit new files from coverage if they are not yet tested, using the correct paths: `homeassistant/components/signal_messenger/__init__.py` and `notify.py`.",
            "  - Ensure comments or references in other project files (like `requirements_all.txt`) use the new domain name consistently.",
            "Step 8: Verify style and import ordering.",
            "  - Run the project’s formatting and linting tools (e.g., isort, black, flake8, pylint, or equivalent) to ensure imports are ordered correctly (standard library, third-party, then local) and code meets style guidelines.",
            "  - Remove unused constants like `REQUIREMENTS` when they are superseded by manifest-based dependency management.",
            "Step 9: Test and iterate based on review.",
            "  - Test the integration locally via Home Assistant with different configuration scenarios and optional attachment behavior.",
            "  - Run the full test suite (e.g., `tox`) and fix any issues.",
            "  - Address code review feedback regarding naming, exception handling, logging verbosity, and schema strictness.",
            "Step 10: For similar future integrations.",
            "  - When integrating any external service (especially one running in Docker), treat it as a network dependency: communicate via HTTP/REST from the integration, encapsulated behind a dedicated library.",
            "  - Use the same patterns: separate library for service logic, manifest-managed requirements, strict voluptuous schemas, snake_case domains, and precise exception handling."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant: add Dyson 360 Eye robot vacuum support via the new vacuum platform. Update the shared Dyson hub to use libpurecoollink 0.4.2, switch to the new connect/auto_connect APIs, and handle OSError on connection. Ensure fan and sensor platforms only create entities for DysonPureCoolLink devices, and the new vacuum platform only for Dyson360Eye devices. Remove the vacuum component’s early return when no `vacuum:` config is present so discovery/programmatic setup works. Add comprehensive unit tests and fix Python 3.5 mock assertion compatibility.",
        "keywords": [
            "homeassistant",
            "Dyson 360 Eye",
            "vacuum platform",
            "dyson component",
            "libpurecoollink 0.4.2",
            "auto_connect",
            "OSError handling",
            "device discovery",
            "isinstance filtering",
            "async_added_to_hass",
            "unittest mock Python 3.5",
            "config[DOMAIN] guard removal",
            "programmatic setup"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR introduced support for the Dyson 360 Eye robot vacuum in Home Assistant using the newly added `vacuum` platform while reusing the existing Dyson hub configuration.\n\nThe author had a practical problem: the vacuum component’s `async_setup` previously contained a guard:\n\n    if not config[DOMAIN]:\n        return False\n\nThis meant that if a user did not explicitly define a `vacuum:` section in `configuration.yaml`, the vacuum component would not initialize. However, the Dyson 360 Eye platform is loaded programmatically from the shared `dyson` hub via `discovery.load_platform`, without a `vacuum:` block in the config. As a result, Dyson 360 Eye entities could not be created even though the hub and devices were configured correctly.\n\nTo fix this, the PR removed that early-return check from `homeassistant/components/vacuum/__init__.py`, allowing the vacuum component to set up even when there is no explicit `vacuum:` section. This enables platforms that are purely discovery-driven (like Dyson) to function.\n\nAt the same time, the Dyson integration was updated:\n- The libpurecoollink dependency was bumped from 0.4.1 to 0.4.2 to gain Dyson 360 Eye support and new connection APIs.\n- The hub component (`homeassistant/components/dyson.py`) was updated to use `device.connect(device_ip)` and `device.auto_connect(timeout, retry)` instead of the old call signature. Connection attempts are wrapped in a `try/except OSError` block to avoid crashing Home Assistant if a device raises (e.g., network issues). Successfully connected devices are stored in `hass.data[DYSON_DEVICES]`.\n- The fan and sensor Dyson platforms were modified to only act on `DysonPureCoolLink` instances via `isinstance(d, DysonPureCoolLink)`, ensuring that non-fan devices (like Dyson 360 Eye vacuums) are not incorrectly treated as fans or sensors.\n- A new vacuum platform (`homeassistant/components/vacuum/dyson.py`) was introduced, which filters `hass.data[DYSON_DEVICES]` for `Dyson360Eye` instances and wraps them with a `Dyson360EyeDevice` entity that extends `VacuumDevice`.\n\n`Dyson360EyeDevice`:\n- Hooks into Home Assistant via `async_added_to_hass`, registering a message listener on the underlying libpurecoollink device and updating state on incoming messages (push model, `should_poll = False`).\n- Maps low-level libpurecoollink states (`Dyson360EyeMode`, `PowerMode`) into human-friendly status strings (“Cleaning”, “Paused”, “Stopped - Charging”, etc.) and fan speeds (“Quiet”, “Max”).\n- Exposes battery level and position attributes, along with proper battery icons via `icon_for_battery_level`, handling charging vs non-charging states.\n- Implements the expected vacuum features: `turn_on`, `turn_off`, `stop`, `set_fan_speed`, `start_pause`, and `return_to_base`, delegating to underlying device methods (`start`, `pause`, `resume`, `abort`, `set_power_mode`) based on current state.\n\nExtensive tests were added and/or adapted:\n- Dyson hub tests now consider the new `auto_connect` method and verify that discovery loads three platforms (sensor, fan, vacuum) instead of two.\n- A new `tests/components/vacuum/test_dyson.py` file tests setup without devices, setup with both vacuum and non-vacuum devices, state mapping, command methods, and message handling. It uses `spec=Dyson360Eye` (or `MagicMock` where needed) to keep mocks realistic.\n- Tests were adjusted for Python 3.5 compatibility by replacing `mock.assert_called()` with `self.assertTrue(mock.called)` where necessary.\n- Minor code review tweaks were incorporated: constructor signature simplified (no `hass` parameter on `Dyson360EyeDevice`), import order adjustments, `dict.get` used for safer state mapping, and passing `{}` instead of `None` as config to `setup_platform` in tests.\n\nThis PR enabled Dyson 360 Eye robot vacuums to work using the new vacuum platform while improving robustness and ensuring the integration behaves correctly with a mixed set of Dyson devices.",
        "semantic_memory": "Generalizable insights and best practices from this change:\n\n1. **Discovery-based platform setup should not depend on explicit config blocks**\nIf a component (like `vacuum`) can be used purely via discovery or programmatic platform loading (e.g., `discovery.load_platform` from another hub component), its `setup`/`async_setup` functions should not early-return simply because there is no user-defined configuration section. A guard such as `if not config[DOMAIN]: return False` can silently prevent valid discovery-driven integrations from working. Instead, initialize the component’s `EntityComponent` regardless of config presence, and let platforms register entities when appropriate.\n\n2. **Use a shared hub component and type-based routing of devices**\nWhen a vendor API supports multiple product types (fans, vacuums, sensors) through a shared hub, it’s cleaner to:\n- Have a single hub component responsible for authentication and device discovery.\n- Store the raw device objects in `hass.data[HUB_KEY]`.\n- Let each platform (fan, sensor, vacuum) filter those devices by type using `isinstance` checks, so that each platform only wraps relevant devices. This avoids misclassifying devices and reduces duplication of discovery logic.\n\n3. **Adapt quickly to upstream library API changes and handle connection errors robustly**\nThird-party libraries like `libpurecoollink` may change method signatures (e.g., from `connect(None, ip, timeout, retry)` to `connect(ip)` and `auto_connect(timeout, retry)`). To maintain stability:\n- Update integration code to use the new APIs correctly.\n- Wrap I/O-heavy operations (network connections, logins) in `try/except` blocks (e.g., `except OSError`) and log meaningful errors instead of letting exceptions propagate and break the component setup.\n- Ensure that devices which fail to connect are not added to `hass.data` so that subsequent platforms don’t attempt to use invalid connections.\n\n4. **Push vs poll: let devices drive state updates when possible**\nFor integrations that provide event/callback mechanisms (like Dyson’s `add_message_listener`), prefer a push model:\n- Set `should_poll = False` on entities.\n- Register a message listener in `async_added_to_hass` and call `schedule_update_ha_state()` when messages arrive.\nThis minimizes network traffic, improves responsiveness, and aligns with Home Assistant’s async/event-driven architecture.\n\n5. **Map low-level device enums to human-readable Home Assistant state**\nDevice libraries often expose states via enums or codes (e.g., `Dyson360EyeMode.FULL_CLEAN_RUNNING`). Home Assistant entities should translate these into readable, localized status strings like “Cleaning” or “Paused”. Use a dictionary mapping and `dict.get(state, state)` to gracefully handle unknown or new states.\n\n6. **Write tests that are realistic and stable across Python versions**\n- Use `mock.Mock(spec=SomeClass)` or `mock.MagicMock(spec=SomeClass)` to ensure mocks behave like the underlying objects and to catch typos in method or attribute names.\n- For older Python versions (like 3.5) where some `unittest.mock` helpers are less robust, favor assertions like `self.assertTrue(mock.called)` over `mock.assert_called()` if needed.\n- When testing setup functions, pass realistic config objects (e.g., `{}` instead of `None`) to match what Home Assistant core actually uses.\n\n7. **Keep platform responsibilities narrow and explicit**\nEach platform (fan, sensor, vacuum) should implement only the capabilities that make sense for that device type and advertise them via `supported_features`. Centralized constants (e.g., `SUPPORT_TURN_ON`, `SUPPORT_RETURN_HOME`) make it clear which operations are expected and supported by an entity.\n\nThese patterns can be applied anytime you are integrating a new device type into a home automation framework or any plugin system that combines hub-style discovery with per-capability platforms.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of discovery-based platforms not initializing\n- Observe that a new platform (e.g., vacuum, climate, etc.) never creates entities, even though the shared hub or parent component appears to be working and devices are configured correctly.\n- Check logs for the parent component (e.g., `dyson`) to confirm that devices are discovered and connected, but no corresponding platform entities appear.",
            "Step 2: Inspect the component’s setup logic\n- Open the main component module (e.g., `components/vacuum/__init__.py`).\n- Look for early-return conditions based on configuration, such as `if not config[DOMAIN]: return False`.\n- Consider whether your use case relies on programmatic or discovery-based platform loading instead of a user-defined config section. If yes, this guard may be preventing proper initialization.",
            "Step 3: Adjust setup to support discovery-only usage\n- Remove or relax the guard that demands an explicit configuration block when this would block discovery-based setups.\n- Ensure that the component always initializes its `EntityComponent` (or equivalent) so that platforms loaded via `discovery.load_platform` or similar mechanisms can successfully register entities.",
            "Step 4: Structure hub and platform responsibilities\n- Implement or verify a hub component that:\n  - Authenticates with the vendor/backend.\n  - Discovers all available devices.\n  - Stores the raw device instances in a shared data structure (e.g., `hass.data[HUB_KEY]`).\n- In each platform (fan, sensor, vacuum, etc.):\n  - Filter `hass.data[HUB_KEY]` by device type using `isinstance(device, DesiredClass)`.\n  - Wrap only devices of the expected type into entities.\nThis avoids misclassification (e.g., a vacuum being treated as a fan).",
            "Step 5: Update to new upstream library APIs and handle errors\n- Check the third-party library’s release notes or code for API changes (e.g., new connection method signatures or new device classes).\n- Update calls accordingly, such as:\n  - Replace `device.connect(None, ip, timeout, retry)` with the new `device.connect(ip)` (or similar) and `device.auto_connect(timeout, retry)`.\n- Wrap connection calls in a `try/except OSError` (or appropriate exceptions):\n  - On success: log and add the device to `hass.data`.\n  - On failure or exception: log an error with details, and do not append the device to `hass.data`.",
            "Step 6: Implement push-based state updates when supported\n- If the device library supports callbacks/event listeners (e.g., `add_message_listener`):\n  - In your entity’s `async_added_to_hass`, register the listener.\n  - In the callback, log the message (if useful) and call `self.schedule_update_ha_state()`.\n  - Set `should_poll = False` in the entity to indicate push-based updates.\nThis ensures timely state updates without periodic polling.",
            "Step 7: Map device states to user-friendly Home Assistant metadata\n- Identify the relevant enums or state constants (e.g., `Dyson360EyeMode`, `PowerMode`).\n- Create dictionaries that map these internal values to human-readable strings and enumerated options, for example:\n  - Vacuum status: `mode_enum -> \"Cleaning\" / \"Paused\" / ...`.\n  - Fan speed: `PowerMode.MAX -> \"Max\"`, `PowerMode.QUIET -> \"Quiet\"`.\n- Use `dict.get(key, key)` to safely handle unknown states without crashing.\n- Implement `supported_features` using the domain’s feature flags (e.g., `SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_RETURN_HOME`).",
            "Step 8: Add and adapt tests for robustness and compatibility\n- For the hub:\n  - Mock the vendor account and devices to simulate successful connections, failed connections, and exceptions (e.g., `OSError`).\n  - Assert that only successfully connected devices are stored in `hass.data` and that the correct platforms are loaded via discovery.\n- For each platform/entity:\n  - Use `mock.Mock(spec=DeviceClass)` or `mock.MagicMock(spec=DeviceClass)` to ensure your mocks mirror real device attributes and methods.\n  - Test:\n    - Setup with and without devices.\n    - State mappings (status, speed, battery, attributes).\n    - Action methods (`turn_on`, `turn_off`, `stop`, `return_to_base`, etc.) calling the right underlying methods.\n    - Message listener behavior (that it triggers `schedule_update_ha_state`).\n- For Python 3.5 or other older environments:\n  - Prefer assertions like `self.assertTrue(mock.called)` over `mock.assert_called()` when necessary for compatibility.",
            "Step 9: Verify end-to-end behavior\n- Configure only the hub/parent integration (e.g., just the `dyson:` block, no `vacuum:` block).\n- Start Home Assistant and confirm that:\n  - The hub logs indicate discovered and connected devices.\n  - Fan, sensor, and vacuum entities are created appropriately, each bound to the correct device type.\n  - Commands from the UI or services invoke the expected device methods without errors.\n- Monitor logs for any unhandled exceptions or warnings and refine error handling or state mapping as needed."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Implementation of a new NILU-based air quality platform for Home Assistant, refactored from a sensor platform to the standardized air_quality component. It integrates the niluclient library, supports configuration by area or station, validates inputs, throttles API calls, returns numeric pollutant values (without unit formatting), and handles missing station data gracefully.",
        "keywords": [
            "Home Assistant",
            "air_quality",
            "NILU",
            "niluclient",
            "air pollutants",
            "integration",
            "platform schema",
            "voluptuous validation",
            "Throttle",
            "SCAN_INTERVAL",
            "configuration.yaml",
            "Norway air quality",
            "stations",
            "area lookup",
            "coverage omit",
            "requirements_all.txt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request adds a new Home Assistant air_quality platform for NILU, the Norwegian air research institute, exposing air pollution data from official stations across Norway. Initially, the implementation was created under an `air_pollutants` component, then refactored and moved to the standardized `air_quality` component after upstream API changes. The platform uses the external `niluclient==0.1.2` library to query NILU's APIs. Configuration supports three modes: a specific NILU area (from a curated allow-list of area names), explicit station names, or automatic station discovery via latitude/longitude (falling back to the instance’s coordinates if none are configured). The code defines a `NiluData` wrapper that handles data fetching with a 30-minute `SCAN_INTERVAL` using Home Assistant’s `Throttle` to avoid excessive API calls. \n\nThe `NiluSensor` entity extends `AirQualityEntity` and exposes a wide set of pollutants as properties: CO, CO2, NOX, NO, NO2, O3, PM2.5, PM10, PM1, and SO2. An initial iteration formatted these values as strings combining numeric value and unit (e.g., '10.00 µg/m³'), but this was later changed to return raw numeric values so the unit handling is managed by the integration or UI layer consistently. A helper method `get_component_state` centralizes lookup of each pollutant’s sensor in the NILU data and the value extraction.\n\nThe entity tracks the maximum pollution index across all pollutants (NILU’s own classification) as the `air_quality_index`, and also exposes a `nilu_pollution_index` attribute mapped to a textual descriptor via `nilu.POLLUTION_INDEX`. Additional attributes like `area`, and optionally latitude/longitude (when `show_on_map` is true), are added to support mapping and context. The `state` property override was removed to align with the base `AirQualityEntity` behavior, and the textual index is now provided as an attribute instead.\n\nThe platform schema uses `voluptuous` to enforce that either `area` or `stations` is configured (but not both), that areas are one of a fixed list of valid NILU areas, and that station lists contain strings. It also enforces latitude/longitude pairing via `vol.Inclusive` and `vol.Exclusive`. During setup, the code now checks for stations that return no sensors and logs a warning instead of adding an empty entity. The component is excluded from coverage in `.coveragerc`, and its dependency is documented in `requirements_all.txt` with an appropriate comment referencing `homeassistant.components.air_quality.nilu`. Docstrings and URLs were updated to point to the correct `air_quality.nilu` documentation. Overall, the PR turns an earlier sensor-based NILU integration into a consistent air_quality platform with better validation, cleaner API usage, and safer entity creation behavior.",
        "semantic_memory": "This change illustrates several general best practices for integrating third-party environmental data services as Home Assistant platforms (or more broadly, as data integrations in any modular system):\n\n1. **Align with core domain models and base classes**: Instead of hacking on a generic sensor, the integration now uses Home Assistant’s dedicated `AirQualityEntity` abstraction. This ensures consistent semantics (standard properties for pollutants and AQI), better UI integration, and reuse of core logic. More generally, whenever a framework provides domain-specific base classes (e.g., for climate, lights, air quality), new integrations should extend these instead of generic entity types.\n\n2. **Use common configuration schemas and validation**: The platform leverages the shared `PLATFORM_SCHEMA` and extends it with custom options, enforcing mutual exclusivity (`vol.Exclusive`) and coupled fields (`vol.Inclusive`) via `voluptuous`. It also validates area names against a known set and coerces station lists to a list of strings. The pattern of strong schema validation catches misconfigurations early and produces clearer error messages, which is especially important for user-facing YAML configuration.\n\n3. **Throttling and SCAN_INTERVAL for external APIs**: The integration wraps the underlying API client in a `NiluData` class whose `update` method is decorated with `Throttle` using a module-level `SCAN_INTERVAL`. This pattern avoids hammering external APIs, reduces rate-limit risk, and minimizes unnecessary network traffic while maintaining reasonably fresh data. The same approach is widely useful for any integration that polls a remote HTTP or cloud API.\n\n4. **Lazy imports of optional dependencies**: `niluclient` is imported inside `setup_platform` and, when needed, inside properties, instead of at module import time. This aligns with Home Assistant’s requirement that optional or heavy dependencies be imported lazily to keep startup fast and to avoid ImportError crashes when the dependency isn’t needed for a particular configuration. This pattern generalizes to any plugin-driven system where not all integrations are used at once.\n\n5. **Graceful handling of missing or empty data**: Before creating entities, the integration checks whether `client.data.sensors` is non-empty. If NILU returns no sensors for a configured station, a warning is logged and no entity is created. This avoids entities that would remain in an unusable `unknown` state, and provides actionable feedback for the user (even though the message was simplified in the final revision). The generic lesson is to validate remote data before instantiating persistent objects, and surface clearly when a configuration may be referring to non-existent resources.\n\n6. **Separation of numeric values from units**: The initial implementation returned human-readable strings combining numeric values and units for pollutant properties. This was refactored so that properties now return numeric values only, leaving unit handling to the base entity or the UI. This is a common integration best practice: keep the data layer numeric and machine-parseable, and centralize unit representation to avoid inconsistencies and ease localization and unit conversion.\n\n7. **Attribute-based enrichment of entities**: Rather than overloading the main entity `state` with multiple meanings, additional contextual information (area name, coordinates, textual pollution index) is provided via `device_state_attributes`. This preserves a clear primary state while still making rich metadata available to automations and dashboards. The same pattern applies anywhere a primary scalar state must be augmented with secondary data.\n\n8. **Consistent refactoring when moving between components**: When the platform was moved from `air_pollutants` to `air_quality`, the PR updated imports, class inheritance, documentation URLs, requirements comments, and coverage configuration. The holistic approach (rather than a partial move) helps avoid dead references and broken docs. Generally, structural refactors should address not just code paths but also documentation, tests, dependency metadata, and tooling configuration.\n\nOverall, the PR demonstrates how to implement a robust, framework-aligned integration of a third-party environmental API: clear configuration options, strong validation, proper rate-limiting, cautious entity creation, and adherence to core domain abstractions.",
        "procedural_memory": [
            "When adding or refactoring an external data integration (e.g., a new air quality provider) into a framework like Home Assistant, follow these steps:",
            "Step 1: Identify the appropriate domain and base class.",
            "  - Determine whether the integration belongs under a domain-specific component (e.g., `air_quality`, `climate`, `sensor`).",
            "  - Use the domain’s base entity class (e.g., `AirQualityEntity`) and shared `PLATFORM_SCHEMA` instead of a generic sensor when domain-specific semantics exist.",
            "Step 2: Define and validate configuration options.",
            "  - Extend the base `PLATFORM_SCHEMA` with custom config keys like `area`, `stations`, `show_on_map`, etc.",
            "  - Use `vol.Exclusive` for mutually exclusive options (e.g., `area` vs `stations`) so users can’t configure conflicting modes.",
            "  - Use `vol.Inclusive` when fields must appear together (e.g., latitude and longitude).",
            "  - Normalize and validate types: e.g., wrap lists with `cv.ensure_list` and validate strings or allowed values with `vol.In`.",
            "Step 3: Integrate the external client as a thin data layer.",
            "  - Add the external library to the integration’s requirements (e.g., `REQUIREMENTS` in the module and `requirements_all.txt`) and document it with a domain-specific comment.",
            "  - Import the library lazily inside `setup_platform` or other functions that need it to avoid loading unused dependencies and to keep startup fast.",
            "  - Wrap the third-party client in a small data class (e.g., `NiluData`) that exposes a `.data` property and an `update()` method.",
            "Step 4: Implement throttled polling.",
            "  - Define a `SCAN_INTERVAL` for how often the integration should poll the external API.",
            "  - Decorate the data-layer `update()` method with `@Throttle(SCAN_INTERVAL)` to automatically limit call frequency.",
            "  - In the entity’s `update()` method, call the data object’s `update()` rather than directly calling the library.",
            "Step 5: Discover and validate resources before creating entities.",
            "  - Implement logic to resolve configuration into actual resources (e.g., convert an `area` into station names via `lookup_stations_in_area`, or discover nearby stations via latitude/longitude).",
            "  - For each resource (e.g., station), create a client and perform an initial `update()`.",
            "  - Check that the data contains expected fields (e.g., `client.data.sensors` is not empty); if not, log a warning and skip entity creation.",
            "Step 6: Map external data to standardized entity properties.",
            "  - For each pollutant or metric (CO, CO2, NOx, NO2, O3, PM2.5, PM10, PM1, SO2), implement a property on the entity that returns the appropriate value.",
            "  - Use a helper like `get_component_state(component_name)` to DRY out repeated patterns: look up the sensor in a dict and return its value or `None` if missing.",
            "  - Return numeric values (floats or ints) from these properties; avoid concatenating units into strings. Rely on the base entity or framework to provide units.",
            "Step 7: Represent aggregate or derived indexes properly.",
            "  - If the external API exposes a pollution or quality index per pollutant, compute a station-level index (e.g., max of all pollution indexes).",
            "  - Assign the aggregated numeric index to the entity’s standard index property (e.g., `air_quality_index`).",
            "  - If textual descriptions exist (like NILU's `POLLUTION_INDEX` mapping), expose them via attributes (e.g., `nilu_pollution_index`) rather than overloading the entity state.",
            "Step 8: Add contextual attributes but keep the primary state simple.",
            "  - Store metadata like `area`, and optionally `latitude`/`longitude` for map display, in `device_state_attributes`.",
            "  - Avoid overriding the entity `state` with composite or textual values when a numeric index or standard state is expected; use attributes instead.",
            "Step 9: Update non-code references on refactors.",
            "  - If you move the integration between components or rename it, update import paths, base classes, documentation URLs, comments in `requirements_all.txt`, and coverage configuration (`.coveragerc`).",
            "  - Ensure docstrings and links point to the correct component path (e.g., `air_quality.nilu` instead of `sensor.nilu_air_quality` or `air_pollutants.nilu`).",
            "Step 10: Test and log clearly.",
            "  - Test with various configurations: specific area, explicit station list, and auto-discovery via coordinates.",
            "  - Confirm that entities are not created when stations return no data and that the log contains a clear warning.",
            "  - Verify that values are numeric, attributes are correctly populated, and the update interval respects `SCAN_INTERVAL`."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Hydro-Québec integration failed to work with pyhydroquebec 2.2.2; updating the integration's manifest.json to require pyhydroquebec 2.4 resolved the issue.",
        "keywords": [
            "Hydroquebec integration",
            "pyhydroquebec",
            "Home Assistant",
            "dependency version",
            "manifest.json",
            "requirements",
            "third-party API change",
            "integration not working"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Hydroquebec integration was not functioning correctly when using the Python library pyhydroquebec at version 2.2.2. The user reported that they 'could not get it to work otherwise,' indicating runtime failures or incompatibility with the Hydro-Québec service or with the integration itself. The root cause was that the integration depended on a specific third-party library version that had become outdated and incompatible. The fix was straightforward: in homeassistant/components/hydroquebec/manifest.json, the required version of pyhydroquebec was updated from 'pyhydroquebec==2.2.2' to 'pyhydroquebec==2.4'. This change ensures that Home Assistant installs a newer, compatible version of the library when setting up the Hydroquebec integration. No other code changes were made in this PR. Administrative issues (CLA not signed, missing checklist steps) caused the PR to be closed due to inactivity, but the technical resolution was to bump the dependency version in the component manifest.",
        "semantic_memory": "This case illustrates a common pattern in integrations that rely on external services and third-party Python packages: breakages often arise due to mismatched or outdated dependency versions rather than bugs in the integration's own logic. When an integration stops working without changes in its own code, the cause is often an API change at the provider or a change in the underlying library that now requires a newer version. In ecosystems like Home Assistant, the correct place to specify such library versions is the integration's manifest or central requirements files. Keeping these dependency pins up-to-date and aligned with the library's documented compatible versions is crucial. It's also important to run the project's standard tools (e.g., generators like gen_requirements_all) and follow contribution checklists, since dependency upgrades can have global effects and need to be reflected in derived requirement files.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and observe the failure\n- Attempt to run the integration with current dependencies.\n- Check logs for import errors, attribute errors, or API-related exceptions involving the third-party library (e.g., pyhydroquebec).",
            "Step 2: Identify the dependency version in use\n- Locate the integration's dependency declaration (e.g., manifest.json in Home Assistant, setup.py/pyproject.toml/requirements.txt in other projects).\n- Note the currently pinned version (e.g., pyhydroquebec==2.2.2).",
            "Step 3: Check upstream library changes\n- Visit the third-party library's repository or PyPI page.\n- Review release notes and changelog for breaking changes or bug fixes between versions.\n- Confirm if a newer version (e.g., 2.4) is required for current API compatibility or bug fixes.",
            "Step 4: Test with a newer library version locally\n- In a local virtual environment, install the newer version: `pip install pyhydroquebec==<new_version>`.\n- Run the integration or a minimal reproduction script to verify that the new version resolves the observed issues.",
            "Step 5: Update the project dependency declaration\n- Modify the integration's manifest or requirements file to pin the working version (e.g., change `pyhydroquebec==2.2.2` to `pyhydroquebec==2.4`).\n- In Home Assistant, ensure related global requirement files (e.g., requirements_all.txt) are updated using the prescribed script (`python3 -m script.gen_requirements_all`) if required.",
            "Step 6: Run tests and linters\n- Execute the project's test suite (e.g., `tox`) to ensure no regressions.\n- Fix any failing tests that might rely on the old behavior of the library.",
            "Step 7: Verify integration behavior end-to-end\n- Start the application and configure the integration.\n- Confirm that the integration now successfully connects, fetches data, and behaves as expected.",
            "Step 8: Prepare and submit the patch\n- Include only necessary changes to the dependency version and any related files.\n- Follow the project's contribution checklist (CLA, documentation, manifest checks, etc.).\n- Clearly reference the issue being fixed (e.g., 'Resolve issue #24498') and describe why the dependency bump is needed.",
            "Step 9: Monitor after deployment\n- After merge and release, watch for user reports or automated error tracking.\n- Be prepared to adjust the version pin or handle new API differences if further issues appear."
        ]
    }
}
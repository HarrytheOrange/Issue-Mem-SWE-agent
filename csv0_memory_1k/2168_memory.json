{
    "search_index": {
        "description_for_embedding": "Performance issue in StackStorm CLI where 'st2 execution list' and 'st2 execution get' were slow because large 'result' and 'trigger_instance' fields were always fetched from the API/DB even when not displayed. Fix: add client-side exclude_attributes logic (respecting --attr) to avoid retrieving these heavy fields by default, and introduce a centralized debugging utility that also pretty-indents JSON responses when st2api runs in debug mode.",
        "keywords": [
            "StackStorm",
            "st2",
            "st2client",
            "st2api",
            "execution list performance",
            "execution get performance",
            "exclude_attributes",
            "large result field",
            "trigger_instance",
            "API payload size",
            "database read performance",
            "CLI optimization",
            "JSON pretty print",
            "debug mode",
            "ActionExecutionListCommand",
            "ActionExecutionGetCommand"
        ]
    },
    "agent_memory": {
        "episodic_memory": "On a StackStorm build server, the 'st2 execution list' CLI command was observed to be very slow (~9 seconds for a default run). Profiling indicated that the majority of time was spent reading large execution documents from the database and transferring them over the network, especially the 'result' and 'trigger_instance' fields, which can contain large payloads for workflow actions. Notably, the default 'execution list' output does not display these fields at all, meaning the data was being fetched and transferred but then ignored by the client.\n\nSimilarly, 'st2 execution get <id>' always retrieved full execution objects, including 'result' and 'trigger_instance', even when the user only requested a subset of attributes via the '--attr' option.\n\nTo address this, the fix introduced a shared base class, ActionExecutionReadCommand, for read/view commands (list/get) in st2client. This class provides a '_get_exclude_attributes(args)' helper that builds a list of fields to exclude based on the attributes requested by the user. By default, if 'result' or 'trigger_instance' are not in 'args.attr', they are added to the exclude list.\n\nFor 'st2 execution list', the command now passes 'exclude_attributes' to the manager.query() call, ensuring that 'result' and 'trigger_instance' are not retrieved unless explicitly requested. For 'st2 execution get', the command now passes 'params={\"exclude_attributes\": ...}' into get_resource_by_id(), again omitting heavy fields unless requested.\n\nThe change was tested on the build server. Before the optimization, 'st2 execution list > /dev/null' took around 8.8 seconds. After the change, it took around 0.5 seconds, and listing 100 executions took around 0.8 seconds, making the commands effectively instantaneous.\n\nIn the same PR, a new debugging utility module (st2common.util.debugging) was introduced. When StackStorm is started with the '--debug' flag (cfg.CONF.debug is true), 'enable_debugging()' is invoked during service setup. This sets a global debug flag and raises all loggers' levels to DEBUG. The API response wrapper now checks 'is_debugging_enabled()'; if debugging is enabled, JSON responses are pretty-indented (indent=4), otherwise they are compact. The debugging-related logic was centralized in the debugging module, and the changelog was updated to document both the performance improvements and the new debug behavior.",
        "semantic_memory": "This case illustrates a common performance anti-pattern: eagerly fetching and transmitting large data fields that are not needed for the current view or operation. In systems where resources have some fields that can be very large (e.g., execution results, logs, payloads, or blobs), list and read endpoints should support projection or field exclusion. Clients should leverage these mechanisms to avoid retrieving heavy fields by default, only including them when explicitly requested.\n\nKey generalizable concepts:\n1. **Field projection for performance**: For list views or summary endpoints, only fetch minimal fields needed for display. Provide filters like 'include_fields' or 'exclude_fields'/'exclude_attributes' to avoid unnecessary DB reads and network transfer.\n2. **Client-server contract on fields**: The client knows which fields it intends to display (e.g., via display_attributes or a '--attr' filter). Use this knowledge to drive the projection/exclusion parameters in API calls.\n3. **Respect user-specified attributes**: When users specify a narrow subset of attributes (e.g., '--attr result'), ensure the backend does not fetch unrelated heavy fields, and conversely, does fetch the requested ones even if they are heavy.\n4. **Shared logic for similar commands**: When multiple commands have similar behavior (e.g., list and get for the same resource), centralize shared logic in a base class (here, ActionExecutionReadCommand) to avoid duplication and ensure consistent behavior.\n5. **Debug vs production behavior**: Pretty-printing JSON responses is very useful during debugging but can add overhead and clutter logs. Using a debug flag to switch between compact and pretty output is a good practice. Also, centralizing the debug toggling (log levels, formatting, flags) in a single module keeps behavior consistent and discoverable.\n6. **Changelog discipline**: Performance changes and debug behavior changes should be documented clearly so that operators understand why behavior (speed or formatting) has changed across versions.\n\nOverall, the pattern is: expose projection/exclusion in the API, route that through the client based on display needs, and keep heavy operations and verbose formatting behind explicit debug or opt-in flags.",
        "procedural_memory": [
            "To diagnose and optimize slow list/get operations that involve large resource payloads, follow these steps:",
            "Step 1: Reproduce and measure the latency.\n- Run the problematic CLI commands (e.g., 'execution list', 'execution get <id>') several times and measure wall-clock times (using 'time' or equivalent).\n- Confirm the slowness is repeatable and not just transient load.",
            "Step 2: Identify heavy fields.\n- Inspect the resource schema (e.g., execution model) to find fields that can grow large: 'result', 'logs', 'payload', 'metadata', etc.\n- For sample records, look at their size and note which fields dominate the total size.",
            "Step 3: Check what the client actually displays.\n- Look at the CLI command implementation to see 'display_attributes' and any '--attr' options.\n- Determine which fields are shown by default and which are only required for detailed views or special options.",
            "Step 4: Inspect API calls and parameters.\n- Find where the CLI calls into its manager / HTTP client (e.g., manager.query(), get_resource_by_id()).\n- See whether those calls support field projection or exclusion (e.g., 'exclude_attributes', 'include_fields', 'fields'). If not, consider adding such support at the API layer first.",
            "Step 5: Implement field exclusion/projection.\n- Add logic in the client command layer to construct an appropriate list of fields to exclude based on requested attributes:\n  - Define a helper (e.g., '_get_exclude_attributes(args)') that:\n    - Starts with an empty list.\n    - For each known heavy field (e.g., 'result', 'trigger_instance'), adds it to the exclude list if it is not in 'args.attr' and not part of the default display.\n  - Convert this list to a comma-separated string and pass it as 'exclude_attributes' (or similar) to the API call.",
            "Step 6: Centralize shared read behavior.\n- If multiple commands (like list and get) need the same exclusion logic, create a shared base class (e.g., 'ActionExecutionReadCommand') with the helper method.\n- Refactor the list and get commands to subclass this base and reuse the logic.",
            "Step 7: Wire up the parameters correctly to API calls.\n- For list operations, pass 'exclude_attributes' directly as part of the query parameters or kwargs (e.g., 'manager.query(limit=args.last, **kwargs)').\n- For get operations, ensure the 'params' dictionary passed to 'get_resource_by_id' contains 'exclude_attributes'.",
            "Step 8: Re-test and compare performance.\n- Re-run the same timing tests as in Step 1.\n- Confirm that wall-clock time has dropped significantly and that output remains correct.\n- Check that specifying '--attr' to include heavy fields still works (no missing data when explicitly requested).",
            "Step 9: Add or refine debug behavior (optional but recommended).\n- If verbose output (like pretty JSON) is desirable for debugging, gate it behind a global debug flag.\n- Implement a 'debugging' utility module that:\n  - Maintains a global 'ENABLE_DEBUGGING' flag.\n  - Exposes 'enable_debugging()', 'disable_debugging()', and 'is_enabled()'.\n  - In 'enable_debugging()', set log levels appropriately (e.g., via a 'set_log_level_for_all_loggers' helper).\n- In response serialization code, check 'is_debugging_enabled()' and choose indent=4 for JSON when true, indent=None when false.",
            "Step 10: Integrate debug flag with service setup.\n- In the service setup code, after parsing configuration, check if a debug flag (e.g., 'cfg.CONF.debug') is set.\n- If it is, call 'enable_debugging()' from the debugging utility module.\n- Remove scattered debug-related calls from other modules to keep behavior centralized.",
            "Step 11: Document the changes.\n- Update the changelog to note:\n  - The performance improvement and the fact that large fields are now excluded by default unless requested.\n  - Any new behavior related to debug mode (e.g., pretty-indented JSON responses).\n- Mention the impact: better performance on installations with large execution results or heavy payloads.",
            "Step 12: Monitor in production.\n- After deploying, monitor execution list/get response times and API resource usage.\n- Ensure no regressions in functionality (e.g., scripts relying on previously implicit fields are updated to request them explicitly if necessary)."
        ]
    }
}
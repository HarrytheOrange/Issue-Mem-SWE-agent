{
    "search_index": {
        "description_for_embedding": "Home Assistant Broadlink SP2 switch integration did not expose real-time power/energy usage. The fix fetches power data via get_energy(), stores it on the entity, and exposes it through the current_power_w property with rounding and exception handling so that load power is visible in Home Assistant.",
        "keywords": [
            "Home Assistant",
            "Broadlink",
            "SP2",
            "switch",
            "energy monitoring",
            "power usage",
            "current_power_w",
            "get_energy",
            "entity attributes",
            "polling",
            "integration bugfix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Broadlink SP2 smart plug integration in Home Assistant did not expose its load power (energy usage) in the UI or to the state machine. The device library already offered get_energy(), but the Home Assistant switch entity wrapper only called check_power() to determine on/off state and did not surface the energy measurement.\n\nThe fix was implemented in the Broadlink switch platform file (homeassistant/components/switch/broadlink.py), specifically in the SP2 switch entity class. A new instance variable, self._load_power, was added and initialized to None in __init__. In the internal _update() method, alongside the existing call to self._device.check_power(), the code now calls self._device.get_energy() and stores the result in load_power. After a successful update, self._state is set from the check_power() result and self._load_power is updated from load_power.\n\nInitially, the implementation tried to expose this value via device_state_attributes with a custom attribute name (first 'load_power', then 'current_power_w'). This approach was later refactored to follow Home Assistant patterns for energy reporting on switches: a dedicated current_power_w property was introduced. This property returns the current power usage in watts, rounded to two decimal places, and wrapped in a try/except block to handle ValueError and TypeError (returning None on error). Polling remained enabled (should_poll returns True), ensuring the power value is kept up to date.\n\nThe end result is that the Broadlink SP2 switch entity in Home Assistant now exposes its real-time power consumption via current_power_w, making it usable in the UI, automations, and energy-related dashboards, while safely handling cases where the underlying device returns invalid or missing data.",
        "semantic_memory": "This fix illustrates several generalizable patterns when integrating hardware energy/power monitoring into a home automation platform:\n\n1. **Expose device capabilities end-to-end**: A device library may already support richer capabilities (e.g., power/energy readings via get_energy()), but the integration layer must explicitly fetch, store, and expose these values on the entity model. Otherwise, the functionality remains hidden even though the device supports it.\n\n2. **Follow platform conventions for attribute naming**: Using standard property names (such as current_power_w in Home Assistant for power in watts) makes the data predictable and compatible with the wider ecosystem (UI components, statistics, energy dashboards). Custom or ad-hoc attribute names make the data harder to discover and may break tooling expectations.\n\n3. **Use periodic polling and cache results on the entity**: For devices that require active queries, the integration should implement should_poll = True and maintain internal state fields (like _load_power). The update/_update methods should refresh those fields, and entity properties should read from them. This pattern keeps network calls centralized and predictable.\n\n4. **Defensive handling of device data**: Hardware APIs can return invalid, transient, or None values. Wrapping conversions/rounding in try/except and returning None on error prevents the integration from crashing and signals to the platform that the measurement is temporarily unavailable.\n\n5. **Separation of concerns**: The low-level device access (check_power, get_energy) is kept inside the update cycle, while properties like current_power_w only expose already-collected state. This abstraction makes entities easier to reason about and avoids doing I/O inside property getters.\n\nThese ideas apply broadly to any home automation or IoT integration where hardware metrics (power, temperature, humidity, etc.) need to be surfaced reliably and consistently to the core platform.",
        "procedural_memory": [
            "When a device supports power/energy monitoring but the platform does not show it, the key steps are to wire the device's data through the integration entity and expose it using the platform's standard properties.",
            "Step 1: Identify missing capability and device API support.\n- Confirm that the physical device (e.g., Broadlink SP2) supports the measurement you care about (power, energy, etc.).\n- Inspect the underlying device library to locate the relevant method (e.g., get_energy(), get_power_usage()).",
            "Step 2: Add internal state fields to the entity.\n- In the entity class (e.g., the switch entity for the device), add an instance variable to store the measurement, initialized to a safe default:\n  - Example: `self._load_power = None` in `__init__`.\n- Ensure the entity is configured to poll the device if the data is not pushed (implement `should_poll` returning True if necessary).",
            "Step 3: Fetch device data in the update cycle.\n- Locate the method responsible for synchronizing entity state from the device (often `update()` or a helper like `_update()`).\n- In that method, call the device library function that returns the desired metric:\n  - Example: `load_power = self._device.get_energy()` alongside existing calls such as `state = self._device.check_power()`.\n- Handle network/communication errors with try/except, and implement retries if the pattern is already present.",
            "Step 4: Persist the fetched measurement on the entity.\n- After successful communication with the device, assign the measurement to the entity’s internal field:\n  - Example: `self._load_power = load_power`.\n- Keep this in sync with other state updates (e.g., `self._state = state`).",
            "Step 5: Expose the measurement via the platform’s standard interface.\n- Prefer official or commonly-used property names over custom attributes so that the rest of the platform can recognize and use the metric.\n  - In Home Assistant, use `current_power_w` for current power in watts.\n- Implement a property on the entity that reads from the internal field and applies any necessary formatting:\n  - Example:\n    - `@property`\n    - `def current_power_w(self):`\n    - `    try:`\n    - `        return round(self._load_power, 2)`\n    - `    except (ValueError, TypeError):`\n    - `        return None`",
            "Step 6: Guard against invalid or missing data.\n- Wrap conversion or rounding logic in try/except to handle cases where the device returns an unexpected type or None.\n- Return None or a platform-appropriate sentinel value when data is unavailable instead of raising, so the entity remains functional.",
            "Step 7: Verify integration and behavior.\n- Run the integration locally and confirm that the new property appears on the entity.\n- Check logs for errors during polling.\n- Validate that the value updates over time when the load on the device changes.",
            "Step 8: Align with platform conventions and cleanup.\n- Remove or avoid redundant custom attributes if a dedicated property exists for the metric.\n- Ensure docstrings and naming clearly describe what the metric represents (e.g., 'current power usage in Watt').\n- Keep I/O (device calls) inside the update cycle, not in properties, to avoid blocking calls on property access."
        ]
    }
}
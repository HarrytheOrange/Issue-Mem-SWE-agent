{
    "search_index": {
        "description_for_embedding": "Added per-entity configuration overrides for Fibaro lights and binary sensors in Home Assistant. Users can now override default imported behavior (device_class, icon, dimming, color, white_value, reset_color) via a fibaro.device_config section in configuration.yaml.",
        "keywords": [
            "Home Assistant",
            "Fibaro",
            "fibaro integration",
            "binary_sensor",
            "light",
            "device_config",
            "entity overrides",
            "device_class override",
            "icon override",
            "dimming override",
            "color override",
            "white_value override",
            "reset_color",
            "configuration.yaml"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the Fibaro integration for Home Assistant was enhanced to allow users to override the auto-imported behavior of Fibaro lights and binary sensors on a per-entity basis. Previously, the integration would map Fibaro devices into Home Assistant entities with fixed behavior (e.g., inferred device_class for binary_sensors, and inferred features like dimming and color support for lights) based solely on what the Fibaro controller reported. This caused limitations where Fibaro’s metadata was incomplete, misleading, or where users wanted different behavior in Home Assistant.\n\nTo address this, a new configuration section `device_config` was added under the `fibaro:` domain in `configuration.yaml`. Within `device_config`, users reference individual devices and then specify overrides:\n\n- For binary_sensors: `device_class` (using any valid Home Assistant binary_sensor device class such as `battery`, `cold`, `connectivity`, `door`, `garage_door`, etc.) and `icon` to override the default icon.\n- For lights: `dimming` (boolean to force-enable or force-disable dimming capability), `color` (boolean to force-enable or disable color support), `white_value` (boolean to force-enable or disable a white channel like the W component of RGBW LEDs), and `reset_color` (boolean to reset the color to white whenever the light is turned on).\n\nThere was a brief design discussion: initially the idea was to use an `entity_config` section (similar to Z-Wave), but there was concern about confusion with the existing `entity_config` used by Alexa and other features. The final decision was to use `device_config`, aligning with the pattern used in the Z-Wave integration while avoiding conflicts with other config namespaces. The PR added the necessary configuration handling to the Fibaro component to read and apply these overrides when setting up entities, and it was verified via local testing and tox, with no commented-out code left in the patch.",
        "semantic_memory": "This change illustrates a recurring pattern in integrations: auto-detection of device capabilities is convenient but not always accurate or sufficient. Device metadata from external systems (like a Fibaro Home Center) can be incomplete or misaligned with how users want entities to behave in Home Assistant (e.g., a light that technically supports dimming but the user wants it treated as simple on/off, or a sensor whose generic type is better represented as a more specific device_class).\n\nA robust integration often needs a per-entity override mechanism, allowing users to fine-tune behavior beyond what the upstream system reports. This is typically implemented as a structured configuration section (e.g., `device_config`) that:\n\n- Maps to entities or devices using stable identifiers (entity_id, node id, or integration-specific IDs).\n- Exposes well-defined override fields for capabilities and presentation (e.g., device_class, supported_features, icons, behavior flags like `reset_color`).\n- Follows existing configuration patterns across the project to reduce user confusion (e.g., aligning Fibaro config structure with Z-Wave’s approach instead of inventing a new pattern or overloading a name already used elsewhere like `entity_config` for Alexa).\n\nAnother generalizable lesson is to keep configuration options positively expressed (e.g., `dimming: false` rather than `no_dimming: true`), which makes configuration more intuitive to read and reduces logical double-negatives in both code and docs.\n\nFinally, when introducing new configuration capabilities, consistency with the broader ecosystem (naming, structure, semantics) and clarity about the precedence rules between auto-detected and manually configured values are key to avoiding confusion and support issues.",
        "procedural_memory": [
            "When users need to override default behavior of auto-discovered devices in an integration:",
            "Step 1: Identify pain points in current behavior.\n- Review user reports or issues where automatically imported device capabilities or classifications (e.g., device_class, dimming support) do not match real-world behavior or user expectations.\n- List specific attributes users want to override (e.g., device_class, icon, supported_features like dimming/color, behavioral flags like reset_color).",
            "Step 2: Design a per-entity configuration schema.\n- Choose a top-level configuration key under the integration domain (e.g., `fibaro:` → `device_config:`).\n- Ensure naming does not conflict with similarly named sections used by other subsystems (e.g., avoid overloading an existing global `entity_config` used for Alexa/other platforms unless it’s truly the same concept).\n- Define per-entity keys (e.g., device IDs or entity_ids) and the allowed override options (booleans for capabilities, enums/strings for classes, etc.).\n- Keep option names positively expressed (e.g., `dimming: false` instead of `no_dimming: true`).",
            "Step 3: Implement configuration parsing.\n- Extend the integration’s configuration schema (e.g., using voluptuous in Home Assistant) to validate the new `device_config` structure and its fields.\n- Define types and allowed values (e.g., restrict device_class to known binary_sensor device classes; icon as string; booleans for `dimming`, `color`, `white_value`, `reset_color`).\n- Make sure defaults preserve existing behavior when no overrides are present.",
            "Step 4: Map configuration to entities during setup.\n- In the integration’s setup or entity creation logic, look up the current device/entity in `device_config` using a stable identifier (e.g., Fibaro device id or entity_id).\n- Apply overrides by updating entity properties or supported features based on the configuration.\n- Ensure that manual configuration has precedence over automatically detected values while not breaking entities with no overrides.",
            "Step 5: Implement behavior-specific logic.\n- For lights: adjust `supported_features` to reflect `dimming`, `color`, and `white_value` overrides.\n- Implement behavioral flags such as `reset_color` by adding logic in `turn_on` (or equivalent) to set the light’s color to white whenever it is switched on if the flag is true.\n- For binary_sensors: override `device_class` and `icon` properties to respect the configured values.",
            "Step 6: Test thoroughly.\n- Create sample configuration.yaml snippets replicating likely user setups, including both overridden and non-overridden entities.\n- Run unit tests and integration tests (e.g., using `tox` in Home Assistant) and add tests verifying that overrides actually change entity capabilities and attributes as intended.\n- Verify that existing setups without `device_config` behave exactly as before (no regressions).",
            "Step 7: Document and communicate.\n- Add or update documentation in the project’s docs repo showing the new configuration options, including example configuration.yaml sections.\n- Describe precedence rules (manual config vs auto-detection) and explain typical use cases (e.g., disabling dimming or forcing garage_door device_class).\n- Reference similar patterns (e.g., Z-Wave `device_config`) so users can transfer knowledge between integrations."
        ]
    }
}
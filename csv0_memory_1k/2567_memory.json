{
    "search_index": {
        "description_for_embedding": "Home Assistant joaoapps_join component was limited to a single device because the config schema only accepted one device object. The fix changed the configuration to accept a list of devices (using cv.ensure_list) and refactored setup to iterate over each device, validating API keys and registering services per device.",
        "keywords": [
            "home-assistant",
            "joaoapps_join",
            "Join integration",
            "multiple devices support",
            "config schema",
            "voluptuous",
            "cv.ensure_list",
            "service registration",
            "API key validation",
            "list vs single object configuration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant joaoapps_join component was originally designed to accept configuration for only a single device. The CONFIG_SCHEMA was defined as `{DOMAIN: vol.Schema({...})}`, which meant users could not configure multiple Join devices and corresponding services within one Home Assistant instance. Services such as `join_ring`, `join_send_sms`, etc., were effectively tied to a single configured device.\n\nThe fix changed the configuration schema to expect a list of device configurations using `vol.All(cv.ensure_list, [{...}])`. Instead of treating `config[DOMAIN]` as a single dict, `setup` now iterates over `config[DOMAIN]` (a list of device entries). A new helper function `register_device(hass, device_id, api_key, name)` was introduced to encapsulate registering the Join-related services (`ring`, `set_wallpaper`, `send_sms`, `send_file`, `send_url`, `send_tasker`) for each device.\n\nWithin `setup`, for each device entry, the code now:\n- Extracts `device_id`, `api_key`, and `name` from the device config.\n- Normalizes the name into a safe service name prefix (`name.lower().replace(\" \", \"_\") + \"_\"`), if provided.\n- Validates the API key using `get_devices(api_key);` if the API key is invalid, it logs an error and aborts setup by returning `False`.\n- Calls `register_device` to bind the appropriately prefixed services for that specific device.\n\nThis change allows multiple Join devices to be configured, each with its own set of services, and preserves API key validation per device. The PR thus resolves issue #2565, which requested support for multiple components/devices in the Join integration.",
        "semantic_memory": "When an integration is initially written to support only a single instance (device, account, etc.) but users need multiple instances, the configuration schema is often the bottleneck. A common pattern is that the schema accepts a single object under a domain key, making it impossible or awkward to configure multiple entries. The general fix is to update the schema to allow a list of objects and then iterate over them in the setup code.\n\nKey concepts and patterns illustrated by this fix:\n\n1. **List-friendly configuration schemas**: Using a schema helper like `cv.ensure_list` (or similar in other frameworks) allows the configuration to accept either a single object or a list of objects, but normalize it into a list for internal processing. This prevents breaking existing configurations while enabling multi-instance support.\n\n2. **Per-instance service registration**: When multiple instances of a component are supported, service names often need to be namespaced (e.g., prefixed with a device-specific name) to avoid collisions and to make it clear which instance the service operates on.\n\n3. **Refactoring common logic**: Extracting a helper function (here, `register_device`) to register services for each instance reduces duplication and clarifies the lifecycle: `setup` is responsible for configuration iteration and validation, while the helper handles registration.\n\n4. **Per-instance validation**: API or connectivity validation (like `get_devices(api_key)`) should happen per instance, and the component should decide what to do on failure (log an error, skip a device, or abort the entire setup). This PR chose to abort on the first invalid API key, matching prior single-instance behavior.\n\n5. **Name normalization for identifiers**: When user-supplied names are used in identifiers such as service names, they should be normalized (e.g., lowercasing, replacing spaces with underscores) to conform to platform constraints and avoid subtle bugs or inconsistencies.\n\nOverall, the fix demonstrates best practices for evolving a single-instance integration into a multi-instance one without drastically changing internal logic: adjust the schema, iterate over instances, reuse registration logic, and maintain clear validation semantics.",
        "procedural_memory": [
            "To diagnose and fix issues where an integration or component cannot handle multiple devices/instances due to configuration limitations:",
            "Step 1: Identify the limitation in the configuration schema.\n- Inspect the config schema definition for the component.\n- Look for patterns like `{DOMAIN: vol.Schema({...})}` or similar that obviously only support a single object.\n- Confirm user reports or tests showing failure or impossibility of specifying multiple devices/accounts.",
            "Step 2: Decide on a multi-instance configuration structure.\n- Choose a schema that allows a list of configuration objects under the integration's domain.\n- Ensure backward compatibility by using a helper like `ensure_list` so that existing single-object configs still work while being treated as a list of length one.",
            "Step 3: Update the configuration schema.\n- Replace the single-object schema with something like:\n  `CONFIG_SCHEMA = vol.Schema({ DOMAIN: vol.All(cv.ensure_list, [{ ... per-device fields ... }]) }, extra=vol.ALLOW_EXTRA)`\n- Keep per-device fields (IDs, API keys, names) inside the list item schema.",
            "Step 4: Refactor setup logic to handle multiple entries.\n- Update the `setup` (or equivalent) function to treat the domain config as a list of device configs: `for device in config[DOMAIN]: ...`.\n- Extract the necessary fields from each device entry (e.g., `device_id`, `api_key`, `name`).",
            "Step 5: Normalize and namespace per-instance identifiers.\n- Normalize user-provided names into safe identifiers: lowercasing, replacing spaces, and optionally adding a separator or suffix.\n- Use this normalized name as a prefix for services or other identifiers (e.g., `name + 'ring'`, `name + 'send_sms'`) so each instance has its own service set.",
            "Step 6: Validate per-instance configuration (e.g., API keys).\n- For each device config, run any required external validation such as `get_devices(api_key)` or a lightweight API probe.\n- On failure, log a clear error message that includes which device/config entry failed.\n- Decide on behavior: either abort the entire setup (return False) or skip only the failing instance, depending on platform conventions and backward compatibility.",
            "Step 7: Factor out common registration logic.\n- Create a helper function (e.g., `register_device`) that takes the platform context (`hass`), device identifiers, API key, and normalized name.\n- Move all per-device service registrations (and any handlers) into this helper.\n- Call this helper once per device in the main setup loop.",
            "Step 8: Test with multiple and single configurations.\n- Verify that a single-device configuration still works without changes.\n- Add a multi-device configuration and confirm that:\n  - All devices register their respective services with correct prefixes.\n  - Calls to services target the correct device.\n  - Invalid API keys trigger the expected error behavior.",
            "Step 9: Update documentation.\n- Document the new ability to configure multiple devices.\n- Show the expected list structure in configuration examples.\n- Clarify how service names are constructed when a `name` is provided."
        ]
    }
}
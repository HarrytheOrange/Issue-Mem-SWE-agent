{
    "search_index": {
        "description_for_embedding": "Fix for napari _merge_stack action so that merged stack slices follow the LayerList visual ordering instead of the arbitrary selection ordering. The selection is re-derived by iterating the LayerList and filtering by the current selection.",
        "keywords": [
            "napari",
            "LayerList",
            "merge to stack",
            "_merge_stack",
            "layer selection ordering",
            "stack creation order",
            "UI action bug",
            "list vs set ordering",
            "layers/_layer_actions.py"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the `merge to stack` action in napari did not respect the visual ordering of layers in the `LayerList`. The `_merge_stack` function originally built its `selection` with `list(ll.selection)`. The `ll.selection` object does not guarantee the same order as the `LayerList` (it can behave like a set or otherwise unordered container), so the resulting stack had slices ordered inconsistently with what users see in the layer panel. This led to unexpected slice order in the merged stack. The fix was to reconstruct the selection in the exact order of the `LayerList` by iterating over `ll` and filtering on `ll.selection`: `selection = [layer for layer in ll if layer in ll.selection]`. This forces the merge operation to follow the layer list ordering while still respecting which layers are selected.",
        "semantic_memory": "When working with UI selections or collections, it is critical not to assume that the selection container preserves the same order as the underlying visual or logical list. Many selection implementations behave like sets or use an internal ordering unrelated to display order. If an operation (like stacking, batching, or concatenation) must follow the visual or logical order shown to the user, the selection should be re-derived by iterating the authoritative ordered collection (e.g. a list backing the UI) and including only those elements that are selected. This pattern ensures deterministic, user-expected ordering regardless of the internal representation of the selection. More generally, any feature that combines or processes multiple selected entities in sequence should explicitly specify which collection defines the sequence order, and should not rely on the incidental iteration order of secondary containers.",
        "procedural_memory": [
            "When you see an operation that processes a set of selected items in an unexpected order, suspect a mismatch between the selection container's ordering and the primary list's ordering.",
            "Step 1: Reproduce the issue and verify that the order of operation (e.g., stack slice order, concatenation order) does not match the visual or logical ordering that users expect (e.g., the order in a list widget or layer list).",
            "Step 2: Inspect the code where the selection is obtained. Look for constructs like `list(selection)`, iteration over a `selection` object, or use of containers that may not preserve order (sets, unordered dicts, or custom selection types).",
            "Step 3: Identify the authoritative ordered collection that represents the user-facing ordering (e.g., a `LayerList`, a list model of items, or an ordered array). This is the source of truth for how items should be ordered in multi-item operations.",
            "Step 4: Modify the code to derive the ordered selection by iterating over the authoritative ordered collection and filtering by the selection membership, for example: `ordered_selection = [item for item in ordered_list if item in selection]`.",
            "Step 5: Replace uses of the old selection ordering (e.g., `list(selection)`) with the new `ordered_selection` in the operation (stacking, merging, bulk action). Ensure any subsequent logic (like removal from the list) still works with the new ordered list.",
            "Step 6: Add or update tests (if possible) that explicitly assert the order of results given a defined initial ordering and selection. For example, create multiple layers in a known order, select a subset in varying ways, perform the merge/stack, and check that the resulting sequence respects the `LayerList` ordering.",
            "Step 7: Manually test in the UI (if applicable) to confirm that operations now behave according to user expectations, particularly when selection order might differ from visual order (e.g., selecting items out of order or via multi-select gestures).",
            "Step 8: Document the behavior if relevant, clarifying that batch operations follow the main list ordering, not the order in which items were selected or any incidental internal ordering."
        ]
    }
}
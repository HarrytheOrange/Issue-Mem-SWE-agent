{
    "search_index": {
        "description_for_embedding": "Home Assistant evohome integration: added water_heater (DHW) support, refactored from async to sync, fixed KeyError when parsing DHW schedules, handled systems without schedules, improved Round Thermostat compatibility, and corrected storage/scheduling of Honeywell TCC OAuth tokens with robust UTC/local datetime handling.",
        "keywords": [
            "homeassistant",
            "evohome",
            "water_heater",
            "DHW",
            "domestic hot water",
            "climate-1.0",
            "RoundThermostat",
            "honeywell deprecation",
            "KeyError",
            "schedule parsing",
            "no schedule",
            "OAuth token storage",
            "access_token_expires",
            "async to sync refactor",
            "datetime UTC conversion",
            "async_track_point_in_utc_time"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the evohome integration in Home Assistant was extended and hardened to support additional device types and edge cases.\n\nThe main functional addition was support for domestic hot water (DHW) controllers via the water_heater platform. Previously, if evohome reported a DHW controller (broker.tcs.hotwater), the integration only logged a warning that DHW was not supported. Now, the setup() function calls load_platform for 'water_heater' when a hotwater device exists, and a new EvoDHW entity class is introduced. EvoDHW maps Home Assistant ON/OFF to Evohome DHW modes (EVO_FOLLOW and EVO_PERMOVER) and states via HA_STATE_TO_EVO and EVO_STATE_TO_HA. It exposes operation modes, current temperature, and uses the underlying evohomeclient2 device API, catching RequestException and AuthenticationError via a shared _handle_exception helper.\n\nThe integration’s initialization was refactored from asynchronous to synchronous, as requested by Home Assistant maintainers. async_setup became setup, async_setup_platform became setup_platform, and async_load_platform was replaced by load_platform. Periodic updates now use track_time_interval instead of async_track_time_interval. Blocking evohomeclient2 calls are made directly rather than via hass.async_add_executor_job, since the setup is now sync.\n\nA significant bug fix involved handling Honeywell TCC OAuth tokens. EvoBroker.init_client now loads tokens from Home Assistant’s storage using _load_auth_tokens, and always schedules a save via _save_auth_tokens once the client is initialized, even if the access token hasn’t changed. This fixes edge cases where access tokens previously weren’t stored or refreshed correctly (e.g., when tokens were invalid or changed). Datetime handling for access_token_expires was corrected:\n- Tokens are stored in UTC isoformat in storage.\n- _load_auth_tokens parses the stored string with parse_datetime and returns a UTC-aware datetime.\n- init_client converts that UTC datetime to local time before passing it into evohomeclient2, because the library uses local datetimes.\n- _save_auth_tokens converts evohomeclient2’s local access_token_expires back to UTC (using _local_dt_to_utc) before saving to storage.\n- A future call to _save_auth_tokens is scheduled with async_track_point_in_utc_time at access_token_expires + scan_interval, ensuring token persistence and refresh are reliably maintained.\n\nAnother class of issues was schedule handling. EvoDevice.get_setpoints, which reads schedule() from the evohome API, previously assumed each switchpoint had a 'heatSetpoint' key and that there was always a non-empty DailySchedules array. This caused a KeyError for DHW controllers (which use 'DhwState' instead of 'heatSetpoint') and broke systems that have no schedule at all. The method now:\n- Returns None when schedule['DailySchedules'] is empty, signaling the absence of a schedule.\n- For each switchpoint, creates a structure with a 'from' datetime (converted to UTC ISO 8601 via _local_dt_to_utc) and either 'temperature' or 'state', depending on whether 'heatSetpoint' or 'DhwState' is present, avoiding KeyError.\n\nThe consumers of get_setpoints were updated to handle None gracefully. EvoZone._set_operation_mode now only uses self.get_setpoints() when running a temporary override (EVO_TEMPOVER) and checks for a non-None result. If no schedule exists, it falls back to a permanent override (no 'until'). set_temperature and the DHW set_operation_mode use parse_datetime on the 'from' value, which is now stored as UTC, instead of parsing custom strings with datetime.strptime.\n\nCompatibility with the Honeywell Round Thermostat (RoundModulation model) was improved. The controller entity (EvoController) recognizes when the first zone’s modelType is 'RoundModulation' and restricts controller preset modes to [PRESET_AWAY, PRESET_ECO] instead of exposing the full evohome preset set, matching the device’s capabilities and avoiding invalid mode selections. Logging was also improved to reflect zoneType and modelType correctly.\n\nFinally, multiple smaller cleanups were done: type hints were tightened (e.g., Optional types and return types), logging for configuration and status was gated behind debug level checks to avoid unnecessary I/O, helper functions _local_dt_to_utc and _utc_to_local_dt were refined (using utcnow() and datetime.now() to maintain relative offsets and normalize microseconds), and various lint errors and minor regressions were fixed during the review cycle.\n\nOverall, this PR adds DHW water_heater support, converts the integration to sync setup, fixes schedule parsing and token handling edge cases, normalizes datetime usage to UTC for state attributes, and improves device compatibility for Round Thermostat users migrating from the deprecated honeywell integration.",
        "semantic_memory": "Generalizable lessons from this change revolve around integration design for home automation, robust datetime handling, token management, and defensive parsing of third-party APIs.\n\n1. **Async vs sync integration boundaries**: Home Assistant and similar frameworks often have strict guidelines on where asynchronous code is allowed. Moving from async_setup/async_setup_platform to sync setup and setup_platform required replacing async helper utilities (async_load_platform, async_track_time_interval) with their sync counterparts (load_platform, track_time_interval) and ensuring that blocking I/O runs in allowed contexts. The lesson is to design initialization paths that respect the host application’s concurrency model, and not to mix async utilities into sync entry points.\n\n2. **Robust schedule parsing and optional data**: When consuming third-party APIs, it’s unsafe to assume that schedules are always present or that all switchpoints share the same schema. In evohome, climate zones use 'heatSetpoint' while DHW uses 'DhwState', and some systems can have no schedule at all. A robust implementation:\n- Treats schedules as optional (returns None if missing or empty).\n- Uses try/except or conditional checks around optional keys.\n- Structures parsed results to represent alternatives (e.g., either 'temperature' or 'state').\nThis pattern applies to any system where different device types share a nominal API but with subtle variations.\n\n3. **Consistent datetime semantics (UTC vs local)**: The integration had to reconcile three different expectations:\n- The external library (evohomeclient2) expects local datetimes for tokens.\n- Home Assistant stores datetimes and schedules callbacks in UTC.\n- State attributes exposed to Home Assistant should be in UTC, per platform guidelines.\nThe solution was to define central helper functions to convert between local and UTC, always strip or normalize microseconds, and use the host framework’s utilities (parse_datetime, async_track_point_in_utc_time, utcnow). Any system that persists timestamps, interacts with user-local time, and schedules future tasks can benefit from this pattern: store UTC, convert to local only at the boundaries that require it, and centralize conversion logic.\n\n4. **Token storage and refresh robustness**: OAuth/long-lived tokens must be stored and refreshed reliably. It is not enough to save tokens only when they change; failures or edge cases (like invalid tokens leading to re-authentication) can leave storage out of sync. A more robust design:\n- Always save tokens after a successful client initialization or refresh.\n- Store the expiry time in a normalized format (e.g., UTC ISO 8601).\n- Schedule a future task near expiry to re-save or refresh tokens, using framework-native schedulers.\nThis approach generalizes to any integration that needs to maintain token validity and survive process restarts.\n\n5. **Graceful handling of device capability differences**: The same integration can support different device types (e.g., evohome controller vs Round Thermostat) with different supported modes. Instead of exposing a one-size-fits-all mode list, the integration checks modelType and exposes only valid presets for that model. This prevents invalid user operations and UI confusion. The general pattern: inspect device model/capabilities at runtime and tailor exposed features accordingly.\n\n6. **Centralized error handling**: Using a shared _handle_exception that raises for unexpected exceptions and translates known request/auth errors into log messages or retries keeps the codebase consistent and easier to maintain. It is a good practice to funnel external I/O errors through a single place where policies (retry vs fail-fast, logging level) can be enforced.\n\nOverall, this PR illustrates best practices for: migrating integrations across API styles (async->sync), defensive coding against optional/mismatched API fields, clean separation of UTC/local time responsibilities, robust token lifecycle management, and capability-aware UX for heterogeneous devices.",
        "procedural_memory": [
            "How to diagnose and fix similar issues in a Home Assistant-like integration involving new device support, schedule parsing, and token/datetime handling.",
            "Step 1: **Identify missing or unsupported device types.** If users report that certain hardware (e.g., DHW controllers) is detected but not exposed as entities, inspect the integration’s setup() logic. Look for conditional branches like `if broker.tcs.hotwater` that only log warnings instead of loading a platform. Confirm which platforms (climate, water_heater, etc.) should be created for which device types.",
            "Step 2: **Add the appropriate platform and entity class.** Implement a new platform file (e.g., water_heater.py) that defines setup_platform and one or more entity classes (e.g., EvoDHW). Map the device’s native states/modes to the framework’s concepts (ON/OFF mapped to EVO_FOLLOW/EVO_PERMOVER, stateStatus, temperatureStatus). Ensure entity methods (current_operation, operation_list, current_temperature, operation setters) use the underlying client library correctly and handle known exception types via a shared error handler.",
            "Step 3: **Refactor async/sync entry points according to framework guidelines.** If the framework expects sync setup, rename async_setup to setup and async_setup_platform to setup_platform. Replace async helpers (async_load_platform, async_track_time_interval) with their sync equivalents (load_platform, track_time_interval) in the top-level integration code. Avoid calling async-only helpers from sync functions; if necessary, schedule async calls via the framework’s job API (e.g., hass.add_job) from a sync context.",
            "Step 4: **Audit schedule parsing code for optional fields.** For any method that parses external schedules (like EvoDevice.get_setpoints), verify assumptions: check if arrays (e.g., DailySchedules) may be empty and if keys like 'heatSetpoint' are always present. Adjust code to:\n- Early-return None when a schedule is missing or empty.\n- Handle alternative keys with try/except KeyError or conditional logic (e.g., if 'heatSetpoint' in switchpoint else use 'DhwState').\n- Construct a clear, documented structure (e.g., 'from' timestamp plus either 'temperature' or 'state').",
            "Step 5: **Update callers to handle the absence of a schedule.** For any logic that uses get_setpoints to compute an 'until' time for temporary overrides, check for None before indexing. If there is no schedule, fallback to a reasonable behavior, such as a permanent override (no 'until') or a default duration. In the evohome case, EvoZone._set_operation_mode now only uses the 'next' setpoint if get_setpoints() returns a non-None dict.",
            "Step 6: **Normalize datetime usage across the integration.** Decide on a canonical internal representation (usually UTC). Implement helper functions to convert between local and UTC datetimes, and to strip/normalize microseconds. Use the framework’s datetime helpers (parse_datetime, utcnow, async_track_point_in_utc_time) to parse ISO 8601 strings and schedule future tasks. Ensure that:\n- State attributes (e.g., schedule 'from') are stored as UTC ISO strings.\n- External libraries that expect local time get local datetimes, converted just before calling them.\n- Stored values in configuration or storage are in UTC, so they can be compared and scheduled reliably.",
            "Step 7: **Implement robust token storage and refresh.** When using an external client with refresh/access tokens:\n- Load tokens from persistent storage at startup and pass them into the client constructor.\n- After a successful client initialization (or refresh), always save the current refresh token, access token, and expiry time back to storage, regardless of whether they changed.\n- Persist expiry time as a normalized UTC isoformat string.\n- Schedule a future task near the expiry time using async_track_point_in_utc_time (or equivalent) to re-run the token save/refresh logic. This ensures that on the next restart, tokens are valid and reflect the latest state.",
            "Step 8: **Tailor modes and presets to specific device models.** Inspect configuration returned by the external API (e.g., modelType, zoneType) and adapt the list of supported hvac/preset modes accordingly. For devices with limited capabilities (like RoundModulation), restrict preset_modes to the subset that is valid. This prevents UI from offering unsupported options and avoids API errors when a user attempts to set invalid modes.",
            "Step 9: **Centralize and standardize error handling.** Create a single _handle_exception function that accepts known external errors (requests exceptions, authentication errors) and decides whether to log, retry, or propagate. Use this helper consistently whenever calling external client methods (e.g., _set_dhw, _set_temperature, _set_status). This simplifies reasoning about error scenarios and makes it easier to adjust behavior globally.",
            "Step 10: **Add and refine type hints and logging.** Improve type hints (Optional, concrete return types) on core methods like get_setpoints, token loaders, and operation setters to catch issues at static analysis time. Use debug-level logging to output configuration and status only when necessary, avoiding unnecessary I/O in normal operation. Run the project’s lint and test suite (e.g., tox) after each major refactor to ensure no regressions were introduced."
        ]
    }
}
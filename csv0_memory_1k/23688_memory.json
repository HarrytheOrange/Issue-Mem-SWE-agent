{
    "search_index": {
        "description_for_embedding": "Added a new Home Assistant Leaf Spy integration that exposes a custom HTTP GET endpoint for the Leaf Spy mobile app, validates a shared secret from query parameters, and forwards parsed telemetry data into the device_tracker component via config entries and dispatcher. Includes config_flow, manifest updates, and handling of Leaf Spy–specific fields (VIN, SOC, plug state, charge mode, etc.).",
        "keywords": [
            "Leaf Spy",
            "Nissan Leaf",
            "Home Assistant integration",
            "device_tracker",
            "HTTP GET webhook",
            "query string authentication",
            "config_flow",
            "HomeAssistantView",
            "async_setup_entry",
            "dispatcher",
            "telemetry parsing",
            "manifest.json",
            "config_flows.py",
            "config_entries",
            "local push integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set introduces a new Home Assistant integration for the Leaf Spy mobile application, which monitors Nissan Leaf vehicles and can send telemetry to an HTTP server via HTTP GET with query parameters. Because Leaf Spy cannot send HTTP POST payloads or standard Home Assistant webhooks and always includes user/pass query parameters, the author implemented a custom HTTP view instead of reusing the generic webhook subsystem.\n\nA new domain `leafspy` is defined with constants in `leafspy/const.py`, and a config flow in `leafspy/config_flow.py` is registered via `@config_entries.HANDLERS.register(DOMAIN)`. When the user sets up the integration, a random 8-character secret is generated using `generate_secret`, and a URL is constructed from `hass.config.api.base_url` plus `/api/leafspy/update`. The scheme (`http://` or `https://`) is stripped from the URL so that Leaf Spy’s configuration, which expects only host/port/path, can use it. The config flow enforces only one instance (`one_instance_allowed`) and provides detailed setup instructions through `strings.json` / `.translations/en.json`.\n\nThe integration’s `async_setup` bootstraps a config entry automatically if none exists by starting a config flow with source `SOURCE_IMPORT`. In `async_setup_entry`, the secret from the entry is stored in a `LeafSpyContext` object (`hass.data[DOMAIN]['context']`), the custom `LeafSpyView` HTTP handler is registered, and the device_tracker platform is forwarded via `async_forward_entry_setup`.\n\n`LeafSpyView` extends `HomeAssistantView`, exposes the path `/api/leafspy/update`, and disables authentication (`requires_auth = False`) because Leaf Spy cannot handle Home Assistant auth. On incoming GET requests, it retrieves the `LeafSpyContext`, reads the query parameters, checks that `message['pass']` matches the stored secret, and if valid, emits a dispatcher event on the `leafspy` signal (`hass.helpers.dispatcher.async_dispatcher_send(DOMAIN, hass, context, message)`). On success it responds with a 200 response containing the text `\"status\":\"0\"`; on any exception, it logs the error and still returns an empty 200 response to avoid breaking the client.\n\nIn `leafspy/device_tracker.py`, the device tracker platform connects to that dispatcher signal in `async_setup_entry` and wires the provided `async_see` callable into the `LeafSpyContext` so the HTTP view handler can feed location updates. The helper `_parse_see_args` translates Leaf Spy query parameters into the format expected by `async_see`: it builds a stable device ID like `leaf_<VIN>` (slugified), sets the `host_name` from `message['user']`, constructs a `(Lat, Long)` GPS tuple, and parses Leaf Spy-specific metrics. `SOC` (state of charge) is parsed as a float battery value; attributes include amp-hours (`AHr`), trip and odometer, battery and ambient temperature, plug state, charge mode, charge power, VIN, power switch status, device battery, RPM, Gids, elevation, and sequence counter. Plug state and charge mode numeric codes are mapped to human-readable strings using `PLUG_STATES` and `CHARGE_MODES` arrays. `ATTR_SOURCE_TYPE` is set to `SOURCE_TYPE_GPS`.\n\nVarious follow-up commits resolve static analysis and lint issues: unused imports and variables are removed; constants are moved to `const.py` with a docstring; the code style (blank lines, indentation) is normalized; dev_id construction is simplified; and return variables are renamed (`kwargs` to `args`). The manifest is expanded to include `config_flow: true`, a dependency on `http`, and code ownership (`@jesserockz`). The `leafspy` integration is added to `config_entries.async_step_discovery` and to the generated `config_flows.py` so Home Assistant recognizes it as a config-flow capable integration. Finally, `.coveragerc` is updated to omit the new `leafspy` package from coverage checks.",
        "semantic_memory": "This PR illustrates how to integrate a third-party mobile app that only supports HTTP GET with query parameters into Home Assistant’s modern integration architecture.\n\nKey patterns and concepts:\n\n1. **Handling non-standard webhooks / HTTP GET-only clients**: Some external tools cannot conform to a platform’s standard webhook format (e.g., they only support GET, or they encode payloads as query parameters and send fixed fields like `user`/`pass`). In these cases, implementing a custom `HomeAssistantView` (or equivalent framework-specific HTTP handler) with `requires_auth = False` and manual query parameter validation using a shared secret is a pragmatic solution. A dedicated `secret` configured via a config flow helps secure the endpoint, substituting for Home Assistant’s normal authentication or webhook authorization.\n\n2. **Using config entries and config flows for UI-based setup**: New integrations should use Home Assistant’s config entry system: register a `ConfigFlow` for the domain, support a `user`-initiated step, enforce single-instance constraints, and generate any secrets or identifiers needed for the integration. The UI can be driven by `strings.json` and translations, and description placeholders (`{secret}`, `{url}`) can be used to show user-specific instructions.\n\n3. **Separation of concerns via context and dispatcher**: The PR separates HTTP handling from entity updates using a `LeafSpyContext` object and Home Assistant’s dispatcher. The HTTP view decodes the incoming request, validates credentials, and sends a signal carrying `(hass, context, message)`. The device tracker connects to this dispatcher channel and is responsible for transforming the raw payload into `async_see` arguments. This decoupling makes it easier to change parsing logic without touching HTTP handling and provides a reusable pattern for push-based integrations.\n\n4. **Parsing and normalizing telemetry from query parameters**: When ingesting telemetry over query parameters, values arrive as strings. The integration explicitly casts each field into an appropriate type (int, float, bool) and maps numeric enums (e.g., plug state, charge mode) into human-readable strings. This results in cleaner, more semantic attributes on Home Assistant entities and reduces ambiguity for consumers.\n\n5. **Lifecycle and registration housekeeping**: Adding a new integration in Home Assistant requires multiple touches: a `manifest.json` with correct domain, doc URL, dependencies (`http` for HTTP-based views), and `config_flow` flag; updates to auto-generated lists (`generated/config_flows.py`); addition to discovery lists (`config_entries.async_step_discovery` where necessary); translation files; and code ownership and coverage configuration. Maintaining these ensures the integration is discoverable, properly loaded with its dependencies, and conforms to project quality gates.\n\n6. **Fail-safe responses to third-party clients**: The HTTP handler always responds with HTTP 200, even on server-side exceptions, logging the error internally. Some clients may not handle non-200 responses well, so trading strict HTTP semantics for client compatibility is a sometimes-necessary compromise. In such cases, logging becomes crucial for debugging.\n\nThese ideas generalize beyond Home Assistant: whenever you need to integrate a constrained third-party client into a modern, async, config-driven platform, consider creating a dedicated HTTP endpoint that validates a shared secret, transforms query-string payloads, and dispatches them asynchronously into the internal event/entity system.",
        "procedural_memory": [
            "Step-by-step instructions on how to design and implement a similar HTTP GET-based push integration in Home Assistant (or a similar platform):",
            "Step 1: Understand client constraints\n- Inspect the third-party app or device you want to integrate.\n- Determine what HTTP methods it supports (GET vs POST), what parameters it can send (query string, headers, body), whether it supports HTTPS, and if it can handle authentication or custom headers.\n- Identify any fixed fields (e.g., `user`, `pass`) that can be repurposed as credentials.",
            "Step 2: Define a dedicated domain and constants\n- Create a new integration package (e.g., `homeassistant/components/<domain>/`).\n- Add a `const.py` with a domain constant (`DOMAIN`) and any key URLs or config keys (e.g., `URL_<DOMAIN>_PATH`, `CONF_SECRET`).\n- Keep constants centrally defined so they can be reused by config flows, HTTP views, and platforms.",
            "Step 3: Implement a config flow for UI setup\n- Create `config_flow.py` and register a `ConfigFlow` using `@config_entries.HANDLERS.register(DOMAIN)`.\n- Implement `async_step_user` to:\n  - Abort if an instance already exists (if your integration should be single-instance).\n  - Show a confirmation form first if you want a simple one-step flow.\n  - On submission, generate any necessary secrets (e.g., `generate_secret(8)`).\n  - Build the external URL for the client to use by combining `hass.config.api.base_url` with your path and adjusting it to the client’s expectations (e.g., stripping `http://`/`https://` for clients that require host-only).",
            "Step 4: Create or update strings and translation files\n- Add `strings.json` for your domain specifying:\n  - `config.title`, `config.step.user` description/title.\n  - `abort` reasons like `one_instance_allowed`.\n  - `create_entry.default` with user instructions. Use placeholders like `{secret}` and `{url}` for dynamic values.\n- Mirror strings into `.translations/en.json` so the UI can display them in English (and prepare for other locales).",
            "Step 5: Implement the integration entry setup\n- In `__init__.py`, implement:\n  - `async_setup(hass, config)` to initialize `hass.data[DOMAIN]` and optionally auto-start the config flow if no entries exist.\n  - `async_setup_entry(hass, entry)` to:\n    - Extract and store the secret from `entry.data` in a context object (e.g., `LeafSpyContext`).\n    - Register your HTTP view (`hass.http.register_view(...)`).\n    - Forward the entry to any platform(s) (e.g., `device_tracker`) via `async_forward_entry_setup`.",
            "Step 6: Implement a context object and hook in async_see (or equivalent)\n- Create a simple context class (e.g., `LeafSpyContext`) that holds shared state such as `hass` and a secret.\n- Define an `async_see` method (or interface) that will later be bound by the platform (e.g., device_tracker).\n- In the platform’s `async_setup_entry`, assign `hass.data[DOMAIN]['context'].async_see = async_see` so HTTP handlers can call `context.async_see(...)` without knowing about the platform implementation.",
            "Step 7: Implement the custom HTTP view\n- Subclass the framework’s HTTP view base (e.g., `HomeAssistantView`).\n- Set properties:\n  - `url` to your endpoint path (e.g., `/api/leafspy/update`).\n  - `name` to a unique name (e.g., `api:leafspy`).\n  - `requires_auth = False` if the client cannot handle platform auth; otherwise, keep it True.\n- Implement `async def get(self, request)` (or matching method) to:\n  - Retrieve `hass` and your context (`request.app['hass']`, `hass.data[DOMAIN]['context']`).\n  - Access `request.query` to get query parameters.\n  - Validate the shared secret (e.g., compare `message['pass']` with `context.secret`).\n  - On success, dispatch an internal event via `async_dispatcher_send(DOMAIN, hass, context, message)`.\n  - Return an HTTP 200 response with an appropriate body that the client expects.\n  - Wrap logic in a try/except, log exceptions, and decide whether to still return 200 for compatibility.",
            "Step 8: Connect the platform to dispatcher and parse payloads\n- In your platform (e.g., `device_tracker.py`):\n  - Implement `async_setup_entry(hass, entry, async_see)` and:\n    - Assign `async_see` to the context (`hass.data[DOMAIN]['context'].async_see = async_see`).\n    - Subscribe to the dispatcher signal (`hass.helpers.dispatcher.async_dispatcher_connect(DOMAIN, async_handle_message)`).\n  - Implement `_parse_see_args(message)` that:\n    - Extracts and validates all expected query parameters.\n    - Converts string values to the correct types (int, float, bool).\n    - Maps numeric codes to descriptive strings when appropriate.\n    - Builds arguments for `async_see` (`dev_id`, `host_name`, `gps`, `battery`, `attributes`, `source_type`).\n  - Implement `async_handle_message(hass, context, message)` that:\n    - Logs the raw message for debugging.\n    - Calls `_parse_see_args(message)`.\n    - Awaits `context.async_see(**args)` to update the entity.",
            "Step 9: Update manifest, discovery, and generated lists\n- Add `manifest.json` with fields:\n  - `domain`, `name`, `documentation` URL.\n  - `requirements` if any external libs are needed.\n  - `dependencies` (e.g., add `\"http\"` if you rely on the HTTP component).\n  - `config_flow: true` to enable config-flow based setup.\n  - `codeowners` for maintenance.\n- Add your domain to:\n  - `config_entries.async_step_discovery` if it should appear in the UI discovery list.\n  - Generated `config_flows.py` so the framework knows about your config flow.\n- Optionally, add your integration to `.coveragerc` `omit` list if you are not yet providing tests.",
            "Step 10: Conform to style, lint, and type expectations\n- Run the project’s lint and static analysis tooling (e.g., `tox` in Home Assistant).\n- Fix unused imports, wrong docstrings, indentation, and variable naming inconsistencies.\n- Ensure your HTTP responses are properly quoted and valid.\n- Confirm that any broad exception handling is justified and logs errors for debugging.",
            "Step 11: Testing and validation\n- Configure the third-party client with the generated URL and secret.\n- Verify that:\n  - The client can reach your endpoint without authentication errors.\n  - The secret validation works (requests with wrong `pass` are ignored).\n  - Entities in the platform (e.g., a device_tracker entity) are created/updated with correct location and attributes.\n  - Edge cases (missing fields, invalid values) either log errors or are handled gracefully.\n- Adjust parsing logic based on real-world messages, adding new attributes as needed."
        ]
    }
}
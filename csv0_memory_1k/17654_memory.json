{
    "search_index": {
        "description_for_embedding": "Home Assistant integration for the Somfy MyLink hub adding cover and scene support. Uses an external somfy-mylink-synergy library, asynchronous setup, per-entity configuration (entity_config) with default move time and reverse options, and optional emulated position tracking based on movement duration. Also fixes the issue where cover state was lost on Home Assistant restart by using RestoreEntity to restore last known state and position.",
        "keywords": [
            "homeassistant",
            "somfy_mylink",
            "Somfy MyLink",
            "cover component",
            "scene component",
            "RestoreEntity",
            "async_setup",
            "async_setup_platform",
            "entity_config",
            "time-based position tracking",
            "emulated cover position",
            "state restore on restart",
            "somfy-mylink-synergy",
            "async_track_time_change",
            "JsonRPC",
            "configuration.yaml"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced a new Home Assistant integration for the Somfy MyLink hub, exposing covers and scenes via the Synergy JSON-RPC API. Initially, the implementation included an internal socket-based API wrapper, synchronous setup, a custom cover_options configuration format, and a simple time-based emulated position tracking for covers. The author noticed a key usability problem: every time Home Assistant restarted or the component reloaded, cover state was lost and reverted to defaults. This broke automations that depended on knowing partial positions (e.g., 50% or 80% open). To resolve this, the implementation was refactored and aligned with HA patterns in several steps.\n\nFirst, the low-level JSON-RPC logic was replaced with an external PyPI library `somfy-mylink-synergy`, declared via REQUIREMENTS and imported lazily inside async_setup. The integration was updated to use asynchronous lifecycle methods: `async_setup`, `async_setup_platform` for both cover and scene platforms, async service calls (e.g., `async_open_cover`, `async_close_cover`, `async_stop_cover`, and async scene `activate`), and `async_track_time_change` for time-based emulation. Platform loading moved to `async_load_platform` with proper discovery_info.\n\nThe configuration format changed from a generic `cover_options` list to an `entity_config` mapping, plus top-level defaults. The new schema allows setting `default_move_time` and `default_reverse` at the integration level and overriding `move_time` and `reverse` per entity, keyed by entity_id (e.g., `cover.bedroom`). To support this, a validator builds a normalized entity_config dict, and `async_setup` injects computed defaults under a `default` key passed as discovery_info to platforms. The cover platform uses slugified cover names to derive entity_ids and apply the matching config and defaults.\n\nFor emulated position tracking, the Somfy covers expose only up/down/stop, so the integration estimates position when `move_time` is configured. When a target position is requested via `set_cover_position`, it calculates a required duration based on total move_time and uses `async_track_time_change` with a LISTEN_INTERVAL to increment or decrement an internal `_position` until it reaches the desired rounded position. Movement commands are sent via helper methods (`mylink_open_cover`/`mylink_close_cover`) that transparently handle reversed directions. `async_stop_cover` stops motion and cancels the timer listener.\n\nThe specific bug of state resetting on reload was addressed by making the cover entity subclass `RestoreEntity` and implementing `async_added_to_hass`. On startup, it calls `super().async_get_last_state()` to fetch the previous state for the entity. If found, it restores `_state`, `_state_ts`, `_position` (from `current_position` attribute when emulation is enabled), and `_closed` (from the last state string). This ensures that after a restart, blinds retain their last known closed/position state rather than reverting to 0/closed. Along the way, logging levels were tuned (debug vs info), imports and style fixed (line lengths, sorted imports, docstring style), `.coveragerc` updated to omit the new integration from coverage, and CODEOWNERS updated to assign ownership. During review, project maintainers raised architectural concerns about simulating state/position in integrations, noting that official policy is to represent device data as-is and leave simulation to automations. This ultimately stalled and closed the PR, but the work encapsulates a full pattern for building such an integration, including state restore and per-entity behavior.",
        "semantic_memory": "Generalizable lessons from this change:\n\n1. **State restoration in Home Assistant entities**:\n   - If an entity should survive restarts with meaningful state (e.g., light brightness, cover position), it should typically subclass `RestoreEntity` and implement `async_added_to_hass`. In that method, call `await super().async_get_last_state()` to retrieve the last persisted state and reconstruct internal fields (e.g., position, is_closed) from `state.state` and `state.attributes`.\n   - Avoid duplicating state persistence logic; let the base class manage storage and focus only on reconstructing transient fields.\n\n2. **Per-entity configuration with defaults (`entity_config` pattern)**:\n   - For integrations that need per-entity options (e.g., `move_time`, `reverse`), it is more maintainable to use an `entity_config` mapping keyed by entity_id rather than custom ad hoc lists. A schema validator can normalize and validate these mappings.\n   - Provide sensible top-level defaults (e.g., `default_move_time`, `default_reverse`) and merge them into each entity’s configuration. Putting defaults into the same structure (under a `default` key) simplifies platform code, which only has to merge two dicts: `config_options.get('default', {})` and `config_options.get(entity_id, {})`.\n\n3. **Async integration design in Home Assistant**:\n   - New integrations should use `async_setup` / `async_setup_platform`, async entity methods (`async_open_cover`, `async_close_cover`, `async_stop_cover`, `async_update`, etc.), and async helpers like `async_track_time_change` and `async_load_platform` to avoid blocking the event loop.\n   - External libraries that perform I/O should be declared in the integration’s `REQUIREMENTS` and imported within async_setup or other functions (lazy import) so dependency installation is managed by HA and imports don’t run before requirements are installed.\n\n4. **Time-based emulated device state**:\n   - When hardware does not expose granular state (e.g., percentage for blinds), some developers emulate state by combining total movement time (`move_time`) with periodic timers to estimate current position. This involves using a consistent polling interval (LISTEN_INTERVAL), computing the percentage delta per tick, and updating an internal `_position` until the target is reached.\n   - However, Home Assistant core policy discourages simulated state in integrations. The recommended approach is for integrations to expose only the data the device actually provides (binary open/closed). Complex behaviors (\"go to 50%\") should be implemented via automations in the user’s configuration (e.g., trigger open, wait X seconds, then stop). Integrations that simulate state risk becoming inconsistent or brittle.\n\n5. **Direction reversal and behavioral wrappers**:\n   - For hardware where install orientation may be inverted, it’s cleaner to centralize direction logic in helper methods (e.g., `mylink_open_cover` and `mylink_close_cover`) that interpret a `reverse` flag and call the appropriate underlying up/down API. This keeps higher-level methods like `async_open_cover` and `async_close_cover` simple and reduces duplication.\n\n6. **Discovery info and guarding platform setup**:\n   - When loading platforms via `async_load_platform`, configuration is passed via `discovery_info`. Within `async_setup_platform`, you should guard against `discovery_info` being `None` to prevent setup from running when not explicitly configured.\n\n7. **External API wrappers vs in-component logic**:\n   - Home Assistant prefers that protocol and API handling be moved to an external library (e.g., `somfy-mylink-synergy`) rather than embedded raw socket/JSON handling within the component. This improves testability, reuse, and separation of concerns.\n\nOverall, the main pattern is: design integrations to be async, to have clear configuration structures and per-entity overrides, to use RestoreEntity for state persistence, and to align with project-wide architectural policies (e.g., avoiding simulated state inside integrations).",
        "procedural_memory": [
            "How to diagnose and fix Home Assistant entities losing state on restart, and implement a robust custom integration with per-entity options:",
            "Step 1: Reproduce and confirm the state-loss issue.\n- Restart Home Assistant and observe whether entities (e.g., covers) revert to default state or lose information such as current position.\n- Confirm via the UI and logs that the entity is initialized with default values rather than the last known values.",
            "Step 2: Use RestoreEntity for state persistence.\n- Make your entity class inherit from `RestoreEntity` in addition to its base (e.g., `class MyCover(CoverDevice, RestoreEntity):`).\n- Implement `async_added_to_hass`:\n  - Start with `await super().async_added_to_hass()` to let the base class perform its setup.\n  - Call `state = await super().async_get_last_state()` (or the current API equivalent) to fetch the last persisted state.\n  - If `state` is not None, restore your internal fields:\n    - Interpret `state.state` (e.g., 'open', 'closed') to set `_closed`, `_is_opening`, `_is_closing` as appropriate.\n    - Read attributes (e.g., `state.attributes.get('current_position')`) to restore `_position` or other numeric states.\n  - Avoid restoring if `_state` is already set (to prevent double-initialization).",
            "Step 3: Design a clean per-entity configuration structure.\n- Instead of lists of options, define an `entity_config` mapping in the integration’s CONFIG_SCHEMA:\n  - Example keys: `move_time`, `reverse`.\n  - Implement a validator (`validate_entity_config`) that:\n    - Verifies the input is a dict.\n    - Validates each key as a valid entity_id.\n    - Validates each value with a nested schema (e.g., `vol.Optional(CONF_MOVE_TIME): vol.Coerce(float)`).\n- Add optional top-level defaults to the config (e.g., `default_move_time`, `default_reverse`) and, in async_setup, merge those into `entity_config` under a `default` key so platforms can easily apply them.",
            "Step 4: Implement async setup and platform loading.\n- Define `async_setup(hass, config)` for the main integration:\n  - Import your external library inside the function (lazy import).\n  - Instantiate the client (e.g., `SomfyMyLinkSynergy(system_id, host, port)`).\n  - Handle connection errors and log user-friendly messages; return False if setup fails.\n  - Save the client in `hass.data[DATA_MY_DOMAIN]` for use by platforms.\n  - For each platform (e.g., 'cover', 'scene'), call `hass.async_create_task(async_load_platform(hass, platform, DOMAIN, entity_config_or_discovery_info, config))`.\n- In each platform module (`cover/my_integration.py`, `scene/my_integration.py`), implement `async_setup_platform(hass, config, async_add_entities, discovery_info=None)` and guard with `if discovery_info is None: return`.",
            "Step 5: Wire per-entity config into entity creation.\n- When creating entities in `async_setup_platform`:\n  - Fetch the shared client from `hass.data[DATA_MY_DOMAIN]`.\n  - For each discovered device from the hub’s API, derive its entity_id (e.g., `cover.{slugify(device_name)}`) and build a config dict:\n    - Start from `config_options.get('default', {})` for defaults.\n    - Overlay `config_options.get(entity_id, {})` to apply per-entity overrides.\n  - Pass this merged config into the entity constructor (e.g., `move_time`, `reverse`, `device_class`).",
            "Step 6: Implement direction reversal via helper methods.\n- Inside the entity class, add wrapper methods such as `async def mylink_open_cover(self):` and `async def mylink_close_cover(self):` that:\n  - Check a `self._reverse` flag.\n  - Call the appropriate underlying API method (`move_up` or `move_down`) based on that flag.\n- In `async_open_cover` and `async_close_cover`, call these helper methods rather than directly calling the hub client, so reversal logic is centralized.",
            "Step 7: Implement optional time-based position emulation (if allowed by project policy).\n- Define a `move_time` configuration option representing full-travel time in seconds.\n- When handling `async_set_cover_position`, if `move_time` is non-zero:\n  - Compute current-to-target difference in percentage.\n  - Calculate the move duration for that difference: `duration = move_time * abs(diff) / 100`.\n  - Set `_requested_closing` based on whether the target is less than current.\n  - Trigger physical motion via `mylink_open_cover` or `mylink_close_cover`.\n  - Use `async_track_time_change` with a LISTEN_INTERVAL to periodically adjust `_position` by `int(100 / move_time * LISTEN_INTERVAL)` until the target is reached.\n  - Stop motion by calling `async_stop_cover` when the target is reached or when at endpoints.\n- Note: For Home Assistant core, double-check architecture guidelines before shipping simulated state; this pattern might be better left to user automations.",
            "Step 8: Ensure asynchronous patterns and non-blocking behavior.\n- Use async versions of entity methods (`async_open_cover`, `async_close_cover`, `async_stop_cover`, `async_update`, etc.).\n- Avoid blocking I/O in these methods; any operations that call out to the external library must either be async or delegated to the executor if the library is sync.\n- Use `async_track_time_change` instead of blocking `time.sleep` for periodic tasks.",
            "Step 9: Polish integration quality (logging, coverage, ownership).\n- Set log level appropriately: use `_LOGGER.debug` for verbose or repeated logs (e.g., periodic position updates) and `_LOGGER.info` / `_LOGGER.error` for key events and failures.\n- Update `.coveragerc` to omit the integration if tests are not yet present, or add tests to cover logic.\n- Add CODEOWNERS entries for the integration so maintainers are automatically requested in future PRs.",
            "Step 10: Align with project architecture and policies.\n- Before introducing simulated capabilities or significant behavioral enhancements not backed by the device, check the project’s architecture documentation or open an issue in the architecture repo.\n- Be prepared for maintainers to require that integrations expose only true device state and leave enhancements (like time-based percentage simulation) to user automations or separate generic helper components."
        ]
    }
}
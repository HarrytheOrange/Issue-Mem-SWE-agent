{
    "search_index": {
        "description_for_embedding": "Home Assistant Velbus integration added and iteratively fixed: a new core velbus component exposes a shared python-velbus Controller via hass.data[DOMAIN], and platform modules (light, switch, fan, cover, binary_sensor) subscribe to bus messages and send commands. Multiple bugs and style issues were resolved, including incorrect config schema handling, wrong hass vs self.hass usage, incorrect domain imports, duplicated requirements, and fan speed / cover logic.",
        "keywords": [
            "Home Assistant",
            "Velbus",
            "python-velbus",
            "serial bus integration",
            "hass.data[DOMAIN]",
            "CONFIG_SCHEMA",
            "PLATFORM_SCHEMA",
            "binary_sensor.velbus",
            "light.velbus",
            "switch.velbus",
            "fan.velbus",
            "cover.velbus",
            "async_added_to_hass",
            "Controller.subscribe",
            "requirements_all.txt duplicate",
            "style fix",
            "travis lints",
            "event-driven hardware integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, a full Velbus integration was introduced into Home Assistant, along with a series of follow-up fixes and refactors.\n\nInitially, the author added a new core component `homeassistant/components/velbus.py` that connected to a Velbus USB serial port via the `python-velbus` library and exposed a `Controller` instance in `hass.data['VelbusController']`. Early versions used an event-dispatcher pattern (`VELBUS_MESSAGE` via `async_dispatcher_send`) and per-platform async setup with discovery payloads. Over time this was simplified to a synchronous `setup` that stores the controller in `hass.data[DOMAIN]` (`DOMAIN = 'velbus'`) and registers a `stop_velbus` listener on `EVENT_HOMEASSISTANT_STOP` to cleanly stop the serial connection.\n\nPlatform modules were added for:\n- `binary_sensor.velbus` – pushbutton/binary inputs, with optional `is_pushbutton` behavior that only toggles on 'closed' events.\n- `light.velbus` – relay lights with per-device module & channel configuration.\n- `switch.velbus` – generic relay switches.\n- `fan.velbus` – fans mapped to three discrete relay channels (low/medium/high) with logic to interpret channel combinations into a speed state and issue correct on/off sequences.\n- `cover.velbus` – covers (e.g., blinds) controlled by two relay channels (open/close), using short delays between relay operations and providing open/close/stop support.\n\nEarly versions of each platform directly accessed `hass.data['VelbusController']`, imported their own `REQUIREMENTS`, used async dispatcher, or duplicated configuration patterns. Pascal Vizeli then refactored them for consistency and style:\n- All platform modules now depend on the core `velbus` component (`DEPENDENCIES = ['velbus']`) and retrieve the controller via `hass.data[DOMAIN]` using `from homeassistant.components.velbus import DOMAIN`.\n- `async_added_to_hass` in each entity now wraps Velbus initialization in an `_init_velbus` function, scheduled via `yield from self.hass.async_add_job(_init_velbus)`. This function calls `controller.subscribe(self._on_message)` and sends an initial `ModuleStatusRequestMessage` to populate state.\n- Several bugs were fixed: using `self.hass` inside `setup_platform` (corrected to `hass`), using wrong module `homeassistant.components.velus` instead of `velbus`, a typo in `_open_channel_State` vs `_open_channel_state`, and fan speed interpretation logic (the meaning of medium and high in terms of which channels must be on/off).\n- The Velbus library version was incrementally updated to `python-velbus==2.0.11`, and `requirements_all.txt` was regenerated so that Velbus requirements are declared once under the `velbus` component, rather than per-platform or duplicated.\n- Cover configuration changed from a generic multi-type switch to a dedicated `cover.velbus` with its own schema (`CONF_COVERS`, `CONF_NAME`, `module`, `open_channel`, `close_channel`), removing the earlier overloaded 'double switch' concept from the switch platform.\n- Documentation URLs in module docstrings were corrected to point to the platform-specific pages (e.g., `/components/light.velbus/`, `/components/switch.velbus/`, etc.).\n\nTravis and linting runs surfaced several style and API-usage issues (unused imports, incorrect callback decorators, unnecessary constants, wrong return types or extra `return True`, subscription patterns), which were iteratively resolved. The final state is a coherent Velbus integration: the core component owns the serial connection, platform entities subscribe to bus messages and send commands through the shared controller, and configuration is validated with consistent `CONFIG_SCHEMA`/`PLATFORM_SCHEMA` patterns.",
        "semantic_memory": "This PR illustrates several general best practices for integrating a hardware bus or gateway into Home Assistant and for cleaning up API and style issues in component code:\n\n1. **Central controller via hass.data[DOMAIN]**\nInstead of each platform opening its own connection (or stashing an ad-hoc object in `hass.data['SomeString']`), define a core component (e.g., `velbus`) that owns the external connection and exposes a reusable controller via `hass.data[DOMAIN]`. All dependent platforms (light, switch, sensor, etc.) declare `DEPENDENCIES = ['velbus']` and access the shared controller. This avoids duplicate connections, makes teardown predictable, and centralizes error handling.\n\n2. **Use CONFIG_SCHEMA for main components, PLATFORM_SCHEMA for platforms**\nMain integrations that appear in `configuration.yaml` under their domain should define `CONFIG_SCHEMA` keyed by `DOMAIN`, while entity platforms (e.g., `light.velbus`) should extend their base `PLATFORM_SCHEMA` with per-device configuration (`CONF_DEVICES` / `CONF_COVERS`, etc.). This separates gateway-level configuration (port, credentials) from entity-level configuration (module ID, channels, friendly name).\n\n3. **Asynchronous initialization of subscriptions and initial state**\nEntity classes should attach to external event streams in `async_added_to_hass`. If the external library uses blocking or synchronous APIs, you can wrap subscription and initial status requests in a helper function (`_init_velbus`) and schedule it with `yield from hass.async_add_job(...)`. This ensures that subscription occurs after the entity is fully registered, and initial state is fetched without blocking the event loop.\n\n4. **Direct use of external controllers rather than Home Assistant dispatcher when not needed**\nIf the underlying library already provides a subscription mechanism (e.g., `controller.subscribe(callback)`), you don't necessarily need to wrap this in Home Assistant's dispatcher or event bus. You can subscribe directly and simply translate library events into entity state updates (`schedule_update_ha_state()`), reducing indirection and complexity.\n\n5. **Mapping multi-channel hardware states into HA entities**\nFor devices like fans and covers implemented via multiple relay channels, encode the relationship between channels and logical state in well-defined helper methods (e.g., `_is_off`, `_is_low`, `_is_medium`, `_is_high` for fans). This makes it easier to reason about and fix logic bugs (such as misinterpreting which channels must be on for a 'medium' speed), and simplifies the `set_speed` / `open_cover` / `close_cover` logic.\n\n6. **Consistent error/stylistic fixes across platforms**\nCommon sources of breakage in HA platforms include:\n- Using `self.hass` in module-level functions instead of the `hass` argument (e.g., in `setup_platform`).\n- Importing incorrect modules or domains (`velus` vs `velbus`).\n- Duplicating dependencies in `requirements_all.txt` or per-platform `REQUIREMENTS`. The current HA pattern is to put library requirements on the main component and let platforms depend on the component.\n- Using `@callback` unnecessarily for methods not registered with HA as callbacks, or forgetting to remove async/sync mismatches when refactoring.\nBy aligning all platforms to a single pattern, maintenance and correctness improve.\n\n7. **Graceful shutdown**\nWhen integrating with long-lived resources like serial ports, always register an `EVENT_HOMEASSISTANT_STOP` listener in the main component to close the connection cleanly. This is important for avoiding resource leaks and ensuring external hardware returns to a known state.\n\nThese patterns are broadly applicable to any integration that:\n- Talks to an external gateway or serial bus.\n- Has multiple entity platforms sharing one connection.\n- Needs to subscribe to asynchronous events and track device state in HA.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Design the integration architecture\n- Decide on a central domain component (e.g., `velbus`) that owns the external connection or client object.\n- Define `DOMAIN` and `CONFIG_SCHEMA` for gateway-level config (e.g., serial `CONF_PORT`, host/credentials).\n- Ensure this component exposes a controller object through `hass.data[DOMAIN]` for reuse by all entity platforms.",
            "Step 2: Implement the core component\n- In `components/<domain>.py`, import and initialize the external library (e.g., `velbus.VelbusUSBConnection(port)`, `velbus.Controller(connection)`).\n- Store the controller in `hass.data[DOMAIN]` so it’s accessible to other modules.\n- Register an `EVENT_HOMEASSISTANT_STOP` listener that stops or closes the connection.\n- Add the library to `REQUIREMENTS` in the component and ensure it appears exactly once in `requirements_all.txt` (use the project’s generation script if available).",
            "Step 3: Define platform schemas and config\n- For each platform (light, switch, fan, cover, binary_sensor), extend the appropriate `PLATFORM_SCHEMA`.\n- Use per-device lists or mappings, e.g.: `vol.Required(CONF_DEVICES): vol.All(cv.ensure_list, [device_schema])` or `CONF_COVERS: vol.Schema({cv.slug: COVER_SCHEMA})`.\n- Keep platform configs focused on device characteristics (module ID, channels, friendly name).",
            "Step 4: Implement setup_platform correctly\n- In each platform’s `setup_platform(hass, config, add_entities, discovery_info=None)`:\n  - Retrieve the shared controller: `velbus = hass.data[DOMAIN]`.\n  - Instantiate your entity classes with device configs and the controller: `entities.append(MyEntity(device, velbus))`.\n  - Call `add_entities(entities)`; avoid using `self.hass` here (there is no `self`).",
            "Step 5: Initialize entities and subscribe to events\n- In each entity class, implement `async_added_to_hass`:\n  - Define an inner function `_init_client()` that:\n    - Calls `controller.subscribe(self._on_message)` or equivalent.\n    - Sends initial status requests (`ModuleStatusRequestMessage`, etc.) so that the entity starts with the correct state.\n  - Schedule that function with `yield from self.hass.async_add_job(_init_client)` to avoid blocking the event loop.\n- Do not subscribe at import time or in the constructor; always wait until the entity is added to HA.",
            "Step 6: Handle incoming messages and update state\n- Implement an `_on_message(self, message)` method per entity that:\n  - Checks whether the message type and addressing (module/channel) apply to this entity.\n  - Updates internal state attributes accordingly (e.g., `_state`, `_channels_state`, `_close_channel_state`, `_open_channel_state`).\n  - Calls `self.schedule_update_ha_state()` to trigger HA’s state machine update.\n- If mapping multiple hardware channels to one entity (fans, covers), encapsulate your logic in helpers like `_is_off`, `_is_low`, `_is_medium`, `_is_high` or compute open/closed from per-channel states.",
            "Step 7: Implement control methods using the shared controller\n- For actuators, implement `turn_on`, `turn_off`, `set_speed`, `open_cover`, `close_cover`, `stop_cover`, etc.:\n  - Construct the appropriate message instances (e.g., `SwitchRelayOnMessage`, `SwitchRelayOffMessage`, `ModuleStatusRequestMessage`).\n  - Set module and channel fields (`set_defaults(self._module)`, `relay_channels`, `channels`).\n  - Send messages via the shared controller: `self._velbus.send(message)`.\n- Avoid calling back into `hass.data['Something']` from inside entities; use the controller passed in at construction.",
            "Step 8: Fix common style and API issues\n- Avoid using `self.hass` in module-level `setup_platform` or `setup` – use the `hass` argument.\n- Ensure imports are accurate (`from homeassistant.components.velbus import DOMAIN` not `velus`).\n- Remove unused imports (`callback`, `time`, etc.) and unused constants.\n- Only decorate with `@callback` when you are defining a function that HA may schedule inline and you guarantee it doesn’t block.\n- Use meaningful docstrings and correct documentation URLs in module headers (`https://home-assistant.io/components/light.velbus/` etc.).",
            "Step 9: Validate requirements and configuration\n- Run the project’s requirements generation script (e.g., `script/gen_requirements_all.py`) and ensure the external library shows up once in `requirements_all.txt` under the main component.\n- Verify that your `CONFIG_SCHEMA` and `PLATFORM_SCHEMA` validate typical example configurations from documentation.\n- Add or update docs to match the final configuration format (e.g., `velbus: port: '/dev/ttyUSB0'` plus per-platform `devices` or `covers`).",
            "Step 10: Test and iterate on logic bugs\n- Write or run existing tests to ensure that entity states change correctly on simulated messages and that commands send the expected messages.\n- For multi-channel devices, test combinations (e.g., turning fan to LOW, MEDIUM, HIGH and OFF) and verify that channel on/off patterns match the hardware specification.\n- For covers, verify that open/close/stop operations do not leave relays in conflicting states and that short delays (if needed) are applied correctly.\n- Fix any discovered issues (e.g., wrong speed mapping, typos in attribute names) and re-run tests and linters until CI passes."
        ]
    }
}
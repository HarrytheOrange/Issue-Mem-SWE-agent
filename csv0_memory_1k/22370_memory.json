{
    "search_index": {
        "description_for_embedding": "Home Assistant config component cleanup: stop adding config sub-panels (e.g., 'config.zwave') to hass.config.components and update tests that depended on this behavior. The system now relies solely on EVENT_COMPONENT_LOADED to signal panel availability instead of duplicating state in hass.config.components.",
        "keywords": [
            "Home Assistant",
            "hass.config.components",
            "config panels",
            "config.zwave",
            "EVENT_COMPONENT_LOADED",
            "frontend integration",
            "state duplication",
            "test update",
            "component loaded tracking",
            "refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant project had legacy behavior where configuration sub-panels (e.g., the Z-Wave config panel) were being added into hass.config.components as pseudo-components under names like 'config.zwave'. This was originally used by the frontend to detect which config panels were available. Over time, the frontend stopped relying on this specific mechanism and instead could determine availability based on whether the actual component (e.g., 'zwave') was loaded, combined with component-loaded events.\n\nThe remaining code in homeassistant/components/config/__init__.py still added these pseudo-component names to hass.config.components after successfully setting up a config panel:\n\n  key = '{}.{}'.format(DOMAIN, panel_name)\n  hass.bus.async_fire(EVENT_COMPONENT_LOADED, {ATTR_COMPONENT: key})\n  hass.config.components.add(key)\n\nThe PR removed the line that added these keys to hass.config.components, leaving only the EVENT_COMPONENT_LOADED firing. This aligned the internal state with current usage and removed unnecessary state duplication.\n\nHowever, there were tests in tests/components/config/test_init.py that explicitly asserted 'config.zwave' in hass.config.components, reflecting the old behavior. Once the line was removed, these tests started failing. After discussion (including confirmation from a maintainer that the old behavior is no longer required), the fix was to update the tests by removing the assertions that checked for 'config.zwave' in hass.config.components. The tests still verify that the setup function is called (stp.called), but no longer rely on the obsolete side-effect.\n\nNet result: config panels no longer mutate hass.config.components with synthetic entries; availability is indicated via the component-loaded event and the real component state, and the tests are updated accordingly.",
        "semantic_memory": "This change illustrates a broader pattern: when a system evolves, legacy mechanisms for signaling state to other layers (such as a frontend) can become obsolete and should be cleaned up to avoid unnecessary complexity and state duplication.\n\nKey concepts:\n1. **Avoid duplicating state when a single authoritative mechanism exists.**\n   If there is an event bus (like EVENT_COMPONENT_LOADED) that already indicates when something is loaded, maintaining a second parallel data structure (hass.config.components containing synthetic entries like 'config.zwave') is redundant and prone to drift. Removing the duplicate state reduces maintenance burden and confusion.\n\n2. **Frontend/backend contracts can change; tests must reflect current, not historical, behavior.**\n   Behavior that existed solely to satisfy a frontend contract may no longer be necessary once the frontend is updated. When backend code is cleaned up, tests that encode the old contract as assertions must be updated or removed; otherwise they will prevent legitimate refactors.\n\n3. **Prefer checking real component state over synthetic, derived identifiers.**\n   Using 'config.zwave' as a pseudo-component name is more fragile than simply checking if 'zwave' is loaded and using standardized events. Real component names are less likely to be special-cased and easier to reason about than composed identifiers representing sub-features.\n\n4. **Tests should assert stable, meaningful behavior, not incidental implementation details.**\n   The important behavior here is that the config panel is set up and that the appropriate events are fired or side-effects occur (e.g., the setup callback is called). Asserting that hass.config.components contains a very specific synthetic key ties the tests to an internal implementation detail that was never intended as a long-term API.\n\nOverall best practice: when refactoring state tracking, minimize public or semi-public surfaces (like global sets) and prefer events and clear, documented APIs. When such refactors happen, align tests with the new design rather than preserving checks for no-longer-used side effects.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify legacy or redundant state-tracking mechanisms.",
            "Inspect the code for places where state is being stored in multiple locations (e.g., an event bus plus a separate set/list of component names). Determine which of these are actually consumed by other parts of the system (frontend, other services, integrations).",
            "Step 2: Confirm current consumers and contracts.",
            "Search the codebase (and closely related repositories, such as frontend code) for references to the legacy pattern (e.g., 'config.zwave' or similar synthetic keys). Confirm whether the mechanism is still required. Check issues/PR discussions or ask maintainers if the pattern is still a supported contract.",
            "Step 3: Decide on the single source of truth.",
            "Choose one authoritative mechanism for signaling state (e.g., an event like EVENT_COMPONENT_LOADED or a well-defined API to check if a component is loaded). Plan to remove or deprecate redundant state (e.g., adding synthetic entries to hass.config.components) that is no longer necessary.",
            "Step 4: Remove the redundant state mutation.",
            "Modify the code to stop updating the redundant state. In this case, remove calls such as hass.config.components.add(key) when key is a synthetic or legacy identifier that is not needed anymore. Ensure the primary signaling mechanism (events, official APIs) is still invoked.",
            "Step 5: Run tests and identify failures tied to old behavior.",
            "Run the full test suite. Examine failing tests for assertions that reference the removed behavior (e.g., assert 'config.zwave' in hass.config.components). These tests typically encode expectations for the old, now-deprecated behavior.",
            "Step 6: Update tests to assert meaningful behavior instead of implementation details.",
            "Refactor the failing tests so they validate the behavior that still matters: for example, that the setup function is called, that the component-loaded event is fired, or that the real component is loaded. Remove or adjust assertions that depend on obsolete internal state (such as synthetic component names).",
            "Step 7: Re-run tests and validate.",
            "Run tests again to ensure they pass. Verify that the removal did not unintentionally break real consumers (e.g., manual testing of the frontend to confirm config panels still appear and behave correctly).",
            "Step 8: Document the refactor and rationale.",
            "Document that the legacy pattern (e.g., adding 'config.*' entries to hass.config.components) is deprecated and removed, and that consumers should rely on the real component state and events. This helps future contributors avoid reintroducing similar redundant state or tests based on outdated behavior."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fixes the PokemonGo-Bot SpinFort task so it respects a local fort timeout cache instead of (or in addition to) server cooldown timestamps, preventing the bot from repeatedly attempting to spin the same fort after errors/softbans. Also includes minor PEP8 cleanups and clearer logging for database-backed spin and softban logs.",
        "keywords": [
            "SpinFort",
            "spin fort task",
            "pokestop",
            "cooldown",
            "fort_timeouts",
            "softban",
            "daily spin limit",
            "PokemonGo-Bot",
            "get_forts_in_range",
            "logic bug",
            "task worker",
            "Python",
            "PEP8"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the PokemonGo-Bot's SpinFort cell worker had faulty logic in how it selected which forts (Pok√©Stops) to spin. The `get_forts_in_range` function filtered forts only by their `cooldown_complete_timestamp_ms` timestamp from the server:\n\n- It computed `now = time.time() * 1000` and then used `filter(lambda x: x.get('cooldown_complete_timestamp_ms', 0) < now, forts)`.\n- There was a commented-out filter intended to skip forts listed in `self.bot.fort_timeouts` (a local cache of forts that should not be spun for a while, typically after errors or suspected softbans).\n\nAs a result, even if the bot had marked a fort in `self.bot.fort_timeouts` (e.g., after detecting a likely softban or repeated failure), `get_forts_in_range` would ignore that local timeout and still consider the fort eligible to spin as long as its server cooldown had expired. This caused the bot to repeatedly attempt to spin the same problematic fort, which is undesirable behavior and could exacerbate softban-like situations.\n\nThe fix changes `get_forts_in_range` to filter forts by the `fort_timeouts` cache instead of the server cooldown timestamp:\n\n- Old behavior:\n  - Compute `now` and filter by `cooldown_complete_timestamp_ms < now`.\n  - `fort_timeouts` filtering was commented out and not used.\n- New behavior:\n  - Remove the `now` calculation and cooldown-based filter.\n  - Use `filter(lambda fort: fort[\"id\"] not in self.bot.fort_timeouts, forts)` so forts currently in the timeout cache are skipped entirely.\n\nThe rest of the logic that sets `self.bot.fort_timeouts[fort[\"id\"]] = (time.time() + 300) * 1000` after certain error responses (e.g., when detecting a possible softban) now works as intended, preventing spins on that fort for 5 minutes.\n\nAdditionally, the patch cleans up some PEP8 issues and improves logging around database-backed tables:\n\n- Removes unused imports (`json`, `os`, `base_dir._base_dir`).\n- Normalizes spacing in the daily spin-limit query and condition.\n- Simplifies `emit_event` calls for `pokestop_log` and `softban_log` when tables are missing, making them more readable while preserving behavior.\n\nOverall, this PR fixes the practical bug of SpinFort repeatedly hitting forts that should be temporarily blacklisted, making spin behavior safer and more human-like, while also doing minor style and logging improvements.",
        "semantic_memory": "The generalizable lesson from this fix is that cooldown and retry/ban-avoidance logic must be consistent and use the same canonical source of truth for 'do not touch this resource right now.' In a system that interacts repeatedly with remote resources (like game entities, APIs, or data endpoints), multiple mechanisms may exist to delay or block access (server timestamps, local timeout caches, softban detection, etc.). If these mechanisms are not wired into the main selection/filtering logic, the system can repeatedly hammer resources that it was intended to avoid.\n\nKey concepts:\n\n1. **Single, consistent gating logic**: When deciding whether to act on a resource (spin a fort, call an API, requeue a job), all relevant conditions (server cooldown, local ban/timeout, rate limits) should be applied in the same path that chooses eligible targets.\n\n2. **Respect error-based blacklists/timeouts**: If the system detects possible bans, rate limits, or repeated failures for an entity, it should store that state (e.g. in a `fort_timeouts` map) and the main worker should consult that state before acting again.\n\n3. **Avoid dead code and mismatched filters**: A commented-out filter using `fort_timeouts` was present but not active; meanwhile, the code relied solely on the cooldown timestamp. This mismatch between intention (avoid certain forts) and implementation (only cooldown-based filtering) caused the bug. In general, ensure that your code reflects current design decisions, and remove or re-enable logic explicitly, not via comments.\n\n4. **Database logging should be guarded by existence checks**: While not fully refactored here, the code pattern highlights the importance of checking for a table's existence before performing queries or inserts, and emitting clear events when skipping such logging. Robust logging should fail gracefully if the database schema is incomplete.\n\n5. **PEP8 and readability support correctness**: Small cleanups (better spacing, removing unused imports, simplifying event calls) reduce noise and make it easier to spot actual logic errors like a missing filter.\n\nThese patterns are broadly applicable in systems involving rate limits, retries, or per-resource cooldowns, such as API clients, web scrapers, bots, and task queues.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom\n- Observe what the worker/task is doing at runtime (logs, behavior). For a spin or retry worker, symptoms might include repeatedly acting on the same resource (e.g., same endpoint or object) despite supposed cooldown or softban logic.\n- Check whether there are logs mentioning softbans, rate limits, or timeouts but the worker continues to hit the same target.",
            "Step 2: Locate selection/filtering logic\n- Find the function that selects which resources to act on (e.g., `get_forts_in_range`, `get_next_request`, `choose_target`).\n- Inspect all filters applied to the resource list: time-based cooldowns, error-based blacklists, distance/range filters, etc.\n- Look for commented-out filters or conditions that seem relevant but are not active.",
            "Step 3: Trace where and how cooldown/ban state is stored\n- Search for structures like `*_timeouts`, `blacklist`, `softban_cache`, or `rate_limit_state`.\n- Identify where these structures are written to (e.g., when the system detects an error, softban-like response, or rate limit).\n- Confirm what data they store (e.g., resource ID to timestamp) and the intended semantics (how long to avoid resource).",
            "Step 4: Ensure selection logic uses the stored state\n- If there is a local cache (like `fort_timeouts`) meant to prevent access to certain resources, ensure the main selection function consults it.\n- Add or fix filters accordingly. For example:\n  - Before fix: `filter(lambda x: x.get('cooldown_complete_timestamp_ms', 0) < now, resources)`\n  - After fix: `filter(lambda r: r['id'] not in self.bot.fort_timeouts, resources)` or combine both conditions if needed.\n- Remove or uncomment outdated/mismatched code so that only current, intended logic is in play.",
            "Step 5: Decide on precedence between server cooldowns and local timeouts\n- Determine whether server-provided cooldown timestamps, local timeout caches, or both should gate access.\n- Implement a clear priority rule, e.g.:\n  - First, skip anything in `local_timeouts`.\n  - Then, skip anything whose server cooldown has not expired.\n- Encode this rule explicitly in the filter to avoid future confusion.",
            "Step 6: Add or refine logging around blacklist/timeout decisions\n- When a resource is added to a timeout/blacklist (e.g., due to a suspected softban), log the action with the resource identifier and duration.\n- When skipping a resource due to timeout, optionally log at debug level to aid future debugging.",
            "Step 7: Verify database-backed logging (if present)\n- If the workflow logs to a database (e.g., spin logs, softban logs), ensure it checks for table existence before performing inserts or selects.\n- Pattern:\n  - Query `sqlite_master` (or equivalent) to check if the table exists.\n  - If not, emit an `emit_event` or log message and skip logging instead of crashing.\n- Confirm that queries that assume the table exists are not run before the existence check.",
            "Step 8: Clean up style issues that obscure logic\n- Remove unused imports to reduce clutter and avoid confusion about unused features.\n- Fix basic style issues (spacing, long chained calls) so that logic branches and filters are easier to read.\n- Simplify multi-line logging calls where possible while keeping them clear.",
            "Step 9: Test the behavior under realistic scenarios\n- Simulate or reproduce situations that trigger local timeouts (e.g., force the error path that sets `fort_timeouts` or a blacklist entry).\n- Run the worker and confirm:\n  - The resource is not selected while it is in the timeout cache.\n  - After the timeout expires (or is cleared), the resource can be selected again.\n- Check that no unexpected crashes occur when database tables for logging are missing.",
            "Step 10: Document the intended behavior\n- Add comments or short documentation explaining the role of the timeout/blacklist structure and how it interacts with server cooldowns.\n- Note how long resources remain blocked and what conditions clear them, so future contributors don't reintroduce inconsistent filtering."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant HomematicIP Cloud integration: add new component-level services to control eco and vacation modes (activate/deactivate by duration or end time, optional accesspoint_id for multi-AP setups). Implemented service schemas, async handlers, and services.yaml definitions using HomematicIP home API (activate_absence, activate_vacation, deactivate_absence, deactivate_vacation).",
        "keywords": [
            "Home Assistant",
            "HomematicIP Cloud",
            "climate",
            "eco mode",
            "vacation mode",
            "component services",
            "services.yaml",
            "accesspoint_id",
            "hap",
            "home.activate_absence_with_duration",
            "home.activate_absence_with_period",
            "home.activate_vacation",
            "home.deactivate_absence",
            "home.deactivate_vacation",
            "voluptuous schema",
            "multi-access-point setup",
            "integration feature"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The HomematicIP Cloud integration in Home Assistant lacked a way to control eco (absence) and vacation modes at the access point level. These modes are not exposed on individual climate entities, so users could not enable or disable them through standard entity services. This PR implemented five new component-level services under the homematicip_cloud domain: activate_eco_mode_with_duration, activate_eco_mode_with_period, activate_vacation, deactivate_eco_mode, and deactivate_vacation.\n\nThe implementation introduced constants for service names and attributes (duration, endtime, temperature, accesspoint_id) and defined voluptuous schemas to validate input:\n- duration: positive integer (minutes)\n- endtime: datetime\n- temperature: float 0–55°C with default 18.0\n- accesspoint_id: optional 24-character string.\n\nEach service has an async handler registered via hass.services.async_register in the integration's async_setup function. The handlers either operate on a specific access point (if accesspoint_id is provided) by resolving it from hass.data[DOMAIN][accesspoint_id].home via a helper _get_home, or operate on all configured access points by iterating over hass.data[DOMAIN] and calling the relevant home methods:\n- activate_absence_with_duration(duration)\n- activate_absence_with_period(endtime)\n- activate_vacation(endtime, temperature)\n- deactivate_absence()\n- deactivate_vacation().\n\nA brief naming detour occurred: the parameter was initially called accesspoint_id, then renamed to hapid for consistency with config, but that change was reverted after discussion because accesspoint_id is more user-friendly and matches what users see in the integration UI and on the physical AP label. The final version uses accesspoint_id everywhere (code schemas and services.yaml).\n\nservices.yaml was added for homematicip_cloud, describing each service, its fields, and example values. This enables UI service documentation and use in automations. The end result is that users can now globally control eco and vacation modes for all or specific Homematic IP Access Points via Home Assistant services, even though these modes are not represented as separate entities.",
        "semantic_memory": "When an integration needs to control behavior that is not modeled as an entity (for example, hub-level or access point–level modes), Home Assistant best practice is to add component-level services rather than forcing awkward entity mappings. These services should:\n\n- Be defined as constants (both service names and attribute names) to avoid magic strings and to keep references consistent.\n- Use voluptuous schemas to validate input types, ranges, and formats (e.g., cv.positive_int, cv.datetime, vol.Coerce(float), vol.Range, string length constraints for IDs).\n- Support multi-instance setups by allowing an optional identifier (like accesspoint_id) and, if absent, applying the operation to all instances managed under hass.data[DOMAIN].\n- Keep service handlers async and leverage underlying API objects (here, the HomematicIP home object) to perform real operations.\n- Be documented in services.yaml to expose clear descriptions, field docs, and examples in the frontend and for users writing automations.\n\nA secondary lesson is that parameter naming must balance internal consistency with user-facing clarity. Although short internal identifiers (like hapid) might seem consistent with configuration keys, terms that match what users actually see (like accesspoint_id, printed on hardware or shown in UI) are preferable for service arguments. This reduces confusion and makes automation authoring more accessible.\n\nOverall, the pattern is: for hub-level modes that affect groups of devices and are not per-entity, implement component-level services, validate them well, and make them discoverable and understandable through services.yaml.",
        "procedural_memory": [
            "How to add new Home Assistant integration services for hub-level (non-entity) features:",
            "Step 1: Identify the missing capability and its scope.\n- Determine if the behavior is per-entity or hub/access-point–level. If it cannot reasonably map to a single entity (e.g., eco/vacation mode affecting many climate devices), plan to expose it as a component-level service.",
            "Step 2: Define service and attribute constants.\n- In the integration's __init__.py or constants module, add constants for service names (e.g., SERVICE_ACTIVATE_VACATION) and attribute keys (e.g., ATTR_DURATION, ATTR_ENDTIME, ATTR_TEMPERATURE, ATTR_ACCESSPOINT_ID). This avoids duplicated magic strings throughout the codebase.",
            "Step 3: Design and implement voluptuous schemas.\n- For each service, define a SCHEMA_<SERVICE_NAME> using vol.Schema.\n- Use appropriate validators:\n  - cv.positive_int for durations in minutes.\n  - cv.datetime for timestamps/end times.\n  - vol.Coerce(float) + vol.Range(min=..., max=...) for numeric fields like temperatures.\n  - vol.All(str, vol.Length(min=..., max=...)) for ID strings (e.g., 24-char accesspoint_id).\n- Make instance identifiers (like accesspoint_id) optional to allow a default \"all instances\" behavior when omitted.",
            "Step 4: Access integration instances from hass.data.\n- Ensure your integration stores instance objects (e.g., access points or hub wrappers) in hass.data[DOMAIN][instance_id].\n- Implement a small helper like _get_home(instance_id) that looks up the instance, returns the underlying API object (e.g., hap.home), or None if not found.",
            "Step 5: Implement async service handlers.\n- Inside async_setup, define async functions for each service that:\n  - Extract validated arguments from service.data using the ATTR_* constants.\n  - Optionally read accesspoint_id (or similar) to determine scope.\n  - If an ID is provided, call _get_home and then the appropriate method (e.g., home.activate_vacation(endtime, temperature)) if the instance exists.\n  - If no ID is provided, iterate over hass.data[DOMAIN] and invoke the method on each instance (supporting multi-hub setups).",
            "Step 6: Register the services with Home Assistant.\n- Use hass.services.async_register(DOMAIN, SERVICE_NAME, handler, schema=SCHEMA_NAME).\n- Ensure registration occurs after integration setup so that hass.data[DOMAIN] is populated.",
            "Step 7: Document the services in services.yaml.\n- Create or update homeassistant/components/<integration>/services.yaml.\n- For each new service, add a description and define fields, each with a description and example value.\n- Keep the field names in services.yaml exactly aligned with the ATTR_* keys (e.g., accesspoint_id).",
            "Step 8: Validate behavior with single and multiple instances.\n- Test calling the service without accesspoint_id and ensure it correctly affects all instances.\n- Test with a specific accesspoint_id and ensure the behavior is scoped to that instance only.\n- Confirm errors are handled gracefully if a non-existent ID is provided (e.g., _get_home returns None).",
            "Step 9: Align naming with user expectations.\n- Review service and attribute names for clarity and discoverability.\n- Prefer names that match labels visible in the UI or on hardware (e.g., accesspoint_id instead of internal abbreviations like hapid).\n- If naming changes are debated, ensure final naming is consistent across code, docs, and UI hints.",
            "Step 10: Add or update external documentation and tests.\n- Update the integration’s documentation repo (home-assistant.io) to reflect new services, parameters, and examples.\n- Run the test suite (tox) and add tests if feasible to validate service registration and handler behavior."
        ]
    }
}
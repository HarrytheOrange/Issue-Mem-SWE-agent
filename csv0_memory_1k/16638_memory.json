{
    "search_index": {
        "description_for_embedding": "Home Assistant Z-Wave integration: add generic services `zwave.set_node_value` and `zwave.refresh_node_value` to set or refresh arbitrary Z-Wave node values (e.g., indicator LEDs), replacing indicator-specific services, and include `COMMAND_CLASS_INDICATOR` in sensor discovery. Uses voluptuous schemas with integer coercion and adds tests and service documentation.",
        "keywords": [
            "Home Assistant",
            "Z-Wave",
            "zwave.set_node_value",
            "zwave.refresh_node_value",
            "COMMAND_CLASS_INDICATOR",
            "service schema",
            "voluptuous Coerce",
            "device value control",
            "node value refresh",
            "discovery_schemas"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant Z-Wave integration lacked a way to directly set or refresh arbitrary Z-Wave values, which was required to control the indicator LEDs on a Cooper 5-button scene controller (via COMMAND_CLASS_INDICATOR). The initial approach added dedicated `set_indicator` and `refresh_indicator` services plus discovery for COMMAND_CLASS_INDICATOR. During review, the implementation evolved toward a more general solution.\n\nThe final state of the PR removes the indicator-specific services and instead introduces two generic services:\n\n1. `zwave.set_node_value` – sets the data for a specific Z-Wave value on a node.\n   - Schema: `node_id` (int), `value_id` (int), `value` (from `ATTR_CONFIG_VALUE`, coerced to int).\n   - Implementation: inside `components/zwave/__init__.py`, the handler looks up `network.nodes[node_id].values[value_id]` and assigns `value` to `.data`, then logs the operation.\n\n2. `zwave.refresh_node_value` – refreshes the value for a specific Z-Wave value on a node.\n   - Schema: `node_id` (int), `value_id` (int).\n   - Implementation: looks up `network.nodes[node_id].values[value_id]` and calls `.refresh()` on the value, then logs the operation.\n\nBoth services are registered in `_finalize_start()` with appropriate voluptuous schemas. The `REFRESH_NODE_VALUE_SCHEMA` originally allowed `value_id` as either an int or string, but after review it was simplified to `vol.Coerce(int)` so templated service calls that produce strings still work, while keeping the internal type consistent.\n\nAdditionally, `COMMAND_CLASS_INDICATOR` is added to the Z-Wave sensor discovery schema (`discovery_schemas.py`), so indicator values are exposed as sensors. This enables automations to template out the `value_id` and current indicator state, and use the new services to manipulate LED states via bitwise arithmetic in Home Assistant templates.\n\nService documentation in `components/zwave/services.yaml` is updated to describe `set_node_value` and `refresh_node_value`, and constants `SERVICE_SET_NODE_VALUE` and `SERVICE_REFRESH_NODE_VALUE` are added to `components/zwave/const.py`.\n\nComprehensive tests are added in `tests/components/zwave/test_init.py` using `MockNode` and `MockValue`. For `set_node_value`, the test creates a node with a value, calls the service, and asserts that `.data` is updated. For `refresh_node_value`, the test patches `.refresh` with a `MagicMock`, calls the service, and asserts that `refresh()` was invoked. The earlier tests and code for `set_indicator` and `refresh_indicator` are removed in the final patch.\n\nThis change ultimately gives users a generic, reusable mechanism to set and refresh any Z-Wave value (including indicator LEDs) without introducing narrowly scoped, command-class-specific services.",
        "semantic_memory": "Generalizable insights from this change:\n\n1. Prefer generic capabilities over narrow, device-specific ones\nInstead of exposing a `set_indicator` / `refresh_indicator` pair only for COMMAND_CLASS_INDICATOR, the final design exposes generic `set_node_value` and `refresh_node_value` services that work for any Z-Wave value. This makes the API more powerful, reusable across devices, and avoids proliferation of one-off services.\n\n2. Use service schemas with coercion to handle templated input\nHome Assistant services often receive values via Jinja2 templates, which can produce strings even for numeric content. Defining service schemas with `vol.Coerce(int)` allows the service code to always operate on integers while accepting string input, reducing type-handling boilerplate and runtime errors. Initially allowing multiple types (int or string) and then standardizing via coercion is a good pattern.\n\n3. Align service naming and behavior with the underlying domain model\nThe Z-Wave network model exposes nodes and values; reflecting that model in service names (`set_node_value`, `refresh_node_value`) creates a predictable, discoverable API surface. It also makes it clear what the granularity of operations is (node + value_id) and avoids ambiguity.\n\n4. Integrate new functionality into discovery instead of special services\nAdding `COMMAND_CLASS_INDICATOR` to the sensor discovery schema surfaces indicator values as normal entities. This allows standard automations, templating, and UI patterns to apply, rather than forcing users into custom service flows or special-case code. If a capability can be modeled as a normal entity, prefer that over bespoke mechanisms.\n\n5. Always pair new service APIs with tests and documentation\nThe change includes tests for each new service (verifying both state updates and refresh calls), and updates `services.yaml` so that end users can understand the API. This reduces the chance of regressions and ensures the feature is discoverable and correctly used.\n\n6. Iterative refinement through code review\nThe patch history shows a typical evolution: start with a device-specific solution, then refactor to generalized services, prune redundant services (`set_indicator` / `refresh_indicator`), tighten schemas, and keep the codebase clean. Being willing to remove or consolidate earlier additions in favor of a better design is important for maintainable APIs.",
        "procedural_memory": [
            "How to add generic Home Assistant services for manipulating integration-specific values (like Z-Wave node values):",
            "Step 1: Identify the underlying model and required operations",
            "  - Understand how the integration represents devices and properties (e.g., Z-Wave has `network.nodes[node_id].values[value_id]`).",
            "  - Determine the minimal generic operations that cover your use case (e.g., \"set a value\" and \"refresh a value\") rather than creating device- or command-class-specific services.",
            "Step 2: Define clear service schemas with voluptuous",
            "  - In the integration's main module (e.g., `components/zwave/__init__.py`), define `vol.Schema` objects describing the inputs:",
            "    - Use `vol.Required` / `vol.Optional` as needed.",
            "    - For numeric identifiers (node IDs, value IDs), use `vol.Coerce(int)` to accept both numbers and numeric strings from templates.",
            "    - Only allow types you actually want; prefer coercion over `Any(int, string)` when the target type is known.",
            "  - Example:\n    - `SET_NODE_VALUE_SCHEMA = vol.Schema({ node_id: vol.Coerce(int), value_id: vol.Coerce(int), value: vol.Coerce(int) })`",
            "Step 3: Implement the service handlers using the integration's data model",
            "  - Inside the setup function where you have access to the integration state (e.g., `network` for Z-Wave), define service handler functions that:\n    - Extract arguments from `service.data` using the constants for attribute names.\n    - Look up the domain-specific objects (e.g., `node = network.nodes[node_id]`).\n    - Perform the desired operation (e.g., set `node.values[value_id].data = value` or call `node.values[value_id].refresh()`).\n    - Log the action with enough context (`node_id`, `value_id`, and new value) for debugging.",
            "Step 4: Register the services during integration initialization",
            "  - In the integration's startup/finalization function (e.g., `_finalize_start()` for Z-Wave):\n    - Use `hass.services.register(DOMAIN, SERVICE_NAME, handler, schema=SCHEMA)` to expose the service.\n    - Define `SERVICE_NAME` constants in a dedicated constants module (e.g., `components/zwave/const.py`) for reuse and consistency.",
            "Step 5: Update service documentation",
            "  - In `services.yaml` for the integration, add entries for the new services with:\n    - A brief `description` of what the service does.\n    - A `fields` section documenting each parameter, its type, and meaning (e.g., `node_id`, `value_id`, `value`).",
            "Step 6: Integrate related capabilities into discovery where appropriate",
            "  - If the feature relates to a specific command class / capability (e.g., COMMAND_CLASS_INDICATOR), update the integration's discovery schemas to expose those values as normal entities (e.g., sensors).\n    - This allows users to reference those values via entity IDs and attributes in automations and templates.",
            "Step 7: Write tests for the new services",
            "  - Create or extend tests for the integration (e.g., `tests/components/zwave/test_init.py`):\n    - Use mocks (`MockNode`, `MockValue`) that mirror the integration's internal objects.\n    - Set `node.values` and register nodes into the mock network.\n    - Call the service via `hass.services.call(DOMAIN, SERVICE_NAME, data)` and `hass.block_till_done()`.\n    - Assert that:\n      - For \"set\" services, the underlying value's `.data` has been updated to the expected value.\n      - For \"refresh\" services, the value's `.refresh()` method has been called.",
            "Step 8: Prefer generic services over redundant specialized ones",
            "  - If you initially add a specialized service (e.g., `set_indicator`), but later introduce a generic alternative (`set_node_value`), consider removing the specialized service to avoid API bloat and confusion.\n    - Update tests and documentation accordingly to use the generic service.",
            "Step 9: Validate templated usage and type handling",
            "  - Test typical user scenarios where service parameters come from templates (e.g., `value_id` from a sensor attribute).\n  - Ensure the schema coercion handles these values correctly and that service handlers don't have to manually cast types.",
            "Step 10: Use logs to aid debugging in production",
            "  - Ensure service handlers log actions (including IDs and values) so that when users report issues with node value updates/refreshes, you can reason about what was called and with what parameters."
        ]
    }
}
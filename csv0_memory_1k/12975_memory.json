{
    "search_index": {
        "description_for_embedding": "Home Assistant: added an IFTTT-based alarm_control_panel platform that controls security systems via the existing ifttt integration instead of direct webhooks, and introduced an ifttt_push_alarm_state service so IFTTT can push back state changes. Fixes issue where the alarm entity reverted to disarmed because REST state changes do not update entity state.",
        "keywords": [
            "homeassistant",
            "alarm_control_panel.ifttt",
            "IFTTT",
            "ifttt_push_alarm_state",
            "assumed_state",
            "entity state sync",
            "REST API vs entity state",
            "hass.services.call",
            "async_schedule_update_ha_state",
            "hass.data",
            "platform integration",
            "pyfttt removal",
            "DEPENDENCIES ifttt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR implemented a new Home Assistant alarm_control_panel platform for security systems controlled through IFTTT, such as Piper or iSmartAlarm, which lack open APIs. The first iteration directly called IFTTT webhooks using requests and pyfttt, and assumed that calling Home Assistant's REST API to set an entity state would update the entity object's state. A tester (arsaboo) observed that the alarm_control_panel briefly changed state but then reverted to 'disarmed', i.e., the entity did not reflect the device's current state. Paulus (balloob) clarified that Home Assistant's states are a reflection of entities and cannot be reliably driven by writing to the state via REST; instead, entities must update their own state from within their code, usually in response to service calls or polling. In response, the author reworked the design: the platform now depends on the core ifttt component (via DEPENDENCIES = ['ifttt']) and triggers IFTTT applets using hass.services.call(IFTTT_DOMAIN, SERVICE_TRIGGER, {ATTR_EVENT: ...}). The IFTTT applets, in turn, call back into Home Assistant via the REST API, not to set the entity’s state directly, but to call a new domain-level service, ifttt_push_alarm_state. This service is registered under the alarm_control_panel domain, takes entity_id and state, looks up all IFTTTAlarmPanel devices stored in hass.data['ifttt_alarm'], and calls push_alarm_state(state) on matching entities, which validates the requested state against an ALLOWED_STATES list and updates the internal _state before scheduling an async state update (async_schedule_update_ha_state). The platform also exposes assumed_state = True and no longer sets a default disarmed state at initialization (initial _state is None), reflecting that the real state comes from external updates. Configuration supports optional name and code; code_format is derived from whether a code is configured, and all arm/disarm methods enforce code checking with a private _check_code helper. The final result is a robust IFTTT-based alarm platform that uses the existing ifttt integration, handles asynchronous state feedback from IFTTT correctly, and clearly marks its state as assumed.",
        "semantic_memory": "Entity state in Home Assistant must be controlled by the entity code, not by writing directly to the state machine via REST. The REST /api/states endpoint can set a state, but this is not the true source of truth for entities and will be overridden by the next entity update. When integrating external services like IFTTT, the correct pattern is to use service calls: outbound actions from Home Assistant to IFTTT should go through an integration component (e.g., the ifttt component) instead of custom HTTP logic, and inbound updates from IFTTT should be realized as calls to a dedicated Home Assistant service that the entity listens to, updating its internal state and then scheduling a state update. For platforms driven by webhook-style callbacks, maintaining a list of devices in hass.data and registering a domain service that dispatches incoming updates to those devices is a clean design. When the true device state cannot be polled or verified, entities should expose assumed_state = True so UI and automations know that the state is best-effort. Async service handlers should use async_schedule_update_ha_state to avoid blocking and fit into HA's event loop. Reusing common integration layers (like the dedicated ifttt component) avoids duplicated dependencies (requests, pyfttt) and centralizes external API handling.",
        "procedural_memory": [
            "When an entity’s state in Home Assistant does not persist or reflect the real device state (e.g., it immediately reverts after a change), investigate how the state is being updated and ensure it is driven by the entity code rather than direct REST writes.",
            "Step 1: Reproduce and observe the problem",
            "1. Configure the entity/platform and perform a state change (e.g., arm an alarm).",
            "2. Watch the UI and logbook to see if the state reverts or fails to match the external device.",
            "3. Check the Home Assistant logs for any errors or suspicious state transitions.",
            "Step 2: Verify how state is updated",
            "1. Inspect the platform/entity code to see where self._state (or equivalent internal state) is set.",
            "2. Confirm whether the integration is incorrectly relying on /api/states REST calls to update entity state. If the entity’s state property is not updated in code, REST changes will be overwritten on the next entity refresh.",
            "3. Ensure that all state changes originate from within the entity’s logic (service handlers, polling, callbacks), not from external state writes.",
            "Step 3: Route external actions through a proper integration component",
            "1. If the platform talks to a third-party service (e.g., IFTTT), check if there is a core integration (like the ifttt component) and declare it as a dependency (DEPENDENCIES = ['ifttt']).",
            "2. Replace direct HTTP/webhook client usage (e.g., requests, pyfttt) inside the platform with hass.services.call() into the integration’s service API (e.g., hass.services.call(IFTTT_DOMAIN, SERVICE_TRIGGER, {ATTR_EVENT: event})).",
            "3. Remove unnecessary external dependencies from REQUIREMENTS and requirements_all.txt when using the shared integration.",
            "Step 4: Implement a callback service for inbound state updates",
            "1. Define a new service under the appropriate domain (here, alarm_control_panel) that will be called by external systems (via REST) to push state updates, e.g. SERVICE_PUSH_ALARM_STATE = 'ifttt_push_alarm_state'.",
            "2. Create a voluptuous schema for its parameters (typically ATTR_ENTITY_ID and ATTR_STATE) to validate incoming data.",
            "3. In setup_platform, initialize a shared list in hass.data (e.g., hass.data['ifttt_alarm'] = []) to store all platform instances.",
            "4. Append each created entity instance to that list in setup_platform so the service handler can access them.",
            "5. Implement an (async) service handler that:",
            "   - Reads entity_ids and the new state from service.data.",
            "   - Filters hass.data[...] to obtain the target devices.",
            "   - Calls a method on each device (e.g., device.push_alarm_state(state)) to update its internal state.",
            "   - Calls device.async_schedule_update_ha_state() to propagate the state change to Home Assistant.",
            "6. Register the service using hass.services.register(DOMAIN, SERVICE_PUSH_ALARM_STATE, handler, schema=...).",
            "Step 5: Implement device-level push logic with validation",
            "1. On the entity class, add a method like push_alarm_state(value) that:",
            "   - Verifies the new value is in a set of allowed states (e.g., ALLOWED_STATES for alarm states).",
            "   - Logs the incoming change for debugging.",
            "   - Updates the internal _state field to the new value.",
            "2. Optionally expose assumed_state = True if the integration cannot guarantee perfect state accuracy.",
            "Step 6: Implement outbound control methods correctly",
            "1. Ensure arm/disarm methods (alarm_disarm, alarm_arm_home, etc.) validate any configured code via a helper (e.g., _check_code) before triggering external events.",
            "2. In these methods, call a helper like set_alarm_state(EVENT_NAME) that invokes hass.services.call(IFTTT_DOMAIN, SERVICE_TRIGGER, {ATTR_EVENT: event}).",
            "3. Do not directly mutate the internal state on outbound commands if the true state is confirmed only via callbacks; rely on push_alarm_state to set state when confirmation arrives.",
            "Step 7: Make the platform HA-compliant and async-friendly",
            "1. Use async service handlers (async def) where appropriate and async_schedule_update_ha_state() instead of the sync scheduler from within async contexts.",
            "2. Use hass.data to maintain shared state instead of ad hoc global variables or custom container classes unless truly necessary.",
            "3. Remove unused code paths and storage classes once hass.data-based lists are used.",
            "Step 8: Document configuration and IFTTT wiring",
            "1. Document the platform configuration, including how to define the alarm_control_panel.ifttt with optional name and code.",
            "2. Explicitly explain that the entity shows an assumed state and depends on IFTTT applets to push state updates via the new service.",
            "3. Provide IFTTT configuration examples: one set of applets to trigger device actions when HA calls IFTTT, and another set that calls HA’s REST API to invoke ifttt_push_alarm_state when the physical alarm changes state.",
            "Step 9: Test end-to-end behavior",
            "1. Configure the IFTTT applets and Home Assistant according to the documentation.",
            "2. Trigger alarm arm/disarm actions from Home Assistant and verify the correct IFTTT events fire and the physical device reacts.",
            "3. Change the physical device state (e.g., via its native app) and confirm that IFTTT calls back into HA, the ifttt_push_alarm_state service runs, and the entity state updates appropriately in the UI/logbook.",
            "4. Confirm that the state no longer reverts unexpectedly and that assumed_state is set as expected."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Adds a new Home Assistant Fitbit sensor integration with full OAuth2 setup flow, token persistence, and configurable monitored resources. Includes a configurator-based onboarding flow, HTTP endpoints for Fitbit OAuth, unit handling based on locale, throttled API updates, and dependency wiring.",
        "keywords": [
            "Fitbit sensor",
            "homeassistant.components.sensor.fitbit",
            "OAuth2 integration",
            "Fitbit API",
            "Home Assistant configurator",
            "token persistence",
            "fitbit.conf",
            "Throttle",
            "HTTP callback handler",
            "requirements_all.txt",
            ".coveragerc",
            "REST device integration",
            "monitored_resources",
            "measurement units by locale"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, support for Fitbit was added as a new Home Assistant sensor platform (sensor.fitbit). Before this, Home Assistant had no built‑in way to read Fitbit metrics like steps or sleep data.\n\nThe implementation introduces a new module `homeassistant/components/sensor/fitbit.py` and wires in the third‑party `fitbit==0.2.2` library via the `REQUIREMENTS` variable and `requirements_all.txt`. A frontend image is also added to visually guide users when creating a Fitbit developer app.\n\nConfiguration is split into two stages:\n1. **App setup (developer credentials)** – On first run, the platform looks for `fitbit.conf` in Home Assistant's config directory. If the file does not exist, it writes a default placeholder configuration containing `CLIENT_ID_HERE` and `CLIENT_SECRET_HERE` and triggers the configurator UI (`request_app_setup`). The configurator shows instructions to create a Fitbit app, set the callback URL, and fill in real client_id/client_secret in the `fitbit.conf` file. If `fitbit.conf` exists but still matches the default placeholder values, the configurator is re‑shown to force the user to fix the file.\n\n2. **OAuth2 user authorization** – Once real client_id/client_secret are available, `setup_platform` checks for existing `access_token` and `refresh_token` in `fitbit.conf`. If tokens do not exist, it constructs a `FitbitOauth2Client`, registers two HTTP routes on `hass.http`:\n   - `GET /auth/fitbit` to start the OAuth2 flow (redirects the browser to Fitbit's authorize URL with appropriate scopes and redirect_uri).\n   - `GET /auth/fitbit/callback` to finish the flow. This handler reads the `code` query parameter, exchanges it for tokens using `oauth.fetch_access_token`, handles `MissingTokenError` and `MismatchingStateError`, and returns a simple HTML message to the user. On success, it writes `access_token`, `refresh_token`, `client_id`, and `client_secret` back into `fitbit.conf` and recursively calls `setup_platform` to finish sensor setup. If any errors occur, the HTML response describes them and instructs the user to try again.\n\nWhen tokens are present, `setup_platform` uses `fitbit.Fitbit` to create an authenticated client. It optionally refreshes tokens if the last save time (`last_saved_at`) is older than an hour, sets `client.system` based on the Fitbit profile locale (e.g., `en_US`, `en_UK`, `metric`), then instantiates one `FitbitSensor` entity per configured `monitored_resources` (falling back to `activities/steps` if unspecified).\n\nEach `FitbitSensor` computes a friendly name from the resource path (e.g., `activities/steps` -> `Steps`, `body/bmi` -> `BMI`), derives units of measurement either directly from a mapping (`FITBIT_RESOURCES_LIST`) or from the locale‑specific `FITBIT_MEASUREMENTS` table, and fetches initial state during `__init__`. The `update` method is decorated with `Throttle(MIN_TIME_BETWEEN_UPDATES)` (30 minutes) to limit Fitbit API calls. It queries Fitbit's time series endpoint over the last 7 days, takes the last entry's value, and uses `restingHeartRate` when the resource is `activities/heart`. After every update, it saves the latest `access_token`, `refresh_token`, client metadata, and `last_saved_at` back into `fitbit.conf` using a shared `config_from_file` function, logging an error if saving fails.\n\nThe platform depends on the `http` component for registering OAuth endpoints, uses Home Assistant's `configurator` component to guide the user through credentials and authorization, and adds an image (`config_fitbit_app.png`) to the frontend to support that UI. The fitbit sensor module is added to `.coveragerc`'s omit list, indicating it is excluded from coverage metrics.",
        "semantic_memory": "This change illustrates a complete pattern for adding an OAuth2‑based third‑party integration to Home Assistant (or similar frameworks) that combines:\n\n- **Two‑phase configuration**: First collect static app credentials (client_id/client_secret) from the user, then perform an interactive OAuth2 flow to obtain user‑specific access/refresh tokens.\n- **File‑backed configuration and token storage**: A small JSON file (`fitbit.conf`) is used both for initial developer config and for persisting tokens and metadata. A generic helper `config_from_file` abstracts reading/writing this file and gracefully handles missing files or IO errors.\n- **Configurator‑driven onboarding**: The integration uses a centralized configurator component to guide users step‑by‑step, validate that they actually edited the config file (checking for default placeholder values), and provide links, images, and submit actions. This avoids headless or undocumented configuration flows.\n- **HTTP‑exposed OAuth2 endpoints**: The server registers explicit HTTP paths for starting and finishing the OAuth2 flow, constructs an authorize URL with required scopes and redirect URI, and then handles the callback by reading query parameters, exchanging the authorization code, handling error cases, and giving human‑readable feedback via a minimal HTML page.\n- **Token refresh and rotation**: Once tokens are available, the integration refreshes them periodically (here, at most once per hour on load) and persists the new tokens back to disk after each API call. This ensures access stays valid without manual user intervention and that restarts use up‑to‑date credentials.\n- **Dynamic unit and naming logic**: Sensors generated from generic resource identifiers can compute human‑friendly names and units at runtime. A mapping of resource paths to unit categories plus a locale‑to‑units table allows the same code to support different measurement systems (US, UK, metric) and multiple resource types.\n- **Rate limiting API calls**: Using a `Throttle` decorator (or similar mechanism) to enforce a minimum update interval is a robust way to prevent exceeding third‑party rate limits while still integrating with an application’s periodic update model.\n- **Error handling and feedback**: OAuth2 flows are particularly fragile. Explicitly catching protocol‑specific errors like `MissingTokenError` and `MismatchingStateError`, logging them, and providing user‑facing messages improves resilience and debuggability.\n\nOverall, the pattern generalizes to any integration that needs: user‑driven developer app registration, OAuth2 authentication via browser, persistent tokens, and periodic polling of an external API to populate sensor entities or similar stateful objects.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and implement a similar OAuth2-based sensor integration:",
            "Step 1: Define the new integration module and dependencies.\n- Create a new component or platform module (e.g., `components/sensor/<service>.py`).\n- Declare third‑party library requirements using a `REQUIREMENTS` constant and add the pinned version to `requirements_all.txt`.\n- Add any new modules to `.coveragerc` if they should be excluded from coverage (or ensure tests are written if not excluded).",
            "Step 2: Design configuration and storage.\n- Decide where to store service‑specific configuration and tokens, typically in a small JSON config file in the app’s config directory (e.g., `<service>.conf`).\n- Implement a helper like `config_from_file(path, config=None)` that:\n  - Writes JSON if `config` is provided, handling IO errors and returning False on failure.\n  - Reads JSON if `config` is None and returns an empty dict if the file doesn’t exist.\n- Use reasonable defaults for placeholder values (e.g., `CLIENT_ID_HERE`), so you can later detect whether the user has actually customized the file.",
            "Step 3: Implement the app-credentials onboarding flow.\n- On initial setup, read the config file.\n- If the file is missing, write a default configuration with placeholder client_id/client_secret and then prompt the user via a configurator or UI.\n- If the file exists but still contains placeholder values, re‑prompt the user, displaying clear instructions: where to create the developer app, what callback URL to use, and where to put the credentials.\n- Use a central configurator component (or similar UI) to:\n  - Show a description and optional images.\n  - Provide a submit action that re‑runs your platform setup when the user indicates they are done editing the file.\n- Only proceed to OAuth when valid client_id/client_secret are present.",
            "Step 4: Implement the OAuth2 flow with HTTP endpoints.\n- Instantiate the service’s OAuth2 client using the configured client_id/client_secret.\n- Compute a redirect URI that points back to your application (e.g., `base_url + /auth/<service>/callback`).\n- Register two HTTP routes on your app’s HTTP component:\n  - `/auth/<service>`: start the flow.\n    - Build the authorize URL with required scopes and redirect_uri.\n    - Respond with a redirect (301 or 302) to that URL.\n  - `/auth/<service>/callback`: finish the flow.\n    - Parse query parameters (e.g., `code`, `state`).\n    - Call `fetch_access_token(code, redirect_uri)` on the OAuth2 client.\n    - Catch and log exceptions such as MissingToken or state mismatch.\n    - Return a simple HTML response that tells the user whether authorization succeeded and what to do next.\n- After successful token exchange, write the access_token, refresh_token, and client metadata back into the config file using your helper.\n- Trigger platform setup again (or notify the main app) to continue initialization with valid tokens.",
            "Step 5: Build the entity/sensor classes.\n- For each monitored resource configured by the user, create a sensor/entity instance with:\n  - A human‑readable name derived from the resource path (e.g., strip prefixes, replace slashes with spaces, adjust case).\n  - A unit of measurement mapping based on resource type and the service’s locale or measurement system (using lookup dictionaries).\n- In the entity’s `__init__`, store references to:\n  - The authenticated API client.\n  - The config file path (so you can update tokens on refresh).\n  - The resource type being monitored.\n- Initialize the state to a sane default (e.g., 0 or None) and call `update()` once to fetch initial data.",
            "Step 6: Implement periodic data fetching with throttling and token refresh.\n- Decorate the entity’s `update` method with a throttling mechanism (e.g., `@Throttle(datetime.timedelta(minutes=30))`) to enforce a minimum time between API calls.\n- In `update`:\n  - Construct any needed request parameters from the resource (e.g., convert `activities/steps` to `activities-steps` for container keys).\n  - Call the appropriate API (e.g., a time series endpoint) and safely extract the relevant value from the response structure.\n  - Handle special cases (e.g., for a heart rate resource, read `restingHeartRate` instead of `value`).\n  - Update the sensor’s internal state.\n- After a successful API call, read the OAuth2 client’s current token and write updated `access_token`, `refresh_token`, and metadata (like `last_saved_at`) back into the config file. Log an error if writing fails.",
            "Step 7: Implement token refresh logic.\n- On platform setup (after reading `fitbit.conf`), check if access_token and refresh_token exist.\n- If they exist, construct a fully authenticated client.\n- Optionally refresh tokens before doing any work, based on elapsed time since `last_saved_at` or token expiry directives.\n- Always persist new tokens after refresh.",
            "Step 8: Integrate with the configurator lifecycle.\n- If a configurator entry was previously opened for the service, mark it as done (`request_done`) once the platform has valid tokens and sensors are created.\n- On OAuth errors, notify the configurator of failures so the user sees a clear message and can retry.\n- Use configuration UI states to avoid leaving stale or confusing prompts active.",
            "Step 9: Test and validate.\n- Run automated tests (e.g., `tox`) to ensure no regressions.\n- Manually test the OAuth flow end‑to‑end:\n  - Start Home Assistant with the new integration.\n  - Follow the configurator instructions to create the developer app and update the config file.\n  - Visit the `/auth/<service>` URL and complete the provider’s authorization page.\n  - Confirm the callback handler saves tokens and the configurator transitions to a success state.\n  - Verify sensors appear in the UI with correct naming, icons, units, and values.\n- Watch logs for any MissingToken/MismatchingState errors and confirm they are handled gracefully.",
            "Step 10: Reuse the pattern for other services.\n- For any future OAuth2‑backed integrations, reuse the same structural elements:\n  - JSON config file with helper read/write.\n  - Two‑phase onboarding (developer credentials + OAuth2 user auth).\n  - HTTP start/callback routes.\n  - Throttled entity updates and token refresh persistence.\n  - Clear configurator/UI guidance and error messaging.\n- Adjust only the API client, scopes, resource mapping, and unit conversion logic to match the new service."
        ]
    }
}
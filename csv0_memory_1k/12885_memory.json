{
    "search_index": {
        "description_for_embedding": "Home Assistant components had overly aggressive 1-second SCAN_INTERVAL values for several platforms (concord232 alarm panel, concord232 binary sensors, folder sensor, simulated sensor), causing excessive polling that spammed the state machine and hammered file systems/devices. The fix was to relax the polling intervals (e.g., to 10 seconds, 30 seconds, or 1 minute) to reduce load while still maintaining reasonable responsiveness.",
        "keywords": [
            "Home Assistant",
            "SCAN_INTERVAL",
            "polling frequency",
            "aggressive scan interval",
            "performance degradation",
            "I/O thrashing",
            "state machine spam",
            "concord232",
            "binary_sensor.concord232",
            "alarm_control_panel.concord232",
            "sensor.folder",
            "sensor.simulated",
            "file system hammering",
            "device hammering",
            "rate limiting",
            "polling vs responsiveness"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, several Home Assistant integrations were polling far too often, which led to performance and resource issues. Specifically, the concord232 alarm control panel, concord232 binary sensor, folder sensor, and simulated sensor platforms all used a 1-second SCAN_INTERVAL. This caused the state machine to be spammed with frequent updates and resulted in heavy I/O against user file systems and devices. Users reported that their systems were being hammered with constant scans.\n\nTo fix this, the PR adjusted the SCAN_INTERVAL defaults to more reasonable values:\n- alarm_control_panel.concord232: from 1 second to 10 seconds.\n- binary_sensor.concord232: from 1 second to 10 seconds.\n- sensor.folder: from 1 second to 1 minute.\n- sensor.simulated: from 1 second to 30 seconds.\n\nThese changes significantly reduced the load caused by constant polling while keeping updates reasonably fresh. However, one user (cweakland) reported a trade-off: after the concord232 binary sensor scan interval was increased to 10 seconds, door sensors became slow enough that a person could pass through a door without it being detected in Home Assistant. Reverting that interval to 1 second restored responsiveness for that user. This highlights the tension between responsiveness and system load when choosing polling intervals.\n\nOverall, the PR resolves the original issue of \"way too aggressive\" scan intervals and file-system/device hammering by increasing polling intervals, but it also surfaces the need to balance defaults against real-world responsiveness requirements and perhaps make such settings configurable per deployment.",
        "semantic_memory": "This fix illustrates a general pattern around polling-based integrations and scan intervals:\n\n1. **Overly aggressive polling is a performance bug.** Even if each individual poll is cheap, a global 1-second polling interval across multiple entities can cause unnecessary CPU usage, disk I/O, network traffic, and state machine churn. This can manifest as slowdowns, increased hardware wear (on disks or SD cards), and noisy logs.\n\n2. **Polling intervals must balance responsiveness vs. resource usage.** For critical, fast-changing signals (e.g., security sensors, motion detectors), short scan intervals may be warranted. For slower-changing or synthetic data (e.g., folder size, simulated sensors), longer intervals (tens of seconds to minutes) are often sufficient and much less resource-intensive.\n\n3. **Default configuration should be conservative and safe.** Library or framework defaults should avoid extremes (like 1-second scanning) unless there is a strong, documented justification. Defaults must assume shared, constrained environments (Raspberry Pi, networked devices, flash storage, etc.).\n\n4. **Poll vs. push/event-driven architecture.** If a system requires truly real-time responsiveness, the better solution is often an event-driven or push-based integration (e.g., device sends events on change) instead of increasing poll frequency. Polling has inherent latency and scaling limitations.\n\n5. **Per-use-case configurability is important.** A single hard-coded SCAN_INTERVAL value rarely suits all installations. Some users prioritize responsiveness; others prioritize system longevity and low resource consumption. Making polling intervals configurable (with safe defaults) allows tuning for specific environments.\n\n6. **Scan interval issues can be subtle.** They may not show up as crashes, but as elevated background activity, HDD/SD wear, unresponsive UI, or devices being \"hammered.\" Profiling or logging may be required to notice that the root cause is simply a too-frequent polling loop.\n\n7. **Cross-component consistency matters.** When multiple related components (e.g., alarm panel and its binary sensors) poll the same or related backend, their combined polling effect must be considered; staggered or shared polling can reduce redundant work.",
        "procedural_memory": [
            "When diagnosing and fixing issues related to aggressive scan intervals or polling frequency, follow these steps:",
            "Step 1: Identify symptoms of aggressive polling.\n- Look for reports of high CPU usage, heavy disk or network I/O, or devices being 'hammered'.\n- Check if the state machine or event bus appears to be flooded with frequent, similar updates.\n- In user reports, note mentions of frequent sensor updates or logs indicating constant polling.",
            "Step 2: Inspect polling configuration.\n- Locate constants like SCAN_INTERVAL or equivalent polling timers in the relevant components.\n- Check if intervals are set to very low values (e.g., 1 second) by default.\n- Identify all components that may be polling the same backend or resource (e.g., a panel integration and its sensors).",
            "Step 3: Understand the use case and required responsiveness.\n- Categorize each integration or sensor: security-critical/real-time vs. slow-changing/non-critical.\n- For real-time-ish needs (e.g., door/window sensors, motion), determine the maximum acceptable latency (e.g., 1–2 seconds).\n- For non-critical or slow-changing data (e.g., folder sizes, simulated data, statistics), determine a relaxed interval (e.g., 30–60 seconds or more).",
            "Step 4: Propose and apply new scan intervals.\n- Increase SCAN_INTERVAL values for non-critical components (e.g., from 1 second to 30 seconds or 1 minute).\n- For critical components, consider more modest increases (e.g., from 1 second to 5–10 seconds), or keep them short if absolutely required.\n- Update the code where SCAN_INTERVAL (or equivalent) is defined, ensuring consistent use of datetime.timedelta (or framework equivalents).",
            "Step 5: Evaluate impact on system load and responsiveness.\n- Run the system and monitor CPU, I/O, and memory usage before and after the change.\n- Check logs for reduced frequency of polling-related messages.\n- Test common scenarios to ensure user-facing responsiveness is still acceptable (e.g., open a door, check how fast Home Assistant updates).",
            "Step 6: Handle trade-offs and configurability.\n- If some users need higher responsiveness, make SCAN_INTERVAL configurable via configuration files, options, or UI, with safe defaults baked in.\n- Document the trade-offs between responsiveness and system load, and explain how users can tune the interval.\n- For especially critical sensors, consider event-driven or push-based mechanisms instead of relying solely on polling.",
            "Step 7: Prevent regressions and communicate changes.\n- Add tests or checks that guard against unreasonably low default intervals in future changes.\n- Note the new SCAN_INTERVAL values in release notes or upgrade documentation so users are aware of potential behavior changes.\n- If changing intervals may cause missed short-lived events, highlight this explicitly and suggest configuration overrides or alternative integration patterns.",
            "Step 8: Monitor user feedback post-release.\n- Watch for reports that indicate over-correction (e.g., sensors becoming 'too slow') and be prepared to adjust defaults or provide configuration options.\n- Use this feedback to refine best practices for polling intervals across similar integrations."
        ]
    }
}
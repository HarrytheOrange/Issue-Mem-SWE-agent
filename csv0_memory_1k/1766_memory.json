{
    "search_index": {
        "description_for_embedding": "StackStorm pack installation sometimes reused an existing virtualenv, leading to stale or conflicting Python dependencies when reinstalling or upgrading packs. The fix ensures the pack virtualenv directory is removed before being recreated, using shutil.rmtree, so requirements are always installed into a clean environment.",
        "keywords": [
            "stackstorm",
            "packs.install",
            "packs.setup_virtualenv",
            "virtualenv",
            "python dependencies",
            "stale virtualenv",
            "reinstall pack",
            "sensor",
            "shutil.rmtree",
            "environment recreation",
            "pack_mgmt",
            "setup_virtualenv.py"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, StackStorm's pack installation workflow (`packs.install` â†’ `packs.setup_virtualenv`) could reuse an existing virtualenv for a pack. When a pack was reinstalled or upgraded, the old virtualenv directory remained on disk, so previously installed dependencies persisted. This could cause subtle issues such as stale dependencies not being updated, conflicting versions, or failures when trying to recreate the virtualenv in the same directory.\n\nThe developer introduced a change in `contrib/packs/actions/pack_mgmt/setup_virtualenv.py` to proactively remove the old virtualenv directory before creating a new one. A new helper method `_remove_virtualenv(self, virtualenv_path)` was added which:\n- Checks if the virtualenv path exists.\n- Logs if it doesn't exist and returns.\n- If it exists, logs a debug message and uses `shutil.rmtree(virtualenv_path)` to completely remove the directory.\n- On failure, logs an error and re-raises the exception.\n\nThis method is called at the beginning of `_setup_pack_virtualenv`, before `_create_virtualenv` is invoked. This ensures each pack installation gets a fresh virtualenv. The change was tested with the `mmonit` pack and other packs; it no longer failed as before and did not negatively impact sensor registration or restart behavior. Minor follow-up changes adjusted the logging line to comply with the 100-character lint limit.\n\nThere was a discussion about whether deleting a virtualenv while a running process uses it could cause issues. After local testing, maintainers confirmed that the approach works in practice: the old sensor container is stopped, the virtualenv is removed and recreated, and then the sensor container is restarted. Any small race window was considered acceptable, and the change was accepted.",
        "semantic_memory": "When managing Python-based extensions or plugins (e.g., packs, sensors, or actions), reusing an existing virtualenv across upgrades or reinstalls can cause stale or conflicting dependencies. A robust pattern is to treat the virtualenv as disposable and recreate it from scratch on each install or upgrade, ensuring dependency resolution matches the declared requirements.\n\nKey concepts and best practices derived from this fix:\n1. **Idempotent environment setup**: Environment setup actions (like `setup_virtualenv`) should be idempotent. Running them multiple times should yield a consistent state. Deleting and recreating the virtualenv helps achieve this.\n2. **Clean rebuild over in-place modification**: When dependency sets might change, deleting the old environment and rebuilding is safer than attempting in-place upgrades, which can leave old packages or incompatible versions behind.\n3. **Fail loudly on environment manipulation errors**: When tearing down or creating environments, failures should be logged clearly and propagated (re-raised) so orchestration workflows can detect and handle them.\n4. **Use high-level filesystem operations**: For removing complex directories like virtualenvs, `shutil.rmtree` or equivalent high-level recursive delete functions are more reliable than manual deletions.\n5. **Consider interaction with running processes**: Deleting an environment potentially used by running processes requires control over process lifecycle. In this case, the system ensures the sensor container is stopped and restarted as part of the pack installation workflow, so removing the virtualenv is safe.\n6. **Log both success and non-existence**: Logging when the virtualenv doesn't exist, as well as when it is removed, provides useful diagnostics without being noisy.\n\nThese ideas generalize to any system that manages isolated environments for plugins (e.g., Python virtualenvs, Node.js `node_modules` folders, container images): prefer reproducible rebuilds to partial, in-place modifications when correctness is more important than avoiding a rebuild.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of stale or conflicting environments. Look for cases where updating a pack/plugin (or its requirements file) does not seem to change the runtime behavior, or where virtualenv creation fails because the target directory already exists.",
            "Step 2: Inspect the environment lifecycle in your install/upgrade workflow. For StackStorm, examine actions like `packs.setup_virtualenv` and the overall `packs.install` workflow to see when virtualenvs are created and whether they are ever deleted.",
            "Step 3: Confirm the existence and path of the virtualenv. Determine where the virtualenv for a given pack or plugin is stored (e.g., a base virtualenv path plus pack name). Check if that directory persists between installs or upgrades.",
            "Step 4: Manually test deleting and recreating the environment. Stop any processes using the environment (e.g., sensor containers), manually remove the virtualenv directory, and run the environment setup step again to verify that dependencies are correctly installed and the system behaves as expected.",
            "Step 5: Automate environment cleanup before creation. In the environment setup code (e.g., `_setup_pack_virtualenv`), add a function to remove the existing virtualenv directory if it exists. Use a robust recursive delete operation such as `shutil.rmtree(virtualenv_path)` in Python, with proper try/except handling.",
            "Step 6: Log key actions and errors. When removing the environment, log whether the directory existed and whether deletion succeeded or failed. On failures, log detailed error information and re-raise the exception so orchestration or calling workflows can detect the failure.",
            "Step 7: Invoke cleanup at the start of setup. Ensure the remove function is called before creating the new environment, so every install or upgrade step starts from a clean slate.",
            "Step 8: Validate interaction with process lifecycle. Confirm that any services or processes using the environment (e.g., sensor containers) are stopped before deletion and restarted after recreation. For StackStorm, this is handled by `packs.load` and `packs.restart_component` in the `packs.install` workflow.",
            "Step 9: Regression test with multiple packs/plugins. Install, upgrade, and reinstall multiple packs to verify that the new behavior works consistently and no longer leaves stale dependencies. Observe logs to ensure the cleanup and recreation steps occur as intended.",
            "Step 10: Document the behavior. Update developer/internal docs to note that environments are fully recreated on install/upgrade and that any manual changes inside virtualenvs may be wiped, encouraging dependency management only via requirements files."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Implements a bridge from the Home Assistant event bus to the KNX bus, allowing KNX group write messages to be sent in response to Home Assistant events. Adds a new knx_frame_send event type, validates event payload (address, data), parses KNX group addresses, converts data into a KNX data block, and writes it via the KNX tunnel.",
        "keywords": [
            "Home Assistant",
            "KNX",
            "event bus",
            "knx_frame_send",
            "KNXTUNNEL.group_write",
            "parse_group_address",
            "integration bridge",
            "automation events",
            "data validation",
            "homeassistant.components.knx"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change adds an outbound bridge from Home Assistant (HASS) to the KNX bus. Previously, the KNX component only listened for KNX frames and could expose certain group addresses as events on the HASS event bus (EVENT_KNX_FRAME_RECEIVED) for automations. There was no built-in way for an automation to send arbitrary KNX group write commands back onto the KNX bus, which made it difficult to control less-supported KNX devices or use low-level KNX features like day/night messages.\n\nTo solve this, the PR introduces a new event type, EVENT_KNX_FRAME_SEND = 'knx_frame_send', in homeassistant/components/knx.py. The setup function now registers a handler, handle_knx_send, on the HASS event bus for this event. When a knx_frame_send event is fired, the handler:\n\n1. Extracts the 'address' field from event.data. If it's missing, it logs 'KNX group address is missing' and returns.\n2. Extracts the 'data' field from event.data. If it's missing, it logs 'KNX data block missing' and returns.\n3. Attempts to convert the address to an int; if that fails, it leaves it as-is.\n4. Uses parse_group_address(addr) to convert the address to a KNX group address object, catching KNXException. On failure, it logs 'KNX address format incorrect' and returns.\n5. Builds the KNX data block: if data is already a list, it uses it as-is; otherwise, it attempts to turn data into a single byte [int(data) & 0xff]. If that fails, it logs 'KNX data format incorrect' and returns.\n6. Calls KNXTUNNEL.group_write(knxaddr, knxdata) to send the KNX telegram.\n\nThe maintainer feedback clarified that using the HASS event bus is acceptable for automation-related communications (i.e., user-space integrations) but not for internal component-to-component communications, which should use helper/dispatcher instead. The existing KNX-to-event-bus routing already had a whitelist based on 'listen' addresses, so no performance issue was introduced there. A minor formatting patch fixed indentation around reading the 'data' field and constructing the knxdata list.",
        "semantic_memory": "This PR illustrates a pattern for bridging an application-level event bus with an underlying device/protocol bus (here: Home Assistant events to KNX telegrams). The key ideas are:\n\n1. **Event-to-protocol bridging**: Expose a protocol-level operation (KNX group write) as a high-level event (knx_frame_send) so automations and scripts can trigger it without coupling to protocol specifics.\n2. **Controlled use of the event bus**: In Home Assistant, the event bus is appropriate for user-facing behavior (automations, scripts, external integrations), while purely internal communication should use dedicated infrastructure (e.g., helper/dispatcher). Bridges like this should be designed for automation use, not internal component messaging.\n3. **Validation and error handling of event payloads**: When consuming events, the payload (event.data) must be carefully validated: check for required keys, verify formats (e.g., KNX group address syntax), and ensure type correctness (list vs scalar, numeric ranges). Fail fast and log meaningful errors instead of allowing malformed data to propagate.\n4. **Decoupling addresses and data representation from the transport**: The bridge accepts flexible representations (string or integer address; scalar or list data) and normalizes them before sending. This pattern makes automation rules easier to write while keeping the bridge responsible for canonicalizing into protocol-specific forms.\n5. **Performance and scoping of event exposure**: When exposing protocol-level traffic as events (e.g., KNX frames to HASS events), it is important to filter/whitelist which addresses are surfaced. Broadcasting every low-level frame on the application event bus hurts performance and can overwhelm automations.\n\nMore broadly, any system that integrates a high-level automation engine with a lower-level field bus can apply these principles: define clear event schemas, validate inputs, normalize formats, and be deliberate about what traffic is exposed or bridged.",
        "procedural_memory": [
            "To add an event-to-protocol bridge (e.g., from an automation framework to a device bus):",
            "Step 1: Define a clear event contract. Choose an event name (e.g., 'knx_frame_send') and specify the required payload fields (e.g., 'address', 'data'). Document supported formats (string vs int, list vs scalar) so automation authors know how to use it.",
            "Step 2: Register an event listener in the integration/component setup. Use the platform's event bus subscription mechanism (e.g., hass.bus.listen(EVENT_NAME, handler)) at component initialization time, after the underlying connection/tunnel is established.",
            "Step 3: Validate required fields in the event payload. In the handler, read event.data and check for required keys. If any are missing, log a clear error message and return early to avoid undefined behavior.",
            "Step 4: Normalize and parse protocol-specific parameters. Convert addresses (e.g., strings like '1/2/3' or integers) into the protocol's address representation using existing parsing utilities (e.g., parse_group_address). Catch and log parsing exceptions with a specific error message.",
            "Step 5: Normalize data format into the protocol-native data block. Accept flexible inputs (scalar or list), then convert them into the exact format the protocol expects (e.g., a list of bytes). Mask or bounds-check as needed (e.g., int(data) & 0xff). On conversion failures, log an explicit 'data format incorrect' error and abort.",
            "Step 6: Invoke the protocol-level send method. Use the existing transport/tunnel abstraction (e.g., KNXTUNNEL.group_write(address, data_block)) instead of re-implementing transport details. This keeps the bridge focused on translation and validation.",
            "Step 7: Scope event usage and traffic. Use the event bus for user-exposed automation, not internal-only communication; for internal signals, use the framework's dedicated dispatcher mechanisms. When routing from the protocol bus to the event bus, apply whitelists/filters to avoid flooding the event system.",
            "Step 8: Add logging for diagnostics. For each failure mode (missing field, invalid address, invalid data) log a concise, actionable message. This makes it easier to debug misconfigured automations and malformed events.",
            "Step 9: (Optional) Add unit/integration tests. Write tests that fire the event with valid and invalid payloads, asserting that the protocol-level send function is called with correct parameters in the valid case and not called in the invalid cases, and that errors are logged appropriately."
        ]
    }
}
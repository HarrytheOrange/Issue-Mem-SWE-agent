{
    "search_index": {
        "description_for_embedding": "Home Assistant PR adding a new KEF LS50 Wireless media_player platform using the pykef library. Initial tests failed under tox due to a missing pykef dependency, even though pytest worked locally. The fix added pykef to requirements_all.txt and requirements_test_all.txt, adjusted gen_requirements_all to respect it, and removed kef.py from .coveragerc omit so it is covered. The media_player implementation was iteratively improved: simplified online/offline state handling by relying on pykef’s caching, removed custom state enums and sleep loops, and added a 30s turn_on throttling timer tied to a configurable Home Assistant service used to power on the speakers via IR or similar. The component supports volume control, mute, source selection, and power off.",
        "keywords": [
            "Home Assistant",
            "media_player.kef",
            "KEF LS50 Wireless",
            "pykef",
            "tox tests failing",
            "missing dependency",
            "ModuleNotFoundError: pykef",
            "requirements_all.txt",
            "requirements_test_all.txt",
            "device integration",
            "online/offline state handling",
            "turn_on_service throttling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "A new Home Assistant media_player platform was implemented to integrate KEF LS50 Wireless speakers via TCP/IP using the external pykef library. The platform exposes volume get/set, step up/down, mute, input source selection, and power-off. Power-on is handled indirectly via a configurable Home Assistant `turn_on_service` and `turn_on_data` (e.g., IR blaster or smart plug).\n\nInitially, the developer added `homeassistant/components/media_player/kef.py` and tests under `tests/components/media_player/test_kef.py`. They also added `REQUIREMENTS = ['pykef==1.2.0']` inside the component and updated `requirements_all.txt` using `script/gen_requirements_all.py`. Running `pytest tests/components/media_player/test_kef.py` in a local venv worked because pykef was installed locally, but `tox -r` failed with `ModuleNotFoundError: No module named 'pykef'`. The root cause was that pykef was not in `requirements_test_all.txt`, so tox’s test environment did not install it, and simply mocking `pykef.KefSpeaker` wasn’t enough because the module itself wasn’t importable.\n\nThe fix sequence was:\n- Add pykef to `requirements_all.txt` under `# homeassistant.components.media_player.kef` and to `requirements_test_all.txt` so tox installs it for tests.\n- Add `pykef` into the generator configuration (`script/gen_requirements_all.py`) so the requirements generator handles this dependency consistently.\n- Initially the component was added to .coveragerc’s `omit` list; later that line was removed, ensuring the new code is included in coverage.\n\nDuring review, the integration was also cleaned up and made more robust:\n- The configuration schema was tightened: `host` is now required (`CONF_HOST: cv.string`); default name changed to \"KEF Wireless Speaker\".\n- The documentation URL in the module docstring was updated to point to the official Home Assistant docs instead of the pykef GitHub.\n- `setup_platform` was updated to pass `add_entities([...], True)` instead of `add_devices`, requesting an initial update.\n- Internal state management was refactored. Originally, the component defined a `States` Enum (Online, Offline, TurningOn, TurningOff), maintained `_update_timeout` and `CHANGE_STATE_TIMEOUT`, and implemented a polling loop `__wait_for_online_state` that slept while waiting for the speaker to come online. This was removed in favor of relying directly on pykef’s `speaker.online`, `muted`, `source`, and `volume` properties. The component’s `state` now simply maps `speaker.online` to `STATE_ON` or `STATE_OFF`; volume is exposed only if it’s a numeric float.\n- Caching responsibilities were moved into pykef (dependency bumped to `pykef==1.3.0` in both runtime and test requirements), so the HA component no longer tries to cache or debounce updates via internal timeouts.\n- A new `_TURNING_ON_TIMER_WAIT` (30 seconds) and `_turning_on_timer` were introduced in the entity. After `turn_on` is invoked (which triggers the configured HA service call with JSON-parsed `turn_on_data`), the component suppresses subsequent `turn_on` calls for 30 seconds, avoiding repeated IR/power commands while the speaker boots. `turn_on` also refuses to run if the service is not configured, or if the entity is already on.\n- Volume and mute operations were simplified: on each operation, the component updates its own cached field and immediately calls the corresponding method/property on `self._speaker`, catching `ConnectionRefusedError` and logging warnings when the device is offline.\n\nTests were implemented using a `KefSpeakerMock` class that simulates volume, mute, source, online status, and methods like `turnOff`, `increaseVolume`, and `decreaseVolume`. Tests verify:\n- Platform setup with correct host and default port.\n- Setup with and without `turn_on_service` in config.\n- Turn-off behavior changes the state to OFF.\n- Turn-on triggers the configured HA service only when the device is offline and the service is configured; it is not called when the device is already online.\n- Setting, increasing, and decreasing volume behave as expected.\n\nUltimately, the PR was closed as stale by a maintainer, but the incident provides a full example of adding a hardware-backed integration, handling external dependencies for both runtime and tests, and refining state management and power-on behavior.",
        "semantic_memory": "Several general lessons can be abstracted from this PR:\n\n1. **Dependency handling for integrations and tests**\n   - When adding a new integration that uses an external library, declare it in the component’s `REQUIREMENTS` and also in the project-wide dependency files (`requirements_all.txt` and, if tests import it, `requirements_test_all.txt`). Otherwise, local tests may pass (because the developer has the library installed globally/locally), but CI environments (tox, CI runners) will fail with `ModuleNotFoundError`.\n   - Even when tests fully mock classes from a third-party library, the Python module itself must still be importable for `mock.patch('module.Class')` to work.\n   - Ensure the requirements generation tooling (`script/gen_requirements_all.py`) is aware of the new dependency and will preserve it; some projects maintain allow/block lists for certain packages.\n\n2. **Media device state & caching design**\n   - It is often better to rely on the device library’s own caching and state management instead of re-implementing your own complex state machine in the integration layer. In this case, the custom `States` enum, timeouts, and busy-wait loops were replaced with a simple check against `speaker.online` and direct access to cached properties.\n   - Avoid busy-waiting and `time.sleep` loops inside entity operations (e.g., `__wait_for_online_state`). They can block the event loop or worker threads and cause poor responsiveness. Instead, tolerate transient offline errors, catch exceptions like `ConnectionRefusedError`, and let periodic `update()` calls reconcile state.\n   - Represent entity state in terms of simple, canonical mappings (e.g., `STATE_ON` if `speaker.online` else `STATE_OFF`) rather than custom enums that mirror the same information.\n   - When exposing volume to the rest of the system, provide a clean API: ensure the value is numeric before returning it from `volume_level` and treat `None` appropriately.\n\n3. **Power-on strategy for devices that cannot be powered directly over IP**\n   - Some devices (like speakers) can be controlled over TCP/IP when on, but cannot be powered on via the same protocol. Using a configurable HA service (`turn_on_service` with `turn_on_data`) lets users integrate IR blasters, smart plugs, or other mechanisms to power on the device while keeping the media_player abstraction consistent.\n   - It’s good practice to rate-limit or throttle `turn_on` actions: immediately after a `turn_on` command is dispatched, suppress further `turn_on` calls for a fixed time window while the device boots. This prevents users or automations from hammering power-on commands and can avoid hardware issues or unnecessary network traffic.\n\n4. **Configuration schema and logging**\n   - Use strict configuration schemas (`CONF_HOST` required, sensible defaults for `CONF_PORT` and `CONF_NAME`) to catch misconfigurations early.\n   - For configuration options that need structured data (like JSON), validate or parse them centrally (e.g., `json.loads` on `turn_on_data`) rather than treating them as opaque strings.\n   - Clean, parameterized logging (logging objects, not stringified manually) improves debuggability and keeps logs readable.\n\n5. **Testing hardware-backed integrations**\n   - Implement a focused mock for the hardware library that simulates crucial behavior (online/offline, volume changes, mute, power) and use it in tests through `mock.patch`. This allows running tests without actual devices and still exercising integration logic.\n   - Include tests that cover both normal and edge scenarios: device offline, multiple calls to `turn_on`, and volume adjustments from different starting states.\n\nOverall, the PR illustrates best practices for: introducing external dependencies in a large project, decoupling UI state from device internals, avoiding blocking behavior in integrations, and designing safe power-on semantics for partially controllable hardware.",
        "procedural_memory": [
            "How to handle a missing-module error for a new integration in tox/CI:",
            "Step 1: Confirm the error. If tox or CI fails with `ModuleNotFoundError: No module named 'xyz'` for a new integration, verify that your component file imports that module (directly or via REQUIREMENTS) and that tests patch or reference it.",
            "Step 2: Add the dependency to the component’s REQUIREMENTS list (e.g., `REQUIREMENTS = ['pykef==1.3.0']`) so the integration system knows which pip package to install at runtime.",
            "Step 3: Add the same dependency and version to `requirements_all.txt` under an appropriate comment section (e.g., `# homeassistant.components.media_player.kef`) to ensure it is documented and installed in full builds.",
            "Step 4: Add the dependency to `requirements_test_all.txt` so test environments created by tox have the library installed and can import it, even if tests patch out all its behavior.",
            "Step 5: If the project uses a requirements generator script (like `script/gen_requirements_all.py`), ensure the new package is handled correctly there (update ignore/allow lists as needed). Run the generator if required by project policy.",
            "Step 6: Run `tox -r` to rebuild virtualenvs and confirm all tests, including the new integration tests, now pass.",
            "",
            "How to simplify device state handling in a media integration:",
            "Step 1: Identify what the device library already provides (e.g., `device.online`, `device.volume`, `device.muted`, `device.source`) and which of those properties are cached or inexpensive to call.",
            "Step 2: Remove redundant state machines and timeouts in the integration layer where possible. Instead of custom enums and timers, map device properties directly to the platform’s standard states (e.g., `STATE_ON` / `STATE_OFF`).",
            "Step 3: Make `update()` a simple snapshot of the device state: if the device is online, read and store its properties; if offline, clear or null out those values.",
            "Step 4: Avoid `time.sleep` or busy-wait loops within entity methods. Let the platform’s scheduler call `update()` periodically to reconcile state.",
            "Step 5: Wrap accesses that can fail (e.g., network I/O) in try/except blocks catching `ConnectionRefusedError` or similar, and log at debug/warning level without crashing the integration.",
            "",
            "How to implement a safe, service-backed power-on for a device:",
            "Step 1: Add optional configuration options to your integration for `turn_on_service` and `turn_on_data` so users can specify how the device should be powered on (e.g., via another HA integration).",
            "Step 2: In your entity, implement `__is_turning_on_supported()` to return True only when both options are configured.",
            "Step 3: In `turn_on()`, first check if power-on is supported, if the entity is already on, or if a recently invoked power-on is still within a cooldown period (tracked via a timestamp). If any of these conditions hold, exit early.",
            "Step 4: Parse `turn_on_data` into a structured object (e.g., `json.loads(self._turn_on_data)` if it is provided as JSON) and call `self._hass.services.call(service_domain, service_name, service_data, blocking=False)`. Handle errors as appropriate.",
            "Step 5: Set a future timestamp (e.g., `self._turning_on_timer = time.time() + 30`) to throttle repeated calls to `turn_on` while the device boots.",
            "Step 6: Ensure `state` uses the device’s online or availability information so that once the device is reachable, it reports `STATE_ON` without additional special handling.",
            "",
            "How to test a hardware-backed integration with a mocked device library:",
            "Step 1: Implement a mock class that mirrors the public interface of the real device class (e.g., `KefSpeakerMock` with properties `volume`, `muted`, `source`, `online`, and methods like `turnOff`, `increaseVolume`, `decreaseVolume`).",
            "Step 2: Use `@mock.patch('pykef.KefSpeaker', side_effect=KefSpeakerMock)` (or equivalent) on test methods or fixtures so the integration imports and uses the mock instead of the real hardware class.",
            "Step 3: Write tests to verify initial setup (entity count, host/port passed to the mock), correct configuration handling (with and without `turn_on_service`), and behavioral methods (volume set/up/down, mute, select_source, turn_on/turn_off).",
            "Step 4: Include tests for edge cases: device offline, multiple `turn_on` calls in quick succession, unknown sources, etc.",
            "Step 5: Keep the dependency in test requirements even though you mock the class: the module must import successfully for `mock.patch` to work."
        ]
    }
}
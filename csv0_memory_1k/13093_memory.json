{
    "search_index": {
        "description_for_embedding": "Lint and lazytox scripts were updated so that git diff is computed from the merge-base of upstream/dev and HEAD, which includes uncommitted working tree changes, and pylint is skipped on tests/ files to reduce noise, aligning local lint behavior with CI.",
        "keywords": [
            "lint script",
            "lazytox",
            "git diff",
            "merge-base",
            "working tree changes",
            "uncommitted changes",
            "pylint",
            "skip tests directory",
            "CI consistency",
            "home-assistant"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the project’s linting workflow had two practical issues. First, the shell-based `script/lint` and the Python `script/lazytox.py` scripts used `git diff upstream/dev...` to determine changed files. This approach compares the current HEAD to `upstream/dev` but does not include uncommitted working tree changes, so developers could modify Python files locally and run the lint script without those edits being checked. Second, the lint script ran `pylint` on all changed Python files, including those under the `tests/` directory, even though CI did not pylint `tests/`. This produced extra local noise and inconsistency with CI behavior.\n\nThe fix adjusted both scripts to compute the merge base between `upstream/dev` and `HEAD`, and then diff from that merge base to the working tree. Concretely, `script/lint` was updated to: `git diff $(git merge-base upstream/dev HEAD) --diff-filter=d --name-only | grep -e '\\.py$'`, which ensures both committed and uncommitted Python file changes are captured. The script’s banner was also simplified to a generic 'FILES CHANGED' header.\n\nFor pylint, the script was changed from `pylint $files` to `pylint $(echo \"$files\" | grep -v '^tests.*')`, effectively excluding any files under the `tests/` directory from pylint runs while still running `flake8` on all changed Python files. This mirrors the CI configuration and reduces local lint noise.\n\n`script/lazytox.py` was similarly updated: instead of directly calling `git diff upstream/dev... --name-only`, it now first calls `git merge-base upstream/dev HEAD` to get the SHA of the common ancestor, stores it, and then runs `git diff <merge_base> --name-only`. This brings lazytox’s file selection logic in line with the updated lint script and ensures uncommitted changes are also considered in lazy test runs. There was some discussion about whether to lint `tests/` in lazytox, but the current patch focuses on the merge-base behavior and defers further changes to a follow-up PR.",
        "semantic_memory": "This case illustrates two generalizable practices for developer tooling around git-based diffs and linting.\n\n1) **Use merge-base to include uncommitted changes in diffs**: Relying on `git diff upstream/branch...` (with the triple-dot syntax) can lead to confusion: it compares to HEAD and does not include uncommitted working tree changes by default. For tooling that needs to operate on all current changes a developer is working with—including staged and unstaged—it's often better to compute the merge-base between the target branch (e.g., upstream/dev) and `HEAD`, and then run `git diff <merge-base>` without a second commit. This ensures the diff is against the common ancestor and includes working tree changes. This pattern is useful for any local tooling that needs an accurate view of 'what changed' compared to an upstream base.\n\n2) **Align local lint behavior with CI and suppress low-value noise**: Running heavy or strict linters (like pylint) on directories that CI does not check (e.g., test code) can create friction: developers see warnings locally that will never cause CI failures, leading to confusion or wasted time. A better practice is to either (a) keep local and CI lint scopes aligned or (b) clearly separate informational checks (warnings only) from enforced checks (failures). If a directory is intentionally excluded from strict linting in CI, local helper scripts should either follow that exclusion or be explicit about their different behavior.\n\nMore broadly, this incident reinforces that developer productivity scripts should:\n- Accurately mirror CI behavior when they are intended as local analogs of CI checks.\n- Use robust git plumbing (`merge-base`, explicit diff ranges) instead of relying on more opaque shortcuts that may not capture all desired changes.\n- Treat tests differently when appropriate, e.g., allowing more flexibility in test code style compared to production code.",
        "procedural_memory": [
            "To diagnose and fix issues where local lint/test scripts miss uncommitted changes or behave inconsistently with CI, follow these steps:",
            "Step 1: Confirm how changed files are currently detected.",
            "Check any helper scripts (shell, Python, etc.) that collect 'changed files' for linting or testing. Look for commands like `git diff`, `git diff origin/main...`, or similar. Note whether they use triple-dot syntax (`A...B`) and whether they specify both sides of the diff.",
            "Step 2: Test whether uncommitted changes are included.",
            "Create a dummy change in a tracked file without committing it (e.g., modify a .py file) and run the lint/test script. If the file is not listed or not linted, the script is likely only looking at committed changes.",
            "Step 3: Switch to a merge-base–based diff if needed.",
            "If you want to compare your current work (including uncommitted changes) against an upstream branch, compute the merge base explicitly:\n- Run `git merge-base <upstream-branch> HEAD` to get the common ancestor SHA.\n- Use that SHA as the starting point for `git diff`, e.g.: `git diff $(git merge-base upstream/dev HEAD) --name-only`.\n- In shell scripts, assign this to a variable or inline it as shown in the patch. In Python, call `git merge-base` first, read its stdout, and then call `git diff <merge-base> --name-only`.",
            "Step 4: Filter for relevant file types and handle deletions.",
            "Use `--diff-filter=d` in `git diff` if you want to ignore deleted files. Pipe the output through filters like `grep '\\.py$'` to restrict to specific file types. For example: `git diff $(git merge-base upstream/dev HEAD) --diff-filter=d --name-only | grep -e '\\.py$'`.",
            "Step 5: Align local lint scopes with CI configuration.",
            "Inspect your CI configuration (e.g., Travis, GitHub Actions) to see which directories and tools are enforced. If CI does not run pylint on `tests/`, consider excluding `tests/` from local pylint runs to avoid confusion, or clearly mark that local lint is stricter. In shell, you can filter out a directory with `grep -v '^tests.*'` before passing files to pylint: `pylint $(echo \"$files\" | grep -v '^tests.*')`.",
            "Step 6: Preserve or adjust behavior for other tools (flake8, pytest, etc.).",
            "Decide which tools should run on tests and which should not. For example, you may still want `flake8` on tests but not `pylint`. Implement directory-based filters only where needed and document the rationale.",
            "Step 7: Update developer-facing output for clarity.",
            "Adjust script banner messages to describe what is actually happening instead of echoing raw commands, especially when commands use nested invocations (like `git merge-base` inside `git diff`). A simple header such as 'FILES CHANGED' is often clearer than a complex literal command string.",
            "Step 8: Verify behavior across common workflows.",
            "Test the updated script in these scenarios: (a) no local changes, (b) uncommitted changes only, (c) committed changes only, (d) mix of both, and (e) files under `tests/` vs production code directories. Confirm that the expected files are linted and that the behavior matches CI where intended.",
            "Step 9: Document the assumptions and options.",
            "Add comments or README notes explaining that the script uses the merge base of `upstream/dev` and HEAD and intentionally excludes certain directories from certain linters. This helps future maintainers understand why behavior differs from naive `git diff` usage."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant ZHA remotes (e.g., Zigbee switches, dimmers, controllers) were incorrectly exposed as binary_sensor entities. This PR converts those remote-like devices into stateless event sources by adding ZHAEvent, ZHASwitchEvent, and ZHALevelEvent classes that listen to Zigbee OnOff and LevelControl clusters and fire Home Assistant events (zha.on, zha.off, zha.toggle, zha.level_change). It also refines ZHA device classification via REMOTE_DEVICE_TYPES so actual binary sensors (IAS Zone and OnOff sensors like door/window contacts) still create binary_sensor entities, now using attribute reporting instead of polling and proper binding/configuration.",
        "keywords": [
            "home-assistant",
            "zha",
            "zigbee",
            "remote control",
            "binary_sensor",
            "event-based",
            "ZHAEvent",
            "ZHASwitchEvent",
            "ZHALevelEvent",
            "OnOff cluster",
            "LevelControl cluster",
            "IAS Zone",
            "REMOTE_DEVICE_TYPES",
            "device classification",
            "attribute reporting",
            "bind and configure_reporting"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set for Home Assistant's ZHA (Zigbee Home Automation) integration, remote-like devices were being modeled as binary_sensor entities. That meant handheld remotes, wall switches, and dimmers showed up as binary sensors whose state toggled, which is semantically wrong (they are controllers, not sensors) and awkward to use in automations. Additionally, the previous classification logic relied heavily on the presence of the OnOff cluster, causing both true remotes and some output/sensor devices to be treated the same.\n\nThe fix removes the ZHA Switch binary_sensor implementation that wrapped OnOff/LevelControl clusters in homeassistant/components/binary_sensor/zha.py. Instead, the ZHA core component (homeassistant/components/zha/__init__.py) now registers event listeners for remote-like devices via a new event abstraction:\n- ZHAEvent: base class that attaches as a Zigbee cluster listener and derives a stable device identifier based on ieee, manufacturer, model, endpoint, and an optional suffix.\n- ZHASwitchEvent: listens to the general.OnOff cluster and fires Home Assistant bus events OFF_EVENT_KEY (zha.off), ON_EVENT_KEY (zha.on), and TOGGLE_EVENT_KEY (zha.toggle) with a payload {\"device\": <id>} and EventOrigin.remote.\n- ZHALevelEvent: listens to the general.LevelControl cluster and maintains a local level value. It fires OFF/ON events when level crosses zero, and LEVEL_CHANGE_EVENT_KEY (zha.level_change) with {\"device\": <id>, \"level\": <value>} on each change.\n\nRemote registration logic was moved from ad hoc checks in the binary_sensor platform to the ZHA application controller: during device initialization, if the endpoint's device type is in REMOTE_DEVICE_TYPES for its profile (ZHA or ZLL), the code constructs a custom discovery_info and calls _async_setup_remote. This binds the relevant OnOff/LevelControl clusters, configures reporting, and creates ZHASwitchEvent/ZHALevelEvent instances that attach as listeners.\n\nAt the same time, real binary sensors were cleaned up:\n- IAS Zone devices are now represented by a dedicated IasZoneSensor subclass of BinarySensor. It reacts to zone_status cluster_command updates and sends an enroll_response when requested.\n- A generic BinarySensor class now handles attribute_updated callbacks; it treats its value_attribute (default attr 0) as the boolean source of truth, setting _state and scheduling Home Assistant state updates.\n- A new _async_setup_onoff factory binds and configures the general.OnOff cluster for OnOff-based sensors (e.g., contact sensors) and instantiates BinarySensor with the appropriate device_class (DEVICE_CLASS_OPENING for door/window-like devices).\n\nThe constants module (homeassistant/components/zha/const.py) was updated so that many device types previously mapped to the 'binary_sensor' component are now collected under REMOTE_DEVICE_TYPES instead (for both ZHA and ZLL profiles). DEVICE_CLASS for ZHA was adjusted to map ON_OFF_OUTPUT to binary_sensor (a true sensor-like endpoint), while remote controllers (ON_OFF_SWITCH, LEVEL_CONTROL_SWITCH, REMOTE_CONTROL, ON_OFF_LIGHT_SWITCH, DIMMER_SWITCH, COLOR_DIMMER_SWITCH, and corresponding ZLL controller/scenes types) are treated as remotes and no longer create binary_sensor entities.\n\nIn summary, the incident here was a mis-modeling of ZHA remotes as binary sensors. The resolution introduces a proper event-based representation for stateless Zigbee controllers and clarifies which device types should expose entities vs events, while also improving binding, reporting, and state handling for actual binary sensors.",
        "semantic_memory": "When integrating hardware protocols (like Zigbee) into a higher-level automation system, it's important to model devices according to their semantics rather than just their low-level clusters or attributes:\n\n1. **Controllers vs sensors**: Handheld remotes, wall switches, and dimmers are generally stateless controllers. They should generate events when buttons are pressed or levels change, rather than being represented as binary_sensor entities whose state is toggled. Entities imply persistent state that should reflect reality; controllers often don't have a meaningful persistent 'on/off' state.\n\n2. **Classification by device type, not just clusters**: Many Zigbee device types expose the same clusters (e.g., OnOff, LevelControl) for very different roles. A switch, a plug, and a remote might all expose an OnOff cluster. Relying solely on the presence or direction (in/out) of a cluster to decide the Home Assistant platform often leads to misclassification. Instead, use profile + device type (e.g., zha.DeviceType.*, zll.DeviceType.*) and maintain explicit mappings (e.g., DEVICE_CLASS and REMOTE_DEVICE_TYPES) for clearer semantics.\n\n3. **Event abstractions for stateless input devices**: A simple listener abstraction (like ZHAEvent) that attaches to Zigbee clusters, translates cluster commands/attribute updates into high-level bus events, and normalizes IDs/payloads is an effective pattern. It decouples low-level cluster logic from the entity model and enables consistent automations via event triggers.\n\n4. **Binding and configure_reporting**: For sensor-like devices (including those driving binary_sensor entities), you typically want to bind to their clusters and configure attribute reporting instead of polling. This reduces traffic and latency and better matches Zigbee's push model. Error handling for Zigbee-specific exceptions (e.g., DeliveryError, ZigbeeException) should be robust, logging issues but not failing the entire setup.\n\n5. **Attribute-driven state updates**: For binary sensors that represent actual states (e.g., IAS Zone alarms, contact sensors), design the entity to update from attribute_updated/cluster_command callbacks rather than reading state on demand. Maintain a clear mapping from specific attributes/bitfields (like zone_status & 3) to boolean state, and ensure state transitions are idempotent and well-logged.\n\n6. **Stable device identifiers in events**: When firing events for remote actions, construct stable identifiers that combine manufacturer, model, ieee tail, and endpoint. This provides human-readable, collision-resistant IDs and keeps event filtering in automations straightforward.\n\nOverall, the key design lesson is to separate *stateful entities* from *event-producing controllers*, and to base classification on the protocolâ€™s known device types and profiles rather than on ad hoc cluster presence. This leads to more intuitive automations, cleaner UI, and fewer surprises for users and developers.",
        "procedural_memory": [
            "Step-by-step pattern for diagnosing and fixing mis-modeled controller devices (e.g., remotes) in a Zigbee-like integration:",
            "Step 1: Identify the symptom.\n- Observe that certain devices (handheld remotes, scene controllers, wall switches, dimmers) appear as binary_sensor or switch entities but their entity state does not reflect a meaningful persistent physical state.\n- Check user reports or UI behavior where these entities seem to toggle briefly on button press, or are confusing to use in automations.",
            "Step 2: Inspect device classification logic.\n- Locate the mapping from protocol profile/device type to Home Assistant components (e.g., DEVICE_CLASS in zha.const).\n- Check whether remote-like Zigbee device types (ON_OFF_SWITCH, LEVEL_CONTROL_SWITCH, REMOTE_CONTROL, controller/scene-controller types) are mapped to 'binary_sensor' or other stateful platforms.\n- Examine any logic that infers platform solely from cluster presence or direction (e.g., detecting OnOff cluster in out_clusters to decide on a binary_sensor).",
            "Step 3: Design an event-based abstraction.\n- Introduce a base event listener class that:\n  - Accepts a hass instance, a Zigbee cluster, a logical domain/name, and discovery_info.\n  - Attaches itself as a listener to the cluster (cluster.add_listener(self)).\n  - Constructs a stable identifier using ieee tail + manufacturer/model + endpoint + optional suffix.\n- Define specialized subclasses for each remote behavior:\n  - For OnOff: listen to cluster_command and map command IDs (0x0000/0x0040 to off, 0x0001/0x0041/0x0042 to on, 0x0002 to toggle).\n  - For LevelControl: track a level value and interpret move/move_to_level/step commands to emit level change events, also inferring on/off when crossing zero.",
            "Step 4: Decide event names and payload schema.\n- Define constants for event names (e.g., OFF_EVENT_KEY='zha.off', ON_EVENT_KEY='zha.on', TOGGLE_EVENT_KEY='zha.toggle', LEVEL_CHANGE_EVENT_KEY='zha.level_change').\n- Decide on a consistent payload schema (e.g., {\"device\": <id>, \"level\": <int>}), and use constants for keys (DEVICE, LEVEL) to avoid typos.\n- Emit events with EventOrigin.remote (or equivalent) so they are correctly identified as remote-origin events in the system.",
            "Step 5: Integrate event registration into device initialization.\n- In the device initialization flow (e.g., async_device_initialized), detect whether an endpoint is a remote by checking profile_id + device_type against a REMOTE_DEVICE_TYPES mapping instead of relying on clusters only.\n- For remote endpoints:\n  - Build a discovery_info containing application_listener, endpoint, in_clusters/out_clusters dicts, new_join flag, and unique_id.\n  - Call a dedicated _async_setup_remote(discovery_info) that:\n    - Optionally binds to OnOff/LevelControl clusters if new_join is True.\n    - Configures attribute reporting (e.g., attr 0, min_report=0, max_report=600, report_change=1) with robust exception handling.\n    - Instantiates event listener objects (ZHASwitchEvent, ZHALevelEvent) and stores them in hass.data if needed.",
            "Step 6: Fix classification constants.\n- Update your constants module so that:\n  - DEVICE_CLASS maps truly sensor-like device types to appropriate components (binary_sensor, switch, light, etc.).\n  - Remote-like device types for each profile (ZHA, ZLL) are moved to a dedicated REMOTE_DEVICE_TYPES mapping instead of being mapped as binary_sensor.\n- For each profile, enumerate remote device types explicitly (e.g., ZHA: ON_OFF_SWITCH, LEVEL_CONTROL_SWITCH, REMOTE_CONTROL, ON_OFF_LIGHT_SWITCH, DIMMER_SWITCH, COLOR_DIMMER_SWITCH; ZLL: COLOR_CONTROLLER, COLOR_SCENE_CONTROLLER, CONTROLLER, SCENE_CONTROLLER, ON_OFF_SENSOR).",
            "Step 7: Rework binary sensor implementations to use attribute-based updates.\n- Ensure BinarySensor base class:\n  - Has a value_attribute (default attr 0) indicating which Zigbee attribute represents the boolean state.\n  - Implements attribute_updated to set _state = bool(value) when the correct attribute is updated and schedule a state update in Home Assistant.\n- For IAS Zone:\n  - Create an IasZoneSensor subclass that holds a reference to the IasZone cluster.\n  - In cluster_command, interpret command_id 0 as a zone_status update, set _state based on relevant bits (e.g., args[0] & 3), and respond to enroll requests (command_id 1) using enroll_response.\n- For OnOff-based binary sensors (e.g., contact sensors):\n  - Implement _async_setup_onoff(hass, config, async_add_devices, discovery_info, device_class) that binds and configures reporting for general.OnOff and instantiates a BinarySensor with DEVICE_CLASS_OPENING or another appropriate device_class.",
            "Step 8: Remove obsolete entity-based remote handling.\n- Delete or deprecate any binary_sensor/switch entity classes that tried to model remotes (e.g., Switch class in binary_sensor/zha.py that wrapped OnOff/LevelControl as a binary sensor).\n- Ensure no platform setup path creates entities for remote endpoints; only event listeners should be attached.",
            "Step 9: Add error handling and logging.\n- Wrap bind and configure_reporting calls in try/except for Zigbee-specific exceptions (e.g., ZigbeeException, DeliveryError).\n- Log failures at debug or warning level without aborting setup, so the device is still partially functional and issues can be diagnosed.",
            "Step 10: Test and validate behavior.\n- Pair or restart a variety of ZHA/ZLL devices:\n  - Confirm that remotes and scene controllers no longer appear as binary_sensor entities but do emit zha.* events when buttons are pressed or levels changed.\n  - Confirm that IAS Zone sensors and OnOff-based sensors appear as binary_sensor entities and change state based on Zigbee attribute updates and cluster commands.\n- Create automations bound to the new event names and payloads to verify they trigger correctly and consistently across restarts and re-joins."
        ]
    }
}
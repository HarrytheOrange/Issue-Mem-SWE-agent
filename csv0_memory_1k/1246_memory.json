{
    "search_index": {
        "description_for_embedding": "Attempted fix for napari packaging issues where pyproject.toml in the sdist triggered PEP 517 build isolation and broke custom setup.py logic for conditional Qt backend dependencies (PyQt5 vs PySide2). The PR excluded pyproject.toml from sdist and added CI to verify that installing from sdist with PyQt5 did not pull in PySide2. Maintainers ultimately rejected this workaround and decided to embrace standard packaging with extras (napari[pyside2], napari[pyqt5], napari[all]) and proper pyproject configuration instead of hacking around PEP 517.",
        "keywords": [
            "pyproject.toml",
            "sdist",
            "MANIFEST.in",
            "PEP 517",
            "build isolation",
            "setuptools",
            "conditional dependencies",
            "extras_require",
            "PyQt5",
            "PySide2",
            "Qt backend",
            "napari packaging",
            "CI sdist installation test"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the project was struggling with how to install napari with one of two mutually exclusive Qt backends (PyQt5 or PySide2) without forcing users to specify extras. They had previously added non-standard logic in setup.py (PR #1059) to select a backend depending on the environment, and had disabled wheels (PR #1215) to keep that hack working. However, the presence of pyproject.toml in the source distribution (sdist) triggered PEP 517/518 build isolation behaviour in pip, which bypassed or interfered with their setup.py logic and broke their intended conditional dependency installation.\n\nThis PR proposed another workaround: exclude pyproject.toml from the sdist to prevent pip from using PEP 517 build isolation and to restore the old, non-isolated setuptools behavior. Concretely, it added `exclude pyproject.toml` to MANIFEST.in so that the source tarball would no longer contain pyproject.toml. It also added a Cirrus CI task that:\n- Built an sdist via `python setup.py sdist` in a clean Python 3.7-slim container.\n- Installed development requirements, then PyQt5 and numpy.\n- Installed napari from the built sdist (`pip install dist/napari*.tar.gz`).\n- Ran a small Python script that failed the job if PySide2 could be imported, verifying that installing napari from sdist with PyQt5 present did not pull in PySide2.\n\nDuring discussion, maintainers concluded that this direction was fundamentally flawed. They observed that they were fighting against modern packaging standards (PEP 517/518, build isolation, wheels) just to avoid telling users to run `pip install napari[pyside2]` or `pip install napari[pyqt5]`. This had already led to multiple hacks: custom setup.py logic, avoiding wheels, and now trying to hide pyproject.toml. They also noted the broader problem of napari's \"split personality\" as both an end-user application (which wants strict, opinionated dependencies) and a library (which wants looser, configurable dependencies).\n\nThe consensus was to abandon this PR and the workaround. Instead, the project would:\n- Embrace extras like `napari[pyside2]`, `napari[pyqt5]`, and possibly `napari[all]` (which could also include plugins like napari-svg, napari-console, etc.).\n- Accept that users must pick an appropriate extra or use a default extra pattern, rather than encoding complex logic in setup.py.\n- Move towards fully standard packaging practices: keep pyproject.toml, declare a build backend (e.g. setuptools.build-meta), and build wheels.\n\nThe PR was closed unmerged with agreement from the core maintainers that excluding pyproject.toml from sdist and fighting build isolation was not a sustainable fix.",
        "semantic_memory": "Key lessons from this case revolve around Python packaging best practices and how to handle optional or mutually exclusive dependencies.\n\n1. **Don’t fight PEP 517/518 and pyproject.toml**: Once a project adopts pyproject.toml, pip will typically build in an isolated environment using PEP 517. Trying to hide or remove pyproject.toml from sdists just to preserve legacy setup.py behavior is brittle and non-standard. It’s better to work with the modern packaging workflow: specify the build backend in pyproject.toml (e.g. setuptools.build-meta), allow isolated builds, and rely on standard mechanisms (extras, environment markers) rather than runtime hacks.\n\n2. **Avoid complex conditional logic in setup.py for dependency selection**: Encoding environment-dependent logic in setup.py to choose between backends or dependencies is fragile and often fails under isolated builds or when building wheels. It also surprises tools and users because it deviates from declarative dependency specification. Instead, use extras_require, optional dependencies, or separate meta-packages.\n\n3. **Use extras for optional or mutually exclusive backends**: When you must support multiple optional backends (e.g., PyQt5 vs PySide2), provide clearly named extras such as `project[pyside2]` and `project[pyqt5]`. For a \"batteries-included\" experience, provide an `project[all]` extra that bundles the typical backend and optional add-ons. This shifts the responsibility to users to opt into specific configurations, and it aligns with pip’s expected semantics.\n\n4. **Recognize the tension between library and application packaging**: A package used both as a library and an application may need different dependency strategies. As an application, you want stricter, opinionated dependencies for a smooth end-user experience. As a library, you want looser, configurable dependencies. It can be more sustainable to separate the two roles (e.g., a thin app shell package depending on a more flexible library package) rather than trying to make one package satisfy both perfectly.\n\n5. **CI should test sdist installation in a clean environment**: It’s valuable to have CI builds that create an sdist, install it into a minimal container with specific dependency combinations, and then verify that the resulting environment is correct (e.g. that an unwanted backend was not installed). This catches packaging and dependency issues that only appear during installation from sdists, not just from local editable installs.\n\nOverall, the generalizable guidance is: embrace modern Python packaging standards and declarative configuration via pyproject.toml and extras, and avoid relying on non-standard build-time logic or hacks like removing pyproject from sdists.",
        "procedural_memory": [
            "When handling packaging issues related to PEP 517 build isolation, pyproject.toml, and conditional dependencies, follow these steps:",
            "Step 1: Reproduce the issue in a clean environment.\n- Use a minimal container or virtualenv (e.g., python:3.7-slim or a fresh venv).\n- Install only the minimal tools needed (pip, setuptools, wheel).\n- Install your package from sdist (`python setup.py sdist` then `pip install dist/yourpkg*.tar.gz`) or directly via `pip install .`.\n- Observe which dependencies are installed and whether any undesired backends or extras are pulled in.",
            "Step 2: Inspect pyproject.toml and build configuration.\n- Check whether pyproject.toml is present and which build-backend is declared.\n- Understand that pyproject.toml triggers PEP 517 build isolation by default.\n- Avoid attempting to remove pyproject.toml from the sdist via MANIFEST.in or other tricks; instead, plan to work with the PEP 517 workflow.",
            "Step 3: Examine dependency specification strategy.\n- Review setup.cfg/setup.py or pyproject.toml configuration of install_requires and extras_require.\n- Identify any custom logic in setup.py that inspects the environment to decide which dependencies to install (e.g., choosing PyQt5 vs PySide2 at install time).\n- Recognize that such logic will often fail or behave unpredictably in isolated builds and when building wheels.",
            "Step 4: Replace conditional install-time logic with extras or separate packages.\n- Define explicit extras in your packaging config, e.g. `extras_require = {'pyside2': ['PySide2'], 'pyqt5': ['PyQt5'], 'all': ['PySide2', 'optional-plugin1', 'optional-plugin2']}`.\n- Recommend clear install commands to users, such as `pip install yourpkg[pyside2]` for one backend or `pip install yourpkg[all]` for a full feature set.\n- If necessary, consider a separate \"shell\" application package that depends on the library and on a specific backend for user-friendly default installs.",
            "Step 5: Embrace PEP 517 and wheel builds.\n- Keep pyproject.toml and explicitly set a build-backend (e.g., `build-backend = \"setuptools.build-meta\"`).\n- Configure CI to build both wheels and sdists and to upload them as artifacts or to PyPI.\n- Remove non-standard logic in setup.py that is incompatible with isolated builds.",
            "Step 6: Add CI checks for packaging correctness.\n- Add a CI job that:\n  - Builds an sdist (and optionally a wheel).\n  - Creates a fresh environment or container.\n  - Installs specific dependency combinations (e.g., only PyQt5, not PySide2).\n  - Installs your package from the built artifact.\n  - Runs a small script to verify that only the intended backend(s) are importable and that undesired ones are absent.",
            "Step 7: Provide runtime checks and clear error messages.\n- Within your package’s runtime code, detect whether any required backend is available.\n- If none is available, raise a clear, actionable error message guiding users to install the appropriate extra (e.g., `pip install yourpkg[pyside2]`).\n- Avoid implicitly importing or installing additional backends at runtime; keep dependency resolution in the packaging layer.",
            "Step 8: Document the installation patterns.\n- Update project docs to explain the recommended install commands for different user profiles (e.g., application users vs library integrators).\n- Explicitly mention extras like `[pyside2]`, `[pyqt5]`, and `[all]` and what they include.\n- Clarify that the project follows modern packaging standards and that manual or legacy installation tricks are no longer supported."
        ]
    }
}
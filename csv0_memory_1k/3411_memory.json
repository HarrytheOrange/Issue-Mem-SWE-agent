{
    "search_index": {
        "description_for_embedding": "Fix st2 RBAC sync tool (st2-apply-rbac-definitions) so that it also removes role assignments from the database for users that do not exist in the User DB, while still ignoring remote assignments. Adds get_all_role_assignments service, updates syncer logic to work over all usernames present in files, users, and assignments, and extends tests.",
        "keywords": [
            "StackStorm",
            "st2-apply-rbac-definitions",
            "RBAC",
            "role assignments",
            "orphan role assignments",
            "user does not exist in DB",
            "RBACDefinitionsDBSyncer",
            "get_all_role_assignments",
            "rbac_services",
            "remote assignments",
            "sync_users_role_assignments",
            "data consistency",
            "database cleanup",
            "authorization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the StackStorm RBAC sync tool `st2-apply-rbac-definitions` had asymmetric behavior for role assignments tied to users that did not exist in the database. The system already supported pre-creation of role assignments: you could define role assignments in files for users who had never logged in, and those assignments would be stored in the database even though the corresponding `User` records did not yet exist (StackStorm lazily creates users on first authentication). However, when RBAC definitions were removed from disk, the sync process only removed assignments for users that existed in the User DB. Any role assignments belonging to non-existent users remained in the database indefinitely, becoming orphan records. While this had no direct security impact (a non-existent user cannot authenticate), it was inconsistent behavior and left stale data in the RBAC tables.\n\nThe fix introduced a new service function, `rbac_services.get_all_role_assignments(include_remote=True|False)`, which can query all `UserRoleAssignmentDB` objects, optionally excluding \"remote\" assignments. The RBAC syncer (`RBACDefinitionsDBSyncer.sync_users_role_assignments`) was updated to:\n\n1. Assert that `role_assignment_apis` is a list/tuple.\n2. Preload all non-remote role assignments using `get_all_role_assignments(include_remote=False)`.\n3. Build a `username_to_role_assignment_dbs_map` from the loaded assignment DBs.\n4. Construct a unified `all_usernames` set that includes usernames from three sources: existing `User` records, role assignment files on disk, and role assignments already in the DB.\n5. For each username, look up the `UserDB` (if it exists), the file-based role assignment API (if present), and the DB assignments from `username_to_role_assignment_dbs_map`.\n6. Run `_sync_user_role_assignments` to reconcile DB vs file state, even if the user does not exist in the User DB.\n\nThe code includes an explicit safeguard: it asserts that all processed role assignments have `is_remote is False`, ensuring the sync tool does not touch remote assignments. The tests were expanded to cover:\n\n- Creating and syncing assignments for a user that does not exist in the DB, and confirming that the assignments are created.\n- Removing those assignments by syncing with no role assignments on disk (for that username) and verifying the DB is emptied, even though the user still does not exist.\n- Partially updating assignments for a non-existent user (e.g., three roles to one role) and ensuring the DB correctly reflects additions and deletions.\n- Ensuring `get_all_role_assignments` returns the expected number of assignments when including or excluding remote entries.\n\nThe changelog was updated to document the improvement/bug fix: `st2-apply-rbac-definitions` now also removes assignments for users that do not exist in the database, aligning removal behavior with creation behavior and keeping RBAC data consistent.",
        "semantic_memory": "This fix illustrates a common pattern in RBAC and configuration-sync systems: all sources of truth must be reconciled symmetrically. If a system allows pre-creation of role assignments or configuration for entities that do not yet exist (e.g., lazy-created users, services, or resources), the cleanup and synchronization logic must also consider those 'potential' or 'future' entities when removing or updating assignments.\n\nKey generalized lessons:\n\n1) **Symmetry of create and delete semantics**: If your system supports defining entities or relationships in advance of their existence (e.g., role assignments for a user that will be created later), you must ensure that deletions or modifications operate on the same address space. Otherwise, you accumulate orphan entries that can confuse operators, complicate migrations, or subtly break invariants, even when there is no direct security risk.\n\n2) **Reconciliation must consider all participant sets**: A sync process typically pulls from multiple sets: the configuration source (files, API), the current database state, and the set of known entities (users, groups, resources). To correctly reconcile, you must consider the union of all these sets, not just the intersection. In this case, the union of (usernames with DB users) ∪ (usernames in role assignment files) ∪ (usernames in existing DB role assignments) is the correct domain to iterate over.\n\n3) **Preloading and grouping improve consistency and performance**: Instead of calling per-user DB queries inside a loop, the fix preloads all role assignments and builds an in-memory mapping from username to assignments. This reduces query overhead and ensures you have a global view when computing the set of usernames to process.\n\n4) **Explicit handling of special categories (e.g., remote assignments)**: RBAC data often has subsets with different semantics (such as remote vs local assignments). It is important to encode these distinctions in your APIs and to enforce them with explicit filters and assertions. Here, `get_all_role_assignments(include_remote=False)` and the assert `role_assignment_db.is_remote is False` ensure the sync tool does not accidentally manipulate remote data outside its scope.\n\n5) **Testing orphaned and non-existent owners**: When dealing with relational data, tests should explicitly cover the case where a relationship exists in the DB but its owner entity is missing. This guards against bugs where cleanup code assumes the owner always exists and consequently ignores or mishandles orphan records.\n\n6) **APIs that support both scoped and global queries**: Introducing `get_all_role_assignments` alongside `get_role_assignments_for_user` is an example of API design that supports both fine-grained operations and global maintenance tasks (like sync, audit, or cleanup). Systems that only expose scoped queries make it harder to implement robust sync/maintenance logic.\n\n7) **Assertions as safety rails**: Lightweight assertions (e.g., ensuring a parameter is a list/tuple, or verifying `is_remote is False`) help catch incorrect usage early and prevent silent corruption of data. This is particularly important in maintenance tooling that can affect large parts of the RBAC state.",
        "procedural_memory": [
            "Step-by-step approach to diagnosing and fixing similar RBAC sync and orphan-assignment issues:",
            "Step 1: Reproduce and characterize the behavior\n- Identify the asymmetry: check if creation and deletion of RBAC assignments behave differently for certain entity states (e.g., users that do not exist yet).\n- Create assignments via your sync tool for a non-existent entity (user, group, service) and confirm they appear in the database.\n- Remove or modify the corresponding configuration on disk (or in your source of truth) and run the sync tool again.\n- Observe whether the database assignments are updated/removed as expected.",
            "Step 2: Inspect the sync logic and data sources\n- Locate the sync function (here, `RBACDefinitionsDBSyncer.sync_users_role_assignments`).\n- Identify what data sources it uses:\n  - Current DB state (e.g., role assignments in the database).\n  - Configuration state (e.g., role assignment files or API inputs).\n  - Entity state (e.g., existing users).\n- Check if the code gathers only a subset of relevant entities (e.g., only usernames that have User records or only those that appear in files) instead of the full union of all.\n- Verify if it ever loads assignments that belong to users/entities missing from the primary entity table.",
            "Step 3: Detect orphan or unaccounted records\n- Use global queries to inspect all RBAC assignments:\n  - If you only have per-user APIs (e.g., `get_role_assignments_for_user`), implement or temporarily add a global method (like `get_all_role_assignments`) that returns all assignments.\n- Scan for assignments whose owner (user/group/resource) does not exist in the corresponding entity collection.\n- Confirm whether your sync loop ever iterates over those orphaned entities; if not, they will never be updated or removed.",
            "Step 4: Fix the domain of reconciliation\n- Adjust the sync logic so that it iterates over the union of:\n  - All entities present in the configuration source.\n  - All entities present in the entity table (e.g., `User` DB).\n  - All entities present in existing assignment records.\n- Build mappings such as:\n  - `username_to_user_db_map` from entity DB.\n  - `username_to_role_assignment_api_map` from config inputs.\n  - `username_to_role_assignment_dbs_map` from existing assignment DB records (obtained via a global query).\n- Compute `all_usernames = set(usernames_from_users ∪ usernames_from_apis ∪ usernames_from_assignments)` and iterate over that set.",
            "Step 5: Implement correct per-entity reconciliation\n- For each username/entity in the union:\n  - Look up the corresponding entity DB object (may be `None` if the entity does not exist yet).\n  - Look up the file/API representation (may be `None` if nothing is defined in the source of truth).\n  - Look up existing assignments from the preloaded mapping.\n- Implement or reuse a helper (like `_sync_user_role_assignments`) that:\n  - Computes which assignments are new (present in config, missing in DB) and creates them.\n  - Computes which assignments are stale (present in DB, missing in config) and deletes them.\n  - Works even when the entity object does not exist (if your system supports pre-creation).",
            "Step 6: Respect special categories and safety constraints\n- Identify any attributes that separate assignments into categories with different handling rules (e.g., `is_remote` vs local assignments).\n- Update query APIs to support filtering on these attributes (e.g., `include_remote` flag).\n- Always filter appropriately in the sync logic to avoid touching data outside its intended domain (e.g., `include_remote=False` for a local-only sync tool).\n- Add assertions to ensure that assumptions hold (e.g., in the loop, assert `not role_assignment_db.is_remote` for every processed assignment).",
            "Step 7: Add and extend tests\n- Write unit tests that explicitly cover:\n  - Creating assignments for entities that do not exist in the DB yet, and verifying they are stored.\n  - Removing those assignments by syncing with no corresponding config definitions and verifying they are removed from the DB even though the entity still does not exist.\n  - Partial updates (e.g., from three roles down to one) for non-existent entities.\n  - Ensuring remote or other special-category assignments are not altered by the sync.\n  - New service methods like `get_all_role_assignments` (including behavior with filters such as `include_remote`).",
            "Step 8: Document the behavior\n- Update release notes / changelog to explain:\n  - The previous behavior (e.g., assignments for non-existent users were not removed).\n  - The new behavior (assignments for non-existent users are now created and removed symmetrically).\n  - Any impact or guarantees (e.g., no change in security model, improved data consistency).",
            "Step 9: Monitor and verify in production\n- After deploying the fix, run the sync tool against a real environment.\n- Inspect RBAC assignments before and after:\n  - Confirm orphaned assignments are cleaned up.\n  - Confirm remote or otherwise protected assignments remain untouched.\n- Keep logs or metrics of created/removed assignments to validate the correctness of the reconciliation logic over time."
        ]
    }
}
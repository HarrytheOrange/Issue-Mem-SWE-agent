{
    "search_index": {
        "description_for_embedding": "Added a websocket endpoint to the Home Assistant calendar component to retrieve all normalized events for a calendar entity, including optional date-range and maximum-count filtering. Refactored calendar entities to store full event lists, normalized event structure, and removed legacy offset parsing logic. Updated Google, CalDAV, and demo calendar platforms plus tests to support this new API.",
        "keywords": [
            "Home Assistant",
            "calendar component",
            "websocket API",
            "calendar/events",
            "get all events",
            "entity events list",
            "normalize_event",
            "filter_events",
            "GoogleCalendarData",
            "CalDAV calendar",
            "demo calendar",
            "offset removal",
            "ISO 8601 datetime",
            "hass.data[DOMAIN]",
            "websocket_api.error_message"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change introduced a new websocket endpoint and internal data model adjustments for the Home Assistant calendar component.\n\nProblem / Goal:\nThe existing calendar component only exposed the *next* event and some limited state via the entity. There was no way for a frontend calendar card to retrieve all events for a calendar entity over a period of time. The issue requested a websocket API that returns all events associated with a specific calendar entity so a core calendar card could be built.\n\nWhat was implemented:\n1. New websocket endpoint `calendar/events`:\n   - Registered in `homeassistant/components/calendar/__init__.py` with `hass.components.websocket_api.async_register_command(get_calendar_info)` during `async_setup`.\n   - Uses `@websocket_api.websocket_command` with voluptuous schema:\n     - `type`: required, must be `'calendar/events'`.\n     - `entity_id`: required, `cv.entity_id`.\n     - `maximum` (`CONF_MAXIMUM`): optional, defaults to 14, must be positive int.\n     - `start`: optional, defaults to `datetime.min`, accepts `None` or a datetime (parsed from ISO string on the wire).\n     - `end`: optional, defaults to `datetime.max`, accepts `None` or a datetime.\n   - Handler `get_calendar_info(hass, connection, msg)`:\n     - Retrieves the `EntityComponent` from `hass.data[DOMAIN]` (using the instance stored during setup).\n     - Looks up the calendar entity via `component.get_entity(msg['entity_id'])`.\n     - If no entity is found, returns a websocket error message with code `entity_not_found` and message `Entity not found`.\n     - If the entity has no events (`calendar.events is None`), returns `not_found` / `Events not found` error.\n     - Otherwise calls `filter_events(calendar.events, **msg)` and sends the filtered list as the result.\n\n2. Normalization and filtering of events:\n   - Introduced `normalize_event(event)` in `calendar/__init__.py`:\n     - Converts provider-specific event dicts into a consistent schema.\n     - Resolves start/end using `get_date(event['start'])` and `get_date(event['end'])`, which handle both all-day (`date`) and timed (`dateTime`) events and localize them via `dt.as_local(dt.parse_datetime(...))`.\n     - Adds internal datetime keys: `dt_start`, `dt_end`.\n     - Stores external-facing ISO 8601 strings: `start`, `end` (or `None` if missing).\n     - Normalizes `summary` into `message` and collapses double+ spaces via regex.\n     - Carries through `location`, `description`, `htmlLink`, and sets `all_day` by checking if `'date' in event['start']`.\n   - Introduced `filter_events(events, **filters)`:\n     - Filters the list of normalized events by a date range and maximum count.\n     - Uses `start_day = filters['start'].date()` and `end_day = filters['end'].date()`.\n     - Includes events whose `dt_start.date()` lies between `start_day` and `end_day` inclusive.\n     - Caps results to `filters[CONF_MAXIMUM]` events.\n\n3. Calendar entity refactor to support full event lists:\n   - In `CalendarEventDevice` (the base calendar entity):\n     - Added `self._events = None` and an `events` property returning `self._events`.\n     - Switched state computation to use the internal datetimes:\n       - Previously used `start` / `end`; now uses `dt_start` / `dt_end`.\n       - State is `STATE_ON` if current time lies between `dt_start` and `dt_end`, otherwise `STATE_OFF`.\n     - Simplified `device_state_attributes`:\n       - Removed offset-related keys (`offset_reached`, `offset_time`).\n       - Now returns `message`, `all_day`, `start_time`, `end_time`, `location`, `description` where `start_time` and `end_time` are ISO 8601 strings from `_cal_data` instead of formatted using `DATE_STR_FORMAT`.\n     - `cleanup()` now resets all fields in `_cal_data` to `None` and also sets `self._events = None`.\n     - `update()` behavior:\n       - If backing data (`self.data`) is falsy or `self.data.update()` is falsy, or if `self.data.event` is falsy, it calls `cleanup()`.\n       - Otherwise, it normalizes `self.data.event` into `self._cal_data` via `normalize_event`.\n       - If `self.data` exposes an `events` attribute and it is truthy, `self._events` is set to `[normalize_event(event) for event in self.data.events]`.\n   - Removed all support for the old **offset** feature:\n     - Dropped `_offset` and associated configuration (no more `CONF_OFFSET`, `DEFAULT_CONF_OFFSET`).\n     - Deleted `offset_reached` method and related regex parsing logic from calendar titles.\n     - Removed `offset_reached` and `offset_time` from the entity state attributes.\n\n4. Platform changes to populate `.events`:\n   - `homeassistant/components/google/calendar.py`:\n     - `GoogleCalendarData` now has `self.events = None`.\n     - In `update()`, instead of using a local `items` variable, calls `result = events.list(**params).execute()` and then sets:\n       - `self.events = result.get('items', [])`.\n     - The search for the next event iterates over `self.events` to compute `self.event`.\n   - `homeassistant/components/caldav/calendar.py`:\n     - `WebDavCalendarEventDevice`-like data implementation got `self.events = None`.\n     - `async_get_events()` builds `event_list` as before, then assigns `self.events = event_list` before returning it.\n   - `homeassistant/components/demo/calendar.py`:\n     - `DemoGoogleCalendarData` now exposes an `events` property returning two copies of the single demo event (`[copy.copy(self.event), copy.copy(self.event)]`), so demo setups can simulate multiple events for the websocket tests.\n\n5. Component setup and data storage:\n   - In `async_setup` for the calendar component:\n     - The `EntityComponent` is now assigned to `hass.data[DOMAIN]` instead of a local variable only:\n       ```python\n       component = hass.data[DOMAIN] = EntityComponent(_LOGGER, DOMAIN, hass, SCAN_INTERVAL, DOMAIN)\n       ```\n     - This object is then used by both the HTTP view and the new websocket API.\n   - The second patch adjusted `get_calendar_info` to fetch the component via `hass.data[DOMAIN]` (instead of `hass.data.get(DOMAIN, {})`) to ensure it is indeed an `EntityComponent`.\n\n6. Tests and behavior validation:\n   - `tests/components/calendar/test_init.py`:\n     - HTTP API tests now refer to `DOMAIN` instead of hard-coded `'calendar'` strings.\n     - New websocket tests:\n       - `test_websocket_get_events_none_found`: requests events for a non-existent `entity_id` and asserts a websocket error with `success: false` and message `Entity not found`.\n       - `test_websocket_get_all_events`: uses a fake `calendar.real_calendar` entity with three events and asserts that the result length is 3.\n       - `test_websocket_get_todays_events`: passes `start` & `end` equal to today's ISO datetime and expects only 1 event in that date range.\n       - `test_websocket_get_max_events`: passes `CONF_MAXIMUM = 2` and asserts exactly 2 events returned.\n   - `tests/components/calendar/conftest.py`:\n     - Defines `TODAY`, `YESTERDAY`, `TOMORROW`, `TOMORROW_AFTER`.\n     - A fake `Calendar` whose attribute access (`__getattr__`) always returns the same 3-event list, each with `dt_start`/`dt_end` spanning those dates.\n     - A fake `CalendarComponent` with a `.get_entity(entity_id)` that returns the fake `Calendar` only for `calendar.real_calendar`.\n     - A `calendar_setup` fixture that sets up the calendar domain and then overrides `hass.data[DOMAIN]` with this fake component for websocket testing.\n   - `tests/components/caldav/test_calendar.py` and `tests/components/google/test_calendar.py` were updated:\n     - Expectations for `start_time`/`end_time` changed from plain `YYYY-MM-DD HH:MM:SS` to full ISO 8601 strings (e.g., `'2017-11-27T17:00:00+00:00'`).\n     - All offset-related tests were removed or simplified, since offsets are no longer supported.\n     - Google calendar tests now use a shared `TEST_EVENT` template and `copy.deepcopy` to create event variants, ensuring consistency.\n\nNet effect:\nThe calendar component now supports a websocket-based `calendar/events` API returning normalized, filterable event lists per calendar entity. Calendar entities keep an internal list of normalized events, use ISO-formatted datetimes, and no longer support offset-based triggers. Platform implementations (Google, CalDAV, demo) were updated to populate `.events`, and tests were added or updated to confirm correct behavior and error handling.",
        "semantic_memory": "Generalizable insights from this change:\n\n1. Designing a normalized event model across heterogeneous providers:\n   - When multiple integrations (e.g., Google Calendar, CalDAV, demo) provide similar kinds of data, it is valuable to define a single normalization function that converts provider-specific structures into a standardized internal schema.\n   - This normalization should:\n     - Handle variants in date/time representation (`date` vs `dateTime`).\n     - Convert to a canonical time zone and type (e.g., timezone-aware `datetime` objects internally, ISO 8601 strings externally).\n     - Provide both internal fields (e.g., `dt_start`, `dt_end`) and user-facing representations (`start`, `end`, `message`, etc.).\n   - Having this layer simplifies UI, APIs, and downstream logic because they no longer need to understand provider-specific differences.\n\n2. Storing domain components in a central registry (`hass.data[DOMAIN]`):\n   - For components that expose functionality via both HTTP and websocket APIs, store the `EntityComponent` instance (or equivalent domain manager) in a known registry (`hass.data[DOMAIN]` in Home Assistant).\n   - This allows ancillary services (websocket, custom views, background tasks) to discover and interact with entities without tight coupling to setup code.\n   - Prefer direct indexed access (`hass.data[DOMAIN]`) if the data must exist after setup, rather than `get(...)` with a default of the wrong type.\n\n3. Introducing a websocket API for entity-backed data:\n   - When you need dynamic, client-driven retrieval of entity-related data (e.g., lists of events, history-like data), a websocket endpoint is often more suitable than a static REST endpoint.\n   - Good websocket design patterns include:\n     - Defining a strict schema for incoming messages using a validation library (e.g., voluptuous) to ensure types and default values.\n     - Using a `type` field to route requests (e.g., `calendar/events`).\n     - Returning structured success/error responses (`result_message` / `error_message`) with meaningful error codes (`entity_not_found`, `not_found`, etc.).\n     - Supporting filters (date ranges, limits) in the request to avoid sending unnecessary data.\n\n4. Separating entity state from API-level collections:\n   - A single entity state usually describes *one* thing (e.g., the current/next event or whether an event is active), while UI needs may require *all* backing data (e.g., all events in a month).\n   - The pattern used here keeps the entity state as the “next or current event” but also adds an internal `events` list that can be exposed via an API without overloading the primary entity state.\n   - This separation allows different consumers (automations vs. UI cards) to use the same entity for different purposes.\n\n5. Removing rarely-used, complex features that complicate the model:\n   - The old “offset in the event summary” feature increased complexity (regex parsing, offset calculations, special state attributes) and complicated tests.\n   - By removing it, the entity model became simpler and more consistent, making new features (like multi-event retrieval) easier to implement.\n   - This is a general reminder: when adding new infrastructure, consider whether existing niche features can be simplified or removed to reduce maintenance burden.\n\n6. Consistent time formatting and test expectations:\n   - Standardizing on ISO 8601 strings for exposed datetimes (“start_time”, “end_time”) simplifies client parsing and avoids ambiguity around timezone and format.\n   - Tests must be updated accordingly to expect the normalized format rather than ad-hoc formatting.\n   - When migrating, maintain both internal precise `datetime` fields and external string fields to balance correctness and usability.\n\n7. Testing websocket endpoints and error paths:\n   - Effective tests for websocket APIs should cover:\n     - Successful responses with valid input.\n     - Error responses for invalid entity IDs or missing data.\n     - Behavior of filters (start/end ranges, maximum count) to ensure business logic is correct and stable.\n   - Using simple fake components (e.g., a fake calendar component in `conftest.py`) allows precise control over test data and independence from real integrations.\n\nOverall, this PR demonstrates how to add a new API surface to an existing domain component by:\n- Defining a normalized internal data model.\n- Exposing that model via a validated websocket command.\n- Adjusting platform backends to populate the new model consistently.\n- Simplifying or removing legacy features that conflict with the new design.",
        "procedural_memory": [
            "How to design and implement a websocket API to return all events for an entity-backed calendar, and refactor the component to support it.",
            "Step 1: Define a normalized internal event schema.",
            " - Identify all the fields you need from provider events (e.g., summary, start, end, location, description, links, all-day flag).",
            " - Implement a `get_date()` helper (or equivalent) to handle multiple timestamp representations (e.g., `date` for all-day vs `dateTime` for time-specific events). Ensure you normalize to a timezone-aware datetime.",
            " - Write a `normalize_event(event)` function that:\n   - Converts provider-specific fields to your canonical schema.\n   - Stores internal datetime fields (e.g., `dt_start`, `dt_end`).\n   - Stores external-facing ISO 8601 strings for UI and APIs (e.g., `start`, `end`).\n   - Cleans up textual fields, e.g., trimming whitespace or collapsing multiple spaces.\n   - Marks all-day events consistently (e.g., `all_day = 'date' in event['start']`).",
            "Step 2: Extend the entity to store full event lists.",
            " - Add an internal attribute (e.g., `self._events`) and a read-only `events` property on your entity class, separate from the primary state attributes.",
            " - Keep the entity's main state focused (e.g., next/current event, or active/inactive) instead of mirroring the entire event list.",
            " - In the entity's `update()` (or `async_update()`):\n   - Normalize the main event (`self.data.event`) into `_cal_data` using `normalize_event`.\n   - If the backing data object has an `events` attribute and it contains events, set `self._events` to `[normalize_event(e) for e in self.data.events]`.\n   - On failures or empty results, call a `cleanup()` method that resets `_cal_data` and `_events` to `None`/empty values.",
            "Step 3: Update provider/backend classes to populate `events`.",
            " - For each platform providing calendar data (Google, CalDAV, demo, etc.):\n   - Add `self.events = None` in the provider's `__init__`.\n   - In the data retrieval method (`update()` or `async_get_events()`):\n     - Store the list of raw provider events in `self.events` (e.g., `self.events = result.get('items', [])`).\n     - Continue computing `self.event` as the next or current event, iterating over `self.events` instead of a separate local list.\n   - Ensure async backends return both the list from the method and set the attribute for the entity (as CalDAV does).",
            "Step 4: Store your domain component centrally for reuse.",
            " - During component setup, assign your `EntityComponent` (or domain manager) to a central registry, e.g., `hass.data[DOMAIN] = EntityComponent(...)` or analogous.\n   - This lets other subsystems (HTTP views, websocket handlers) retrieve the component without special hooks.",
            "Step 5: Implement the websocket command.",
            " - Decide on a `type` string, e.g., `'calendar/events'`.\n   - Define a schema using a validation library (e.g., voluptuous) for incoming messages:\n     - Required `type` and `entity_id` fields.\n     - Optional fields for filtering (e.g., `maximum`, `start`, `end`) with sensible defaults.\n   - Implement the handler, for example `get_calendar_info(hass, connection, msg)`:\n     - Retrieve the domain component from the central registry (e.g., `component = hass.data[DOMAIN]`).\n     - Resolve the entity with `component.get_entity(msg['entity_id'])`.\n     - If the entity doesn't exist, send an error message (e.g., `error_message(msg['id'], 'entity_not_found', 'Entity not found')`).\n     - If the entity has no events (`calendar.events is None`), send a `not_found` / 'Events not found' error.\n     - Otherwise, pass the events and filter parameters to a `filter_events(events, **msg)` function that applies date ranges and maximum limits.\n     - Return the filtered events via a success result message.",
            "Step 6: Implement event filtering logic.",
            " - Write a `filter_events(events, **filters)` helper that:\n     - Derives `start_day` and `end_day` from `filters['start'].date()` and `filters['end'].date()`.\n     - Iterates over normalized events and includes those satisfying the desired criterion (e.g., `start_day <= event['dt_start'].date() <= end_day`).\n     - Enforces `maximum` by limiting the length of the returned list.\n   - Keep the filter logic independent of the transport (websocket) for better testability.",
            "Step 7: Clean up or refactor legacy features that conflict with the new model.",
            " - Identify features that complicate the event representation (e.g., textual offsets embedded in event titles).",
            " - Remove associated configuration, parsing code, and state attributes where they are not essential or poorly used.\n   - Simplify entity attributes to represent only clean, normalized data.",
            "Step 8: Standardize time formats for external consumers.",
            " - Choose a single external time format (ISO 8601 is a good default) for `start_time` and `end_time` in entity attributes and API responses.\n   - Ensure all platforms and tests expect this format.\n   - Maintain internal datetime fields (`dt_start`, `dt_end`) so you can do correct comparisons and time zone handling.",
            "Step 9: Write tests for the new websocket behavior.",
            " - Add fixtures that set up a fake domain component and entities with deterministic events.\n   - Test at least the following cases:\n     - Requesting events for a non-existent entity ID -> error with `success: false` and an appropriate error message.\n     - Requesting all events without filters -> returns the full list.\n     - Requesting events within a specific day or date range -> returns only events in that window.\n     - Requesting with a `maximum` parameter -> caps the number of events returned.\n   - Also update existing platform tests to confirm:\n     - `start_time`/`end_time` use ISO 8601 strings.\n     - Offsets and other removed features are no longer present in state attributes.",
            "Step 10: Verify the integration end-to-end.",
            " - Manually or via integration tests, confirm that:\n     - The calendar component sets up correctly and stores its component in the central registry.\n     - Websocket requests of type `calendar/events` resolve entities and return the expected data.\n     - UI components (e.g., a calendar card) can consume the websocket response and render events on a timeline.",
            "Following these steps will help you add a robust websocket API to an existing entity-based component, normalize data from heterogeneous backends, and keep your component’s state model clean and maintainable."
        ]
    }
}
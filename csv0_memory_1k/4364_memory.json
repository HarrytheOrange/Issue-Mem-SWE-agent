{
    "search_index": {
        "description_for_embedding": "Home Assistant TP-Link (tplink) switch component needed support for the HS200 device. Support actually lived in the pyHS100 library, so the fix required bumping the pyHS100 dependency to a newer commit/version (0.2.1) via a GitHub-zip URL in REQUIREMENTS, and regenerating requirements_all.txt. The PR initially only updated the component’s REQUIREMENTS string, but reviewers clarified that the proper process is to update the library version in pyHS100 itself, then update Home Assistant’s dependency pins and regenerate the global requirements file.",
        "keywords": [
            "Home Assistant",
            "tplink",
            "TP-Link",
            "HS200",
            "pyHS100",
            "dependency update",
            "requirements_all.txt",
            "REQUIREMENTS variable",
            "device support via upstream library",
            "GitHub zip requirement",
            "integration bug",
            "IoT switch component"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a contributor attempted to add support for the TP-Link HS200 switch in Home Assistant’s tplink switch component. The HS200 support had already been added in the upstream pyHS100 library, but Home Assistant was still pinned to an older pyHS100 version (0.2.0) via a GitHub-archive URL in the component’s REQUIREMENTS variable. The contributor updated REQUIREMENTS in homeassistant/components/switch/tplink.py from commit 1f771b7... (pyHS100==0.2.0) to 9c39249... (pyHS100==0.2.1), which is the version containing HS200 support. Reviewers pointed out that simply changing the dependency in Home Assistant was not sufficient: the pyHS100 module itself needed its version bumped, and Home Assistant’s global requirements_all.txt must be regenerated using script/gen_requirements_all.py and committed. One of the library maintainers (GadgetReactor) updated pyHS100 to 0.2.1 and provided the correct GitHub-archive URL. However, the Home Assistant PR was never fully updated with the regenerated requirements_all.txt and passing tests, so the PR was marked stale and closed. The underlying technical need was to align Home Assistant’s dependency pin with the updated upstream library version that included the new device support.",
        "semantic_memory": "When an integration depends on a third-party library for device support, adding support for a new device model often requires updating that library rather than making changes directly in the main application. Once the upstream library adds support and bumps its version, the application should update its dependency pin consistently (e.g., REQUIREMENTS variables, consolidated requirements files), then regenerate any auto-generated requirements lists and run tests. In projects like Home Assistant, dependencies are often pinned to specific versions or commit hashes, sometimes via GitHub-archive URLs, so device support issues can manifest simply because the application is using an older commit of the underlying library. A best practice is to: 1) ensure the upstream library officially releases a new version; 2) update all relevant pins in the consuming project; and 3) follow the project’s dependency-update workflow (run generation scripts, update docs, and run tests). Additionally, PRs that only partially perform this workflow (e.g., changing a single REQUIREMENTS line without updating global requirements or tests) are likely to be rejected or go stale.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify where device support actually lives. For an integration that uses an external library (e.g., pyHS100 for TP-Link switches), confirm whether the missing device (e.g., HS200) is supported in the upstream library and in which version/commit.",
            "Step 2: If the upstream library does not support the device, add support there first. Implement and test the new device support in the library, bump the library’s version, and publish a release (or agree on a specific commit hash) according to that library’s workflow.",
            "Step 3: Determine the consuming project’s dependency management pattern. In Home Assistant, device integrations typically declare dependencies via a REQUIREMENTS list in each component and also in a central requirements_all.txt file, sometimes using GitHub-archive URLs pinned to specific commits and versions.",
            "Step 4: Update the component-level dependency pin. In the relevant integration file (e.g., homeassistant/components/switch/tplink.py), update the REQUIREMENTS entry to point to the new library version, including the correct GitHub-archive URL and version marker (for example: 'https://github.com/GadgetReactor/pyHS100/archive/<new_commit>.zip#pyHS100==0.2.1').",
            "Step 5: Regenerate global requirements. Run the project’s requirements generation script (for Home Assistant: script/gen_requirements_all.py), and commit the resulting changes to requirements_all.txt (and any other generated requirements files). This ensures consistent dependency pins across the project.",
            "Step 6: Run the test suite. Execute the project’s recommended tests (tox, pytest, etc.) to ensure that the dependency bump does not break existing functionality and that the new device works as expected.",
            "Step 7: Update documentation if user-visible behavior changes. If the new device support is user-facing, update the documentation in the appropriate docs repo (e.g., home-assistant.github.io) to mention the new supported device model and any configuration details.",
            "Step 8: Address review feedback quickly. If reviewers request additional changes (e.g., adjusting the version, regenerating requirements, or fixing imports), push updates promptly. Otherwise, the PR may be marked stale and closed.",
            "Step 9: For debugging similar issues in the future, verify versions first. When a device is known to be supported in a library but not working in the main application, compare the library version in use (pip show, logs, or pinned requirements files) against the version that introduced support. Mismatched or outdated dependency pins are a common cause of such problems.",
            "Step 10: Avoid partial dependency updates. Do not only update one place (like a single REQUIREMENTS variable) if the project has multiple dependency declarations. Always ensure all dependency references (component-level, global requirements files, lock files) are updated together to avoid inconsistent environments."
        ]
    }
}
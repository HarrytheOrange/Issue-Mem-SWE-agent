{
    "search_index": {
        "description_for_embedding": "Adds a napari CLI feature to run a Python script inside the Qt event loop via `napari path/to/script.py`, working whether or not the script uses `napari.gui_qt()`. It detects `.py` arguments, ensures only one script argument, runs it with `runpy.run_path` inside `gui_qt`, tracks whether a Qt app already existed, and properly closes the splash screen.",
        "keywords": [
            "napari CLI",
            "run python script",
            "Qt event loop",
            "gui_qt context manager",
            "runpy.run_path",
            "splash screen cleanup",
            "QApplication existed flag",
            "command line interface"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change introduces a new way to run napari from the command line: `napari path/to/script.py`. Previously, the CLI only accepted paths to image or data files and opened them in a viewer. Users wanted to run example/tutorial scripts with napari handling the Qt event loop regardless of whether the script itself used `napari.gui_qt()`.\n\nTo support this, the positional CLI argument name was generalized from `images` to `paths`. The argument parsing hack that splits out `--key=value` options from the positional arguments was updated to operate on `paths` rather than `images`.\n\nThe main new behavior is:\n- If any positional argument ends with `.py` and there is more than one positional argument, the program exits with a clear error: \"When providing a python script, only a single positional argument may be provided\".\n- If exactly one `.py` path is given, napari wraps execution of that script in the `gui_qt` context manager:\n  - `with gui_qt(startup_logo=True) as app:` is used.\n  - If the Qt splash screen exists, it is stored on the app as `app._splash_widget` by `gui_qt`, and the CLI immediately closes it (`app._splash_widget.close()`) before running the user script so the splash does not obscure or outlive the script's UI.\n  - The script is executed using `runpy.run_path(args.paths[0])`, which runs the script in-process.\n  - The `gui_qt` helper in `napari._qt.event_loop` is updated: when a Qt application already exists before entering `gui_qt`, it sets a private flag `app._existed = True`. This lets the CLI detect whether the script created or used an existing Qt app via `gui_qt` (for example, if the script itself calls `napari.gui_qt()` or constructs a viewer that triggers it). After running the script, the CLI checks `getattr(app, '_existed', False)` and calls `sys.exit()` if true, ensuring clean termination when using an existing app/event loop.\n\nTests were added in `test_cli.py` to verify the behavior:\n- A temporary script containing `1/0` is run via `napari script.py`, and the test asserts that a `ZeroDivisionError` is raised, proving that the script actually executes under the CLI.\n- The script is then overwritten with `import napari; v = napari.Viewer(show=False)`. Running it via `napari script.py` is expected to result in a `SystemExit`, validating that scripts that create a viewer (and thus interact with the Qt event loop) run and exit cleanly. The tests use `monkeypatch` to set `sys.argv` for the CLI.\n\nOverall, this PR extends the napari CLI from just opening data files to also acting as a script runner inside the Qt event loop, handling single-script constraints, Qt app existence, and splash screen lifecycle.",
        "semantic_memory": "Generalizable concepts and patterns from this change:\n\n1. **CLI-driven script execution inside a GUI event loop**\n   - A GUI application (here, napari with a Qt backend) can provide a CLI entry point that not only opens data files but also runs arbitrary Python scripts inside its event loop. This allows users to write scripts that assume a GUI context without having to explicitly manage the event loop in every script.\n   - Explicitly treat `.py` positional arguments as scripts to be executed, and keep this mode mutually exclusive with other positional arguments (e.g., data file paths) to avoid ambiguous semantics.\n\n2. **Using a context manager to manage GUI lifecycle**\n   - A context manager like `gui_qt()` can manage creation and teardown of the GUI application/event loop. Wrapping script execution in this context ensures that Qt is initialized before script code runs and is cleanly shut down afterward.\n   - The context manager can expose state back to callers by attaching attributes to the application object (e.g., `app._existed`, `app._splash_widget`), enabling coordination between the GUI lifecycle and higher-level logic.\n\n3. **Detecting pre-existing GUI environments**\n   - In environments where a GUI app may already be running (IPython, Jupyter, another process spawning napari, or nested `gui_qt` usage), it is important to detect that the Qt application already exists. Otherwise, re-entering event loop startup code can cause crashes or undefined behavior.\n   - A simple way to handle this is: when creating the app, check if one already exists. If it does, set a flag on the app object (e.g., `_existed = True`) and skip starting the main event loop on exit. Callers can examine this flag post-context to adjust behavior (e.g., to exit early if the inner script has already taken over the event loop).\n\n4. **Splash screen lifecycle management**\n   - Splash screens are often created at application startup. When embedding application startup inside other flows (like running a user script), ensure any splash screen is explicitly closed at an appropriate time, especially before handing control to user code that might have its own UI expectations.\n   - Attaching the splash widget to the app object (e.g., `app._splash_widget`) provides a simple handle so outer layers (the CLI) can close it without deeply coupling to the GUI internals.\n\n5. **Robust CLI argument handling**\n   - When combining `nargs='*'` positional arguments with named `--key=value` options, argument parsers may need additional post-processing to separate out `--` style options that were accidentally parsed into positionals. A manual pass over `args.paths`/`args.images` to move `--something` entries into `unknown` can resolve this.\n   - Restricting certain flags to specific usage modes (e.g., `--plugin` is only valid when file paths are provided) improves usability and avoids nonsensical combinations.\n\n6. **Testing CLI behavior and script execution**\n   - CLI behavior is testable by monkeypatching `sys.argv` and calling the main entry function directly.\n   - To prove that a script is actually executed, tests can plant deliberate exceptions (like `1/0`) in the temporary script and assert that the corresponding exception propagates out of the CLI call.\n   - To test GUI integration, scripts can import the main package and create viewer objects. The test then asserts that the CLI exits cleanly (e.g., `SystemExit`), indicating correct coordination between script execution, event loop management, and process exit.",
        "procedural_memory": [
            "Implementing and diagnosing CLI-based GUI script execution in a Qt (or similar) application:",
            "Step 1: Decide on CLI semantics for scripts vs. data files",
            "Determine how the CLI should distinguish between opening data files and running Python scripts. A common pattern is to treat any positional argument ending in `.py` as a script and forbid mixing scripts with other positional arguments. Define clear error messages for invalid combinations (e.g., \"When providing a python script, only a single positional argument may be provided\").",
            "Step 2: Extend the argument parser",
            "In your `__main__` or CLI module, update the positional arguments to be general (e.g., `paths` instead of `images`) and support `nargs='*'`. If your parser previously had a workaround for `--key=value` appearing in positional args, make sure it still works with the new generic name.",
            "Step 3: Detect and handle script mode",
            "After parsing arguments, check if any positional arguments end with `.py`. If more than one `.py` file or any additional positional arguments are present, exit with a descriptive error. If exactly one script path is given, switch into 'script mode' instead of 'open data files' mode.",
            "Step 4: Wrap script execution in a GUI context manager",
            "Implement or reuse a context manager (like `gui_qt`) that:\n- Creates the GUI application and optional splash screen if none exists.\n- Yields the app object to the caller.\n- On context exit, starts and/or terminates the event loop appropriately.\nWrap script execution like:\n\n```python\nwith gui_qt(startup_logo=True) as app:\n    if hasattr(app, '_splash_widget'):\n        app._splash_widget.close()\n    runpy.run_path(script_path)\n    if getattr(app, '_existed', False):\n        sys.exit()\n```",
            "Step 5: Track whether a GUI app already existed",
            "Inside your `gui_qt` implementation, detect if a QApplication already exists before creating a new one. If it did already exist, set a private flag on the app (e.g., `app._existed = True`). On exiting the context manager, use this flag to avoid starting a new event loop. Callers (like the CLI) can also inspect this flag to decide whether to exit immediately after the script finishes.",
            "Step 6: Manage splash screen lifecycle",
            "When you create a splash screen at startup, store a reference to it on the app object (e.g., `app._splash_widget = splash_widget`). In scenarios where you run user scripts, close the splash early (before the script runs) to avoid visual artifacts or interference with the scriptâ€™s UI.",
            "Step 7: Maintain legacy modes (e.g., opening data paths)",
            "If the positional argument is not a `.py` script, keep the legacy behavior: call your `view_path`/`open_files` function within `gui_qt` with any necessary keyword arguments and plugin options. Ensure `--plugin` or similar flags are only allowed in this mode, and explicitly error if misused.",
            "Step 8: Write tests for CLI and script behavior",
            "Use pytest (or similar) with `monkeypatch` to set `sys.argv` and call your `main()` function directly. Create temporary scripts to verify behavior:\n- A script that raises a known exception (like `1/0`) to assert that the CLI actually executes the script.\n- A script that imports the GUI package and creates a viewer or calls the GUI context manager. Assert that the CLI returns or raises `SystemExit` without hanging or double-starting the event loop.\nAlso test invalid combinations (multiple `.py` arguments, mixing scripts and data files) to ensure errors are clear.",
            "Step 9: Debugging issues with nested or existing event loops",
            "If you hit issues where the GUI hangs, doesn't show, or crashes when running scripts:\n- Check whether a QApplication already exists when you enter your context manager.\n- Ensure your context manager conditionally starts the event loop only when it created the app.\n- Use flags like `app._existed` to make behavior explicit and testable.\n- Confirm that scripts that themselves call `gui_qt` or create viewers do not cause re-entrant event loop calls.",
            "Step 10: Consider documentation and example migration",
            "Once the CLI-based script runner is stable, update documentation and examples to mention `napari path/to/script.py` (or your equivalent). If you plan to change examples to omit explicit `gui_qt` context managers, do so gradually and consider tooling (like docs-side buttons) to show both standalone and notebook/IPython-friendly usage."
        ]
    }
}
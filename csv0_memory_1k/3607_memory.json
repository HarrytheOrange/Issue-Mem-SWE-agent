{
    "search_index": {
        "description_for_embedding": "In napari, the points layer ADD mode cursor was changed from a pointing hand to a custom crosshair cursor. A QPixmap-based crosshair was implemented and wired into the viewer cursor styles. Initial attempts scaled the cursor with the viewer cursor size/zoom, which led to odd behavior (very large cursors, drawing outside the window). The final fix uses a constant-size (25px) crosshair cursor, independent of zoom, and cleans up debug prints.",
        "keywords": [
            "napari",
            "Qt",
            "QCursor",
            "QPixmap",
            "QPainter",
            "custom cursor",
            "crosshair cursor",
            "points layer",
            "ADD mode",
            "cursor scaling",
            "zoom-independent cursor",
            "viewer_model",
            "CursorStyle",
            "qt_viewer",
            "_qt.utils.crosshair_pixmap"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the napari team improved the UX for placing points by replacing the default pointing-hand cursor with a custom crosshair cursor when the points layer is in ADD mode.\n\nOriginally, the points layer `_cursor_modes` mapped `Mode.ADD` to the `'pointing'` cursor. The issue requested a crosshair design (based on a community design by Isabela). The implementation required several iterations:\n\n1. A new cursor type was added:\n   - `CursorStyle.CROSSHAIR = 'crosshair'` in `napari/components/_viewer_constants.py` and referenced in the `Cursor` model's docstring in `napari/components/cursor.py`.\n   - The points layer mapping in `napari/layers/points/points.py` was updated so `Mode.ADD` now uses `'crosshair'` instead of `'pointing'`.\n\n2. On the Qt side, support for the new cursor style was added to the viewer:\n   - In `napari/_qt/qt_viewer.py`, `_on_cursor` gained a branch for `cursor == 'crosshair'` that creates a `QCursor` from `crosshair_pixmap(...)`.\n   - Initially, `crosshair_pixmap(size)` was called with the viewer cursor size, so the cursor scaled with zoom or cursor size.\n\n3. The custom crosshair graphics were implemented as a QPixmap function in `napari/_qt/utils.py`:\n   - A new `@lru_cache`-decorated function `crosshair_pixmap(...)` was added and iteratively refined.\n   - The implementation uses `QPixmap(QSize(size, size))` + `QPainter` to draw a white cross (horizontal and vertical bars) and a central hollow square, with black outlining for contrast. The crosshair is designed so the central area is transparent/clear, helping the user position points precisely.\n   - Early revisions attempted proportional scaling (e.g., using ratios of `size` for thickness and offsets, or scaling by `25 * size`). There was also a temporary blue debug dot at the center.\n\n4. UX feedback and behavior change:\n   - Reviewers observed that scaling the cursor with zoom caused weird behavior: the cursor would grow very large, could extend beyond the window, and generally felt wrong for point placement. It seemed more appropriate for painting labels than placing points.\n   - Based on this feedback, the author removed cursor scaling with zoom. The final `crosshair_pixmap` signature was simplified to `crosshair_pixmap()` (no size argument) and a fixed `size = 25` pixels was used inside the function so the cursor appears with a constant on-screen size regardless of zoom.\n\n5. Cleanup:\n   - Debug `print(cursor)` in `qt_viewer._on_cursor` and `print(event.cursor)` in `viewer_model._update_cursor` were removed.\n   - The temporary blue center point in the crosshair drawing logic was also removed.\n\nThe result is that when the user switches the points layer into ADD mode, they now see a high-contrast crosshair cursor of fixed pixel size that does not scale with zoom, improving precision and consistency during point placement.",
        "semantic_memory": "This PR illustrates several generalizable patterns for GUI and visualization development, especially when dealing with custom cursors and interaction modes:\n\n1. **Custom cursors via QPixmap/QPainter**\n   - GUI frameworks like Qt allow you to create custom cursors by drawing into a `QPixmap` with `QPainter` and wrapping it in a `QCursor`.\n   - To ensure the cursor looks sharp and consistent, keep the base bitmap size modest (e.g., ~16â€“32 px) and use integer coordinates and consistent line widths.\n   - Use high-contrast colors (white with black outlines) and clear shapes to make cursors visible atop diverse image backgrounds.\n\n2. **Separating semantic cursor style from backend implementation**\n   - A clear `CursorStyle` enum in the core model (e.g., `SQUARE`, `CIRCLE`, `CROSSHAIR`, `POINTING`, `STANDARD`) decouples the conceptual cursor styles from the GUI-specific creation logic.\n   - Layers or tools can map their modes (e.g., `Mode.ADD`, `Mode.SELECT`) to abstract cursor style strings, and the viewer/Qt layer translates those into actual `QCursor` objects.\n   - This makes it easy to swap cursor implementations or redesign them without touching the interaction logic.\n\n3. **Cursor behavior vs. zoom / scaling**\n   - Cursor size that scales with zoom can feel intuitive for brush tools (e.g., painting labels where brush radius relates to world units), but is often undesirable for point placement or selection tools.\n   - Over-scaling cursors with zoom can lead to:\n     - Cursors that extend beyond the viewport or become distractingly large.\n     - Difficulties in precise interaction (the cursor obscures the target or appears laggy/awkward).\n   - For precise point placement, a constant pixel-size cursor is usually more predictable and easier for users to control, regardless of zoom level.\n   - A good rule of thumb: tie cursor scale to **tool semantics**, not just to the camera zoom. Only scale when the cursor represents a physical brush size or selection radius.\n\n4. **Design iteration and clean-up in UI/UX changes**\n   - Iterative visual tuning (adjusting line thickness, rectangle sizes, join styles, etc.) is often necessary to get a cursor that looks good across different display scales and themes.\n   - Use `@lru_cache` for cursor pixmaps to avoid re-allocating and re-painting the same shapes repeatedly; cursors change infrequently.\n   - Remove debugging artifacts (prints, debug dots, exaggerated sizes) before merging; these can otherwise confuse users or clutter logs.\n\n5. **Mode-aware, tool-specific cursor feedback**\n   - Using distinct cursors for different modes (e.g., add vs. select vs. pan/zoom) provides immediate feedback on what interaction will occur when the user clicks.\n   - For spatial annotation tools (points, shapes, landmarks), a crosshair with a clear center is particularly effective at signaling precise placement, as opposed to a generic arrow or pointing hand.\n\nOverall, this change demonstrates how to design and implement a mode-specific cursor with carefully considered behavior (constant size, high-contrast design) that improves user experience in image annotation tools.",
        "procedural_memory": [
            "Implementing and adjusting a custom, zoom-independent cursor in a Qt-based viewer:",
            "Step 1: Define or extend an abstract cursor style enum in your core model.",
            " - Add a new entry such as `CROSSHAIR = 'crosshair'` to your cursor-style enumeration in the core (non-GUI) layer.",
            " - Update any relevant docstrings so the new style is documented and discoverable.",
            "",
            "Step 2: Map tool or layer modes to the new cursor style.",
            " - Identify the mode in which you want the new cursor (e.g., a points layer ADD mode).",
            " - Update the mode-to-cursor mapping, e.g.:",
            "   - `_cursor_modes = { Mode.ADD: 'crosshair', Mode.SELECT: 'standard', ... }`.",
            " - Ensure that whatever event system you use passes this cursor style string/enum up to the viewer when the active mode changes.",
            "",
            "Step 3: Implement a QPixmap factory for the cursor graphic.",
            " - In your Qt utils module, implement a function that returns a `QPixmap` with the desired cursor figure:",
            "   - Decorate it with `@lru_cache` if the pixmap does not depend on dynamic inputs, so it is created once and reused.",
            "   - Choose a **fixed pixel size** unless you explicitly want scaling (e.g., `size = 25`).",
            "   - Create the pixmap: `pixmap = QPixmap(QSize(size, size)); pixmap.fill(Qt.transparent)`.",
            "   - Use `QPainter` and `QPen` to draw the cursor shape (cross bars, central hollow square, outlines).",
            "   - Use high contrast (white bars, black outlines) and symmetric layout around the center point.",
            " - Design for odd dimensions so there is a clear center pixel.",
            "",
            "Step 4: Integrate the pixmap with Qt's cursor handling.",
            " - In the viewer's Qt class (e.g., `qt_viewer.py`), in the cursor update method (like `_on_cursor`), add a case for the new cursor style:",
            "   - `elif cursor == 'crosshair': q_cursor = QCursor(crosshair_pixmap())`.",
            " - Avoid passing zoom- or size-dependent parameters if you want a constant-size cursor; use a fixed pixmap size instead.",
            "",
            "Step 5: Decide on scaling behavior deliberately.",
            " - If you initially tie cursor size to zoom or a `cursor.size` attribute, test how it feels for the specific tool:",
            "   - If the cursor becomes unwieldy at high zoom or extends beyond the viewport, consider decoupling cursor size from zoom.",
            " - For tools that represent world-space radius (e.g., brush tools), scaling the cursor with zoom may make sense.",
            " - For precise point placement, prefer a constant-size cursor to maintain predictability.",
            "",
            "Step 6: Clean up debugging artifacts.",
            " - Remove `print(...)` calls added during cursor debugging from both the viewer and the model to avoid noisy logs.",
            " - Remove any debug graphics in the cursor drawing (e.g., colored dots at the center) before finalizing.",
            "",
            "Step 7: Test across modes and zoom levels.",
            " - Manually verify that:",
            "   - The new cursor appears only in the intended mode (e.g., points ADD mode).",
            "   - Switching back to other modes restores their original cursors.",
            "   - The cursor remains a comfortable, constant size at different zoom levels if that is the intended behavior.",
            " - Optionally, add automated tests for the mode-to-cursor mapping and for the existence of the new cursor style string in the model.",
            "",
            "Step 8: Iterate on visual design if needed.",
            " - Adjust line thicknesses, padding, and square dimensions for clarity and visibility on typical monitor resolutions and color schemes.",
            " - Keep the center of the crosshair visually clear (transparent area or small hollow), especially important for point placement tools."
        ]
    }
}
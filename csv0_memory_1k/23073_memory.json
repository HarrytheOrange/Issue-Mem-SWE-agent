{
    "search_index": {
        "description_for_embedding": "Home Assistant SABnzbd integration failed to work for SABnzbd instances configured with a non-root url_base (e.g., behind a reverse proxy). The fix adds an optional `path` configuration option, passes it as `web_root` into the pysabnzbd SabnzbdApi client, and threads it through both normal setup and interactive configuration flows so API URLs are built correctly with the base path.",
        "keywords": [
            "Home Assistant",
            "SABnzbd",
            "reverse proxy",
            "url_base",
            "base path",
            "web_root",
            "SabnzbdApi",
            "configuration.yaml",
            "HTTP path handling",
            "integration setup failure"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant SABnzbd component did not support SABnzbd instances that were configured with a non-root `url_base` (for example, when SABnzbd is reverse proxied at `/sabnzbd`). The integration only constructed the API base URL from scheme, host, and port, assuming SABnzbd was available at `/` on that host. For deployments using `url_base`, pysabnzbd would generate incorrect API URLs, causing connection or authentication failures.\n\nTo fix this, the PR introduced an optional `path` setting to the SABnzbd configuration schema, mapped to `CONF_PATH`. In `async_configure_sabnzbd`, the code reads `web_root = config[CONF_PATH]` and passes it into `SabnzbdApi(base_url, api_key, web_root=web_root, session=...)`. The configuration flow helper `async_request_configuration` was also updated to accept `web_root` as a parameter and to pass it when creating `SabnzbdApi` inside the async configuration callback. This ensures that both initial setup and interactive reconfiguration use the same base path and that pysabnzbd builds correct API URLs for SABnzbd instances served under a path prefix like `/sabnzbd`.",
        "semantic_memory": "When integrating with web services that can be hosted behind reverse proxies or under custom base paths, it is not enough to handle only scheme, host, and port. Many services expose a `url_base`, `web_root`, or similar option that shifts the API under a path prefix (e.g., `/sabnzbd`, `/api`, `/service`). Client libraries must be able to incorporate this base path into their URL construction logic, and upstream integrations should expose a configuration option for it and pass it through consistently.\n\nA general best practice is:\n- Model the service endpoint as `scheme://host:port + base_path`, not just `scheme://host:port`.\n- If the underlying client library (here, pysabnzbd) already supports a `web_root` or base-path parameter, the integration should map configuration to that parameter rather than manually concatenating paths.\n- Any configuration or reconfiguration flows (UI prompts, wizards, retry logic) must pass the same base-path value when re-instantiating the client, otherwise validation and runtime behavior diverge.\n- Use shared constants (e.g., `CONF_PATH`) and centralized schemas to keep configuration consistent across components that require path support.\n\nThis pattern applies broadly to HTTP-based integrations, especially in self-hosted or enterprise environments where reverse proxies and path-based routing are common.",
        "procedural_memory": [
            "When an integration fails to reach a service behind a reverse proxy or with a non-root URL base, check whether the integration and its HTTP client correctly support a base path / web_root in addition to scheme, host, and port.",
            "Step 1: Reproduce and characterize the failure.\n- Deploy or identify a service instance that uses a non-root base path (e.g., `http://host:port/sabnzbd`).\n- Configure the integration using only host, port, and SSL settings, and observe connection or authentication failures or 404s.\n- Verify via logs or HTTP traces that requests are going to `http://host:port/...` instead of `http://host:port/<base_path>/...`.",
            "Step 2: Inspect the client library and integration code.\n- Open the integration module and see how it constructs the base URL or client instance (e.g., `SabnzbdApi(base_url, api_key, session=...)`).\n- Check the client library documentation or source to see if it has parameters like `web_root`, `base_path`, or `url_base` that adjust request paths.\n- Confirm whether such a parameter is currently exposed or configured by the integration.",
            "Step 3: Extend the configuration schema.\n- Introduce a new optional configuration option for the base path (e.g., `CONF_PATH` or `base_path`).\n- Update the integration’s config schema to accept this option with appropriate validation (string, may be empty, may start with `/`).\n- Update documentation and configuration examples (e.g., `sabnzbd: path: /sabnzbd`).",
            "Step 4: Thread the base path into client initialization.\n- Read the new config value where the client is constructed (e.g., `web_root = config[CONF_PATH]`).\n- Pass this value into the client constructor (e.g., `SabnzbdApi(base_url, api_key, web_root=web_root, session=...)`).\n- Avoid hard-coding path concatenation logic in the integration when the client library already handles it.",
            "Step 5: Update all configuration / retry flows consistently.\n- Identify any helper or callback functions that re-instantiate the client (e.g., interactive configuration flows like `async_request_configuration`).\n- Update their signatures to accept the base path and pass it through when creating the client.\n- Ensure the same base path is used both during initial validation and during normal operation.",
            "Step 6: Test with and without the base path.\n- Test a standard setup where the service is at the root (`/`); verify that leaving `path` unset preserves existing behavior.\n- Test a reverse-proxied or `url_base` setup (e.g., `/sabnzbd`), specifying the path in configuration, and confirm that requests now succeed and target the correct URLs.\n- Add or update automated tests if the project’s testing infrastructure supports mocking HTTP clients and configurations.",
            "Step 7: Document the new option and edge cases.\n- Add documentation describing when and why to set the `path` / `base_path` option (e.g., when using reverse proxies or custom `url_base`).\n- Mention expected format (leading slash or not) and how the underlying client interprets it.\n- Note that if the path is misconfigured, the integration may return 404s or fail to connect."
        ]
    }
}
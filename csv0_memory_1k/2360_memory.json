{
    "search_index": {
        "description_for_embedding": "Home Assistant MQTT switch/binary_sensor state handling issue when using JSON payloads. The code was assuming that the same payload string is used both to send commands (payload_on/off) and to determine state, which breaks when a value_template is used to extract a subfield from a JSON message. The proposed fix introduces separate status_on/status_off configuration options and uses those for state comparison, allowing payload_on/off to be full JSON commands while state comparison uses simple scalar status values.",
        "keywords": [
            "Home Assistant",
            "MQTT",
            "switch",
            "binary_sensor",
            "payload_on",
            "payload_off",
            "status_on",
            "status_off",
            "value_template",
            "JSON payload",
            "state comparison",
            "MQTT_RO_PLATFORM_SCHEMA",
            "MQTT_RW_PLATFORM_SCHEMA",
            "command_line binary_sensor",
            "template.render_with_possible_json_value"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, a user reported that Home Assistant's MQTT switch and binary_sensor platforms behaved badly when the MQTT payloads were JSON and a value_template was used. The original design used payload_on and payload_off for two purposes: (1) as the command payloads to publish to the MQTT broker, and (2) as the expected values for incoming state messages. The code did `if payload == self._payload_on` / `elif payload == self._payload_off` after optionally applying a value_template. The user wanted to send full JSON commands, e.g. `'{\"action\":\"input\",\"pin\":4,\"switch\":1}'` for payload_on and `'{\"action\":\"input\",\"pin\":4,\"switch\":0}'` for payload_off, while using a value_template that extracted a specific field from the JSON (e.g., `{{ value_json.pin4 }}`) and then compare that to a simple status like '1' or '0'. Because the code compared against payload_on/off directly, once the template was applied the comparison never matched, effectively breaking state updates. The PR introduced new configuration options status_on and status_off for MQTT binary_sensor and MQTT switch (and partially for command_line binary_sensor). These defaulted to the same values as payload_on/off (`\"ON\"` and `\"OFF\"`) for backward compatibility. The message_received callbacks were updated so that after applying the value_template, the code compares the resulting payload against status_on/status_off instead of payload_on/payload_off. This allows payload_on/off to be arbitrary command payloads (including JSON) while status_on/off define the scalar value representing the entity's state. During review, a maintainer pointed out that the user’s configuration misuse could also be fixed by placing the state representation in status_on/status_off and using value_template correctly, without needing to overload payload_on/off with full JSON. The PR eventually went stale and was closed, but the underlying pattern—decoupling command payloads from state comparison values—is an important design lesson.",
        "semantic_memory": "This incident illustrates a recurring design pattern and pitfall when dealing with MQTT or similar messaging systems: the distinction between command payloads sent to actuators and state payloads received from them. Overloading a single configuration field to serve both as the outgoing command and the incoming status reference is fragile, especially once message transformation (templates, JSON parsing, etc.) is involved.\n\nGeneralizable lessons:\n\n1. **Separate command and state concepts**: In protocols like MQTT, the payload published to a `command_topic` should be configurable independently from what is expected on a `state_topic`. Conflating these leads to subtle bugs when the payload formats diverge or when an intermediary modifies messages.\n\n2. **Template processing changes the comparison domain**: When using a template (e.g., Jinja + JSON extraction) to process incoming payloads, the resulting value is often a small scalar (\"1\", \"ON\", true) derived from a larger structure. Comparing that processed value to the original unprocessed payload string is incorrect. Instead, comparisons should be made against a field explicitly defined in that post-template domain (e.g., status_on/status_off or a similar concept).\n\n3. **Backward-compatible configuration evolution**: When extending a configuration schema to separate concerns (e.g., adding status_on/status_off), default the new fields to the old ones' values to retain behavior for existing configurations. Then update internal logic to use the more semantically precise fields.\n\n4. **Configuration misuse vs. framework deficiencies**: Sometimes user issues stem from misunderstanding how to use existing configuration fields (as the reviewer noted: state values belonged in status_on/status_off and not in payload_on/off). However, repeated confusion or awkward configurations can indicate that the underlying API is not clearly expressing the separation between responsibilities. Designing explicit, separate configuration fields for commands and state can reduce confusion.\n\n5. **Avoid tight coupling to raw protocols in business logic**: Application state should depend on domain-level concepts (\"switch is ON\") rather than on raw protocol payloads (the exact JSON string). Templates or adapters should translate from protocol payloads to domain values, and internal code should compare domain values.\n\nThese principles apply broadly to IoT integrations, event-driven systems, and any architecture where serialized messages are transformed before affecting application state.",
        "procedural_memory": [
            "When diagnosing MQTT state issues where JSON payloads and templates are involved, separate the concepts of command payloads and state representation and ensure the code compares the correct, post-template values.",
            "Step 1: Reproduce the issue. Configure an MQTT entity (switch or binary_sensor) with JSON payloads for commands (payload_on/payload_off) and a value_template that extracts a part of the JSON. Observe that state updates do not occur as expected when publishing state messages.",
            "Step 2: Inspect the code path for incoming MQTT messages. Identify where the raw payload is optionally passed through a template (e.g., template.render_with_possible_json_value) and what value is actually returned from that template.",
            "Step 3: Check how state is determined. If you see logic like `if payload == self._payload_on` / `elif payload == self._payload_off` after applying a template, recognize this as a bug: the processed payload is being compared to the outgoing command payload definitions rather than to a dedicated state representation.",
            "Step 4: Design a separation of concerns. Introduce new configuration options (e.g., status_on and status_off) whose sole responsibility is to represent the post-template state values ('ON', 'OFF', '1', '0', true/false, etc.). Keep payload_on/payload_off for command-topic payloads only.",
            "Step 5: Update configuration schemas. In your platform schema (e.g., MQTT_RO_PLATFORM_SCHEMA / MQTT_RW_PLATFORM_SCHEMA), add optional fields for status_on and status_off with defaults equal to the existing payload_on and payload_off defaults to preserve backward compatibility.",
            "Step 6: Wire new config through constructors. Update setup_platform to read status_on/status_off from the config and pass them into the entity constructor (e.g., MqttSwitch or MqttBinarySensor). Add corresponding instance attributes (self._status_on, self._status_off).",
            "Step 7: Fix message handling logic. In the message_received callbacks, after applying value_template, change the comparisons from payload_on/payload_off to status_on/status_off, e.g.: `if payload == self._status_on: self._state = True` / `elif payload == self._status_off: self._state = False`.",
            "Step 8: Ensure defaults maintain existing behavior. Verify that if a user does not configure status_on/status_off, the defaults ('ON'/'OFF') still allow legacy configurations (where payload_on/off == status_on/off) to work exactly as before.",
            "Step 9: Add tests. Write unit tests that cover: (a) plain text payloads without templates; (b) JSON payloads with value_template returning 'ON'/'OFF' and status_on/status_off set accordingly; and (c) regression tests that confirm existing configurations without status_on/status_off still function.",
            "Step 10: Document usage clearly. In the documentation, explain that payload_on/off define what is sent to the device (commands), while status_on/off define what values in incoming messages (after templates) map to 'on' and 'off' states. Provide JSON examples showing full JSON in payload_on/off and simple values in status_on/off.",
            "Step 11: When encountering similar user reports, first check if the issue is a configuration misunderstanding. Ensure the user’s value_template output matches their status_on/status_off configuration. Only if the configuration is correct and the behavior is still wrong, look for logic that improperly reuses command payloads as state comparators.",
            "Step 12: Apply the same pattern across other integrations. For other protocols or platforms (HTTP, command_line, WebSocket), audit the code for places where outgoing payload definitions are reused as incoming state references, and refactor to separate state values from command payloads."
        ]
    }
}
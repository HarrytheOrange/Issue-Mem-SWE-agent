{
    "search_index": {
        "description_for_embedding": "Home Assistant Brottsplatskartan sensor bug where incident type counters in entity attributes were monotonically increasing and never reset, even though the total incident count reset daily. Fix: recreate the attributes dict on each update and re-calculate incident type counts from current incidents, effectively resetting them daily and removing unused tracking of previous incidents.",
        "keywords": [
            "Home Assistant",
            "Brottsplatskartan",
            "sensor",
            "entity attributes",
            "counter never resets",
            "daily reset",
            "stale attributes",
            "statistics over time window",
            "remove unused state",
            "lazy import",
            "breaking change"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant Brottsplatskartan sensor, the total number of incidents (`self._state`) was reset every day, but the per-incident-type counters stored in the entity's attributes were not. They were maintained in a dict that was only updated, never cleared, and there was additional unused logic tracking `self._previous_incidents`. As a result, the type counters effectively accumulated over the lifetime of Home Assistant instead of reflecting a daily snapshot, which was confusing to users and inconsistent with the main state. The fix changed the update behavior so that on every `update()` call, the code constructs a fresh `incident_counts` dict, recomputes counts for the current incidents only, then recreates `_attributes` with just the attribution and these fresh counts. This inherently resets the per-type counters along with the daily state. At the same time, the unused `previous_incidents` tracking and related logic were removed, and the `brottsplatskartan` import was moved into `update()` to follow the local-import pattern. The result is that both the main state and the incident type attributes now reset daily, while the code is cleaner and free of dead state-tracking logic. This change is marked as a breaking change because attribute behavior (and thus automation expectations) changes: type counts no longer accumulate across restarts or days.",
        "semantic_memory": "When modeling time-bounded statistics (e.g., 'today's incidents by type') in long-running services, you must ensure that all derived counters and attributes are reset or recomputed consistently with the intended time window. Simply updating an attributes dict in-place can leave stale keys and values that no longer reflect the current time slice, especially if categories can disappear or if you expect counters to reset with the main state.\n\nA robust pattern is to treat each update as a full recomputation: derive a fresh map of counts from the current data and then replace the attributes structure entirely, rather than mutating it. This guarantees that removed categories vanish and old values don't persist.\n\nAdditionally, tracking extra state (like `previous_incidents`) that is not actually used in any behavior or output adds complexity and can create subtle bugs if future logic accidentally relies on it. Removing dead code and unused state makes sensor behavior easier to reason about and maintain.\n\nIn frameworks like Home Assistant, it's also a best practice to use lazy imports inside functions (e.g., inside `update()`) for optional/extra dependencies. This keeps the component importable even if optional dependencies are missing and can reduce startup costs.\n\nFinally, any change that alters how an entity's attributes or counters behave over time (reset logic, time windows, aggregation semantics) should be treated as a breaking change, because automations and dashboards may rely on the old semantics.",
        "procedural_memory": [
            "To diagnose and fix counters or attributes that never reset and accumulate incorrectly in a long-lived sensor:",
            "Step 1: Clarify the intended time window and semantics of the sensor's state and attributes (e.g., 'total incidents today', 'events in last hour'). Verify whether all outputs (state and attributes) follow the same time window.",
            "Step 2: Inspect the sensor implementation, focusing on the `update()` method or equivalent refresh logic. Look for any dict or list of counts/attributes that is updated in-place (e.g., `self._attributes.update(...)`) without ever being cleared or replaced.",
            "Step 3: Check if there is any stateful tracking of previous data (e.g., `previous_incidents`, cached IDs, cumulative counters) that is not strictly necessary for the current spec. Identify whether this state is actually used to produce outputs or enforce a time window.",
            "Step 4: Reproduce the issue by running the integration over the relevant time period (e.g., overnight or across several refresh cycles), and inspect the sensor's attributes over time. Confirm that counters only grow and never drop or reset when expected.",
            "Step 5: Implement a fix by recomputing the relevant counters from the current dataset on each update. Use a fresh local map (e.g., `incident_counts = defaultdict(int)`) and, after computation, assign a brand-new attributes dict (e.g., `self._attributes = {ATTR_ATTRIBUTION: ATTRIBUTION}` followed by `self._attributes.update(incident_counts)`) instead of mutating the old one.",
            "Step 6: Align state and attributes: ensure that when the main state is conceptually reset (e.g., at midnight or based on current-fetch semantics), the associated per-category counters are inherently reset because they are derived only from current data.",
            "Step 7: Remove unused state-tracking variables and code paths (like `self._previous_incidents`) that no longer serve a purpose. This prevents confusion and potential bugs in future modifications.",
            "Step 8: Follow framework-specific best practices, such as using lazy imports inside functions for optional dependencies (e.g., `import brottsplatskartan` inside `update()` for Home Assistant), and ensure tests pass.",
            "Step 9: Document the behavioral change clearly, especially if attribute values will now reset or decrease where they previously only increased. Mark the change as breaking if existing users or automations might rely on the old cumulative behavior.",
            "Step 10: After deployment, validate by observing the sensor across a full cycle (e.g., one day) and confirming that both state and attribute counters reset or update as intended, without stale categories or ever-increasing counts."
        ]
    }
}
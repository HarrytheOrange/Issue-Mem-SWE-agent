{
    "search_index": {
        "description_for_embedding": "Home Assistant refactor: the built-in map panel registration was moved out of the frontend component into a dedicated map component. The map panel is now enabled/disabled via the `map:` key in configuration.yaml, making it optional and consistent with other built-in panels. The new map component exposes an async_setup that registers the panel with the frontend.",
        "keywords": [
            "home-assistant",
            "map panel",
            "frontend",
            "component split",
            "optional panel",
            "configuration.yaml",
            "register_built_in_panel",
            "async_setup",
            "breaking change",
            "UI panel configuration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the Home Assistant map functionality was refactored out of the core frontend component into its own dedicated `map` component. Previously, the frontend component (`homeassistant/components/frontend/__init__.py`) unconditionally registered the map panel using `register_built_in_panel(hass, 'map', 'Map', 'mdi:account-location')`. This meant the map UI was always present and could not be disabled via configuration. \n\nThe fix introduced a new `homeassistant/components/map.py` module with a `DOMAIN = 'map'` and an `async_setup(hass, config)` coroutine. Inside this setup function, the map panel is registered via `register_built_in_panel(hass, 'map', 'Map', 'mdi:account-location')` and returns True. The registration line was removed from the frontend component so that the panel appears only when the `map` component is loaded.\n\nThe default configuration (`homeassistant/config.py`) was updated to include a commented/templated `map:` section alongside other core features (`logbook:`, `sun:`), signaling that the map is a configurable, optional feature. Functionally, this is a breaking change: existing users who relied on the previously always-on map panel must now explicitly add `map:` to their `configuration.yaml` to re-enable it. \n\nA small design discussion occurred around whether the `map` component should explicitly depend on the `frontend` component since it imports `register_built_in_panel` from `homeassistant.components.frontend`. The direct import indicates a dependency, but the refactor’s main goal was to bring the map in line with other built-in panels and make it toggleable via configuration rather than always-on in the frontend.",
        "semantic_memory": "This change embodies several generalizable patterns and best practices:\n\n1. **Decoupling UI panels from core frontend logic**: Hard-wired UI elements in a global frontend module make features always-on and harder to configure. Moving them into dedicated components or modules allows fine-grained enablement/disablement through configuration and simplifies reasoning about what features are active.\n\n2. **Making features first-class, configurable components**: Treating features (like a map view) as separate components with their own domains aligns them with the rest of the system. This yields a more consistent configuration model (e.g., `map:`) and a clearer mental model for users and developers. It also makes future extension (additional options, new behaviors) easier because the feature has a dedicated module and lifecycle.\n\n3. **Using component setup hooks to register frontend panels**: When a UI panel depends on runtime state (like which components are enabled), the appropriate place to register it is within that component’s `setup`/`async_setup` hook, not in a central frontend initializer. This ensures that the panel only appears when its underlying functionality is active.\n\n4. **Explicit breaking changes via configuration toggles**: Moving a previously always-enabled feature behind a configuration key is inherently breaking. Good practice is to update defaults, documentation, and clearly communicate that users must add a specific config entry (here, `map:`) to preserve existing behavior.\n\n5. **Managing inter-component dependencies**: If a component relies on APIs from another (e.g., `map` importing `register_built_in_panel` from `frontend`), the design should acknowledge and handle that dependency. This can be through explicit dependency declarations, clear documentation, or guaranteed initialization order. Keeping dependencies explicit improves maintainability and reduces subtle initialization bugs.\n\n6. **Consistency across built-in modules**: Aligning all built-in panels so they each have a dedicated component reduces special cases. A uniform pattern (one component per feature, each registering its UI panel) simplifies both the codebase and cognitive load when adding new panels or debugging existing ones.",
        "procedural_memory": [
            "When you have a UI panel or feature that is currently hard-wired into a global frontend/module and you want it to be optionally configurable, follow these steps:",
            "Step 1: Identify hard-wired functionality\n- Locate where the UI panel or feature is being registered or initialized unconditionally (e.g., a `register_built_in_panel` call in a global frontend initializer).\n- Confirm that there is no dedicated component or configuration key controlling this behavior.",
            "Step 2: Create a dedicated component/module\n- Add a new module for the feature (e.g., `components/map.py`) with a unique `DOMAIN`.\n- Implement `setup` or `async_setup(hass, config)` in this module.\n- Move the registration/initialization logic into this setup function (e.g., call `register_built_in_panel` there).\n- Ensure the function returns `True` on successful setup.",
            "Step 3: Remove the hard-wired registration from the global frontend\n- Delete or comment out the old registration logic from the global/frontend module so that the panel is no longer always created.\n- Verify that the feature now appears only when the new component is enabled.",
            "Step 4: Wire it into configuration\n- Choose a configuration key (e.g., `map:`) corresponding to the new component’s domain.\n- Update the default configuration template (e.g., `config.py` or sample configuration yaml) to include this key, typically with a short comment describing the feature.\n- Ensure the application’s configuration loader will instantiate the new component when that key is present.",
            "Step 5: Handle dependencies between components\n- If the new component imports functions or uses API from another component (e.g., `frontend`), make this dependency explicit where the framework supports it (e.g., dependency lists) or ensure proper initialization order.\n- Document the dependency so future maintainers understand why the import is there.",
            "Step 6: Update documentation and mark breaking changes\n- Clearly document that the feature, previously always enabled, now requires an explicit configuration entry.\n- Provide before/after examples in documentation (e.g., add `map:` to `configuration.yaml`).\n- Note that this is a breaking change so users know to update their configuration to maintain the old behavior.",
            "Step 7: Test behavior in both modes\n- Run tests (e.g., `tox` or framework-specific tests) with the feature enabled (config key present) and disabled (config key absent).\n- Confirm that: (a) the panel appears and works when enabled, and (b) the application runs cleanly without errors or stray UI elements when disabled.",
            "Step 8: Apply this pattern to similar features\n- For any other panels or features that are still registered centrally, consider extracting them into dedicated components using the same pattern.\n- This leads to a more modular, maintainable, and user-configurable system overall."
        ]
    }
}
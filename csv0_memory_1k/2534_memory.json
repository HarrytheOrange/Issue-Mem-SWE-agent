{
    "search_index": {
        "description_for_embedding": "PokemonGo bot change to make Pokéball throws more human-like and configurable: introduces configurable odds for Excellent/Great/Nice/Normal throws and spin success, randomizes throw parameters (reticle size, spin modifier, hit position), removes old helpers from human_behaviour.py, and wires new CLI/config options into pokemon_catch_worker. Also notes safety constraints on normalized_hit_position values to avoid potential API bans.",
        "keywords": [
            "PokemonGo-Bot",
            "pokemon_catch_worker",
            "catch_throw_parameters",
            "throw quality configuration",
            "spin_success_rate",
            "normalized_reticle_size",
            "normalized_hit_position",
            "spin_modifier",
            "human behaviour emulation",
            "bot detection risk",
            "CLI config flags",
            "configs/config.json.example",
            "JSON trailing comma",
            "randomized behavior"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the PokemonGo bot's Pokéball throwing logic was refactored from a nearly perfect, deterministic behavior to a more human-like, configurable, and randomized behavior.\n\nPreviously, the bot used helper functions in pokemongo_bot/human_behaviour.py (normalized_reticle_size and spin_modifier) that depended on catch_randomize_reticle_factor and catch_randomize_spin_factor from the config. In practice, the bot tended to send near-perfect throw parameters consistently, which made its behavior unrealistically precise and increased the risk of detection by Niantic as a non-human client.\n\nThe PR introduced a new configuration block catch_throw_parameters with the following keys: excellent_rate, great_rate, nice_rate, normal_rate, and spin_success_rate. These define weighted odds for which throw quality to perform and the probability of successfully applying a curveball spin.\n\nIn pokecli.py, new CLI/config options were added:\n- --catch_throw_parameters.excellent_rate (-cte)\n- --catch_throw_parameters.great_rate (-ctg)\n- --catch_throw_parameters.nice_rate (-ctn)\n- --catch_throw_parameters.normal_rate (-ctm)\n- --catch_throw_parameters.spin_success_rate (-cts)\nAll are floats; the four *_rate values act as weights (do not need to sum to 1), and spin_success_rate is interpreted as a probability between 0.0 and 1.0.\n\nIn pokemongo_bot/cell_workers/pokemon_catch_worker.py, the catch logic now builds a throw_parameters dict for each throw with default values:\n- normalized_reticle_size: 1.950\n- spin_modifier: 1.0\n- normalized_hit_position: 1.0\n- throw_type_label: 'Excellent'\n\nTwo new methods were added:\n- generate_spin_parameter(self, throw_parameters): Uses config.catch_throw_parameters_spin_success_rate and random() to decide whether the throw is a successful spin. If random() <= spin_success_rate, spin_modifier is set in [0.5, 1.0]; otherwise, it's set in [0.0, 0.499].\n- generate_throw_quality_parameters(self, throw_parameters): Uses the four *_rate values from the config as weights. It computes total_chances, samples random_throw = random() * total_chances, and uses cumulative thresholds to choose Excellent, Great, Nice, or Normal. Each case sets:\n  - normalized_reticle_size to an appropriate range for that throw quality:\n    * Excellent: 1.70–1.95\n    * Great: 1.30–1.699\n    * Nice: 1.00–1.299\n    * Normal: 1.25–1.95 but combined with normalized_hit_position=0.0 so it misses the bonus zone.\n  - normalized_hit_position: 1.0 for Excellent/Great/Nice (on-target), 0.0 for Normal (out of bonus circle).\n  - throw_type_label: corresponding label.\n\nThe catch_pokemon API call is updated to use throw_parameters['normalized_reticle_size'], throw_parameters['spin_modifier'], and throw_parameters['normalized_hit_position'] instead of the old human_behaviour helpers. normalized_hit_position is constrained to 0 or 1 due to safety concerns: experimentation with values >1 had apparently led to a temporary ban, while 0 and 1 are known-safe values.\n\nIn pokemongo_bot/human_behaviour.py, the normalized_reticle_size and spin_modifier helper functions were removed entirely, reflecting that throw randomness is now handled in the worker itself.\n\nA sample configuration was added to configs/config.json.example under catch_throw_parameters to demonstrate usage:\n- excellent_rate: 0.1\n- great_rate: 0.5\n- nice_rate: 0.3\n- normal_rate: 0.1\n- spin_success_rate: 0.6\nThere was a brief issue where the example JSON contained a trailing comma, which is invalid in strict JSON, but this was quickly corrected in a subsequent commit.\n\nDiscussion in the PR highlighted that Niantic can detect unnatural, perfectly consistent throw behavior. The goal of this change is to move away from 100% perfect throws and toward user-configurable, varied behavior that better mimics a human player. The author also explicitly warns about experimenting with normalized_hit_position outside the [0,1] range due to potential temporary bans from the API.",
        "semantic_memory": "This change illustrates several generalizable lessons about designing bots and external-API clients, especially when trying to emulate human behavior.\n\n1. **Avoid perfectly deterministic, ideal outcomes when simulating humans.**\nA common failure mode in bot design is to always choose the mathematically optimal action (e.g., 100% Excellent throws). Real humans make mistakes, show variance, and vary their skill level. Overly perfect behavior becomes a clear signal for detection by server-side anti-cheat systems.\n\nThe fix demonstrates a better approach: introduce stochastic behavior (via random()) and map user-configured probabilities to different outcome classes (Excellent, Great, Nice, Normal). This preserves control (users can choose how good their bot is) while ensuring that a distribution of outcomes is produced rather than a constant best-case.\n\n2. **Model behavior using weighted probabilities, not fixed percentages.**\nThe config uses *_rate values as weights, allowing them to be any non-negative float instead of forcing them to sum to 1. Internally, the code computes a sum and uses a random threshold to determine which bucket an outcome falls into. This is a general design pattern:\n- Accept intuitive, loosely constrained inputs (weights).\n- Normalize implicitly at runtime by summing and sampling from [0, total].\nThis simplifies user configuration and reduces errors caused by users trying to maintain exact percentages.\n\n3. **Keep randomization close to where behavior is executed, but configurable from outside.**\nThe randomization logic moved from generic helper functions to the worker that actually performs Pokémon catches. Configuration remains external (CLI/config file) but the behavior itself is encapsulated in methods like generate_spin_parameter and generate_throw_quality_parameters. This pattern helps:\n- Keep related logic together (all throw behavior inside the catch worker).\n- Make it easier to reason about and test behavior in context.\n\n4. **Respect API parameter semantics and safety boundaries.**\nThe discussion around normalized_hit_position illustrates the importance of understanding an external API's accepted ranges and semantics. Values of 0 and 1 are known-good; experimentation with >1 may trigger server-side anomaly detection or temporary bans. The fix enforces strict, safe values (0 or 1) for production behavior and warns about experimenting beyond those values.\n\nMore generally, when reverse-engineering or using undocumented APIs, treat unknown parameter ranges conservatively. Use observed client behavior as a reference and avoid sending values that the official client would never send.\n\n5. **Document and exemplify configuration clearly, and ensure examples are syntactically valid.**\nAdding a sample catch_throw_parameters block is crucial for discoverability and usability: users can copy and tweak rather than guess the structure. However, the transient bug where the example JSON had a trailing comma shows another lesson: configuration examples must be syntactically valid in strict parsers, or they will mislead users and cause runtime errors.\n\n6. **Use separate, composable random factors for different aspects of behavior.**\nThe code splits randomization into (a) the probability of a spin succeeding and (b) the quality of the throw (Excellent/Great/Nice/Normal). Each is controlled via separate configuration parameters. This separation of concerns makes it easier to model complex, human-like behavior by combining independent random variables.\n\nOverall, the PR encapsulates best practices for human-like behavior simulation, safe API usage, and user-configurable randomness in automated clients.",
        "procedural_memory": [
            "When a bot or automated client behaves too perfectly (e.g., always perfect throws, zero variance), treat this as a potential bug or detection risk to correct.",
            "Step 1: Identify unrealistic or deterministic behavior.\n- Inspect the code paths that generate actions sent to the external API (e.g., catch_pokemon calls).\n- Look for hardcoded parameters, always-best outcomes (e.g., always normalized_reticle_size at Excellent threshold), or lack of randomness.\n- Cross-reference with how the official client behaves (e.g., does it ever achieve 100% perfect throws?).",
            "Step 2: Design a configuration schema for behavior variability.\n- Decide which outcome categories you want to model (e.g., Excellent/Great/Nice/Normal throws; success/failure for spin).\n- For each category, define a weight or probability in configuration (e.g., excellent_rate, great_rate, nice_rate, normal_rate, spin_success_rate).\n- Use weights instead of strict percentages: allow arbitrary non-negative floats and normalize during sampling.",
            "Step 3: Implement weighted random selection logic.\n- Read the weight values from the config.\n- Compute total_chances = sum of all weights.\n- Sample random_throw = random() * total_chances.\n- Use cumulative subtraction or thresholds to map random_throw to one of the outcome categories.\n  - Example pattern:\n    - if random_throw <= excellent_weight: Excellent\n    - else if random_throw <= excellent_weight + great_weight: Great\n    - etc.\n- For each outcome, set the corresponding parameter ranges (e.g., different normalized_reticle_size ranges per throw type).",
            "Step 4: Implement separate random factors for independent behavior aspects.\n- For the spin, use a separate probability (e.g., spin_success_rate) to decide whether a throw is a curveball.\n- In the success case, sample spin_modifier from a range that represents a valid spin (e.g., [0.5, 1.0]); in the failure/normal case, sample from the non-spin range (e.g., [0, 0.499]).\n- Keep this logic in a dedicated function (e.g., generate_spin_parameter) to allow targeted testing and tuning.",
            "Step 5: Respect external API parameter ranges and safety constraints.\n- Determine the valid/observed ranges for each API parameter (e.g., normalized_hit_position in [0,1]).\n- Avoid sending values outside the known safe range, especially if prior experiments suggest bans or throttling (e.g., do not exceed 1.0 for normalized_hit_position).\n- If experimentation is needed, do it on throwaway accounts and clearly document the risks.",
            "Step 6: Refactor old helper functions and centralize new behavior.\n- If previous behavior was implemented via generic helpers (e.g., normalized_reticle_size(factor) in human_behaviour.py), consider removing or refactoring them so that behavior is fully controlled by the new configuration-driven logic.\n- Keep all throw-specific logic inside the component responsible for catching (e.g., pokemon_catch_worker) for better coherence.",
            "Step 7: Add and validate configuration examples and CLI flags.\n- Add new CLI arguments or config keys (e.g., --catch_throw_parameters.excellent_rate, etc.) with sensible defaults.\n- Document each parameter with help text explaining its effect and expected range.\n- Provide a sample config block (catch_throw_parameters) in a widely used example config file.\n- Ensure the example is syntactically valid (e.g., no trailing commas in strict JSON), and ideally test loading it with the actual config parser.",
            "Step 8: Log and monitor behavior for realism and safety.\n- Optionally extend logging to include which throw type was selected (e.g., throw_type_label) to inspect actual distributions in real runs.\n- Compare observed behavior distributions to expected ones from the configuration and to real human behavior (if data is available).\n- Watch for any server-side anomalies (e.g., sudden bans or login issues) that could suggest unsafe parameter ranges.",
            "Step 9: Iterate on parameter ranges and distributions.\n- Based on observations and user feedback, tune the ranges (e.g., reticle sizes per throw type) and default weights to better reflect human performance and reduce detection risk.\n- If necessary, add more nuanced modeling (e.g., occasional complete misses, skill-based behavior) while retaining the same configuration pattern."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Worx Landroid sensor failed when reading the mower PIN code because the config schema coerced the PIN to an integer, stripping leading zeros and mismatching the device/API expectation. The fix changed validation to treat the PIN as a 4-digit string using a regex match instead of an integer range.",
        "keywords": [
            "Home Assistant",
            "worxlandroid",
            "sensor",
            "PIN code",
            "configuration validation",
            "voluptuous",
            "schema",
            "string vs int",
            "leading zeros",
            "regex validation",
            "Range vs Match",
            "config error"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Worx Landroid integration in Home Assistant had an issue when reading the mower's PIN code from configuration. The platform schema validated `CONF_PIN` using `vol.All(vol.Coerce(int), vol.Range(min=1000, max=9999))`. This coerced the PIN to an integer, which caused problems when the PIN had leading zeros (e.g., '0123' becoming 123) and also did not match the type expected later in the integration (string-based handling). As a result, users could experience failures or incorrect behavior when using valid 4-digit PINs, especially those starting with zero. The fix replaced the integer-based validation with string-based validation: `vol.All(vol.Coerce(str), vol.Match(r'\\d{4}'))`. This ensures the PIN remains a 4-character numeric string, preserves leading zeros, and still enforces that it consists only of digits. After this change, reading and using the Worx Landroid PIN works correctly, and the associated tests pass.",
        "semantic_memory": "Configuration values that look numeric are not always semantically numbers. Credentials, PINs, ZIP/postal codes, phone numbers, and similar identifiers often must be preserved as strings to avoid losing leading zeros or altering formatting. Validation schemas (e.g., with Voluptuous) must be aligned with how the rest of the code and external devices/APIs treat those values. Using integer coercion and numeric ranges for such identifiers can introduce subtle bugs, especially when the identifier is later compared as a string or transmitted to an external API that expects an exact string match. A better practice is to treat these values as strings and use pattern-based validation (e.g., regex) or length checks to enforce constraints. This maintains both type correctness and value fidelity. More broadly, configuration schema design should consider both syntactic validity (digits-only, length) and semantic usage (string vs numeric) to avoid mismatches and runtime errors.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and localize the issue.\n- Attempt to configure the integration with values that are suspected to fail (e.g., PINs with leading zeros).\n- Observe where the failure occurs: during configuration validation, runtime API calls, or internal comparisons.\n- Check logs for type errors, validation errors, or mismatched values.",
            "Step 2: Inspect the configuration schema and data flow.\n- Locate the configuration schema (e.g., Voluptuous `PLATFORM_SCHEMA`) for the problematic field.\n- Identify how the field is coerced and validated (e.g., `vol.Coerce(int)` plus `vol.Range`).\n- Trace how the value is used later in the code: is it passed to an API as a string, compared to a string, or expected to retain leading zeros?",
            "Step 3: Determine the correct semantic type.\n- Decide whether the value is truly numeric (for arithmetic/comparison) or an identifier that must retain formatting (e.g., PIN, ZIP code, phone number).\n- Consult device/API documentation to confirm the expected format and type (string vs integer, required length, allowed characters).",
            "Step 4: Adjust the schema to match semantics.\n- For identifier-like values (PINs, codes), switch from integer coercion to string coercion: use `vol.Coerce(str)` instead of `vol.Coerce(int)`.\n- Replace numeric `Range` checks with pattern/length checks, e.g., `vol.Match(r'\\d{4}')` for a 4-digit PIN, or `vol.All(cv.string, vol.Length(min=4, max=4))` combined with a digit check.\n- Ensure the schema enforces only the necessary constraints (digits-only, fixed length) without altering the value.",
            "Step 5: Verify end-to-end behavior.\n- Test with multiple valid values, including those with leading zeros and boundary cases (e.g., '0000', '9999').\n- Confirm that the value passed to external APIs or used internally matches exactly what the user configured (no trimming or numeric conversion).\n- Run the project's test suite and, if relevant, add or update tests to cover previously failing cases.",
            "Step 6: Document the semantics and constraints.\n- Update any developer or user documentation to clarify the expected format (e.g., 'PIN must be a 4-digit string').\n- Add comments near the schema definition explaining why the field is treated as a string and validated via regex, to prevent future regressions.",
            "Step 7: Generalize the pattern for future work.\n- When adding new configuration fields, explicitly decide: is this value a true number or a string identifier?\n- For string identifiers that look numeric, default to string validation with regex/length checks instead of integer ranges.\n- Review existing schemas for other PINs, codes, or IDs to ensure they are not incorrectly coerced to integers."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant RFLink integration enhancement: add a configuration option `automatic_add` (default true) for RFLink lights and sensors to control whether newly seen RFLink devices are automatically added as entities. Implementation conditionally registers the device creation callbacks based on this flag and adds tests ensuring that when `automatic_add` is false, new devices are not created.",
        "keywords": [
            "Home Assistant",
            "RFLink",
            "automatic_add",
            "auto discovery",
            "entity auto-add",
            "light.rflink",
            "sensor.rflink",
            "configuration option",
            "conditional callback registration",
            "integration alignment",
            "Rfxtrx parity"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the RFLink integration for Home Assistant was updated to allow users to disable the automatic creation of light and sensor entities when new RFLink devices are detected. Previously, RFLink would always auto-add new devices as entities, which could clutter the system with unwanted entities and diverged from the behavior of the related Rfxtrx integration, which already had a similar control. The fix introduced a new configuration option `automatic_add` into the RFLink platform schemas for both lights and sensors, defined centrally as `CONF_AUTOMATIC_ADD` in `homeassistant/components/rflink.py`. The option defaults to `True` to preserve existing behavior.\n\nIn the light platform (`homeassistant/components/light/rflink.py`), the schema was extended with `vol.Optional(CONF_AUTOMATIC_ADD, default=True): cv.boolean`. The previous unconditional registration of the handler that auto-creates devices (`hass.data[DATA_DEVICE_REGISTER][EVENT_KEY_COMMAND] = add_new_device`) was wrapped in a conditional so that registration only happens if `config[CONF_AUTOMATIC_ADD]` is true. The same pattern was applied to the sensor platform (`homeassistant/components/sensor/rflink.py`), gating the registration of the sensor add callback (`EVENT_KEY_SENSOR`) on `automatic_add`.\n\nTests were added to validate the new behavior. For lights, `test_disable_automatic_add` configures the integration with `automatic_add: False`, injects an RFLink command event for a previously unknown device (`protocol_0_0`), and asserts that no `light.protocol_0_0` state is created. For sensors, a similar test injects a temperature event for an unknown sensor (`test2`) and asserts that `sensor.test2` does not exist in Home Assistant state. These tests rely on the existing `mock_rflink` fixture to simulate RFLink events. With these changes, users can now opt out of automatically adding new RFLink lights and sensors, bringing RFLink behavior in line with Rfxtrx and reducing unwanted entity creation.",
        "semantic_memory": "This change illustrates a generalizable pattern for adding configurability around automatic resource or entity creation in event-driven integrations.\n\nKey concepts:\n- **Configurable auto-discovery/auto-add**: Instead of always auto-creating entities or resources on new events, expose a boolean configuration option (e.g., `automatic_add`) that lets users opt in or out while defaulting to current behavior to maintain backward compatibility.\n- **Centralized configuration constants**: Define configuration keys (like `CONF_AUTOMATIC_ADD`) in a shared module so that multiple platform modules (lights, sensors, switches) can use them consistently.\n- **Conditional registration of handlers**: Rather than adding conditionals deep inside event-handling logic, gate the registration of callbacks/listeners themselves based on configuration. If auto-add is disabled, the callback responsible for creating new entities is never registered, preventing unwanted behavior at the root.\n- **Parity across related integrations**: When multiple integrations provide similar functionality (RFLink vs Rfxtrx), keeping their options and behaviors consistent makes the system more predictable and user-friendly.\n- **Negative-path testing**: When adding an option that disables behavior, tests should explicitly verify that the previously automatic behavior does not occur under the disabled configuration (e.g., asserting that no entity exists after an event instead of only testing successful creation).\n\nThese practices apply broadly to any system where components auto-provision resources based on external events and users may want fine-grained control over that provisioning.",
        "procedural_memory": [
            "When you need to add a configuration option to control automatic entity/resource creation in an event-driven integration, follow these steps:",
            "Step 1: Identify the existing auto-add mechanism.\n- Locate where new entities/devices/resources are automatically created in response to events.\n- In this case, RFLink lights and sensors used callbacks registered via `hass.data[DATA_DEVICE_REGISTER][EVENT_KEY_*] = add_new_device` that created entities when unknown device IDs appeared.",
            "Step 2: Introduce a shared configuration constant.\n- In a central module for the integration (e.g., `components/rflink.py`), define a new configuration key like `CONF_AUTOMATIC_ADD = 'automatic_add'`.\n- This ensures consistent use of the key across all related platform modules.",
            "Step 3: Extend platform schemas with the new option.\n- For each platform (e.g., light, sensor), add the new option to the `PLATFORM_SCHEMA` with a sensible default that preserves current behavior.\n- Example: `vol.Optional(CONF_AUTOMATIC_ADD, default=True): cv.boolean`.\n- Keep the default as `True` if the integration was previously auto-adding to avoid breaking existing setups.",
            "Step 4: Gate handler registration based on the configuration.\n- Find where the auto-add callbacks/listeners are registered.\n- Wrap the registration in a conditional that checks the new configuration flag.\n- Example:\n  - Before: `hass.data[DATA_DEVICE_REGISTER][EVENT_KEY_COMMAND] = add_new_device`\n  - After: `if config[CONF_AUTOMATIC_ADD]: hass.data[DATA_DEVICE_REGISTER][EVENT_KEY_COMMAND] = add_new_device`.\n- Prefer this approach over scattering conditional checks inside the handler, as it cleanly disables the behavior at the source.",
            "Step 5: Add tests for the disabled behavior.\n- Create tests that configure the integration with `automatic_add: False`.\n- Simulate events that would normally trigger automatic entity creation (e.g., unknown device ID with a command or sensor reading).\n- After processing, assert that the new entity is not present in the system state (e.g., `assert not hass.states.get('light.device_id')`).\n- Reuse existing mocking helpers/fixtures (like `mock_rflink`) to simulate events.",
            "Step 6: Ensure backward compatibility and parity.\n- Confirm that when `automatic_add` is omitted or set to `True`, behavior remains unchanged.\n- If there are sibling integrations with similar features (e.g., Rfxtrx), align option names and semantics so users get a consistent experience.",
            "Step 7: Document and communicate the new option.\n- Update integration documentation to describe the `automatic_add` option, its default, and impact.\n- Mention that disabling it stops auto-creation of entities and that manual configuration will be required."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant elkm1 alarm_control_panel: frontend Lovelace numeric keypad was not shown because the backend code_format returned a regex while the frontend briefly expected the literal string 'Number'. A PR tried to change code_format to return 'Number', but was rejected in favor of reverting the frontend change and standardizing the API contract.",
        "keywords": [
            "Home Assistant",
            "elkm1",
            "alarm_control_panel",
            "code_format",
            "Lovelace",
            "number pad",
            "numeric keypad",
            "frontend-backend contract",
            "API mismatch",
            "regex vs string"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant elkm1 alarm_control_panel integration exposed a property code_format that originally returned a regular expression: '^[0-9]{4}([0-9]{2})?$'. A frontend change in the Lovelace UI (home-assistant-polymer) briefly started expecting the literal string 'Number' from code_format to decide that a numeric keypad should be shown for alarm code entry. As a result, the Lovelace UI did not display the number pad for elkm1 because the backend still returned a regex instead of 'Number'.\n\nA community PR proposed to 'fix' the issue by changing elkm1.py so that code_format returned 'Number' instead of the regex. This immediately made the numeric keypad appear in Lovelace and would have closed issue #19983. However, the core maintainer (balloob) pointed out that requiring code_format to be 'Number' on the backend was incorrect API design. Rather than enforcing this magic string in backends, he decided to close the PR and revert the frontend change in home-assistant-polymer. The plan was to revert the regression, then later standardize the backend API for code_format and update the frontend accordingly.\n\nOutcome: The proposed backend change (returning 'Number') was not merged. The root cause was an inconsistent contract between the frontend and backend on how code_format should be expressed (regex vs magic type string). The resolution path was to revert the frontend behavior and then work toward a proper standardization, not to adjust backends to match a temporary frontend expectation.",
        "semantic_memory": "This case illustrates a common pattern: a frontend change introduces a new assumption about a backend API (expecting a special string like 'Number' instead of a flexible definition such as a regex). Backends that conform to the older, more general contract suddenly appear 'broken' in the UI, even though their implementation is correct according to the original design.\n\nKey generalized lessons:\n\n1. **Avoid magic strings in API contracts**: APIs should not rely on undocumented or ad hoc magic values like 'Number' to signal behavior. Instead, define clear, explicit types or structures (e.g., regex patterns, enumerations, or schema descriptors) and document them.\n\n2. **Frontend should not unilaterally redefine backend contracts**: If the frontend starts interpreting a field differently (e.g., treating code_format as a type instead of a regex), it can break existing integrations. Contract changes must be coordinated and versioned, especially in large ecosystems.\n\n3. **Prefer reverting a bad API change over forcing widespread hacks**: When a new assumption turns out to be flawed, it is usually better to revert the change and design a proper standard, rather than modifying many backends to comply with a bad contract. This reduces long-term technical debt.\n\n4. **UI behavior should be driven by well-defined semantics**: For something like showing a numeric keypad, the UI should rely on a well-defined capability (e.g., 'input_type: numeric', or a validated pattern) rather than ad hoc interpretations of unrelated fields.\n\n5. **Tight coupling between layers is fragile**: Here, the frontend behavior was tightly coupled to a specific representation in the backend (literal 'Number'). Loose coupling and clear interfaces minimize the chance that a change in one layer silently breaks another.\n\nThese principles apply broadly to any system where multiple components (frontend, backend, integrations, plugins) interact via shared contracts.",
        "procedural_memory": [
            "When a UI element (like a numeric keypad) disappears or misbehaves, first identify which backend property or API the frontend uses to decide that behavior (e.g., code_format for alarm_control_panel).",
            "Step 1: Reproduce the issue in the UI.\n- Confirm the exact symptom (e.g., numeric keypad missing for a specific alarm entity).\n- Check developer tools / console for warnings or errors from the frontend.",
            "Step 2: Inspect the backend entity and its API contract.\n- Locate the integration code (e.g., homeassistant/components/alarm_control_panel/elkm1.py).\n- Find the relevant property or field (here, code_format) and see what it returns (regex, string, enum, etc.).\n- Compare this behavior with other working integrations of the same platform.",
            "Step 3: Check recent frontend changes related to this behavior.\n- Search the frontend repo (e.g., home-assistant-polymer) for the property name (code_format) and review recent commits or PRs.\n- Look for logic that interprets that property (e.g., if code_format == 'Number' then show keypad).",
            "Step 4: Identify whether the bug is in the frontend or backend.\n- If the backend follows the original, documented contract (e.g., code_format is a regex) and other integrations use the same pattern successfully, the bug likely lies in a new frontend assumption.\n- If the backend deviates from a formally documented contract, then the backend should be fixed instead.",
            "Step 5: Avoid quick fixes that corrupt the contract.\n- Resist the temptation to change the backend to return hard-coded magic strings (like 'Number') solely to satisfy a temporary frontend implementation.\n- Consider how this change would affect other tools, assumptions, and long-term maintainability.",
            "Step 6: Propose the correct fix.\n- If the frontend introduced a bad assumption, propose reverting that change or introducing a properly designed API (e.g., a new field or standardized enum) to describe input type.\n- Document the intended contract clearly and ensure both frontend and backend are updated against that spec.",
            "Step 7: Coordinate and communicate.\n- In the PR/issue, explain that the current backend behavior matches prior design, and the regression stems from the frontend change.\n- Agree on a plan: revert the breaking frontend change first, then design and implement a standardized contract for the feature.",
            "Step 8: Add tests to lock in the contract.\n- Add frontend tests that validate the new, standardized behavior.\n- Add backend tests (for representative integrations) that confirm they expose the correct format/type without relying on undocumented magic values."
        ]
    }
}
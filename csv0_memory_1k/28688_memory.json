{
    "search_index": {
        "description_for_embedding": "Home Assistant xiaomi_miio integration did not recognize the Xiaomi Chuangmi plug model chuangmi.plug.hmi206, preventing it from being set up as a switch. The fix adds the model ID to the supported model lists used for config validation and device initialization, enabling full support.",
        "keywords": [
            "home-assistant",
            "xiaomi_miio",
            "switch",
            "ChuangmiPlug",
            "chuangmi.plug.hmi206",
            "chuangmi.plug.hmi205",
            "unsupported device model",
            "device whitelist",
            "integration model list",
            "python-miio"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a new Xiaomi smart plug model, chuangmi.plug.hmi206, was not working with Home Assistant's xiaomi_miio integration. Users attempting to configure the plug would find that the integration did not recognize the model, because the switch platform maintains an explicit whitelist of supported device model strings. The underlying python-miio library already had or was gaining support for this model, but Home Assistant's integration had not yet been updated. The root cause was that chuangmi.plug.hmi206 was missing from two key locations in homeassistant/components/xiaomi_miio/switch.py: (1) the set of allowed model identifiers used in configuration validation, and (2) the list of models that are initialized as ChuangmiPlug devices in async_setup_platform. The fix simply added \"chuangmi.plug.hmi206\" alongside the existing similar models (e.g., chuangmi.plug.hmi205, chuangmi.plug.v2) in both places. After this change, Home Assistant treats chuangmi.plug.hmi206 as a supported plug, instantiates it via ChuangmiPlug, and exposes it as a switch entity.",
        "semantic_memory": "Many Home Assistant integrations maintain explicit lists of supported device models. When a vendor releases a new hardware revision or a closely related model (e.g., Xiaomi Chuangmi plug hmi206 vs hmi205), the underlying device library (like python-miio) may support it before the Home Assistant integration is updated. In such cases, users see symptoms like 'unsupported model', failed discovery, or entities not being created, even though the device is otherwise reachable. The generalizable pattern is: (1) identify where model identifiers are whitelisted (config validation, manifests, conditionals in setup code); (2) confirm that the underlying library can communicate with the new model and that its behavior matches an existing supported family; and (3) extend the whitelist and initialization logic to include the new model string. Consistency is crucial: if you add a model to the configuration options but forget to update the actual device-instantiation logic, configuration may validate but runtime setup will still fail. Tightly coupled model lists across multiple places in the code are a common source of 'device not recognized' issues when new variants appear.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and inspect logs\n- Try to add or auto-discover the device via the integration.\n- Check Home Assistant logs for messages like 'unsupported model', 'Unknown Xiaomi device', or similar errors referencing the model string (e.g., chuangmi.plug.hmi206).\n- Confirm that the device is reachable on the network (ping, IP, etc.) so the issue is clearly model recognition rather than connectivity.",
            "Step 2: Verify underlying library support\n- Identify the underlying Python library used by the integration (here: python-miio for xiaomi_miio).\n- Check the library's documentation, issues, or code to see if the specific model (e.g., chuangmi.plug.hmi206) is supported or behaves like an existing model.\n- If not supported at all, add support in the library first; if supported and mapped to an existing device class (e.g., ChuangmiPlug), proceed to update Home Assistant.",
            "Step 3: Locate model whitelists and conditionals in the integration\n- Search the integration code for related model strings that are already supported (e.g., 'chuangmi.plug.hmi205', 'chuangmi.plug.v2').\n- Typical locations:\n  - Configuration validation or model-option lists (e.g., a tuple or set of allowed model IDs in the platform schema).\n  - Conditional checks deciding which device class to instantiate based on the model string (e.g., if model in [\"chuangmi.plug.m1\", ...]: plug = ChuangmiPlug(...)).\n- Ensure you find all occurrences where model names are used to gate functionality.",
            "Step 4: Add the new model string consistently\n- Add the new model (e.g., \"chuangmi.plug.hmi206\") to the configuration model options / whitelist alongside its closest relatives.\n- Add the same model string to the device-instantiation conditional list that constructs the correct device class (e.g., include it in the list passed to the ChuangmiPlug branch in async_setup_platform).\n- Keep ordering and grouping consistent for readability and future maintenance (place hmi206 near hmi205).",
            "Step 5: Test locally\n- Restart Home Assistant or reload the integration.\n- Add the device using the updated integration and confirm that the entity is created and controllable.\n- Verify that no 'unsupported model' or similar errors appear in the logs for the new model.",
            "Step 6: Harden with tests and documentation (if applicable)\n- If the project has unit tests for supported models, add the new model ID to those tests or create a new test verifying that the model is accepted and mapped to the correct device class.\n- Update any user-facing documentation or example configurations to mention the new model, if that is common practice for the integration.",
            "Step 7: Cross-check with upstream issues\n- Link to or reference any upstream library issues or PRs that validate support for the new model (e.g., a python-miio issue confirming chuangmi.plug.hmi206 is handled the same as chuangmi.plug.hmi205).\n- This helps maintainers understand why the model is safe to add without additional protocol work."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant fix: integrations (Hue, UniFi, deCONZ, HomematicIP Cloud) were directly mutating config_entry.state and implementing their own retry logic for failed setup. The fix routes all config entry updates through the ConfigEntries manager and replaces custom retry/backoff with raising ConfigEntryNotReady so the core config entry system manages retries.",
        "keywords": [
            "Home Assistant",
            "config entries",
            "ConfigEntryNotReady",
            "async_update_entry",
            "ENTRY_STATE_LOADED",
            "retry setup",
            "connection error",
            "Hue bridge",
            "UniFi controller",
            "deconz gateway",
            "homematicip_cloud",
            "backoff logic",
            "centralized state management"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, several Home Assistant integrations (deCONZ, HomematicIP Cloud, Hue, UniFi) were refactored to stop directly manipulating config entries and to rely on the core config entries machinery for state and retries.\n\nOriginally, these integrations implemented their own exponential backoff retry logic inside their async_setup methods. On a connection failure they would:\n- log an error,\n- schedule a retry using hass.helpers.event.async_call_later,\n- and, upon a successful retry, directly set self.config_entry.state = ENTRY_STATE_LOADED via the config entry object.\n\nThis pattern was considered hacky because it bypassed the ConfigEntries manager, duplicated retry logic that the core now supports, and tightly coupled integrations to the internal state field of ConfigEntry.\n\nThe fix proceeds in two stages:\n1. A temporary expansion of the config_entries.ConfigEntries.async_update_entry API to accept both data and state, so integrations could update state through the manager instead of directly via entry.state. Call sites in deconz/gateway.py, homematicip_cloud/hap.py, hue/bridge.py, and unifi/controller.py were updated to use hass.config_entries.async_update_entry(entry=..., state=ENTRY_STATE_LOADED) instead of entry.state = ENTRY_STATE_LOADED.\n2. A full shift to the standard ConfigEntryNotReady mechanism. The integrations' async_setup functions were modified so that if they cannot connect to their respective backends (deCONZ gateway, HomematicIP HAP, Hue bridge, UniFi controller) they now raise ConfigEntryNotReady instead of scheduling their own retries and returning False. As a result, the per-integration retry scheduling and cancellation logic (_cancel_retry_setup, _retry_setup, related async_reset paths) was removed. With this change, the need to update entry.state from integrations disappeared and async_update_entry was simplified back to only updating entry.data.\n\nTests were updated accordingly:\n- Where they previously asserted async_setup returned False and that async_call_later was scheduled, they now use pytest.raises(ConfigEntryNotReady) and no longer assert on retry timers.\n- The test for updating entry state via async_update_entry was simplified to only verify data updates.\n- Old tests that depended on retry-cancellation behavior in async_reset were removed.\n\nThe end result is that config entry state transitions and retry behavior are handled centrally by the ConfigEntries system, integrations no longer reach inside ConfigEntry to mutate state, and the async_update_entry API remains focused solely on data persistence.",
        "semantic_memory": "This PR reinforces several generalizable patterns and best practices for configuration and lifecycle management in event-driven, component-based systems:\n\n1. **Do not mutate framework-owned state directly**\n   Configuration entries (or similar framework-managed records) often have a lifecycle that the framework relies on for orchestration, persistence, and error handling. Directly writing to internal fields like `entry.state` bypasses these lifecycle rules and can lead to inconsistent state, subtle bugs, or incompatibility with future enhancements. Instead, use the provided manager or API (here: `config_entries.async_update_entry`) so all logic passes through a single, authoritative code path.\n\n2. **Centralize retry and backoff logic**\n   Multiple integrations had duplicated exponential backoff and retry scheduling using `async_call_later`. This duplication is error-prone and leads to inconsistent behavior across integrations. Introducing a standardized mechanism (`ConfigEntryNotReady`) allows the core system to implement and evolve retry policies once, while integrations only need to signal that setup is temporarily impossible. This pattern applies broadly: components should signal conditions (e.g., 'temporarily unavailable') and let the orchestrator handle timing and policy.\n\n3. **Use exceptions to signal transient setup failures**\n   Returning booleans from setup functions to indicate success/failure forces callers to implement explicit branching and often leads to ad-hoc retry logic. Using a well-defined exception (e.g., `ConfigEntryNotReady`) to represent a transient failure allows the framework to uniformly intercept and respond, while still distinguishing between permanent errors (e.g., auth failure) and temporary connectivity issues.\n\n4. **Keep update APIs focused and minimal**\n   The temporary extension of `async_update_entry` to also update `state` was rolled back once the correct pattern (raising `ConfigEntryNotReady`) was adopted. This illustrates a design principle: APIs that are narrowly scoped (e.g., `async_update_entry` only updates `data`) are easier to reason about, test, and maintain. Overloading them to manipulate lifecycle-related fields can blur responsibilities and lead to misuse.\n\n5. **Align tests with lifecycle semantics, not implementation details**\n   Tests were originally asserting on implementation details of retries (e.g., exact delays and that `async_call_later` was called). Once retry moved into the config-entry framework, those assertions became incorrect. The updated tests now verify the externally visible contract (raising `ConfigEntryNotReady`) rather than the internal scheduling strategy. This emphasizes that tests should prefer observable behavior and stable contracts over specific internal mechanisms.\n\n6. **Simplify reset/teardown when setup is centralized**\n   Once setup retry is delegated to the framework, integration-level reset logic no longer needs to cancel scheduled retry callbacks. This leads to simpler and more robust teardown paths that focus on closing resources (e.g., network APIs) rather than juggling timers.\n\nThese patterns are widely applicable in plugin-based architectures, microservices with orchestration layers, and any system where components declare their readiness and a central manager coordinates lifecycle and retries.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify direct state mutations on framework-managed config objects.\nSearch the codebase for direct assignments to fields such as `config_entry.state` or similar on objects that are owned by the framework. Also look for ad-hoc persistence updates that bypass a manager or API (e.g., not using `config_entries.async_update_entry`).",
            "Step 2: Check for custom retry/backoff logic in component setup.\nInspect each integration's or component's `async_setup` or setup-equivalent functions for patterns like:\n- catching connection-related exceptions or receiving a False sentinel,\n- logging an error,\n- computing a retry delay (often exponential backoff),\n- using a scheduler (e.g., `async_call_later`) to retry setup,\n- and on success, manually changing the config entry's state.\nThese are candidates for replacement with a centralized mechanism.",
            "Step 3: Confirm whether the framework provides a standard transient-failure mechanism.\nReview the framework docs or core code to see if there is a standardized way to signal temporary setup failures. In Home Assistant, this is the `ConfigEntryNotReady` exception. In other systems, it might be a specific exception type, return value, or callback.",
            "Step 4: Refactor setup to raise the standard transient-failure signal.\nWithin each integration's setup routine, replace custom retry logic with the framework's transient-failure mechanism:\n- Remove code that calculates retry delays and schedules `async_call_later`.\n- When a connection cannot be established, raise the framework's exception (e.g., `ConfigEntryNotReady`) instead of returning False.\n- Do not manually update the config entry state on success; allow the framework to handle state transitions.",
            "Step 5: Restrict config entry updates to the manager API and simplify it if needed.\nEnsure all modifications of config entry data go through the manager method (e.g., `config_entries.async_update_entry(entry, data=new_data)`). If that API has been extended to handle state or other lifecycle fields solely to support workarounds, consider removing those extra parameters once the correct lifecycle pattern is in place. The manager should persist data, while the framework controls state.",
            "Step 6: Clean up setup and reset/teardown paths.\nWith retry handled centrally, integration-level cleanup should focus on:\n- closing connections (e.g., `self.api.close()`),\n- cleaning up tasks and subscriptions,\n- avoiding the need to cancel retry timers (since they are no longer scheduled by the integration).\nRemove fields like `_cancel_retry_setup` and `_retry_setup` that are no longer used.",
            "Step 7: Update tests to align with the new lifecycle behavior.\nAdjust tests that previously expected boolean returns and specific retry scheduling behavior:\n- Replace `assert await setup() is False` with `with pytest.raises(ConfigEntryNotReady): await setup()` when testing transient failures.\n- Remove assertions on `async_call_later` calls if retry is now handled by the framework.\n- Ensure tests still cover permanent failure cases (e.g., auth errors) and that they verify correct behavior (flow initiation, error logging, no retries).",
            "Step 8: Validate integration behavior end-to-end.\nRun the test suite and, if possible, manual or integration tests to ensure that:\n- on transient connection failures, the framework logs appropriate messages and retries setup according to its policy,\n- on successful connection, the entry is moved to the loaded/ready state without direct manipulation by the integration,\n- on permanent errors, the integration fails predictably without entering a retry loop.",
            "Step 9: Document the pattern for future integrations.\nAdd brief guidelines to contributor docs or code comments:\n- 'Do not directly modify `config_entry.state`; raise `ConfigEntryNotReady` on temporary failures.'\n- 'Use `async_update_entry` only to change entry data.'\nThis helps prevent reintroduction of per-component retry logic or direct state mutations in new code."
        ]
    }
}
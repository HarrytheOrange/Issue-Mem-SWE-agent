{
    "search_index": {
        "description_for_embedding": "Home Assistant ZHA dimmable lights sometimes did not physically turn on when using light.turn_on with brightness because only the Zigbee Level Control 'move_to_level_with_on_off' command was sent and Home Assistant optimistically marked the light as on. Some Zigbee devices (e.g., GE 45857GE dimmer) only set On/Off=On if the level actually increases, per ZCL spec, so sending the same or lower brightness left the light off. The fix removes the early return after move_to_level_with_on_off so that an explicit On/Off 'on' command is always sent afterward, ensuring the light turns on and keeping Home Assistant state in sync with the device.",
        "keywords": [
            "Home Assistant",
            "ZHA",
            "Zigbee",
            "light.turn_on",
            "move_to_level_with_on_off",
            "OnOff cluster",
            "Level Control cluster",
            "brightness",
            "dimmer",
            "GE 45857GE",
            "optimistic state update",
            "device state desync",
            "ZCL spec"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's ZHA integration had a subtle bug with dimmable Zigbee lights when calling the light.turn_on service with a brightness value. The implementation invoked the Level Control cluster's move_to_level_with_on_off command and then immediately updated the entity state to 'on' and returned early, without sending an explicit On command to the On/Off cluster.\n\nAccording to the Zigbee Cluster Library (ZCL) spec section 3.10.2.4.5, the '*with On/Off*' variants (move_to_level_with_on_off, etc.) must set the OnOff attribute to On only when the command has the effect of increasing the CurrentLevel. If the level does not increase (e.g., it stays the same or is lowered), the spec does not require the device to turn on.\n\nSome devices (like various Sylvania bulbs) are permissive and turn on regardless of whether the level increased. Others, like the GE 45857GE Zigbee in-wall smart dimmer, follow the spec more strictly: they only change OnOff to On if the new level is strictly greater than the stored level. Consequently, when Home Assistant sent move_to_level_with_on_off to the same or a lower level, the GE dimmer did not physically turn on, even though Home Assistant's code set _state = 1 and scheduled an update so the UI showed the light as on.\n\nUsers observed that:\n- light.turn_on with brightness sometimes left the physical light off on these dimmers.\n- The workaround was to force an On command after setting brightness in a custom component.\n\nThe discussion highlighted that the implementation relied on the assumption that move_to_level_with_on_off always implies On, which is not guaranteed by the spec. It also revealed that optimistic state updates (setting entity state without verifying the device action) can desynchronize Home Assistant's state from the physical device.\n\nThe fix in the pull request is minimal but effective: it deletes the early return after calling move_to_level_with_on_off in homeassistant/components/light/zha.py. Previously the code path was roughly:\n\n- If brightness is provided:\n  - call endpoint.level.move_to_level_with_on_off(...)\n  - set self._state = 1\n  - async_schedule_update_ha_state()\n  - return  # <- removed\n\nBy removing the return, the code continues on to execute endpoint.on_off.on() and then set self._state = 1. As a result, when light.turn_on is called (with or without brightness), an explicit On command is always sent to the On/Off cluster. For devices that already turn on upon move_to_level_with_on_off, the extra On is effectively a no-op. For strict devices like the GE 45857GE, this guarantees that the light actually turns on even when the requested level does not represent an increase.\n\nThis change also reduces reliance on optimistic updates by tying the on-state to sending a concrete On command, rather than assuming the level-control command implicitly toggled the OnOff state.",
        "semantic_memory": "1. Zigbee Level Control 'with On/Off' commands are not guaranteed to always turn on the device.\n   - In the Zigbee Cluster Library, commands like move_to_level_with_on_off must set OnOff=On only when the command increases the CurrentLevel.\n   - If the level does not increase, a compliant device may leave OnOff=Off even though the level is adjusted.\n   - Implementations must not assume that these commands are equivalent to sending an explicit On command.\n\n2. Do not rely on optimistic state updates when controlling real devices.\n   - Setting internal state (e.g., self._state = 1) and updating the UI before sending or confirming the actual device command can cause state desynchronization.\n   - Especially in heterogeneous environments (many vendors with slightly different interpretations of a spec), optimistic assumptions are fragile.\n   - A safer pattern is: send the relevant Zigbee command(s), then update the state based on the command outcome (or, ideally, on attribute reporting or explicit readbacks).\n\n3. Always consider spec edge cases when binding multiple cluster behaviors.\n   - For devices with both On/Off and Level Control clusters, \"associated behavior\" is defined in the spec (e.g., what On should do in relation to OnLevel and CurrentLevel).\n   - Different manufacturers may implement slightly different behaviors, particularly around defaults (OnLevel=0xFF, etc.). Code that assumes a particular behavior (e.g., that all devices treat On as 'go to 100%') should be treated as handling quirks, not generic behavior.\n\n4. Sending an explicit On/Off 'On' after setting brightness is a robust default.\n   - For most dimmable lights, sending On after a brightness change is harmless because the device is already on; the extra command is effectively idempotent.\n   - For strict devices that follow the spec and do not turn on when level does not increase, the explicit On command is necessary to achieve the intended user-visible effect of light.turn_on.\n   - As a result, calling both move_to_level_with_on_off (to set brightness) and On (to ensure on/off state) is a reasonable generic strategy unless device-specific quirks indicate otherwise.\n\n5. Separate generic behavior from device quirks.\n   - If some devices treat On as 'go to 100%' instead of going to OnLevel or the stored level, they may be better modeled as quirky devices with device-specific overrides rather than driving the default logic for all devices.\n   - Frameworks like zigpy can provide a 'CustomDevice' or 'quirks' mechanism to override command handling for specific models while keeping the core logic standards-compliant.\n\n6. Polling vs. reporting in device integrations.\n   - Entities with should_poll=True are polled every scan_interval; should_poll=False means they are not polled and are expected to push updates.\n   - Using polling for many Zigbee lights adds unnecessary traffic and should be a temporary workaround. Ideally, state should be maintained via attribute reporting from devices.\n   - When debugging state-sync issues, understanding when async_update is invoked and how should_poll is configured is crucial.",
        "procedural_memory": [
            "When a Zigbee dimmable light or switch does not turn on reliably after a brightness change, or Home Assistant (or another controller) shows the light as 'on' while the physical device remains off, follow these steps:",
            "Step 1: Reproduce and characterize the behavior.",
            "- Use the light.turn_on (or equivalent) service with various brightness values, including values equal to and lower than the current brightness.",
            "- Observe whether the physical device turns on consistently.",
            "- Compare the controller's reported state to the physical state to detect desynchronization (e.g., HA says 'on' but the light is dark).",
            "",
            "Step 2: Inspect the integration's command flow.",
            "- Locate the turn_on implementation for the relevant integration (e.g., homeassistant/components/light/zha.py).",
            "- Check what commands are sent when brightness is supplied: specifically, look for Level Control cluster commands (e.g., move_to_level_with_on_off) and On/Off cluster commands (e.g., on()).",
            "- Look for early returns or conditional paths that might send level commands without sending an explicit On command.",
            "- Identify any optimistic state updates like self._state = 1 and async_schedule_update_ha_state() that occur before or without a corresponding On command.",
            "",
            "Step 3: Reconcile behavior with the Zigbee specification.",
            "- Consult the Zigbee Cluster Library (ZCL) specification for the Level Control and On/Off clusters.",
            "- Verify the semantics of 'with On/Off' commands: note that they only guarantee setting OnOff=On when the level increases.",
            "- Determine whether the integration is incorrectly assuming that move_to_level_with_on_off always turns the light on.",
            "",
            "Step 4: Adjust the command sequence to be explicit and robust.",
            "- Ensure that when the controller intends to turn the light on (light.turn_on), it always sends an explicit On command to the On/Off cluster, regardless of whether it used move_to_level_with_on_off to set brightness.",
            "- Concretely, if the code currently does:\n  - call move_to_level_with_on_off(...)\n  - set internal state to on\n  - return\n  modify it to:\n  - call move_to_level_with_on_off(...)\n  - do not return early; allow the code to continue to send endpoint.on_off.on()\n  - then update internal state.",
            "- Remove or avoid optimistic state updates that assume the level command toggled OnOff. Instead, base the on-state on having sent the On command or, ideally, on actual attribute updates.",
            "",
            "Step 5: Implement and test the fix.",
            "- Remove any early return that prevents the On command from being sent after move_to_level_with_on_off.",
            "- Re-run the same light.turn_on calls with various brightness values on multiple device models, including the problematic one (e.g., GE 45857GE) and other brands.",
            "- Confirm:\n  - The physical light always turns on when light.turn_on is invoked, regardless of brightness value.\n  - There is no regression for devices that already turned on with move_to_level_with_on_off; the extra On command should be harmless.",
            "",
            "Step 6: Consider device-specific quirks if needed.",
            "- If some devices treat On as 'go to 100%' or exhibit other non-standard behavior, consider adding device-specific quirk classes (e.g., in zigpy's CustomDevice mechanism) to tailor the command sequence for those models.",
            "- Keep the generic implementation standards-compliant and conservative; use quirks for vendor-specific deviations.",
            "",
            "Step 7: Review state synchronization strategy.",
            "- Ensure that the entity does not rely solely on optimistic updates; prefer attribute reporting or polling (as a fallback) to keep state in sync.",
            "- Confirm should_poll is correctly set based on whether the integration supports push updates for that device.",
            "- If using polling as a temporary workaround, verify the scan_interval is reasonable and avoid unnecessary network load.",
            "",
            "Step 8: Document the behavior and rationale.",
            "- Document that the integration now sends an explicit On command after brightness changes, and explain that this is necessary because some devices only toggle On when brightness increases.",
            "- Note any known quirks or device-specific behaviors so future maintainers understand why the explicit On is needed."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Rachio Iro sprinkler integration: new switch platform for zones using the rachiopy library. Fixes include switching from ad‑hoc GitHub ZIP requirements to the pip package, correcting manual run time conversion (minutes to seconds), shortening the update throttle interval for more responsive status, using hass.data instead of module‑level globals, and robust error handling for invalid API tokens and schedule lookups.",
        "keywords": [
            "homeassistant.components.switch.rachio",
            "Rachio Iro",
            "rachiopy",
            "manual_run_mins bug",
            "double conversion minutes to seconds",
            "MIN_UPDATE_INTERVAL",
            "util.Throttle",
            "hass.data",
            "Home Assistant switch platform",
            "sprinkler controller integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set adds and stabilizes a new Home Assistant switch platform for Rachio Iro sprinkler controllers, backed by the rachiopy library. Initially the integration used a GitHub ZIP URL for the dependency and a module‑level global to hold the controller instance. The code also incorrectly handled the manual run duration: the configured manual_run_mins was converted to seconds twice, effectively multiplying the run time by 60 twice and causing significantly longer watering periods. Additionally, the update throttling was set to 5 minutes, making zone state feedback sluggish, and the code didn't robustly handle invalid API tokens or schedule structures.\n\nThe fixes and refinements included:\n- Switching REQUIREMENTS from a GitHub archive URL to a proper PyPI dependency (rachiopy==0.1.1) and reflecting that in requirements_all.txt, so the package installation is stable and consistent.\n- Storing the RachioIro device instance in hass.data[\"rachio\"] instead of a module‑level global, aligning with Home Assistant patterns and avoiding state sharing issues between tests or reloads.\n- Adjusting MIN_UPDATE_INTERVAL from 5 minutes to 30 seconds to provide more timely status updates.\n- Correcting unit conversion for manual run duration: the zone object now stores _manual_run_secs = manual_run_mins * 60 and turn_on() uses that value directly, rather than multiplying by 60 again. This removes the double-conversion bug that made zones run far longer than configured.\n- Simplifying and fixing RachioZone.is_on: it now compares self.zone_id to schedule.get('zoneId'), avoiding the previous logic that tended to always return false if the key was missing.\n- Removing return of raw HTTP headers from turn_on/turn_off and just invoking the API, making the switch implementation match HA's SwitchDevice contract.\n- Making RachioIro.update() the throttled entry point (with util.Throttle) and letting it pull both device data and current schedule; zone.update() is now a simple wrapper that refreshes its own _zone and then forces device update, which avoids conflicting throttling.\n- Ensuring update signatures accept **kwargs (e.g., update(no_throttle=True)) as required by Home Assistant's entity lifecycle.\n- Adding proper validation and error handling around the access token: _get_person() is wrapped and exceptions like KeyError are handled by logging an error and aborting setup, so invalid tokens don't crash the platform but result in a clean failure.\n- General PEP8 and logging cleanups, including removing IDE-specific comments and using logger formatting rather than string concatenation.\n\nOverall, this turned an initial prototype Rachio integration into a properly packaged, robust Home Assistant switch platform with correct runtime behavior and dependency management.",
        "semantic_memory": "Key lessons from this integration and bug fix set:\n\n1. **Use stable, packaged dependencies**: Integrating via GitHub archive URLs in REQUIREMENTS is fragile. Prefer official PyPI packages with pinned versions, and mirror that in requirements_all.txt for consistent installs across environments.\n\n2. **Avoid module-level singletons; use hass.data**: For Home Assistant platforms, shared state like a controller object should be stored in hass.data under a clearly named key, not in module globals. This prevents cross-test contamination, reload issues, and makes state access explicit.\n\n3. **Be careful with unit conversions**: When a configuration option represents minutes but the API expects seconds, carefully centralize the conversion (e.g., manual_run_secs = manual_run_mins * 60) and avoid re-applying conversion in other layers. Double conversion is an easy and severe logic error (e.g., turning 10 minutes into 10 * 60 * 60 seconds).\n\n4. **Throttle at the right level with correct signatures**: When using util.Throttle in Home Assistant, throttle the primary update method (e.g., device.update()) and ensure it accepts **kwargs so entity lifecycle calls like update(no_throttle=True) work. Sub-entities (like zones) should delegate to that instead of having their own independent throttling that can lead to inconsistent or stale data.\n\n5. **Robust schedule and API handling**: When dealing with remote APIs, always treat response structures as potentially incomplete. Use dict.get() instead of indexing, and handle missing keys gracefully (e.g., RachioZone.is_on compares zone_id to schedule.get('zoneId') and returns False if the key is absent). Wrap early API calls like \"get current user\" in try/except and abort setup kindly when tokens are invalid.\n\n6. **Align platform behaviors with Home Assistant contracts**: Methods like SwitchDevice.turn_on/turn_off should not return low-level HTTP data; they should implement the semantic action and rely on state updates or logging. Also, avoid side-channel global flags and rely on HA's entity model (e.g., using hass.data and entity properties) for clarity.\n\nThese patterns generalize to most third-party device integrations: manage dependencies properly, store shared state explicitly, carefully convert configuration units, centralize throttled updates, and harden against unexpected remote API behaviors.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: **Reproduce and characterize the behavior**\n- For time-related behavior (like sprinklers), compare the configured run time (e.g., 10 minutes) to the actual observed run time. If the observed runtime is an order of magnitude off (e.g., 600 vs 36000 seconds), suspect unit conversion issues.\n- For state responsiveness, measure how long it takes for UI status to reflect real-world changes; multi-minute lag suggests throttling or polling problems.",
            "Step 2: **Inspect configuration-to-API conversion paths**\n- Locate where configuration options (e.g., manual_run_mins) are transformed before being passed to the API (e.g., RachioPy's .start() method).\n- Search for multiple occurrences of \"* 60\" or similar conversions; ensure that minutes are converted to seconds exactly once, preferably in the zone or device initialization.\n- Refactor so that a single variable (e.g., _manual_run_secs) holds the converted value and all callers use that variable directly.",
            "Step 3: **Normalize shared state and update throttling**\n- Replace module-level globals (like _IRO) with entries in hass.data (e.g., hass.data['rachio'] = RachioIro(...)). Update all references accordingly.\n- Ensure only one primary update method is decorated with util.Throttle (typically device.update()). Sub-entities should call into this method rather than having their own independent throttling decorators.\n- Make sure throttled update methods accept **kwargs to support flags like no_throttle=True used by HA internals.",
            "Step 4: **Harden API and schedule handling**\n- Wrap initial API calls (e.g., fetching the current user or device list) in try/except blocks and log informative errors (e.g., \"Could not reach the Rachio API. Is your access token valid?\"). Return False from setup_platform if these fail.\n- When reading data structures from the API (like current_schedule), use dict.get('key') instead of direct indexing to avoid KeyErrors and handle 'no current schedule' cases cleanly.\n- For boolean properties like is_on, define behavior for missing fields (e.g., return False if schedule.get('zoneId') is None).",
            "Step 5: **Align with Home Assistant platform patterns**\n- Ensure REQUIREMENTS uses PyPI packages (e.g., rachiopy==0.1.1) and update requirements_all.txt accordingly.\n- Make turn_on/turn_off methods on SwitchDevice subclasses perform actions and rely on state updates/logging; avoid returning raw HTTP or library-specific data.\n- Respect Home Assistant’s platform schema conventions (using vol.Optional/vol.Required) and logging format (logger.debug/info(\"msg %s\", var) instead of string concatenation).",
            "Step 6: **Test and verify**\n- Manually trigger a zone run with the configured manual_run_mins and measure the actual run time; confirm it matches configuration within a reasonable margin.\n- Check that state updates (is_on, enabled zones list) change within the shortened MIN_UPDATE_INTERVAL.\n- Intentionally use an invalid API token and confirm that setup_platform logs a clear error and the platform fails gracefully instead of raising unhandled exceptions.\n- Run Home Assistant’s test suite (pytest/tox) or add targeted tests if possible to ensure the new behavior is stable and the integration behaves as expected under error conditions."
        ]
    }
}
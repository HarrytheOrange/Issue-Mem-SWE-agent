{
    "search_index": {
        "description_for_embedding": "Adds support for per-label properties (metadata) to napari's Labels layer, including automatic mapping from label IDs to property rows, optional use of a DataFrame 'index' column for custom mappings, safe status-message rendering that shows label properties or '[No Properties]' without crashing, and updates to shared dataframe_to_properties utilities used by other layers.",
        "keywords": [
            "napari",
            "Labels layer",
            "label properties",
            "label_index",
            "dataframe_to_properties",
            "segmentation metadata",
            "status message",
            "index column",
            "background label",
            "GUI robustness"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the team introduced a new feature for napari's Labels layer to support per-label properties (metadata). Previously, label layers had no structured way to associate metadata (like 'class', 'size', or 'row') with each label ID. The PR added a `properties` attribute to the Labels layer and a label-to-row mapping mechanism, `label_index`.\n\nInitial versions of the PR explicitly accepted a `label_index` dict from the caller and even briefly implemented an automatic off-by-one remapping that skipped label 0 (background). After design discussion, they reverted this remapping. The final design assumes that the first row in each properties array corresponds to the background label by default and that labels map directly to row indices unless a custom mapping is supplied.\n\nTo support more advanced use cases, they extended `dataframe_to_properties` in `napari.layers.utils.layer_utils` to return both `(properties, index)` instead of just the properties dict. If a pandas DataFrame includes an 'index' column, the utility builds a custom `label_index` mapping from that column, allowing arbitrary/non-contiguous label IDs. All call sites in Points and Vectors layers were updated to unpack this new return signature and ignore the `index` part when not needed.\n\nIn the Labels layer, `__init__` now validates and stores properties, infers `label_index` either from the DataFrame's 'index' column (via `dataframe_to_properties`) or by auto-generating an identity mapping with `_map_index` when only a dict of properties is provided. When `properties` is None, both `_properties` and `_label_index` are initialized empty.\n\nThe `get_message` method was updated so that, when the cursor is over a label, it looks up the label in `_label_index` and appends each non-'index' property as ', key: value' to the base status message. If no properties are defined for the current label, it appends ' [No Properties]' instead of raising a KeyError or failing silently. Background and labels not present in the mapping are handled gracefully.\n\nTests were added (`test_properties` in `napari/layers/labels/_tests/test_labels.py`) to verify correct handling of: a layer with no properties, basic properties mapping, the status message content, the '[No Properties]' path when properties don't cover all labels, and the DataFrame-based 'index' mapping for labels like 12. An example script `examples/add_labels_with_properties.py` was added, using the coins segmentation example and defining 'row' and 'size' properties per coin, including background entries. This both demonstrates usage and provides a realistic scenario for future debugging.\n\nThroughout, special care was taken to avoid breaking existing code: label layers without properties work as before, utilities used by other layers were kept compatible by updating their callers, and the UI no longer risks crashing when properties are incomplete or missing.",
        "semantic_memory": "This PR captures several reusable patterns and best practices for attaching metadata to labeled data and integrating it into a GUI without compromising stability:\n\n1. Designing metadata for labeled arrays:\n   - When working with segmentation labels (integer-valued images), it's common to need per-label metadata (class, size, position group, etc.). Representing this as `properties: Dict[str, np.ndarray]` where each array is length N (labels) is a simple and efficient pattern.\n   - A separate mapping from label IDs to row indices (`label_index: Dict[int, int]`) decouples arbitrary label values (e.g., 0 for background, 12 for a specific object) from dense property tables. This allows supporting sparse or non-contiguous labels and aligning to external tabular data.\n   - When no custom mapping is provided, an identity mapping from label to row index is a sensible default, as long as the relationship between label IDs and property rows is documented (e.g., first row is background).\n\n2. Using DataFrames as a metadata source:\n   - Converting a pandas DataFrame to an internal `properties` dict is useful when end users are working with tabular data. A utility like `dataframe_to_properties` centralizes this conversion.\n   - If the DataFrame includes a special column (like 'index'), the conversion function can derive additional structures (e.g., a `label_index` mapping) instead of requiring users to build them manually. Returning `(properties, index)` instead of just `properties` allows richer semantics while keeping the same core data.\n   - When extending a shared utility, update all call sites explicitly so that layers that don't care about the extra information can simply ignore it.\n\n3. Robustness in GUI status messages:\n   - Any GUI method that reads from user-supplied mappings or arrays should be defensive: always check key membership before indexing into a dict and fall back gracefully when metadata is missing.\n   - Explicitly signaling missing metadata (e.g., appending ' [No Properties]' to a status message) is better than silently ignoring it. This helps users debug mismatched properties vs. labels.\n   - When iterating over properties, exclude internal or structural fields ('index' in this case) from user-facing messages to avoid confusing output.\n\n4. API design and backward compatibility:\n   - When modifying a widely-used helper function (e.g., changing its return type), immediately update all existing callers to correctly handle the new return signature, and keep the original behavior intact for their primary use cases (e.g., they still get a properties dict as before, now with an extra ignored return value).\n   - Avoid unnecessary or implicit remapping that might surprise users (such as auto-offsetting labels to skip background); prefer explicit conventions (first row corresponds to background) and allow advanced users to override via explicit indices.\n\n5. Testing and examples as validation tools:\n   - Tests should cover both the success path and partial/edge cases: no properties, incomplete mapping, and custom mapping via DataFrame. This ensures the UI remains stable when users don't provide perfect metadata.\n   - A real-world example script built on a realistic dataset (coins segmentation with 'row' and 'size' properties) is valuable as both documentation and a regression benchmark.",
        "procedural_memory": [
            "To diagnose and implement per-label metadata (properties) in a segmentation or labels layer, and to integrate it safely into a GUI:",
            "Step 1: Model label properties explicitly",
            "Define a `properties` structure as a dict mapping property names (strings) to one-dimensional arrays (or lists) of equal length, one entry per label. Establish and document a convention for how label IDs map to property rows (e.g., row i corresponds to label i, with row 0 as background).",
            "Step 2: Introduce a label-to-row mapping when needed",
            "If label IDs are non-contiguous or externally defined (e.g., labels like 0, 5, 12, 100), introduce a mapping `label_index: Dict[int, int]` where keys are label IDs and values are indices into the properties arrays. When a mapping is not provided, construct a default identity mapping that assumes labels 0..N-1 correspond to rows 0..N-1.",
            "Step 3: Add a conversion utility for tabular metadata",
            "If users provide metadata as a pandas DataFrame, add a utility (e.g., `dataframe_to_properties`) that converts it to `(properties, index_mapping)`. Build `properties` as a dict of numpy arrays. Optionally interpret a reserved column like 'index' to generate `index_mapping = {label_id: row_index}`. Return both so the caller can set both `_properties` and `_label_index`.",
            "Step 4: Update layer initialization logic",
            "In the layer's constructor, accept a `properties` argument that can be either a dict or a DataFrame. If it's a DataFrame, pass it through the conversion utility to get `(properties, label_index)`; if it's a dict, validate that all arrays have the same length and, if no index mapping is provided by the converter, generate one via a helper like `_map_index`. Initialize `_properties` and `_label_index` accordingly, using empty dicts when `properties` is None.",
            "Step 5: Validate properties consistently",
            "Implement a `_validate_properties` method that ensures all property arrays are the same length and converts any non-numpy sequences to numpy arrays. Raise a clear ValueError if lengths differ. Use this validator in both constructor and `properties` setter.",
            "Step 6: Make GUI code robust to missing properties",
            "In UI methods such as `get_message`, always guard against missing or incomplete metadata:\n- First check that both `_properties` and `_label_index` are non-empty.\n- Check that the current label (e.g., `self._value`) is not None and is present in `_label_index` before indexing.\n- If present, look up the row index and append each user-facing property as ', key: value', skipping internal fields like 'index'.\n- If absent, append a clear indicator such as ' [No Properties]' rather than throwing or silently doing nothing.",
            "Step 7: Adjust shared utilities and their call sites",
            "When changing a shared utility's interface (e.g., making `dataframe_to_properties` return a tuple instead of a single dict), immediately update all call sites to unpack the new return format. For layers that don't need the additional information, simply ignore the second value: `properties, _ = dataframe_to_properties(df)`.",
            "Step 8: Write tests for all key paths",
            "Add tests to cover:\n- A layer instantiated with no properties (properties is empty dict).\n- A layer with simple properties mapping and default identity `label_index`.\n- Status messages that include the expected property values when hovering labels.\n- Behavior when properties arrays are shorter than the range of labels (should show '[No Properties]' for unmapped labels).\n- Custom mapping via a DataFrame with an 'index' column, ensuring `_label_index` matches expectations and the message shows the right property for a non-zero, non-contiguous label ID.",
            "Step 9: Provide a realistic example script",
            "Create an example that uses a real segmentation (e.g., skimage's coins dataset), computes properties like 'row' and 'size' per label, includes a background entry, and passes this to the labels layer. This demonstrates usage to end users and serves as a practical regression case.",
            "Step 10: Avoid surprising implicit remapping",
            "Resist adding hidden offset logic (like shifting indices to skip a particular background label). Instead, adopt simple, explicit conventions that users can reason about, and allow advanced control via explicit indices or an 'index' column in tabular metadata."
        ]
    }
}
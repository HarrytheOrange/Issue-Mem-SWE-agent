{
    "search_index": {
        "description_for_embedding": "Home Assistant DoorBird integration was updated so that webhook/event callbacks from DoorBird devices require an authentication token and now include rich event data (timestamp and video/image URLs) on the Home Assistant event bus. Fix adds a required token configuration option, appends the token as a query parameter to the DoorBird callback URL, validates the token in the HTTP view before firing events, and attaches live video/image URLs as event data for use in automations.",
        "keywords": [
            "Home Assistant",
            "DoorBird",
            "webhook auth",
            "token authentication",
            "event data",
            "video URL",
            "doorbird.py",
            "HomeAssistantView",
            "hass.bus.async_fire",
            "integration security",
            "automation triggers"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The DoorBird integration in Home Assistant exposed an unauthenticated HTTP endpoint used by DoorBird devices to notify the system of events (doorbell press, motion, etc.). The endpoint accepted requests from any source and only fired a bare event on the Home Assistant event bus, without including any contextual data such as video streams.\n\nTo improve both security and usability, the PR introduced a required `token` in the `doorbird` configuration. This token is passed to the `DoorbirdRequestView` and appended as a query parameter to the DoorBird notification URL generated during subscription:\n\n  doorbird:\n    token: RANDOM_STRING\n    devices:\n      - host: x.x.x.x\n        username: USERNAME\n        password: PASSWORD\n        name: Front Door\n        monitored_conditions:\n          - doorbell\n          - motion\n\nIn `subscribe_events`, the callback URL became `.../api/doorbird/{slug}?token={token}`. On the receiving side, `DoorbirdRequestView.get` now reads `request.query.get('token')`, compares it to the configured token, and returns an 'Unauthorized.' JSON message if the token is missing or incorrect. Only authenticated requests proceed to fire events on the Home Assistant bus.\n\nAt the same time, the PR added richer event payloads. A `ConfiguredDoorbird` wrapper now provides `get_event_data()`, which returns a dictionary containing a timestamp and multiple URLs derived from the DoorBird device object: `live_video_url`, `live_image_url`, `rtsp_live_video_url`, and `html5_viewer_url` (treated as properties, not methods). A helper `get_doorstation_by_slug(hass, slug)` maps the incoming sensor slug to the corresponding configured doorstation. If found, its `get_event_data()` is used as the event data when calling `hass.bus.async_fire('doorbird_{sensor}', event_data)`; otherwise an empty dict is passed.\n\nFinally, a dummy `handle_event` listener is registered for each event slug during subscription so that the events appear in the Home Assistant UI. The PR also cleaned up imports (removing unused `asyncio` and `KEY_AUTHENTICATED`), fixed naming style to satisfy linters, and corrected the use of properties vs method calls on the DoorBird device object. Although the PR was ultimately closed in favor of reapplying changes after another refactor (#14933), it embodies the final desired behavior for token-based auth and enriched event data on DoorBird events.",
        "semantic_memory": "Several generalizable patterns emerge from this fix:\n\n1. **Secure webhooks with shared tokens**: When an integration exposes an HTTP endpoint for device callbacks or webhooks, it should not be left open to unauthenticated requests. A common, simple security pattern is to require a shared secret token (or signature) appended as a query parameter or header, configured by the user. The server-side handler compares the received token to the stored one and rejects mismatches. This adds a lightweight authorization layer suitable for devices that cannot perform more complex auth flows.\n\n2. **Propagate auth tokens end-to-end**: When using token-based auth for device callbacks, the token must be configured once and consistently propagated: (a) added as a required config option, (b) stored with the logical device/config wrapper, (c) included in the URL registered on the device, and (d) validated in the HTTP view. Missing any of these steps creates either broken callbacks or security holes.\n\n3. **Enrich events with contextual data**: Instead of firing bare events with no data, include contextual information that is useful for downstream automations. For camera/doorbell integrations, this typically includes timestamps and URLs to video streams, snapshots, or viewers. Centralizing the construction of event data (e.g., in a `get_event_data()` helper on a configuration wrapper object) reduces duplication and ensures consistency.\n\n4. **Use config wrapper objects for devices**: Wrapping low-level device objects in higher-level configuration objects (like `ConfiguredDoorbird`) allows you to attach metadata (name, token, custom URL) and helper methods (like `get_event_data()`). This improves separation of concerns and makes it easier to evolve features without changing the underlying library.\n\n5. **Map incoming webhook paths to configured entities**: For multi-device setups, incoming webhook requests often include a path segment or slug identifying which logical device triggered the event. Implementing a helper like `get_doorstation_by_slug()` allows translating that slug into the correct config object. This is a reusable pattern for any integration where a single HTTP view handles callbacks for multiple instances.\n\n6. **Register dummy listeners to surface events in UIs**: Some platforms only show events in configuration/automation UIs once they have listeners or have been fired. Registering a no-op listener per expected event type can be an intentional technique to make events visible and discoverable to users.\n\n7. **Respect external library APIs (properties vs methods)**: When wrapping or exposing values from a third-party library, it is important to follow its API exactly (e.g., accessing properties instead of calling them as functions). Misunderstanding this leads to runtime errors. Abstracting access through a helper method makes it easier to change usage if the library evolves.\n\n8. **Linting and naming consistency improve maintainability**: The PR demonstrates the value of cleaning up unused imports, following naming conventions (`request_token` instead of `requestToken`), and adding docstrings. These details help keep the integration aligned with project standards and reduce friction in future changes.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the security or data gap in webhook/event handling.\n- Review existing HTTP endpoints used by hardware devices or external services (e.g., doorbells, cameras) for event callbacks.\n- Check whether these endpoints accept requests without any authentication or validation.\n- Inspect what data is currently passed when events are fired (e.g., via `async_fire` or similar) and verify if important context (URLs, timestamps, etc.) is missing.",
            "Step 2: Design a minimal authentication mechanism.\n- Decide on an auth strategy that the external device can support (shared secret token, HMAC, etc.).\n- In environments like Home Assistant, a simple shared token in configuration is a practical choice.\n- Add a new configuration field (e.g., `token`) to the integration’s schema and mark it as required if all callbacks should be authenticated.",
            "Step 3: Wire the token through the integration.\n- Store the token when setting up the integration (e.g., read from `config[DOMAIN][CONF_TOKEN]`).\n- If you have a per-device configuration wrapper (like `ConfiguredDoorbird`), pass the token into that object and expose it via a property.\n- Where you construct the callback URL to register on the device (e.g., `subscribe_events` function), append the token as a query parameter or header (e.g., `...?token={token}`).\n- Log the full callback URL (without leaking secrets in production logs if necessary) to aid debugging.",
            "Step 4: Validate the token in the HTTP handler.\n- Modify the HTTP view or route handler (e.g., subclass of `HomeAssistantView`) to read the token from the incoming request (`request.query.get('token')` or headers).\n- Compare the received token to the expected token stored in the integration.\n- If the token is missing or does not match, return an appropriate error response (e.g., JSON message 'Unauthorized.' with correct HTTP status if the framework supports it) and do not fire any events.\n- Only proceed with event processing for authenticated requests.",
            "Step 5: Create and attach rich event data.\n- Identify what contextual information is valuable for automations (e.g., timestamps, stream URLs, snapshot URLs, device identifiers).\n- Implement a helper on the configuration wrapper object (e.g., `get_event_data(self)`) that builds and returns a dictionary containing these fields.\n- Ensure correct usage of the underlying device API (properties vs methods) when retrieving URLs or values.\n- In the HTTP handler, map the incoming slug or path segment to the correct config object (e.g., via a `get_device_by_slug()` helper).\n- Call `get_event_data()` and pass the resulting dict when firing the platform event (e.g., `hass.bus.async_fire('domain_sensor', event_data)`).",
            "Step 6: Map webhooks to configured devices.\n- Implement a helper function (like `get_doorstation_by_slug(hass, slug)`) that iterates over registered devices stored in a central registry (`hass.data[DOMAIN]` or equivalent) and matches them to the incoming slug.\n- Decide on a matching strategy (exact match or `slugify(name)` containment) and be consistent.\n- If no device is found, handle gracefully (e.g., log a warning and fire an event with empty data, or abort).",
            "Step 7: Ensure events are discoverable in UI and automation tools.\n- If your platform only shows known events that have listeners, register a dummy listener for each expected event type during setup (e.g., `hass.bus.listen('domain_slug', handle_event)` where `handle_event` is a no-op function).\n- This makes it easier for users to find and use these events in automation editors.",
            "Step 8: Clean up and align with project standards.\n- Remove unused imports (e.g., `asyncio`, `KEY_AUTHENTICATED`) that are no longer needed after refactoring.\n- Fix naming to follow project conventions (`snake_case` for variables).\n- Add or update docstrings for new methods and functions, especially helper utilities like `get_event_data()`.\n- Run the project’s linters and test suite (e.g., `tox`) and fix any reported issues.",
            "Step 9: Test end-to-end.\n- Configure the integration with a known token and a test device.\n- Verify that events with correct tokens are accepted and trigger Home Assistant events with the expected event data.\n- Verify that events with missing or incorrect tokens are rejected and do not fire automations.\n- Use logs or developer tools to inspect the payload of fired events and confirm that URLs and timestamps are present and valid.",
            "Step 10: Document configuration and behavior.\n- Update user-facing documentation to describe the new `token` config field, how to generate and set it, and how the DoorBird (or other device) uses it for callbacks.\n- Show example automations or event handlers that consume the new event data fields (e.g., using `live_image_url` in notifications)."
        ]
    }
}
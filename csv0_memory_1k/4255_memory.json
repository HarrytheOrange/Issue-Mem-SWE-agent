{
    "search_index": {
        "description_for_embedding": "Workaround for eventlet WSGI HTTP server defaulting missing Content-Type to text/plain, which broke JSON-based POST/PUT endpoints expecting application/json with optional/empty bodies. Fix adds Router-level logic (only for non-gunicorn/eventlet mode) to treat text/plain as application/json for most endpoints, except specific non-JSON endpoints, and updates tests accordingly.",
        "keywords": [
            "eventlet",
            "WSGI",
            "Content-Type default",
            "text/plain vs application/json",
            "empty request body",
            "POST PUT JSON API",
            "StackStorm Router",
            "is_gunicorn flag",
            "request validation",
            "auth token endpoint",
            "webhooks controller",
            "mistral_validation_controller",
            "multipart/form-data",
            "application/x-www-form-urlencoded",
            "HTTP server interoperability bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, StackStorm's API and auth services had an interoperability issue when running under the eventlet WSGI HTTP server (standalone mode). Eventlet automatically sets a default Content-Type header of text/plain when the client omits the header. Most StackStorm POST/PUT endpoints expect application/json, but many allow an empty body (e.g., /v1/auth/tokens). Many clients therefore send no body and no Content-Type. Under eventlet, this resulted in requests being seen as text/plain instead of application/json. The router uses the Content-Type to decide how to validate and parse the body against OpenAPI schemas. With Content-Type incorrectly set to text/plain, JSON validation logic was skipped or misapplied, breaking normal flows like token creation when no Content-Type was specified.\n\nThe fix introduces an is_gunicorn flag to the Router, passed from each app (st2api, st2auth, st2stream). In Router.__call__, during request-body parameter handling, a conditional was added: when not running under gunicorn (i.e., under eventlet) and the Content-Type is text/plain, the router inspects the OpenAPI operationId. For almost all endpoints, if the operationId does not contain 'mistral_validation_controller', it overrides content_type to application/json, effectively undoing eventlet's implicit text/plain default and restoring the intended behavior. The logic was initially broader (with a NON_JSON_API_ENDPOINTS blacklist that included webhooks) and then simplified to only special-case mistral_validation_controller and only when the content type is text/plain, so explicitly provided non-JSON content types like multipart/form-data or application/x-www-form-urlencoded are preserved. A webhook unit test was updated to explicitly send Content-Type: application/x-www-form-urlencoded so that the webhook still receives the correct content type. A new auth token test verifies that posting to /v1/auth/tokens with no body and content_type='text/plain' still succeeds (201), confirming that the router now treats such requests as JSON when appropriate. A minor .gitignore entry for virtualenv-py3 was also added.",
        "semantic_memory": "This fix illustrates a general pattern in web services: underlying HTTP servers or frameworks may add or modify headers (like Content-Type) when clients omit them, and such behavior can break application-level assumptions and validation logic.\n\nKey generalizable ideas:\n\n1. **Default Content-Type behavior matters**: Some WSGI/HTTP servers (e.g., eventlet) default missing Content-Type to text/plain, while others (e.g., gunicorn) leave it unset. If your app logic branches on Content-Type or uses it to select parsers/validators, you must account for these default behaviors.\n\n2. **Environment-specific behavior flags**: Passing explicit environment flags (like is_gunicorn) into shared components (e.g., a Router) allows you to scope workarounds or tweaks to specific runtimes, avoiding regressions in other environments.\n\n3. **Empty body vs. Content-Type semantics**: Endpoints that accept optional bodies often don't require clients to set Content-Type. However, middleware or servers might still inject a Content-Type, leading to mismatched expectations. Application logic should be robust to empty bodies and default content types and should treat some defaults (e.g., text/plain with an empty body) as effectively equivalent to 'no Content-Type' when appropriate.\n\n4. **Exception lists for non-standard endpoints**: When applying a broad compatibility workaround (e.g., treating certain content types as JSON by default), it's often necessary to explicitly exclude endpoints that legitimately use other content types (e.g., multipart/form-data or form-encoded webhooks, or special validation endpoints like mistral_validation_controller). Using operation identifiers or route metadata is a clean way to implement such exceptions.\n\n5. **Tests must reflect real HTTP behavior**: Unit and integration tests should emulate realistic client behavior, including proper Content-Type headers for non-JSON endpoints. When adding router-level workarounds, tests must verify both the corrected behavior (e.g., JSON endpoints working under eventlet) and that endpoints with genuine non-JSON content types are unaffected.\n\n6. **Scope workarounds narrowly**: The fix is carefully limited to the exact problematic combination: eventlet environment, Content-Type defaulted to text/plain, and JSON-centric endpoints. This reduces the risk of silently misclassifying legitimate text/plain or other real non-JSON requests.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms and environment\n- Observe failing API calls, particularly POST/PUT requests where the body is optional or empty.\n- Check if failures only occur under a specific HTTP server or deployment mode (e.g., eventlet vs. gunicorn).\n- Capture example requests from clients, noting whether Content-Type is explicitly set or omitted.",
            "Step 2: Inspect incoming request headers at the app layer\n- Add temporary logging or use an HTTP proxy to inspect the actual headers seen by the application.\n- Verify whether the server is injecting a default Content-Type (commonly text/plain) when the client omits it.\n- Compare behavior across environments (e.g., eventlet vs. gunicorn) to confirm that a server-specific default is the root cause.",
            "Step 3: Map Content-Type to application logic\n- Review how your router/framework maps Content-Type to parsers and validation logic (e.g., JSON schema validation, form parsing).\n- Identify endpoints that expect application/json but allow empty bodies, and check how they behave when Content-Type is text/plain.\n- Note any endpoints that legitimately accept non-JSON content types (form-encoded, multipart, plain text). These will need exceptions.",
            "Step 4: Introduce environment-aware configuration\n- Add an explicit flag or configuration parameter to your routing/middleware layer to distinguish environment/runtime (e.g., is_gunicorn, is_eventlet, is_production_httpd_type).\n- Ensure each app or service passes the correct value when instantiating shared components like Routers.",
            "Step 5: Implement a narrowly scoped workaround\n- In the request-handling path where Content-Type is interpreted (e.g., before body parsing or schema validation), add logic that:\n  - Triggers only in the problematic environment (e.g., if not is_gunicorn).\n  - Checks for the specific default Content-Type causing issues (e.g., content_type == 'text/plain').\n  - Uses route or operation metadata (e.g., operationId, route name, controller class) to distinguish JSON-centric endpoints from those that legitimately use other content types.\n  - For JSON-centric endpoints, overrides content_type to 'application/json' when it was defaulted to text/plain by the server.\n- Avoid changing content types that were explicitly set by the client (e.g., multipart/form-data, application/x-www-form-urlencoded).",
            "Step 6: Maintain an exception list for non-JSON endpoints\n- Enumerate endpoints that are allowed or expected to use non-JSON content types (e.g., webhooks receiving form data, validation endpoints expecting plain text).\n- Implement exclusions based on operation identifiers, paths, or controller names (e.g., 'mistral_validation_controller').\n- Document these exceptions clearly in code comments so future maintainers understand why they're excluded.",
            "Step 7: Update and add tests\n- For an endpoint that was failing (e.g., /v1/auth/tokens), add a test that sends:\n  - No request body.\n  - content_type='text/plain' (or omit Content-Type if your test framework mimics the server's behavior).\n  - Assert that the request now succeeds and is processed as JSON as intended.\n- For non-JSON endpoints (e.g., webhooks):\n  - Ensure tests explicitly set the appropriate Content-Type (e.g., application/x-www-form-urlencoded).\n  - Assert that the router or handler sees the correct Content-Type and that the body is parsed correctly.\n- Run tests across all relevant environments or simulate behavior (e.g., mimic eventlet's default Content-Type).",
            "Step 8: Validate no regressions in other deployments\n- Verify that the workaround is disabled or a no-op in environments without the issue (e.g., gunicorn) using the environment flag.\n- Re-run the full test suite in those environments.\n- Optionally add sanity tests to assert that the Content-Type is not altered when running under environments that do not inject defaults.",
            "Step 9: Document the behavior and workaround\n- Document in your deployment or developer docs that certain WSGI/HTTP servers (like eventlet) set default Content-Types, and that your application includes a targeted workaround.\n- Note any endpoints with special content-type behavior and how they are handled.\n- Include recommendations for clients (e.g., always set Content-Type when sending a body) while ensuring your server-side logic remains robust to real-world omissions."
        ]
    }
}
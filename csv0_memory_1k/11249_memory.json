{
    "search_index": {
        "description_for_embedding": "Home Assistant Xiaomi Miio Air Purifier integration updated to expose new device attributes (average_aqi, purify_volume), add child lock control services, and bump the python-miio dependency to 0.3.3. Service descriptions for fan.xiaomi_miio are moved to the shared fan/services.yaml for lazy loading instead of a component-local YAML file.",
        "keywords": [
            "Home Assistant",
            "xiaomi_miio",
            "Xiaomi Air Purifier",
            "fan.xiaomi_miio",
            "light.xiaomi_miio",
            "switch.xiaomi_miio",
            "vacuum.xiaomi_miio",
            "python-miio==0.3.3",
            "average_aqi",
            "purify_volume",
            "child_lock",
            "child lock service",
            "service registration",
            "services.yaml",
            "lazy loading service descriptions",
            "component requirements",
            "attribute exposure",
            "integration update"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant Xiaomi Miio Air Purifier integration (fan.xiaomi_miio) was enhanced to support new data and control features introduced by the underlying python-miio library. The python-miio dependency was bumped from 0.3.2 to 0.3.3 across all Xiaomi Miio components (fan, light, switch, vacuum) and in requirements_all.txt to maintain consistency.\n\nTwo new air purifier metrics provided by the device—average_aqi (average air quality index) and purify_volume—were not previously exposed to Home Assistant. The fix introduces new attribute constants ATTR_AVERAGE_AIR_QUALITY_INDEX and ATTR_PURIFY_VOLUME, initializes them in the XiaomiAirPurifier entity's _state_attrs, and populates them in async_update() using state.average_aqi and state.purify_volume from python-miio. This makes those metrics available in Home Assistant state and UI.\n\nThe device also supports a child lock feature that had no corresponding Home Assistant service. New services are added: xiaomi_miio_set_child_lock_on and xiaomi_miio_set_child_lock_off. They are wired into SERVICE_TO_METHOD, implemented as async_set_child_lock_on/off coroutines on the entity, and call self._air_purifier.set_child_lock(True/False) via the shared _try_command helper.\n\nSeparately, service descriptions for Xiaomi Miio fan services were originally stored in a component-specific file fan/xiaomi_miio_services.yaml, and loaded manually with load_yaml_config_file. To align with Home Assistant's newer lazy-loading mechanism, the descriptions were moved into the domain-level fan/services.yaml file. The explicit YAML loading and description parameter in hass.services.async_register() were removed; service registration now just passes the schema, and the platform relies on the shared services.yaml to provide the human-readable descriptions. The old xiaomi_miio_services.yaml file was deleted.\n\nSome minor cleanups were made: the service handler variable names were generalized from target_air_purifiers to devices, docstrings and error messages were corrected (e.g., “Turning the buzzer of the air purifier on failed.”), and a merge conflict around async_register formatting was resolved.",
        "semantic_memory": "This change illustrates a few general integration and platform patterns:\n\n1. **Expose new library/device capabilities through the integration:** When the underlying device library (here python-miio) adds new properties (e.g., average AQI, filtered air volume) or controls (child lock), the Home Assistant integration should be updated to:\n   - Bump the dependency version consistently across all related components and central requirements.\n   - Add corresponding attribute constants and include them in the entity's state attributes.\n   - Populate those attributes from the library's state object during updates.\n   - Add new services and methods that call the underlying device APIs.\n\n2. **Keep dependency versions consistent:** For a shared dependency used by multiple components of the same vendor or protocol, version bumps should be applied everywhere: in each component's REQUIREMENTS list and in the global requirements_all.txt. This avoids version skew where one component expects newer features that others can't satisfy.\n\n3. **Use domain-level service description configuration (lazy loading):** Home Assistant supports lazy loading of service descriptions from a domain-level services.yaml. Instead of each component maintaining its own YAML and manually loading it with load_yaml_config_file, service metadata (description, field descriptions, examples) should live in the shared domain services.yaml. Component code should:\n   - Only register services with domain, name, handler, and schema.\n   - Avoid custom file loading and passing description explicitly when the platform can source it from services.yaml.\n   This centralizes documentation, simplifies components, and ensures consistency in the UI.\n\n4. **Structure generic service handlers for multi-entity operations:** A robust pattern for platform services is:\n   - Accept entity_id as an optional parameter.\n   - If provided, filter hass.data[PLATFORM].values() by entity_id; otherwise operate on all entities.\n   - For each target entity, call the relevant async_* method and then schedule async_update_ha_state(True).\n   - Await all updates together via asyncio.wait().\n   This pattern allows the same service to control one or many entities and ensures state stays in sync.\n\n5. **Error handling and messaging:** When wrapping device calls in helper methods (like _try_command), error messages should be specific to the action and device type, to aid debugging. Updating these when new actions are added keeps logs meaningful.\n\nOverall, this PR demonstrates best practices in keeping an integration aligned with its backend library, centralizing service definitions, and exposing new capabilities cleanly and consistently to the platform.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify new device/library capabilities or missing features in the integration.\n- Monitor upstream device library releases (e.g., python-miio) for new properties or methods.\n- Compare those to the current integration: are new metrics (e.g., average AQI) or actions (e.g., child lock) absent from the entity state or services?",
            "Step 2: Bump and align the dependency version.\n- Update the component's REQUIREMENTS list to the new library version.\n- Search the codebase for other components using the same library (e.g., grep for 'python-miio') and update their REQUIREMENTS too.\n- Update any central requirements file (e.g., requirements_all.txt) to match.\n- Verify that all components are using the same version to avoid conflicts.",
            "Step 3: Expose new read-only attributes in the entity.\n- Add new attribute constants (e.g., ATTR_AVERAGE_AIR_QUALITY_INDEX, ATTR_PURIFY_VOLUME).\n- Initialize them with default values (usually None) in the entity's __init__ _state_attrs dict.\n- In the async_update() method, read the corresponding fields from the device/library state object (e.g., state.average_aqi, state.purify_volume) and assign them to self._state_attrs.\n- Confirm that the attributes appear in the entity state via the developer tools.",
            "Step 4: Add new control services for device actions.\n- Decide on service names following the existing convention (e.g., xiaomi_miio_set_child_lock_on/off).\n- Extend the SERVICE_TO_METHOD mapping to include these services, pointing to appropriate async_* methods and schemas.\n- Implement the async_* methods on the entity class, using any shared helper (e.g., _try_command) to call the underlying library methods (e.g., self._air_purifier.set_child_lock(True/False)).\n- Ensure method docstrings and error messages accurately describe the action and device.",
            "Step 5: Register services using domain-level service descriptions.\n- Move or create service description entries in the domain's services.yaml (e.g., homeassistant/components/fan/services.yaml): define description, fields, and example values for each service.\n- In the component code, register services with hass.services.async_register(domain, service_name, handler, schema=schema) without manually loading YAML or passing description when the platform supports lazy loading from services.yaml.\n- Delete any obsolete component-specific service YAML files and remove code that uses load_yaml_config_file and os.path joins for them.",
            "Step 6: Implement a robust generic service handler.\n- Write an async_service_handler that:\n  - Extracts entity_ids from service.data (if present).\n  - Filters hass.data[PLATFORM].values() to the selected entities or uses all of them when entity_id is absent.\n  - For each device, calls the desired method via getattr(device, method_name)(**params).\n  - After each call, schedules device.async_update_ha_state(True) and aggregates tasks.\n  - Awaits all updates using asyncio.wait(update_tasks, loop=hass.loop).\n- Register this handler for each service defined in SERVICE_TO_METHOD.",
            "Step 7: Test the integration end-to-end.\n- Start Home Assistant with the updated code and confirm it loads without dependency errors.\n- Use the developer tools to inspect a Xiaomi Air Purifier entity; verify that new attributes (average_aqi, purify_volume) appear and have reasonable values.\n- Trigger new services (set_child_lock_on/off, etc.) from the UI or via a service call; confirm that the device behavior changes and state attributes like child_lock are updated.\n- Check logs for any error messages from _try_command to catch failures in the underlying library call.",
            "Step 8: Clean up and ensure code consistency.\n- Rename variables for clarity and generality where appropriate (e.g., target_air_purifiers -> devices if the code is reused or generalized).\n- Update strings, docstrings, and log messages so they correctly reference the new actions and device.\n- Resolve any merge conflicts and adhere to the project's formatting and style conventions."
        ]
    }
}
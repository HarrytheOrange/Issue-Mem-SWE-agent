{
    "search_index": {
        "description_for_embedding": "Home Assistant core change adding LightwaveRF TRV support: new climate and battery sensor entities powered by a TRV UDP proxy, integrated via the lightwave Python library (bumped to 0.18). The PR introduces a nested YAML configuration schema for TRVs (proxy host/port + per‑TRV serial and name), uses LWLink.read_trv_status instead of raw sockets, exposes heating state and target temperature, and a dedicated battery percentage sensor. It also fixes a minor Somfy cover import issue (CONF_OPTIMISTIC).",
        "keywords": [
            "Home Assistant",
            "lightwave",
            "LightwaveRF",
            "TRV",
            "thermostatic radiator valve",
            "climate entity",
            "battery sensor",
            "UDP proxy",
            "LWLink",
            "read_trv_status",
            "requirements_all.txt",
            "integration config schema",
            "CONF_TRV",
            "CONF_SERIAL",
            "DEFAULT_PROXY_IP",
            "DEFAULT_PROXY_PORT",
            "CONF_PROXY_IP",
            "CONF_PROXY_PORT",
            "HVAC_MODE_HEAT",
            "CURRENT_HVAC_HEAT",
            "Somfy cover",
            "CONF_OPTIMISTIC import"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the contributor added support for LightwaveRF thermostatic radiator valves (TRVs) to the existing Home Assistant `lightwave` integration and cleaned up a small Somfy cover regression.\n\nPreviously, the Lightwave integration only supported lights and switches. The TRVs communicate via a separate UDP proxy, and the original prototype implemented socket handling directly inside the Home Assistant platform code. Reviewers requested that network I/O be pushed into the external `lightwave` Python library instead of doing raw socket operations in the integration.\n\nThe contributor introduced new configuration keys under `lightwave:`:\n- `trv:` (CONF_TRV) block containing:\n  - `proxy_ip` / `proxy_port` (with defaults 127.0.0.1:7878) for the TRV UDP proxy\n  - `trvs:` mapping of TRV device IDs to a config object with `name` and `serial` (CONF_SERIAL)\n\n`CONFIG_SCHEMA` was updated to require at least one of lights, switches, or TRV, and to validate the nested TRV configuration using voluptuous. Default values for the proxy are set using dedicated constants (DEFAULT_PROXY_IP/PORT). The overall style was aligned with Home Assistant conventions (domain constants, platform constants, etc.).\n\nIn `async_setup`, the integration now:\n- Instantiates a single LWLink object and stores it in `hass.data[LIGHTWAVE_LINK]`.\n- If TRV config is present, reads the proxy IP/port, calls `lwlink.set_trv_proxy(proxy_ip, proxy_port)` to configure the library, and dynamically loads the `climate` and `sensor` platforms using `async_load_platform`.\n\nTwo new platform modules were added:\n\n1. `lightwave.climate.LightwaveTrv`\n   - Represents a TRV as a `ClimateDevice`.\n   - Uses `LWLink.read_trv_status(serial)` to retrieve:\n     - Current temperature (`temp`)\n     - Target value (`targ`)\n     - Battery and output, though the battery value is no longer used here\n   - Implements logic for interpreting the target value:\n     - `targ == 0` means TRV off → `target_temperature` becomes `None`\n     - `targ >= 40` means call-for-heat / fixed-position mode → `target_temperature` becomes `None`\n     - Otherwise, `targ` is the desired temperature in °C.\n   - Stores `current_temperature`, `target_temperature`, and sets `hvac_action` based on TRV output (`CURRENT_HVAC_HEAT` vs `CURRENT_HVAC_OFF`).\n   - Uses `HVAC_MODE_HEAT` as the only HVAC mode (always reported; `hvac_mode` returns this constant).\n   - Uses `DEFAULT_MIN_TEMP`, `DEFAULT_MAX_TEMP`, `TEMP_CELSIUS`, and a hard-coded `target_temperature_step` of 0.5.\n   - Includes an `_inhibit` flag to avoid flickering of the target temperature immediately after a `set_temperature` call. When a temperature is set, `_inhibit` is set to the new target so `target_temperature` continues to report the user-selected value until the remote state has propagated. On the next successful update, `_inhibit` is cleared and normal proxy values resume.\n   - `set_temperature` forwards the command to `lwlink.set_temperature(device_id, target_temperature, name)` and relies on subsequent polling, no explicit `async_schedule_update_ha_state()` call.\n\n2. `lightwave.sensor.LightwaveBattery`\n   - Represents the TRV battery as a separate sensor entity with `DEVICE_CLASS_BATTERY` and `UNIT_PERCENTAGE`.\n   - In `async_setup_platform`, it iterates `discovery_info.values()` and creates one `LightwaveBattery` per TRV using the stored LWLink instance.\n   - `update` calls `LWLink.read_trv_status(serial)` and extracts the battery percentage from the returned tuple, storing it directly as sensor state.\n\nBoth platforms were simplified to remove unused device attributes and logging. `device_state_attributes` functions were dropped once battery reporting moved fully to the dedicated sensor.\n\nThe PR also updated `homeassistant/components/lightwave/manifest.json` and `requirements_all.txt` to use `lightwave==0.18`, which contains the new TRV proxy handling helper methods (`set_trv_proxy` and `read_trv_status`). This decouples Home Assistant from the raw UDP socket details.\n\nDuring rebase, a Somfy cover file had lost an import of `CONF_OPTIMISTIC`; the author restored it with `from . import API, CONF_OPTIMISTIC, DEVICES, DOMAIN, SomfyEntity` to fix that regression.\n\nThe changes went through multiple review iterations focusing on:\n- Proper config schema semantics and defaults for nested TRV configuration.\n- Avoiding duplicated host configuration keys.\n- Using Home Assistant constants (DEVICE_CLASS_BATTERY, UNIT_PERCENTAGE, DEFAULT_MIN_TEMP, DEFAULT_MAX_TEMP).\n- Cleaning up unused code and attributes, pyflakes/pylint issues (e.g., unused variables, logging imports).\n- Ensuring async setup functions check `discovery_info is None` and use `values()` iteration.\n\nAfter several rounds of small style and logic tweaks, and once tests and CI passed, core maintainers approved the PR as a feature extension for Lightwave.",
        "semantic_memory": "This change illustrates several generalizable patterns for extending and maintaining a Home Assistant integration, especially when adding support for new device types that use an auxiliary proxy or gateway:\n\n1. **Push IO/Protocol Logic into the External Library**\n   Instead of embedding raw socket handling (UDP/TCP, JSON parsing, error handling) in the Home Assistant platform code, encapsulate that logic in the vendor or protocol library (here `lightwave`). The integration then calls a higher-level method (`read_trv_status`) and works with clean Python values. This improves testability, separation of concerns, and keeps integration code focused on entity semantics instead of networking.\n\n2. **Use a Single Shared Client Object in hass.data**\n   Home Assistant integrations are expected to maintain a single connection/client object (LWLink) stored in `hass.data[DOMAIN_...]`. Platform code (climate, sensor, etc.) retrieves this shared client during setup. This avoids duplicated connections, makes it easier to inject configuration (e.g. proxy IP/port) once in `async_setup`, and ensures consistent behaviour across entities.\n\n3. **Structured Configuration with Voluptuous**\n   For complex devices or sub-features, it is better to define a nested configuration structure using voluptuous rather than flat keys. Here, TRV config is grouped under `trv:` with a sub-mapping `trvs:` per device, plus per‑block defaults (`proxy_ip`, `proxy_port`). Constraints like `has_at_least_one_key` are used so that the integration validates successfully as long as at least one supported feature (lights, switches, TRVs) is configured.\n\n4. **Use and Expose Domain-Specific Constants**\n   Domain-level constants (e.g., `HVAC_MODE_HEAT`, `CURRENT_HVAC_HEAT`, `DEFAULT_MIN_TEMP`, `TEMP_CELSIUS`, `DEVICE_CLASS_BATTERY`, `UNIT_PERCENTAGE`) give consistent semantics across integrations. They also make the code self-documenting and reduce the risk of mistakes (such as using raw strings).\n\n5. **Separate Concerns into Dedicated Entities**\n   Instead of overloading the climate entity with battery reporting, this PR introduces a dedicated `battery` sensor entity. This matches Home Assistant best practices: each entity represents a single conceptual measurement or actuator. It simplifies the climate entity and allows the battery sensor to use appropriate device class and unit.\n\n6. **Handle Transitional UI States Carefully**\n   When a user sets target temperature, remote devices may take some time to reflect the new value. If the integration immediately polls and sees the old target, the UI can appear to \"snap back\" to the previous value. The `_inhibit` field addresses this by temporarily overriding the reported target temperature until a stable update is received. More generally, you often need a small reconciliation mechanism between local user intent and remote eventual consistency.\n\n7. **Favor Positive Checks for `discovery_info` and Values**\n   The use of `if discovery_info is None: return` and explicit `is not None` checks for values (e.g., `if targ is not None`) makes behaviour clearer, especially when `0` is a meaningful state distinct from `None` (e.g. `targ == 0` means TRV off). This avoids bugs introduced by using truthiness in contexts where zero is a valid value.\n\n8. **Keep Code Style and Naming Consistent**\n   Names like `LIGHTWAVE_LINK = f\"{DOMAIN}_link\"` and `CONF_PROXY_IP` show a pattern: domain-specific constants built from generic ones, alignment with other integrations, and eliminating magic strings. Consistent naming makes the integration easier to reason about and maintain.\n\n9. **Update Manifests and Global Requirements When Bumping Libraries**\n   When new functionality depends on a newer version of a Python library, both the integration manifest and the global `requirements_all.txt` need to be updated. This is essential in large mono-repos where deployment tooling expects consistency.\n\n10. **Small Fixes Can Ride Along but Should Be Isolated**\n    The Somfy fix (restoring `CONF_OPTIMISTIC` import) is a minimal change that corrects a rebase/backoff error. Keeping such fixes small and clearly separated makes code review easier while still allowing them to be merged with related feature work.\n\nOverall, this PR is a strong example of incrementally refactoring an integration to better architecture while adding feature support: network abstraction, cleaner configuration, more focused entities, and idiomatic Home Assistant coding patterns.",
        "procedural_memory": [
            "When adding support for a new device type (e.g., a TRV) to an existing Home Assistant integration that relies on an external library and possibly a proxy, follow these steps:",
            "Step 1: Extend the external protocol library first.",
            "  - Add high-level methods (e.g., `set_trv_proxy(proxy_ip, proxy_port)`, `read_trv_status(serial)`, `set_temperature(device_id, target, name)`) to the Python library for the integration.",
            "  - Move raw I/O (socket creation, timeouts, JSON decoding) into the library, returning clean Python primitives (temperatures, battery percentage, output state) to the integration.",
            "  - Add tests in the library to validate protocol handling and edge cases (timeouts, malformed responses).",
            "Step 2: Update integration requirements and manifest.",
            "  - Bump the library version in the integration's `manifest.json` and in `requirements_all.txt` to the new version that exposes the desired methods.",
            "  - Run the appropriate Home Assistant scripts (e.g., `python3 -m script.gen_requirements_all`) to regenerate derived files and ensure consistency.",
            "Step 3: Extend the configuration schema using voluptuous.",
            "  - Introduce new config constants like `CONF_TRV`, `CONF_TRVS`, `CONF_SERIAL`, `CONF_PROXY_IP`, and `CONF_PROXY_PORT`.",
            "  - Define a nested schema for the new feature (e.g., TRV block with proxy settings and device mapping) using `vol.Schema` and `vol.All`.",
            "  - Use `cv.has_at_least_one_key` to ensure the integration can be configured with any combination of lights, switches, and TRVs.",
            "  - Provide defaults via constants (e.g., `DEFAULT_PROXY_IP = \"127.0.0.1\"`, `DEFAULT_PROXY_PORT = 7878`) in the schema rather than hardcoding them later.",
            "Step 4: Initialize and share the client object in async_setup.",
            "  - In `async_setup`, instantiate the library client (e.g., `lwlink = LWLink(host)`) and store it in `hass.data[LIGHTWAVE_LINK]`.",
            "  - If the new feature (TRV) is configured, extract proxy settings from the config and call library helpers (e.g., `lwlink.set_trv_proxy(proxy_ip, proxy_port)`).",
            "  - Dynamically load relevant platforms using `async_load_platform` for each platform type (e.g., CLIMATE_DOMAIN, SENSOR_DOMAIN) passing the `discovery_info` mapping (e.g., `trvs`).",
            "Step 5: Implement new platforms/entities using the shared client.",
            "  - In `async_setup_platform` of each platform module, check `if discovery_info is None: return` to guard against unexpected calls.",
            "  - Retrieve the shared client from `hass.data` (e.g., `lwlink = hass.data[LIGHTWAVE_LINK]`).",
            "  - Iterate over `discovery_info.values()` for each configured device, extracting `CONF_NAME` and `CONF_SERIAL` to create entity instances.",
            "  - Call `async_add_entities(entities)` with the list of newly created entities.",
            "Step 6: Implement Climate entities according to HA conventions.",
            "  - Inherit from `ClimateDevice` (or the appropriate base), implement properties:\n    - `name`, `current_temperature`, `target_temperature`, `hvac_modes`, `hvac_mode`, `hvac_action`, `min_temp`, `max_temp`, `temperature_unit`, `supported_features`, `target_temperature_step`.",
            "  - Use constants like `DEFAULT_MIN_TEMP`, `DEFAULT_MAX_TEMP`, `TEMP_CELSIUS`, `HVAC_MODE_HEAT`, `CURRENT_HVAC_HEAT`, `CURRENT_HVAC_OFF`, and `SUPPORT_TARGET_TEMPERATURE`.",
            "  - In `update`, call the library's high-level method (e.g. `temp, targ, _, output = lwlink.read_trv_status(serial)`) and interpret results carefully, treating `0` and `None` distinctly.",
            "  - When `0` is a meaningful state (e.g., off), use `if value is not None` checks instead of simple truthiness.",
            "  - If needed, implement a mechanism like `_inhibit` to avoid UI flickering when recently set values are not yet reflected by the device.",
            "Step 7: Implement separate sensor entities for auxiliary metrics.",
            "  - For battery or similar metrics, create a dedicated sensor entity rather than stuffing measurements into climate attributes.",
            "  - Inherit from `Entity` (or SensorEntity in newer versions), and implement `device_class` (e.g., `DEVICE_CLASS_BATTERY`), `unit_of_measurement` (e.g., `UNIT_PERCENTAGE`), `name`, and `state`.",
            "  - In `update`, call the same library method (`read_trv_status`) and extract the metric you care about (e.g., `battery`) and assign it to `_state`.",
            "Step 8: Clean up device attributes and unused code.",
            "  - Remove obsolete `device_state_attributes` if they are no longer needed or duplicate information provided by dedicated entities.",
            "  - Remove unused imports (e.g., `logging`) and unused member variables to satisfy linting and keep code lean.",
            "  - Use meaningful variable names (e.g., `batteries` instead of `batt`) and iterate with intent (e.g., `for device_config in discovery_info.values():`).",
            "Step 9: Fix any collateral issues caused by rebasing.",
            "  - If rebase or merge introduced regressions (such as lost imports), reintroduce necessary imports or constants (e.g., `CONF_OPTIMISTIC` for Somfy cover) and ensure functions are using them correctly.",
            "Step 10: Run tests, fix style, and respond to review feedback.",
            "  - Run `pytest` and homeassistant-specific test scripts, plus `pylint`/`flake8` and `black` formatting.",
            "  - Be prepared to adjust config schemas (e.g., using `discovery_info is None` checks), remove unnecessary state attributes, and refine edge-case logic (like differentiating `None` vs `0`).",
            "  - Once reviewers approve the architecture, style, and behavior, the feature can be merged as an extension to the existing integration."
        ]
    }
}
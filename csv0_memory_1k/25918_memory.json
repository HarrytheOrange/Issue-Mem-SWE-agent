{
    "search_index": {
        "description_for_embedding": "Home Assistant template sensors gained an `available_template` option and improved error handling so that when source entities are missing or templates fail, the sensor is marked unavailable (`available=False` / `STATE_UNAVAILABLE`) instead of falling back to misleading values like 0 or 'unknown'. This avoids downstream issues (e.g., incorrect utility meter calculations) and centralizes template-related constants in the template integration.",
        "keywords": [
            "home assistant",
            "template sensor",
            "available_template",
            "entity availability",
            "STATE_UNAVAILABLE",
            "TemplateError handling",
            "attribute_templates",
            "sensor platform schema",
            "template integration const",
            "utility meter incorrect values"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant users needed a way to express when a template sensor is logically unavailable. Previously, if a template sensor's source entity was temporarily unavailable or its template rendering failed, the sensor often produced misleading values (e.g., 0 or 'unknown') instead of being marked unavailable. This caused downstream components like the utility meter to do incorrect calculations, because they interpreted those transient values as real data.\n\nTo fix this, the patch introduced a new configuration option `available_template` for the template sensor platform. The sensor schema (`SENSOR_SCHEMA`) was extended with `vol.Optional(CONF_AVAILABLE_TEMPLATE): cv.template`. In `async_setup_platform`, the code now reads `available_template` from each sensor config, tracks any entities referenced by that template for updates, and passes it into the `TemplateSensor` constructor.\n\nWithin `TemplateSensor`, a new `_available` field and `_available_template` are maintained. The `available` property was implemented to return `_available`, integrating with Home Assistant's core availability mechanism. The `state` property was reverted to always return `_state`; availability is now communicated solely via the `available` property, letting the core set `STATE_UNAVAILABLE` automatically when `available` is False.\n\nIn `async_update`, after rendering the main `value_template`, the sensor sets `_state` and `_available = True` on success. If a `TemplateError` occurs, `_available` is set to False, and the previous error-handling logic for specific UndefinedErrors is retained, but the key behavioral change is that the entity is now considered unavailable whenever the value template fails. Additionally, the `available_template`, if configured, is evaluated in the generic property update loop (`(\"_available\", self._available_template)`) to override `_available` based on the user's template, allowing dynamic control of availability (e.g., only available when `switch.track_sun` is on).\n\nConstants were refactored so that `CONF_AVAILABLE_TEMPLATE` and `CONF_ATTRIBUTE_TEMPLATES` now live in `homeassistant/components/template/const.py` instead of the global `homeassistant/const.py`. Tests in `tests/components/template/test_sensor.py` were updated to cover the new `available_template` behavior and to reflect that sensors become `STATE_UNAVAILABLE` when their templates cannot be rendered (e.g., missing attributes). Some earlier expectations on explicit state values in the `available_template` test were relaxed, relying instead on the core availability handling. This change made template sensors safer as data sources for other integrations that depend on correct handling of unavailable data.",
        "semantic_memory": "This change illustrates several general principles for building robust, template-driven or computed entities in event-driven systems:\n\n1. **Explicit availability vs. sentinel values**: When a computed/templated entity cannot be reliably computed (due to missing inputs, errors, or intentional disabling), it's better to expose an explicit availability flag (`available`/`STATE_UNAVAILABLE`) than to emit placeholder values like 0 or 'unknown'. Placeholder values are easily misinterpreted by downstream consumers as real data, leading to subtle data corruption or incorrect calculations.\n\n2. **Configurable availability logic**: Exposing a dedicated 'availability template' or condition allows users to define when an entity is semantically valid, independent of its raw value. This pattern is broadly applicable: any system where derived metrics depend on multiple sources can benefit from a user-controlled 'only valid when these conditions are true' mechanism.\n\n3. **Treat template/rendering failures as unavailability**: Template render errors (e.g., missing attributes, None dereferences) should generally mark the entity as unavailable rather than silently defaulting to arbitrary values. This makes failures visible and prevents them from polluting downstream state.\n\n4. **Centralized constants and schema definitions**: Component-specific configuration keys (like `available_template` and `attribute_templates`) belong in the component's own `const.py` rather than in a global constants module. This improves modularity, avoids global namespace bloat, and makes it easier to evolve component-specific APIs.\n\n5. **Leverage framework-level availability semantics**: Instead of manually encoding unavailability into the entity's state, the entity should expose its boolean availability via the framework's standard interface (`Entity.available`). The framework can then standardize how this appears in the state machine (e.g., mapping to `STATE_UNAVAILABLE`) and in the UI.\n\n6. **Testing for behavioral semantics, not implementation details**: Tests were updated to assert on semantic outcomes (e.g., that availability toggles correctly and that missing attributes result in unavailable sensors) rather than on specific intermediate representations. This makes the tests more robust to internal refactors while still guarding the essential behavior.\n",
        "procedural_memory": [
            "When a templated or computed entity yields misleading values during source unavailability or template errors, modify the entity to expose explicit availability semantics instead of emitting placeholder states.",
            "Step 1: Identify the problem surface.\n- Observe where downstream components (e.g., aggregators, meters, dashboards) are misbehaving because they interpret temporary or erroneous values as real data.\n- Confirm that the root cause is the templated/computed entity outputting fallback values (e.g., 0, 'unknown', or stale data) when its inputs are missing or its template fails.\n\nStep 2: Introduce an explicit availability mechanism.\n- Add a boolean availability concept for the entity if the framework supports it (e.g., an `available` property in Home Assistant's `Entity` base class).\n- Design a configuration option (like `available_template`) that allows users to express when the entity should be considered available (e.g., `available_template: \"{{ is_state('switch.track_sun', 'on') }}\"`).\n\nStep 3: Extend the configuration schema.\n- Update the platform or component schema to accept the new configuration key:\n  - `vol.Optional(CONF_AVAILABLE_TEMPLATE): cv.template` (or equivalent in your validation library).\n- Ensure that any referenced entities in the availability template are tracked, so state changes trigger re-evaluation.\n\nStep 4: Wire the availability template into the entity.\n- Store the parsed `available_template` on the entity (e.g., `self._available_template`).\n- Add an internal `_available` attribute initialized to a safe default (typically `False`).\n- Implement the entity's `available` property to return `_available` so that the framework can automatically handle unavailable state representation.\n- In the entity update method (`async_update` or equivalent):\n  - After successfully rendering the main value template, set `_available = True`.\n  - On template render failure (`TemplateError` or similar), set `_available = False` and log appropriately.\n  - Evaluate `available_template` in the same update cycle (if configured) and assign its result to `_available`, allowing it to override the default availability based on custom logic.\n\nStep 5: Let the framework manage the unavailable state.\n- Avoid encoding availability by manually changing `state` to special strings or `None` solely to indicate errors.\n- Rely on the framework's standard behavior to represent unavailable entities (e.g., mapping `available == False` to `STATE_UNAVAILABLE`).\n- Keep `state` focused on the actual computed value when available, and let availability drive whether that value is considered valid.\n\nStep 6: Refactor constants and shared definitions.\n- Move any new component-specific configuration keys (e.g., `CONF_AVAILABLE_TEMPLATE`, `CONF_ATTRIBUTE_TEMPLATES`) into the component's `const.py` or equivalent.\n- Remove those keys from shared/global constants to reduce coupling and improve modularity.\n\nStep 7: Update and add tests.\n- Add tests that:\n  - Configure an entity with an `available_template` and verify that the entity's `available` attribute toggles as expected when the referenced source state changes.\n  - Simulate template render failures (e.g., missing attributes, None dereferences) and verify that the entity becomes unavailable (e.g., state becomes `STATE_UNAVAILABLE` as seen by consumers).\n  - Verify that prior edge cases (like missing attributes) now yield unavailability instead of ambiguous placeholder values.\n- Avoid over-specifying state contents when availability is False; assert the semantics (e.g., that the system marks the entity unavailable) rather than implementation-specific details.\n\nStep 8: Validate integration behavior.\n- Re-test downstream components (like utility meters or aggregators) that depend on the templated entity to confirm they now ignore unavailable periods instead of using incorrect intermediate values.\n- Monitor logs for TemplateError occurrences and ensure they correspond to expected `available=False` periods rather than silent data corruption.\n"
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Bugfix in Home Assistant entity registry where customized entity name and icon (including original_name/original_icon) were not persisted to storage and therefore were lost on restart. The fix ensures these fields are serialized in _data_to_save and restored in async_load, with regression tests verifying roundtrip persistence.",
        "keywords": [
            "Home Assistant",
            "entity registry",
            "name not saved",
            "icon not saved",
            "entity restoration",
            "persistence bug",
            "serialization",
            "async_load",
            "data_to_save",
            "original_name",
            "original_icon",
            "state restoration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, entities in Home Assistant lost their customized name and icon after a restart. The entity registry was responsible for persisting entity metadata, but only some fields were being serialized and restored. Specifically, while fields like unique_id, platform, disabled_by, capabilities, supported_features, device_class, and unit_of_measurement were saved and reloaded, the user-facing 'name' and 'icon' as well as 'original_name' and 'original_icon' were not included in the persistence logic.\n\nThe root cause was that the entity registry’s _data_to_save method did not include icon, original_name, or original_icon in the data written to storage, and async_load did not read these values back when recreating RegistryEntry objects. As a result, after restarting Home Assistant, entities would be restored without their customized or original name/icon information, breaking UI consistency and restoration behavior.\n\nThe fix updated homeassistant/helpers/entity_registry.py in two places:\n- In async_load, when rebuilding entries from the stored data, additional arguments are passed into the constructor: icon=entity.get(\"icon\"), original_name=entity.get(\"original_name\"), and original_icon=entity.get(\"original_icon\").\n- In _data_to_save, each entry’s serialized dict now includes: \"icon\": entry.icon, \"original_name\": entry.original_name, and \"original_icon\": entry.original_icon.\n\nA regression test was added/extended in tests/helpers/test_entity_registry.py (test_loading_saving_data). The test creates two registry entries, sets original_name and original_icon on one, then updates it to have a user-defined name and icon, triggers save/load, and asserts that name, icon, original_name, and original_icon survive the roundtrip. This confirms that custom and original metadata for entities are now persisted and correctly restored across restarts.",
        "semantic_memory": "When an application persists object metadata for later restoration, all relevant fields that influence behavior or UI must be included both in the serialization and deserialization paths. A common class of bugs occurs when new fields are added to a data model (e.g., name/icon, original_name/original_icon) but the persistence layer is not updated symmetrically. This results in state being visible and modifiable at runtime but silently lost across process restarts.\n\nKey general lessons:\n- Persistence symmetry: Whenever you add or change fields on a domain object (e.g., an entity registry entry), you must update both the 'to storage' path (serialization/_data_to_save) and the 'from storage' path (deserialization/async_load). Missing either direction causes subtle, restart-only bugs.\n- Backward-compatible deserialization: Use safe accessors (like dict.get) when reading newly added fields from persisted data to avoid breaking older stored formats and to handle partial data gracefully.\n- Roundtrip (save-load) tests: For components that persist internal state, unit tests should perform a full roundtrip: create objects with all relevant fields, persist to a simulated store, reload, and assert equality of all important attributes. This pattern guards against regressions where new attributes are forgotten in persistence code.\n- UI / user-facing fields matter: User-configurable attributes such as names and icons are easy to overlook compared to 'core' fields like IDs or supported_features, but they significantly affect the user experience and must be treated as first-class persistence properties.\n- Registry-style patterns: In systems with a registry (entity registry, device registry, etc.), the registry is the source of truth for metadata. Any new metadata fields must be wired into the registry’s schema and persistence paths, not only on runtime objects or entities.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar persistence issues involving missing fields in a registry or storage-backed component.",
            "Step 1: Reproduce the symptom across restarts.\n- Configure or modify the runtime object (e.g., set a custom name/icon on an entity).\n- Trigger a full persistence cycle if necessary (e.g., wait for or force registry save).\n- Restart the application/service.\n- Verify whether the changed attributes are preserved or lost after restart.",
            "Step 2: Locate the persistence layer for the affected object.\n- Identify where the object's metadata is stored (e.g., entity_registry.py, a registry class, or a storage manager).\n- Typically there will be two key methods: one that serializes the objects to a dict or JSON structure (save), and one that deserializes them back into in-memory objects (load).",
            "Step 3: Compare the object model with the serialized schema.\n- Inspect the in-memory object or dataclass (e.g., RegistryEntry) and list all fields that should be persisted, including new fields such as user-customizable name/icon.\n- Inspect the save method (e.g., _data_to_save) and ensure each required field is present in the output dict.\n- Inspect the load method (e.g., async_load) and ensure each required field is read from the stored data and passed into the object constructor or set on the instance.",
            "Step 4: Identify missing or mismatched fields.\n- Look for fields available on the runtime object but missing from the saved data.\n- Look for fields present in saved data but not used during reconstruction.\n- Check for subtle naming mismatches (e.g., original_name vs name, icon vs entity_icon).",
            "Step 5: Implement a symmetric serialization/deserialization fix.\n- In the save path, include the missing attributes in the serialized representation (e.g., add \"icon\": entry.icon and \"original_name\": entry.original_name to the dict).\n- In the load path, read those attributes using safe access (e.g., entity.get(\"icon\")) and pass them into the object constructor or assign them after construction.\n- Ensure default behavior preserves backward compatibility for older stored data (use get with default None or sensible values).",
            "Step 6: Add or update roundtrip tests.\n- Create a unit test that:\n  - Constructs an object with all relevant fields set, including the newly problematic ones.\n  - Persists the object using the same code path as production (e.g., registry save).\n  - Reloads the registry or storage and retrieves the object.\n  - Asserts that all key fields, including new ones, match the original values.\n- Specifically test user-facing fields (name, icon) and any 'original_*' fields used for differentiating system vs user changes.",
            "Step 7: Run the full test suite and validate behavior manually if appropriate.\n- Run unit tests to ensure no regressions and that the new test passes.\n- Optionally perform a manual end-to-end test in a development environment: set the property, restart the service, and confirm persistence.\n- Monitor code coverage: persistence-related lines should be exercised by tests.",
            "Step 8: Document and communicate the behavior.\n- Briefly document that the registry now persists the relevant fields and that they are used for restoration.\n- If applicable, mention that previously configured values may need a one-time update or may be correctly recognized only after this fix.",
            "Step 9: For future changes, enforce a pattern.\n- When adding new fields to registry entries or similar core objects, always:\n  - Update the serialization and deserialization methods in the same commit.\n  - Extend the roundtrip tests to cover the new fields.\n  - Consider backward compatibility of stored data and use dict.get or versioned schemas as needed."
        ]
    }
}
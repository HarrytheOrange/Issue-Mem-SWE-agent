{
    "search_index": {
        "description_for_embedding": "Home Assistant shell_command component was converted from synchronous subprocess.call to asynchronous asyncio.subprocess to avoid blocking the event loop. The service setup was updated to async_setup/async_register, templates now use async_render, subprocess output is captured via process.communicate, and non‑zero exit codes are logged as errors. Tests were updated to mock async subprocess creation and to attach an asyncio child watcher to the test loop, and pylint issues with asyncio.subprocess on Python 3.4 were worked around.",
        "keywords": [
            "home_assistant",
            "shell_command",
            "asyncio.subprocess",
            "subprocess.call",
            "async_setup",
            "async_register",
            "async_render",
            "TemplateError",
            "non-zero return code",
            "child watcher",
            "pytest",
            "pylint no-member",
            "Python 3.4",
            "event loop blocking"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant `shell_command` component was originally implemented using the synchronous `subprocess.call`, which blocks the event loop when running commands. To modernize it and better fit Home Assistant's async architecture, the component was refactored to use `asyncio.subprocess` and to be fully asynchronous.\n\nThe `setup` function was replaced with `async_setup(hass, config)` (decorated with `@asyncio.coroutine`) and services are now registered via `hass.services.async_register`. The service handler became `async_service_handler(service: ServiceCall)`, also a coroutine. Command templates are still supported, but instead of `template.render`, the code now uses `template.Template.async_render(service.data)` to match the async model.\n\nFor commands without templates, the code now uses `asyncio.subprocess.create_subprocess_shell(cmd, loop=hass.loop, stdin=None, stdout=DEVNULL, stderr=DEVNULL)`. For templated commands, it splits the rendered arguments with `shlex.split` and uses `asyncio.subprocess.create_subprocess_exec(*shlexed_cmd, loop=hass.loop, stdin=None, stdout=DEVNULL, stderr=DEVNULL)` to avoid `shell=True` and reduce injection risk. The created process is awaited via `process = yield from create_process` followed by `yield from process.communicate()`. If `process.returncode != 0`, the code logs an exception with the command and return code instead of catching a `SubprocessError`.\n\nTests were updated accordingly. Instead of patching `subprocess.call`, they now patch `asyncio.subprocess.create_subprocess_shell` and `create_subprocess_exec`. A helper coroutine `mock_process_creator(error: bool)` returns a mock process object with an async `communicate` method and a configurable `returncode`. The tests call services with `blocking=True` and then `self.hass.block_till_done()` to ensure the async tasks complete before assertions.\n\nAn additional issue arose in the test environment: when using `asyncio` subprocesses under pytest, a child watcher is required. The test `setUp` attaches one via `asyncio.get_child_watcher().attach_loop(self.hass.loop)`. Linting under Python 3.4 complained about `asyncio.subprocess` attributes (`no-member`), which was worked around by disabling pylint's `no-member` for the specific lines creating subprocesses. Trailing commas and string formatting were also adjusted to satisfy older Python and pylint. After these changes, the shell_command component behaves asynchronously, remains config‑compatible, and passes tests and lint checks.",
        "semantic_memory": "This fix illustrates several generalizable patterns for migrating synchronous, subprocess-based code to an asynchronous architecture:\n\n1. **Convert integration entry points and handlers to async**: When an application core (like Home Assistant) is event-loop driven, integration setup functions and service handlers should be converted from sync to async (`setup` -> `async_setup`, `services.register` -> `services.async_register`). This avoids blocking the main loop and enables better concurrency.\n\n2. **Use `asyncio.subprocess` instead of `subprocess` in async code**: For IO-bound or process-spawning tasks, `asyncio.subprocess.create_subprocess_shell` or `create_subprocess_exec` should replace `subprocess.call`/`Popen` so that the event loop can run other tasks while waiting on child processes. `process.communicate()` should be awaited to allow cooperative multitasking and to capture output if needed.\n\n3. **Security-conscious handling of templated commands**: When constructing shell commands from templates or user input, it's safer to avoid `shell=True`. Split arguments with `shlex.split` and use `create_subprocess_exec` (or `subprocess` equivalents with `shell=False`) to reduce command injection surface. Non-templated or fixed commands may use the shell more safely if strictly controlled.\n\n4. **From exceptions to explicit exit-code handling**: Instead of relying on high-level exceptions like `SubprocessError`, inspecting `process.returncode` gives precise control over success/failure semantics. Non-zero exit codes can be logged or handled explicitly, and stderr or stdout can be captured for diagnostics or future features.\n\n5. **Async template rendering and data flow**: In async architectures that use templating (e.g., Jinja2 integrated into an event loop), rendering helpers often have async variants. Using `async_render` (instead of `render`) ensures consistency with async lock management, IO, and internal state.\n\n6. **Testing async subprocess logic**: Async subprocess code should be tested by mocking the subprocess creation functions to return a coroutine that yields a fake process object with async methods. Tests must drive the event loop to completion (`block_till_done`, `await` tasks) before asserting behavior. This ensures deterministic tests without actually spawning processes.\n\n7. **Child watchers are required when forking subprocesses with asyncio**: On platforms and Python versions that use subprocess watchers (e.g., UNIX with asyncio), the event loop may require an `asyncio.get_child_watcher()` attached to the loop when spawning child processes, especially in custom or test loops. Forgetting this can produce runtime errors under test while working in default loops.\n\n8. **Linting and compatibility across Python versions**: Asynchronous features and modules may not be fully recognized by static analyzers on older Python versions. Pylint can report false `no-member` errors for `asyncio.subprocess`. Targeted disabling of these warnings around known-good APIs, combined with avoiding syntax that only newer versions accept (e.g., trailing commas in function calls if not supported), is sometimes necessary to maintain CI compatibility.\n\nOverall, the change demonstrates a pattern: when migrating a component to async, convert all call paths to coroutine-based APIs, use the event loop's non-blocking primitives (`asyncio.subprocess`, async template rendering, async service registration), adapt tests to drive the loop and mock async APIs, and handle multi-version tooling constraints explicitly.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify blocking subprocess usage in async context.\nSearch for uses of `subprocess.call`, `Popen`, or other blocking calls inside code that runs on an event loop or in service handlers that should be async. In Home Assistant-like systems, look at component setup functions and service handlers.",
            "Step 2: Convert setup and handlers to async APIs.\nIf the integration uses a synchronous `setup` and `hass.services.register`, convert them to `async_setup` (a coroutine) and `hass.services.async_register`. Likewise, convert the service or request handler functions into coroutines (`async def` or `@asyncio.coroutine`). Update any call sites or framework hooks to use the async variants.",
            "Step 3: Replace `subprocess` with `asyncio.subprocess`.\nIn the async handler, replace `subprocess.call`/`Popen` with either `asyncio.subprocess.create_subprocess_shell` (for fixed shell commands) or `create_subprocess_exec` (for argument lists). Pass the running loop (`loop=hass.loop` or current event loop), and set `stdin`, `stdout`, and `stderr` appropriately (e.g., `DEVNULL` if you don't yet need output). After creation, await the process with `process = await create_process` and `await process.communicate()`.",
            "Step 4: Secure templated commands.\nIf command strings are templated or contain user-derived data, render the template first. For non-templated commands, you can pass the entire command string to `create_subprocess_shell`. For templated commands, use `shlex.split(rendered_args)` and `create_subprocess_exec(*args)` to avoid `shell=True`. Keep the original behavior where safe but improve security where arguments are dynamic.",
            "Step 5: Use async template helpers.\nIf the code previously used `template.render()` in a synchronous context, switch to `template.async_render()` (or the framework-specific async template API) inside coroutine handlers. Make sure to pass the correct data (e.g., `service.data`) and handle `TemplateError` exceptions by logging and returning early.",
            "Step 6: Handle subprocess errors via return codes.\nInstead of catching broad `SubprocessError`, inspect `process.returncode` after `communicate()`. If non-zero, log an error or exception with the command and exit code. Optionally, capture stdout/stderr for debugging and include snippets in logs or future features.",
            "Step 7: Update and adapt tests for async behavior.\nIn tests, patch `asyncio.subprocess.create_subprocess_shell`/`create_subprocess_exec` instead of `subprocess.call`. Provide a helper that returns a coroutine yielding a mock process object with an async `communicate` method and configurable `returncode`. Ensure test code drives the async loop to completion (`hass.block_till_done()`, awaiting tasks) after calling services or handlers before asserting effects or verifying mocks.",
            "Step 8: Configure a child watcher in tests if needed.\nIf tests spawn or mock subprocesses using asyncio on platforms that require a child watcher (UNIX), attach it to the custom loop used in tests: `asyncio.get_child_watcher().attach_loop(loop)`. This prevents runtime errors when creating subprocesses under pytest or custom event loop environments.",
            "Step 9: Fix linter and compatibility issues.\nRun linting and pay attention to errors related to async code. For spurious `no-member` errors on `asyncio.subprocess`, disable the specific pylint rule around the known-good calls. Also ensure syntax is compatible with all supported Python versions (e.g., avoid trailing commas or modern syntax not supported in older versions used in CI). Use `%` or logger's built-in formatting rather than `.format` when aligning with project style.",
            "Step 10: Verify behavior and backward compatibility.\nConfirm that configuration format for users has not changed (unless intended), and that services still work as expected end-to-end. Run both unit tests and integration tests, and verify that shell commands execute without blocking the event loop. Ensure error conditions (non-zero exit codes, template errors) are logged and handled gracefully."
        ]
    }
}
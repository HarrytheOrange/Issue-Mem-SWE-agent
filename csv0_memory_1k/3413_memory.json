{
    "search_index": {
        "description_for_embedding": "Implements per-point visibility control in napari's Points layer by adding a boolean `hidden` array property, plumbing it through the vispy rendering stack, and vendoring a custom MarkersVisual with a `hidden` vertex attribute that discards hidden points in the fragment shader. Also restructures the napari._vispy package (layers/visuals/utils/overlays) and introduces a clipping planes mixin and spherical marker lighting.",
        "keywords": [
            "napari",
            "Points layer",
            "per-point visibility",
            "hidden flag",
            "boolean visual channel",
            "MarkersVisual",
            "vispy",
            "shader discard",
            "vendored markers",
            "clipping planes",
            "spherical markers",
            "module refactor",
            "GPU rendering",
            "view slicing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the napari team experimented with adding per-point visibility control to the Points layer. The goal was to let users hide or show individual points based on arbitrary logic, e.g. thresholding a property column.\n\nOn the model side (Python), the Points layer in `napari/layers/points/points.py` gained three new attributes: `antialias`, `spherical`, and, most importantly, `hidden`. The `hidden` attribute is a boolean array specifying which points should *not* be rendered. The setter broadcasts any input (scalar, list, array) to the number of points, stores it as `self._hidden`, and emits a `hidden` event followed by `refresh()`:\n\n- `hidden` property getter returns `self._hidden`.\n- `hidden` setter does `self._hidden = np.broadcast_to(hidden, self.data.shape[0]).copy()` and fires `self.events.hidden()`.\n\nEvents were extended accordingly: the Points layer's event emitter dict now includes `antialias`, `spherical`, and `hidden` events.\n\nTo integrate this with the view, a helper `_view_hidden` property was added to Points:\n- `_view_hidden` returns `self.hidden[self._indices_view]`, i.e., the hidden flags restricted to currently visible points.\n\nOn the rendering side, the vispy bridge for points (`napari/_vispy/layers/points.py`) was updated:\n\n- It now listens to `self.layer.events.hidden` and calls `_on_data_change` when the hidden flags change.\n- `_on_data_change` constructs the data passed to the GPU. For the main markers visual, it uses:\n  - `data = self.layer._view_data` (or a dummy point if empty)\n  - `size = self.layer._view_size` (or `[0]` if empty)\n  - `hidden = self.layer._view_hidden` (or `[False]` if empty)\n- When setting data on the visual subvisuals, it passes `hidden=hidden` to the `MarkersVisual.set_data` call.\n\nThe highlight subvisual (used for selection boxes / highlighted points) also honors hidden flags:\n- If there is a highlighted index, it uses `hidden = self.layer._view_hidden[self.layer._highlight_index]`, otherwise `hidden = False`.\n- The highlight markers are created with `hidden=hidden` so that invisible points do not incorrectly appear in highlight visuals.\n\nTo support the new `hidden` attribute at the GPU level, the project vendored vispy's MarkersVisual, creating `napari/_vispy/vendored/markers.py` and exposing `MarkersVisual` via `napari/_vispy/vendored/__init__.py`.\n\nKey changes in the vendored `MarkersVisual`:\n- The vertex shader (`vert`) now declares:\n  - `attribute float a_hidden;`\n  - `varying float v_hidden;`\n- The fragment shader (`frag`) now discards fragments for hidden points:\n  - `if (v_hidden > 0) discard;`\n- The data dtype includes the new field:\n  - `('a_hidden', np.float32)`.\n- `MarkersVisual.set_data` accepts a `hidden` argument and fills `data['a_hidden']` from it.\n\nAdditionally, the vendored MarkersVisual implements:\n- `u_spherical`, `u_light_position`, `u_light_color`, `u_light_ambient`, and `u_alpha` uniforms.\n- Lighting math in the fragment shader to render markers as lit spheres when `u_spherical` is true.\n\nTo integrate the vendored visual with vispy's scenegraph, `napari/_vispy/visuals/markers.py` was changed to:\n- `from vispy.scene.visuals import create_visual_node`\n- `from ..vendored import MarkersVisual`\n- `BaseMarkers = create_visual_node(MarkersVisual)` and `class Markers(BaseMarkers): ...`, preserving napari-specific `_compute_bounds` behavior.\n\nBeyond the points feature, the PR also performed a substantial refactor of the `napari/_vispy` package:\n- Split into subpackages: `layers`, `visuals`, `overlays`, `filters`, and `utils`.\n- Renamed vispy bridge modules (`vispy_points_layer.py` -> `layers/points.py`, etc.).\n- Added `overlays` for non-layer visuals (axes, scale bar, text) and renamed classes to `VispyAxesOverlay`, `VispyScaleBarOverlay`, `VispyTextOverlay` and updated Qt viewer imports.\n- Introduced `ClippingPlanesMixin` (`visuals/clipping_planes_mixin.py`) to attach a `PlanesClipper` filter to visuals (including compound visuals) for experimental clipping planes. This mixin is used for `PointsVisual`, `ShapesVisual`, `SurfaceVisual`, `VectorsVisual`, and `TracksVisual`.\n- Refactored tracks visuals and filters: created `filters/tracks.py` with `TracksFilter`, and `visuals/tracks.py` attaches a single `TracksFilter` to a compound visual, instead of two separate shaders for tracks and graph.\n- Added a dedicated `VectorsVisual` (a `ClippingPlanesMixin, Mesh` combination) and updated the vectors layer to use it.\n\nThis PR was acknowledged as a proposal and later superseded by another one (#3625). Review discussion noted that a `shown` flag might be a more semantically consistent API than `hidden`, and that doing per-point visibility by slicing on the CPU (and sending fewer points to the GPU) could be cleaner and more performant than masking/branching in the fragment shader. Nonetheless, this PR captures a complete approach to per-element visibility, vendored shader customization, and vispy module structuring.",
        "semantic_memory": "This work illustrates several general patterns for adding per-element visual control in a GPU-based rendering pipeline and managing complex visualization glue code:\n\n1. **Model-layer boolean visual channels (per-element visibility)**\n   - Per-element visibility can be represented as a boolean or 1-bit visual channel, separate from the core numeric data and color/size encodings.\n   - In a layered visualization library, you often want both:\n     - A user-facing property (`layer.hidden` / `layer.shown`) that supports broadcasting and property-based manipulation.\n     - A view-specific projection (`_view_hidden`) aligned with the currently visible indices.\n   - The model property should fire events when changed, allowing the rendering layer to update efficiently.\n\n2. **Plumbing new attributes through the rendering stack**\n   - When introducing a new per-element visual attribute, you must propagate it consistently:\n     - Data model: define the property, ensure consistent shape via broadcasting.\n     - View indexing: compute a view subset (e.g., `hidden[self._indices_view]`).\n     - Bridging layer: include the attribute when building the per-draw call data structure, handle empty views explicitly.\n     - GPU side: add it as a vertex attribute, pass via varyings to the fragment shader, and incorporate it into the rendering logic (e.g., discard, alpha modulation, depth changes).\n   - Inconsistent or partial propagation (e.g., not updating highlights, or not handling empty views) is a common source of subtle rendering bugs.\n\n3. **Vendoring upstream visuals to add features not yet supported**\n   - Upstream libraries (like vispy) may not expose all hooks needed (e.g., additional attributes or uniforms like `hidden`, `spherical`, custom lighting). Vendoring the visual class:\n     - Allows you to add attributes, change shaders, and adjust internal data layout without waiting on upstream.\n     - Requires careful maintenance: keep track of divergences from upstream for future merges.\n   - A thin adapter (`create_visual_node` wrapper) lets you integrate the vendored visual into the existing scenegraph API while preserving local overrides (e.g., custom `_compute_bounds`).\n\n4. **CPU slicing vs. GPU masking for conditional visibility**\n   - There are two canonical choices for per-element visibility:\n     - **GPU masking**: Keep all elements on the GPU and use a boolean attribute in the shader to discard or fade them.\n     - **CPU slicing**: Filter the data on the CPU and send only the visible elements to the GPU.\n   - Trade-offs:\n     - GPU masking avoids reallocating / reuploading large buffers for minor changes in visibility but creates extra branching and unused data transfers.\n     - CPU slicing reduces memory bandwidth and simplifies shader logic but can be more expensive when visibility changes frequently or when the total dataset is huge.\n   - The right approach is context-dependent; this PR opted for GPU masking but explicitly considered slicing as a cleaner/perhaps more performant alternative.\n\n5. **Use of mixins for cross-cutting visual features (clipping planes)**\n   - Cross-cutting behaviors (e.g., clipping planes filters) can be attached via mixins that:\n     - Instantiate and attach a filter (like `PlanesClipper`) to all subvisuals of a compound visual.\n     - Expose a simple property (`clipping_planes`) that proxies to the filter.\n   - This reduces duplication across multiple visuals that need the same behavior (points, shapes, surfaces, tracks, vectors) and centralizes the transform/filter configuration logic.\n\n6. **Module/package restructuring for clarity and maintainability**\n   - Complex glue code (like napari's vispy integration) benefits from clear, role-based subpackages:\n     - `layers` for vispy wrappers around napari layers.\n     - `visuals` for scenegraph primitives.\n     - `overlays` for viewer-level UI visuals (axes, scale bar, text, etc.).\n     - `filters` for shader filters.\n     - `utils` for low-level GL and visual helpers.\n   - Renaming modules and adjusting import paths can dramatically clarify architecture but must be done carefully to avoid breaking references and tests.\n\n7. **Highlight visuals must follow core visibility logic**\n   - Any secondary visuals (highlights, selection boxes, labels) that represent a subset of core elements must respect the same visibility rules.\n   - Failing to pass the `hidden` flag (or equivalent) to highlight visuals can cause confusing UI where hidden items still appear highlighted.\n\n8. **Shader design for enhanced marker appearance**\n   - Spherical markers are implemented by computing a normal from fragment coordinates inside a point sprite, then applying standard Lambertian + specular lighting.\n   - Antialiasing and proper depth adjustment (e.g., adjusting `gl_FragDepth` based on the sphere surface) are important for visually correct and smooth results.\n   - Such features are easiest to implement when you control the full shader source and can add custom uniforms and varyings.\n\nThese patterns generalize to any application that needs fine-grained, dynamic control over individual items in a GPU-rendered visualization, particularly when working with a scenegraph abstraction and bridging from a high-level data model.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Clarify the desired per-element visual behavior\n- Determine what you need to control per element (e.g., visibility, opacity, size, shape, lighting).\n- Decide if the control should be data-driven (e.g., based on properties/attributes) and whether you expect frequent updates.\n- Choose an API name that reflects semantics; prefer positive logic where possible (e.g., `shown` instead of `hidden`).",
            "Step 2: Extend the data model with a dedicated property\n- In your layer/model class, add a new attribute to store the per-element flag or value (e.g., `self._hidden` as a NumPy array of booleans).\n- Implement a property with getter and setter:\n  - Getter returns the array.\n  - Setter:\n    - Broadcasts scalar or shorter arrays to the full length of the data (`np.broadcast_to(value, n_elements).copy()`).\n    - Validates shape/dtype if necessary.\n    - Emits an appropriate event (e.g., `self.events.hidden()`) and triggers a refresh.\n- Add any needed view helpers (e.g., `_view_hidden = self.hidden[self._indices_view]`) to align the property with the subset of data currently rendered.",
            "Step 3: Wire up events and view-level behavior\n- Ensure the layer's event emitter dictionary includes an event for the new property (e.g., `hidden=Event`).\n- In the vispy bridge / rendering controller for the layer, subscribe to that event:\n  - `self.layer.events.hidden.connect(self._on_data_change)` or a more specific handler.\n- Decide how the visibility affects derived visuals, such as labels or highlights, and ensure those code paths also consider the new property.",
            "Step 4: Propagate the attribute into the rendering data\n- In the layer's vispy adapter, update the method that builds per-draw-call data (e.g., `_on_data_change`):\n  - Compute the per-view attribute (`hidden = self.layer._view_hidden`) along with `data`, `size`, `colors`, etc.\n  - Handle empty views explicitly by supplying a dummy element with reasonable defaults (e.g., data `(0,0)`, size `0`, hidden `False`) to avoid crashes.\n- Pass the new attribute down to the visual's `set_data` method:\n  - For example: `subvisual.set_data(..., hidden=hidden)`.",
            "Step 5: Extend or customize the GPU visual\n- If the upstream visual does not support the needed attribute or shader logic, vendor it:\n  - Copy the class (e.g., MarkersVisual) into a local module (e.g., `vendored/markers.py`).\n  - Add a new vertex attribute to the dtype (e.g., `('a_hidden', np.float32)`).\n  - Update `set_data` to accept the new keyword (e.g., `hidden`) and fill the attribute field.\n- Modify shaders:\n  - In the vertex shader, declare the attribute (`attribute float a_hidden;`), pass it to a varying (`v_hidden = a_hidden;`).\n  - In the fragment shader, incorporate it into the logic (e.g., `if (v_hidden > 0) discard;`).\n- Create a scenegraph node from the vendored visual using `create_visual_node` and adjust any napari-specific overrides (e.g., `_compute_bounds`).",
            "Step 6: Ensure secondary visuals obey the same rules\n- Identify all subvisuals/compound visuals that represent subsets of your data (e.g., highlights, selection boxes, text labels).\n- When constructing their data, pass the same visibility flags (or derived logic) so that hidden elements do not appear in those visuals.\n- Example: for a highlighted point, use `hidden = self.layer._view_hidden[self.layer._highlight_index]` and pass `hidden=hidden` to the highlight markers.",
            "Step 7: Consider alternatives and performance implications\n- Evaluate whether GPU masking (boolean flag in shader) or CPU slicing (filtering visible elements before sending to GPU) is more appropriate:\n  - Use GPU masking if you want to avoid frequent reallocation/re-upload and visibility toggles are often.\n  - Use CPU slicing if overall dataset is large and visible subset is small or changes infrequently.\n- If you choose GPU masking, be aware of potential overhead from branching and sending data for hidden elements; mitigate by keeping attribute arrays compact and avoiding unnecessary work in the shader.",
            "Step 8: Introduce cross-cutting visual behaviors via mixins (optional)\n- For features like clipping planes that apply to many visuals, create a mixin that:\n  - Instantiates the filter (e.g., `PlanesClipper`).\n  - Calls `self.attach(self._clip_filter)` in its `__init__` after `super().__init__`.\n  - Exposes a simple property (`clipping_planes`) that delegates to the filter.\n- Apply this mixin to all relevant visuals (`PointsVisual`, `ShapesVisual`, `SurfaceVisual`, `VectorsVisual`, `TracksVisual`) without duplicating code.",
            "Step 9: Restructure modules carefully when refactoring\n- If you reorganize your visualization integration layer:\n  - Group related components into subpackages (`layers`, `visuals`, `overlays`, `filters`, `utils`).\n  - Update all import paths consistently across the codebase and tests.\n  - Provide a stable import surface (`__init__.py` re-exports) for external consumers to minimize breakage.",
            "Step 10: Test and validate behavior\n- Add or update tests to cover:\n  - Setting `hidden` as scalar, 1D array, and property-based boolean mask.\n  - Ensuring hidden points are not rendered and are not highlighted.\n  - Behavior in empty views (no crashes, no NaNs/invalid gl_PointSize).\n  - Interactions with other visual settings (antialiasing, spherical markers, clipping planes).\n- Use small interactive examples (sliders, property-based thresholding) to visually confirm the feature works and performance is acceptable."
        ]
    }
}
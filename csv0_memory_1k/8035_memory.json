{
    "search_index": {
        "description_for_embedding": "Discussion and proposed change in Home Assistant's MQTT light component to support inverted brightness scales via a dedicated config flag (brightness_scale_inverted). The maintainers rejected the change as redundant because the existing brightness_value_template can perform the same inversion, and adding another option would complicate configuration permutations and processing order.",
        "keywords": [
            "Home Assistant",
            "MQTT light",
            "brightness inversion",
            "brightness_scale",
            "brightness_scale_inverted",
            "brightness_value_template",
            "configuration complexity",
            "feature redundancy"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a contributor attempted to add explicit support for inverted brightness scales in Home Assistant's MQTT light platform. Some hardware reports or expects brightness such that lower numeric values mean higher brightness (or vice versa) relative to the configured brightness scale. To address this, the pull request introduced a new boolean configuration option, `brightness_scale_inverted`, alongside the existing `brightness_scale`.\n\nCode-wise, the patch:\n- Added `CONF_BRIGHTNESS_SCALE_INVERTED` and `DEFAULT_BRIGHTNESS_SCALE_INVERTED = False`.\n- Extended the MQTT light config schema to accept `brightness_scale_inverted` as a boolean.\n- Updated `async_setup_platform` and the `MqttLight` constructor to pass and store this new flag.\n- Modified the brightness state handler (`brightness_received`) to compute the internal 0–255 brightness based on whether the scale is inverted:\n  - Previously: `percent_bright = device_value / self._brightness_scale`\n  - Proposed: `percent_bright = (self._brightness_scale_inverted and self._brightness_scale - device_value or device_value) / self._brightness_scale`\n- Modified `async_turn_on` to invert when publishing brightness commands if configured:\n  - Previously: `device_brightness = int(percent_bright * self._brightness_scale)`\n  - Proposed: `device_brightness = int((self._brightness_scale_inverted and 1.0 - percent_bright or percent_bright) * self._brightness_scale)`.\n\nHowever, during review, maintainers pointed out that the same behavior could be achieved using the existing `brightness_value_template` (and corresponding command template mechanisms) without adding a new configuration option. They also raised a design concern: every new option increases the number of configuration permutations the code must handle and raises questions like \"does inversion run before or after the value template?\". Because this use case was considered uncommon and already supported via templates, the maintainers decided that adding `brightness_scale_inverted` was unnecessary and potentially confusing. The PR was not accepted, and the recommended approach is to use value templates to handle inverted brightness scales.",
        "semantic_memory": "This case highlights several generalizable lessons about API and configuration design in software systems, especially in integration-heavy platforms like Home Assistant:\n\n1. **Prefer general transformation mechanisms over specialized flags**: When a system already has a flexible transformation layer (e.g., value templates or mapping functions), it is often better to use that layer to handle edge cases (like inverted brightness) than to add a new dedicated configuration parameter. Templates can invert values, rescale ranges, clamp, and perform arbitrary logic without expanding the core configuration surface.\n\n2. **Beware configuration permutation explosion**: Every new boolean or mode option multiplies the number of behavior combinations the code needs to handle. This increases complexity in understanding, testing, and maintaining the system. It also creates ambiguity about the order of operations (e.g., \"Does inversion happen before or after the value template?\"). Minimizing the number of overlapping or redundant options helps keep behavior predictable and easier to reason about.\n\n3. **Avoid overlapping concerns in configuration**: `brightness_scale` and `brightness_value_template` already define how device brightness values map to Home Assistant's internal model. Adding `brightness_scale_inverted` partially duplicates the responsibilities of templates and blurs the division of concerns: should scaling be done via the scale option or via the template? Clear responsibility boundaries reduce confusion.\n\n4. **Use templates to encode device-specific quirks**: Devices often have non-standard protocols (e.g., inverted scales, custom encodings). Rather than changing core logic for each quirk, a well-designed templating or transformation mechanism lets users adapt to their hardware without expanding the core API.\n\n5. **Design with composition and ordering in mind**: When multiple transformation mechanisms exist (scaling, inversion, templating, offsets, etc.), the order in which they are applied matters. Introducing new mechanisms that interact with existing ones must come with clear semantics about ordering; otherwise, users and maintainers will face ambiguity and subtle bugs.\n\nOverall, this incident reinforces a design best practice: rely on flexible, composable mapping mechanisms (like templates) to handle edge cases instead of adding many specialized configuration flags that increase complexity and ambiguity.",
        "procedural_memory": [
            "When encountering a device with an inverted or unusual value scale (e.g., brightness, temperature, or other numeric attributes), first check whether existing template or transformation mechanisms can handle the mapping before proposing new configuration flags.",
            "Step 1: Identify the device’s native scale and direction.\n- Determine the range of values the device uses (e.g., 0–100, 0–255).\n- Determine whether the scale is inverted (e.g., 0 means full brightness, max means off, or 0 means off and max means full brightness).\n- Verify if there are any additional quirks, like offsets or non-linear mappings.",
            "Step 2: Map device scale to the platform’s internal scale using templates.\n- For Home Assistant MQTT lights, use `brightness_value_template` for incoming messages and the corresponding command template (if available) for outgoing commands.\n- Example for an inverted 0–100 scale where 0 = full brightness, 100 = off:\n  - Incoming (state) template: `{{ (100 - value | float) | round(0) }}` or further scaled to 0–255 if needed.\n  - Outgoing (command) template: `{{ 100 - (value | float) }}`.\n- Ensure the template returns values in the format and range the device expects.",
            "Step 3: Avoid adding redundant configuration options.\n- Before adding a new config flag (e.g., `*_inverted`), check whether the behavior can be achieved via:\n  - Existing templates (value_template, command_template).\n  - Existing scaling or transformation options.\n- If so, prefer documenting how to use templates rather than extending the configuration surface.",
            "Step 4: If a new option is truly necessary, analyze interactions and ordering.\n- List all related options (e.g., `brightness_scale`, `brightness_value_template`, `offset`, `gamma` correction, etc.).\n- Define and document a clear order of operations (e.g., \"Apply value template first, then scale; inversion is part of the template\").\n- Ensure tests cover each combination that users are likely to configure.",
            "Step 5: Implement transformations in a single responsibility layer.\n- Centralize all numeric transformations (scale/inversion/mapping) either in the template layer or in a well-defined conversion function.\n- Avoid scattering transformations across multiple flags and places in the code, which can lead to inconsistent behavior between input (state) and output (commands).",
            "Step 6: Write tests or examples for non-standard device mappings.\n- For inverted scales, create tests that:\n  - Feed an incoming device value and assert the internal brightness matches expectation.\n  - Take an internal brightness and assert the outgoing device value is correctly inverted.\n- Provide configuration examples in documentation to show users how to handle inverted or custom scales using templates.",
            "Step 7: Communicate design rationale in code review.\n- When reviewing or proposing features like `brightness_scale_inverted`, explicitly discuss:\n  - Whether the feature is a common enough use case.\n  - Whether existing mechanisms already cover the need.\n  - The complexity cost of additional options and permutations.\n- Prefer decisions that keep the public API smaller and delegate special cases to flexible components like templates."
        ]
    }
}
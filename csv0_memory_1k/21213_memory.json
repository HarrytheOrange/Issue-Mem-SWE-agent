{
    "search_index": {
        "description_for_embedding": "Home Assistant Harmony integration stopped working with Logitech Harmony Hub firmware 4.15.250 due to incompatibilities in the aioharmony library. The fix is to bump the Harmony integration dependency from aioharmony==0.1.5 to aioharmony==0.1.8, restoring functionality for hubs on the latest firmware but dropping support for older firmware versions.",
        "keywords": [
            "homeassistant.components.harmony.remote",
            "Harmony Hub",
            "aioharmony",
            "firmware 4.15.250",
            "dependency upgrade",
            "breaking change",
            "device firmware compatibility",
            "remote unavailable",
            "XMPP vs websocket",
            "requirements_all.txt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's Harmony integration stopped functioning for users whose Logitech Harmony Hubs auto-updated to firmware version 4.15.250. The integration depended on the Python library `aioharmony==0.1.5`, which was not compatible with the new firmware changes in the hub's API/protocol. Users reported hubs becoming unavailable, and the integration could not control devices.\n\nAn updated `aioharmony` release (0.1.8) added support for the latest Hub firmware (4.15.250). However, this new library version dropped support for older firmware versions, turning the change into a breaking one: older Harmony Hub firmware would no longer work with the updated integration.\n\nThe PR implemented a minimal fix: it changed the Harmony component's requirement from `aioharmony==0.1.5` to `aioharmony==0.1.8` in two places: the component-level `REQUIREMENTS` list in `homeassistant/components/harmony/remote.py` and the global `requirements_all.txt`. This ensures that, when Home Assistant installs or updates, it pulls in the new aioharmony version that speaks the updated hub protocol.\n\nThere was considerable discussion about possibly reverting to the older `pyharmony` (non-async, XMPP-based) library, which some users reported as more stable and aligned with Harmony reverting back to XMPP. However, reverting would require larger changes to the Harmony integration (because `pyharmony` is not asyncio-based and the current integration is), and would also remove newer functionality (e.g., the `change_channel` service). The maintainer decision was to proceed with the aioharmony update to immediately restore functionality for users already on the new firmware, accepting the breaking change that older firmware would no longer be supported. Future moves toward an official XMPP-based async solution were deemed out of scope for this PR.\n\nThe resulting behavior: after this change, any Home Assistant installation using the Harmony integration must have their Harmony Hub(s) upgraded to firmware 4.15.250 for compatibility, and Home Assistant will install aioharmony 0.1.8 to match.",
        "semantic_memory": "This case illustrates several general patterns for device integrations in home automation and similar systems:\n\n1. **Vendor firmware updates can break client libraries**: When a hardware vendor updates firmware (like Logitech Harmony Hub to 4.15.250), protocols or behaviors may change. Client libraries (like aioharmony) that hard-code protocol details can suddenly become incompatible, leading to integrations failing. Keeping track of upstream library versions that track firmware changes is essential.\n\n2. **Dependency version bump as a targeted fix**: Often the smallest, safest fix for a broken device integration is to bump the version of the underlying protocol library, as long as that library already contains the necessary compatibility work. The host application (Home Assistant here) only needs to update its dependency pin (component `REQUIREMENTS` and global requirements list) and ensure tests pass.\n\n3. **Breaking changes through dependency updates**: Upgrading a dependency can be a breaking change when it intentionally drops support for older device firmware or APIs. This needs to be clearly communicated (release notes, logs, docs) and may justify version bumping or deprecation warnings, especially when users might be on a variety of firmware levels.\n\n4. **Trade-off between supporting old and new device firmware**: When an updated library supports only the latest firmware, maintainers must choose between supporting users that have already updated firmware (and are currently broken) vs. users that remain on older firmware. The pragmatic approach may favor compatibility with the vendor's latest firmware, assuming most devices auto-update or that the vendor forces updates.\n\n5. **Considering protocol/API strategy vs. tactical fixes**: There can be a long-term architectural debate (e.g., using an official XMPP API vs. an unofficial one, async vs. sync libraries). However, those strategic shifts are often larger-effort and out of scope for an urgent regression fix. It is valuable to distinguish immediate remediation (dependency bump) from long-term redesign (switch libraries, changes to async model).\n\n6. **Synchronizing dependency definitions**: In projects like Home Assistant, dependencies are often defined in both component-specific `REQUIREMENTS` and centralized files like `requirements_all.txt`. Any dependency change must be applied consistently across these places, often using dedicated scripts like `gen_requirements_all.py` to regenerate global requirement files.\n\n7. **Stability vs. modern architecture**: Users reported older synchronous `pyharmony` as more stable in some environments, despite being non-async. This highlights that stability may depend on networking stack, OS environment, and implementation details; async is not automatically more robust. When designing integrations, maintainers should consider both API support and real-world reliability data.\n\n8. **User impact of protocol changes and configuration requirements**: Moving to a different API (e.g., XMPP) may require users to toggle settings in vendor apps (e.g., enabling XMPP in Harmony mobile app). Any such migration should be accompanied by warnings in logs and documentation so users know how to adjust their device configuration.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom and recent changes.\n- Observe that an integration (e.g., Harmony remote) that used to work now fails, shows entities as unavailable, or cannot connect.\n- Check recent changes: Has the device firmware auto-updated? Check vendor release notes or the device's app for firmware versions (e.g., Harmony Hub firmware 4.15.250).",
            "Step 2: Verify errors and dependency involvement.\n- Inspect application logs (e.g., Home Assistant logs) for errors from the integration or its underlying library (connection errors, protocol errors, authentication failures).\n- Identify which Python package is handling communication (e.g., aioharmony). Confirm its version via the environment (pip freeze, or application dependency lists).",
            "Step 3: Check upstream library and vendor compatibility.\n- Visit the library's repository (e.g., aioharmony GitHub) and look for recent releases and changelogs that mention the new firmware or protocol changes.\n- Verify whether a newer library version explicitly supports the new firmware and whether it has dropped support for older firmware versions.",
            "Step 4: Decide on a compatibility strategy.\n- If the newer library version restores compatibility with updated firmware but drops old firmware support, decide which firmware range you want to support.\n- Consider your user base and vendor behavior (e.g., do devices auto-update?). Document that this will be a breaking change for users on older firmware.",
            "Step 5: Update the dependency in the codebase.\n- Update component-level requirement pins (e.g., in `homeassistant/components/harmony/remote.py` change `REQUIREMENTS = ['aioharmony==old']` to the new version).\n- Update any centralized requirements files (e.g., `requirements_all.txt`) to match the new version.\n- If the project has tooling (e.g., `script/gen_requirements_all.py`), run it to regenerate and sync requirement files.",
            "Step 6: Run tests and local verification.\n- Run the test suite (e.g., `tox`) to ensure there are no regressions in other components.\n- If possible, test locally with real devices on the target firmware to confirm the integration now works (connects, stays available, performs actions correctly).",
            "Step 7: Communicate breaking changes and requirements.\n- Update release notes or changelog to mention that the integration now requires a minimum device firmware version (e.g., Harmony Hub 4.15.250) and that older versions are no longer supported.\n- If applicable, log a warning when detecting older firmware, explaining that users should upgrade firmware or expect incompatibility.",
            "Step 8: Evaluate long-term architecture separately.\n- If there is a broader architectural question (e.g., whether to revert to a different protocol/library like XMPP or pyharmony; async vs. sync), consider that as a separate design/RFC or future PR.\n- Collect user feedback on stability and compatibility of the updated integration, and plan any larger migrations (e.g., move to official APIs) with proper deprecation paths.",
            "Step 9: Monitor post-deployment behavior.\n- After release, monitor issues for reports of persistent outages, hubs going unavailable, or compatibility problems.\n- Distinguish between genuine protocol/library bugs and environmental/network issues (e.g., unstable network on Hass.io) and address them with additional reconnection logic or diagnostics if needed."
        ]
    }
}
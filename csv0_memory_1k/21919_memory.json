{
    "search_index": {
        "description_for_embedding": "Home Assistant input_datetime entities without an initial value or restored state were left with no internal datetime set, causing missing attributes (like timestamp) and template rendering failures when accessing input_datetime.attributes.timestamp. The fix ensures a concrete default datetime of 1970-01-01 00:00:00 is applied according to has_date/has_time flags, aligning behavior with the documentation and guaranteeing timestamp is always available.",
        "keywords": [
            "home assistant",
            "input_datetime",
            "default value",
            "1970-01-01 00:00:00",
            "timestamp attribute",
            "template sensor error",
            "UndefinedError",
            "async_added_to_hass",
            "restore_state",
            "state initialization bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant input_datetime component behaved inconsistently with its documentation. The docs stated that if no initial value is configured, the default should be 1970-01-01 00:00:00. In practice, when an input_datetime entity had no initial value and no stored (restored) state, the component left its internal _current_datetime as None. This meant the entity's state and attributes, especially the 'timestamp' attribute, were missing or incomplete. Users who created template sensors referencing `states.input_datetime.<name>.attributes.timestamp` encountered startup failures and template rendering errors, such as `UndefinedError: 'mappingproxy object' has no attribute 'timestamp'`. The PR modified `homeassistant/components/input_datetime/__init__.py` in the `async_added_to_hass` method to enforce a guaranteed default whenever there is neither an initial value nor a restored state. A constant DEFAULT_VALUE = '1970-01-01 00:00:00' was introduced. Depending on the entity configuration: if `has_date` is False and `has_time` is True, the code now defaults to the time portion '00:00:00' and parses it with `dt_util.parse_time`; if `has_time` is False and `has_date` is True, it defaults to the date portion '1970-01-01' and parses it with `dt_util.parse_date`; if both date and time are present, it uses the full DEFAULT_VALUE and parses it with `dt_util.parse_datetime`. There was a small bug during development where the date/time parts of DEFAULT_VALUE were initially swapped when split, then corrected (date is index 0, time is index 1). New tests were added in `tests/components/input_datetime/test_init.py` to validate that when no initial or restored state exists, each variant (time-only, date-only, and datetime) exposes the expected default state and has a non-None 'timestamp' attribute. This ensures documented behavior, eliminates template failures on first startup, and improves the user experience by avoiding 'unknown' or missing-state issues for new input_datetime entities.",
        "semantic_memory": "This fix illustrates a common pattern in stateful systems: components that expose structured attributes must always initialize their internal state to a valid, coherent value before being used, especially when documentation promises a default. Leaving fields as None or uninitialized often causes subtle template or integration failures, particularly in dynamic or declarative environments where users assume certain attributes always exist. Another important pattern is the divergence between documentation and actual behavior: when code does not match the documented default values, users rely on the docs and build configurations that fail at runtime, leading to confusing errors. Aligning implementation with the documented contract is crucial for a stable API and good developer experience. Additionally, for entities that reconstruct state from persistence (restore_state), there must be a clear fallback behavior for the 'first run' scenario where no prior state exists. In such cases, choosing a predictable default (like Unix epoch start) and applying it consistently across variations (date-only, time-only, datetime) ensures downstream consumers—like template engines—can rely on presence and shape of attributes without defensive checks for None. The tests show the value of verifying not only the primary state but also derived attributes (like timestamp) that other subsystems rely on; failing to validate these can let regressions slip through even if the entity appears to work at a superficial level.",
        "procedural_memory": [
            "When diagnosing issues with entity defaults or missing attributes in a stateful system (e.g., Home Assistant components), start by reproducing the failure with the minimal configuration that illustrates the problem.",
            "Step 1: Reproduce the bug in a controlled environment.\n- Define the entity with the minimal configuration that triggers the problem (e.g., an input_datetime with has_date/has_time flags and no initial value).\n- Add any dependent entities (e.g., a template sensor that reads an attribute like `attributes.timestamp`).\n- Restart the system and observe logs for errors such as UndefinedError or attribute access failures.\n- Confirm that the entity's state or attributes are missing or None when first created.",
            "Step 2: Inspect the component's initialization and restore logic.\n- Locate the component code that runs during entity setup (e.g., async_added_to_hass or equivalent lifecycle hooks).\n- Look for logic that retrieves initial configuration, restores previous state, and sets internal fields like _current_datetime or similar.\n- Check whether the code explicitly handles the case where there is neither an initial config value nor a restored state. If the logic only executes when a restore value is not None, internal state may remain unset.",
            "Step 3: Define and implement a clear default behavior.\n- Decide on a default value consistent with documentation and user expectations (e.g., 1970-01-01 00:00:00 for a datetime).\n- For entities that support different modes (time-only, date-only, full datetime), derive appropriate defaults from the canonical value (e.g., split DEFAULT_VALUE into date and time parts).\n- Update the initialization logic to check: if no initial value and no restored value, assign the default. Ensure each variant (has_date only, has_time only, both) gets a valid parseable string.\n- Use the appropriate parsing utilities (e.g., parse_time, parse_date, parse_datetime) so that internal state is fully populated.",
            "Step 4: Ensure downstream attributes are always present.\n- Identify derived attributes (like a 'timestamp') that templates or other components rely on.\n- Verify that setting the default internal state leads to these attributes being computed and exposed, even on first startup.\n- If necessary, adjust attribute computation logic (often in the entity's state_properties or properties) to assume a non-None internal datetime after initialization.",
            "Step 5: Add targeted tests covering first-run and restore scenarios.\n- Write tests that set up the component with no initial value and no prior state, then assert the entity's state equals the expected default (for each mode: time-only, date-only, datetime).\n- Assert that key attributes (e.g., 'timestamp') are present and non-None for these default states.\n- Also include tests for restore behavior: pre-populate a fake old state, then confirm that the entity restores correctly and does not fall back to the default when a valid restore exists.",
            "Step 6: Keep documentation and code behavior aligned.\n- Compare current behavior against the official documentation to ensure consistency.\n- If changing behavior to match docs, explicitly reference the documentation in code comments or PR description.\n- Conversely, if it is safer to change the documented behavior instead of the implementation, coordinate with maintainers to update the docs and avoid misleading users.",
            "Step 7: Avoid subtle mistakes when reusing default constants.\n- When using a combined default like '1970-01-01 00:00:00', be careful when splitting into date and time components (index 0 is date, index 1 is time).\n- Add small unit tests that assert these parts are correctly derived, or avoid manual splitting by storing separate constants (DEFAULT_DATE, DEFAULT_TIME) if appropriate.",
            "Step 8: Review impact on the UI and unknown states.\n- Consider whether representing 'unknown' as a concrete default is acceptable in your domain, or whether explicit 'unknown' states are preferable.\n- If a concrete default is required to avoid runtime errors, document this behavior clearly so consumers do not misinterpret the default as meaningful user data."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix for a Python 2 crash in StackStorm pack installation logging where LOG.debug used old-style % string interpolation with unicode values returned from a shell command. The solution switched to .format-based interpolation (which handles unicode safely) to prevent type errors when stderr or other values are unicode.",
        "keywords": [
            "unicode interpolation bug",
            "python2 str vs unicode",
            "logging crash",
            "LOG.debug",
            "old-style percent formatting",
            "str.format",
            "stackstorm",
            "st2common.util.pack_management",
            "pack installation",
            "shell stderr unicode"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the StackStorm codebase, specifically in st2common/st2common/util/pack_management.py, a bug was reported where the command `st2ctl reload --register-setup-virtualenvs` could crash. The crash occurred inside the logging code for pack owner/group changes. The code used old-style `%` string interpolation with a byte-string format:\n\n`LOG.debug('Failed to change owner group on directory \"%s\" to \"%s\": %s' % (pack_path, pack_group, stderr))`\n\nWhen the underlying shell command returned unicode output (e.g., stderr as a unicode object) under Python 2, combining a byte-string format and unicode arguments caused a failure during string substitution. This meant that instead of just logging an error about chgrp failing, the entire process crashed due to a type/encoding error in the logging statement.\n\nThe fix updated the LOG.debug calls to use `.format()`-style interpolation, which is more robust when handling unicode values on Python 2. The first change replaced:\n\n- `LOG.debug('Changing owner group of \"%s\" directory to %s' % (pack_path, pack_group))`\n\nwith:\n\n- `LOG.debug('Changing owner group of \"{}\" directory to {}'.format(pack_path, pack_group))`\n\nThe second problematic logging statement was ultimately changed to:\n\n`LOG.debug('Failed to change owner group on directory \"{}\" to \"{}\": {}'.format(pack_path, pack_group, stderr))`\n\nThis ensures that unicode values coming from the shell (e.g., stderr) are interpolated safely without causing a crash. A CHANGELOG entry was added to document that pack installation logging was fixed so unicode strings are interpolated properly. The practical impact is that pack installation and owner/group adjustments now log failures without bringing down the process when unicode output is encountered.",
        "semantic_memory": "This incident illustrates a common Python 2 pitfall: mixing unicode objects with byte-string format strings in old-style (`%`) interpolation can cause runtime errors, especially in logging paths where shell commands often return unicode or non-ASCII content.\n\nKey generalizable lessons:\n\n1. **Avoid mixing byte strings and unicode in Python 2**: If you must support Python 2, ensure consistency in string typesâ€”prefer using unicode (`u\"...\"`) or APIs that handle unicode gracefully.\n\n2. **Be careful with old-style `%` string formatting**: Old-style interpolation (`'%s' % value`) is more error-prone when non-ASCII or unicode objects are involved. Using `.format()` is generally safer and more expressive, and in Python 3 f-strings or `.format()` are preferred.\n\n3. **Logging should never crash business logic**: Logging statements are often treated as harmless, but if they perform complex interpolation or transformations, they can throw exceptions and terminate the main workflow. Logging code should be robust and tested, especially around inputs coming from external systems (shell, network, I/O) that may contain unicode or unexpected characters.\n\n4. **Prefer logger parameterization where possible**: Many logging frameworks (including Python's logging) allow passing arguments separately (e.g., `LOG.debug('Message: %s', value)`). This defers formatting to the logging framework and can avoid some encoding issues, as well as unnecessary string creation when the log level is disabled.\n\n5. **Test error paths with realistic data**: In this case, the failure only manifested when the shell returned unicode output and the command failed (non-zero exit). Testing only the success path or only with ASCII output can easily miss such bugs.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the failure in a controlled environment.\n- Run the command or workflow that triggers logging with external output (e.g., shell commands) using inputs that are likely to produce non-ASCII or unicode output.\n- In this case, execute `st2ctl reload --register-setup-virtualenvs` or similar pack operations and ensure the shell command can fail to hit the error-logging path.",
            "Step 2: Capture the exception and inspect the traceback.\n- Look for exceptions originating from logging calls rather than the main business logic. Typical indicators include `TypeError`, `UnicodeDecodeError`, or `UnicodeEncodeError` originating from string interpolation or logging.\n- Confirm that the failing line involves string formatting in a log statement, such as `LOG.debug('...%s...' % value)`.",
            "Step 3: Identify string types and encoding assumptions.\n- Use `type(value)` (or debugging prints/breakpoints) to confirm whether variables being interpolated (e.g., `stderr`) are `unicode` or `str` in Python 2.\n- Check the format string: if it is a byte string (`'...'`) and you interpolate unicode values with `%`, you may hit encoding issues.",
            "Step 4: Choose a safer formatting strategy.\n- Option A (preferred for Python logging): Use logger parameterization:\n  - Replace `LOG.debug('Failed: %s' % stderr)` with `LOG.debug('Failed: %s', stderr)`.\n- Option B (as used in this fix): Switch to `.format()` which tends to cooperate better with unicode objects in Python 2:\n  - Replace `LOG.debug('...%s...' % (a, b, c))` with `LOG.debug('...{}...'.format(a, b, c))`.\n- Option C: Ensure the format string itself is unicode and/or explicitly encode/decode values consistently (e.g. `u'...' % value` with all values as unicode).",
            "Step 5: Apply the fix to all related logging statements.\n- Search the file or module for similar patterns (`%`-based interpolation in logging functions) that may involve values coming from external sources (shell output, HTTP responses, files).\n- Update them to use `.format()` or logging parameterization consistently.",
            "Step 6: Add or extend tests to cover unicode scenarios.\n- Create tests that simulate shell commands or external calls returning unicode output, including non-ASCII characters.\n- Trigger both success and failure paths where logging is executed.\n- Assert that the operation completes without raising exceptions and that the log message is constructed correctly.",
            "Step 7: Document the change.\n- Add a CHANGELOG entry or release note describing that unicode handling in logging was fixed, especially if this affects operational tools or admin workflows.\n- Briefly highlight the root cause (unicode and byte-string interpolation) so future maintainers understand the rationale and avoid reintroducing the pattern.",
            "Step 8: For new code, adopt best practices to prevent recurrence.\n- In Python 3 codebases, use f-strings or `.format()` with consistent use of unicode strings (the default in Python 3).\n- In mixed or legacy Python 2/3 code, maintain clear conventions: always use unicode for textual data and avoid `%` formatting with unknown external inputs.\n- Prefer logging APIs that handle string interpolation internally instead of pre-formatting log messages."
        ]
    }
}
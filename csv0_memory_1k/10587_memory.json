{
    "search_index": {
        "description_for_embedding": "Home Assistant limitlessled light entities were always turned off after a Home Assistant restart because the component forced a known state on initialization and did not restore the last known state. The fix adds async_added_to_hass with async_get_last_state and assumed_state=True to restore the previous on-state and attributes (brightness, color, etc.) from the database by calling async_turn_on with saved parameters.",
        "keywords": [
            "home-assistant",
            "limitlessled",
            "light platform",
            "state restore",
            "async_added_to_hass",
            "async_get_last_state",
            "assumed_state",
            "PROP_TO_ATTR",
            "device restart behavior",
            "restore previous state from database"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant limitlessled light platform had an undesirable behavior: after Home Assistant restarted, all limitlessled lights were turned off, regardless of their prior state. This happened because the component intentionally forced all groups into a known state (off) during initialization to avoid inconsistencies, but it did not restore the last persisted state from the database. As a result, users experienced a brief flash or state change and ended up in the dark even if their lights had been on before the restart.\n\nThe fix introduces proper state restoration relying on Home Assistant's restore_state mechanism. The developer added an async_added_to_hass coroutine to the LimitlessLED group class. On entity addition, it calls async_get_last_state(self.hass, self.entity_id) to fetch the last stored state from the state machine / recorder. If no old state exists, it simply returns. If there is a previous state, it builds a params dictionary by selecting relevant attributes using PROP_TO_ATTR (mapping which entity attributes should be applied to turn_on). Then, if the old state was STATE_ON, it calls self.async_turn_on(**params) to reapply brightness, color temperature, effects, etc.\n\nBecause limitlessled devices cannot be polled for their real state, the component now explicitly reports assumed_state = True, signaling that Home Assistant should treat the state as assumed rather than verified. This aligns with the rule that restore_state is only correct when the integration cannot query the device and must rely on the last known state.\n\nThe net result: after a Home Assistant restart, limitlessled lights are restored to their last known on-state with previous attributes, instead of being left off. The code now uses the standard restore_state pattern, uses async_added_to_hass instead of a custom async_restore_state signature, and calls async_turn_on to reconcile the component's 'force known state on init' behavior with user expectations.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices for device state management in Home Assistant and similar systems:\n\n1. **Use restore_state only when the device state is not directly queryable.** If an integration cannot poll the physical device for its real state (e.g., limitlessled, some RF or IR remotes), then it is appropriate to rely on the last known state stored in the system's database. In such cases, the entity should set assumed_state = True so the UI and automations know the state is inferred rather than confirmed.\n\n2. **Implement state restoration in async_added_to_hass.** The recommended pattern in Home Assistant is to perform restoration of previous state inside async_added_to_hass. This coroutine is called when the entity is added to Home Assistant and has access to hass and entity_id. Using async_get_last_state in this hook provides a clean and consistent way to restore previous attributes.\n\n3. **Leverage framework-level attribute mappings.** Rather than manually extracting and mapping each possible attribute (brightness, color temp, RGB, effect, etc.) from the old state, use common mappings like PROP_TO_ATTR to ensure that only valid, supported attributes are passed to turn_on / async_turn_on and to reduce duplication.\n\n4. **Align initialization behavior with restore behavior.** If an integration forces devices into a known state (often off) on startup to avoid inconsistent state, and you add restore_state support, you must reconcile those two behaviors. Either remove the forced initial state or make restore_state explicitly reapply the last known state (including turning the device back on) so that user-facing behavior is predictable. In this case, because the integration still resets devices to a known state on init, the restore logic consciously calls async_turn_on when the previous state was on.\n\n5. **Use async_* methods consistently in async components.** When implementing async_added_to_hass and using async_get_last_state, it is important to call async_turn_on instead of the sync turn_on method to keep the component fully asynchronous and avoid blocking the event loop.\n\n6. **State restoration is about user experience, not just correctness.** Even if forcing a known state is logically consistent, it can be user-hostile (e.g., leaving users in the dark after a restart). Persisting and restoring state from the database improves UX and makes the system feel more robust.\n\nThese patterns apply broadly to any smart home integration where physical state cannot be read directly and must be inferred from historical data, especially in event-driven, async frameworks like Home Assistant.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom.\n- Observe what happens to entities after the application or host restarts.\n- Look for reports that lights or devices always end up off (or in some default state) regardless of their previous state.\n- Confirm by turning a device on, restarting the system, and noting whether the UI and physical device state match expectations.",
            "Step 2: Check whether the integration can poll real device state.\n- Review the integration's code or device protocol: can you query current on/off, brightness, etc., at startup?\n- If the device cannot be polled or the protocol is one-way (e.g., some RF bridges), then you must rely on stored state, and the entity should report assumed_state = True.",
            "Step 3: Review current initialization behavior.\n- Inspect the entity's __init__ and update / setup logic.\n- Look for code that forces a known state on startup (e.g., explicitly calling turn_off or setting brightness to defaults in __init__ or during add_devices).\n- Decide whether that behavior is still desirable once state restoration is added.",
            "Step 4: Implement async_added_to_hass and restore previous state.\n- Add an async_added_to_hass coroutine to the entity class (for Home Assistant-style frameworks):\n  - Use async_get_last_state(self.hass, self.entity_id) to fetch the last persisted state.\n  - If old_state is None, exit early (no previous state recorded).\n  - Build a dictionary of parameters from old_state.attributes, preferably using a framework-provided mapping like PROP_TO_ATTR to avoid hardcoding attribute names.\n- Example (conceptual):\n  - old_state = await async_get_last_state(self.hass, self.entity_id)\n  - if not old_state: return\n  - params = {key: old_state.attributes[key] for key in PROP_TO_ATTR if key in old_state.attributes}",
            "Step 5: Decide when to re-apply state and how.\n- If the previous state was on, and the integration either cannot query the device or explicitly reset it to off on startup, call async_turn_on(**params) to restore brightness, color, etc.\n- If the previous state was off, you usually do nothing (leave the device off).\n- Use the async version of the method (async_turn_on) inside async_added_to_hass.",
            "Step 6: Mark the entity as having an assumed state.\n- Implement an assumed_state property returning True when the device's real state cannot be confirmed:\n  - @property\n    def assumed_state(self) -> bool:\n        return True\n- This informs the frontend and automations that the state is inferred from stored data, not actively polled.",
            "Step 7: Test the behavior.\n- Turn a device on, adjust brightness/color, and ensure the state is correctly recorded.\n- Restart the application or host.\n- Verify:\n  - The device returns to the same on/off state and attributes as before the restart.\n  - There are no tracebacks related to async_get_last_state or async_added_to_hass.\n  - The UI reflects the restored state accurately.",
            "Step 8: Refine initialization logic if needed.\n- If the integration still forces a known state on init (e.g., turning everything off), confirm that the restore logic adequately compensates (by turning devices back on when appropriate).\n- Alternatively, consider removing or softening the forced state behavior if it conflicts with expected restored state semantics.",
            "Step 9: Document the behavior.\n- Note in integration documentation that the component restores the last known state from the database and that the state is assumed when the device cannot be polled.\n- Clarify any edge cases, such as a brief flicker or state transition during startup if the integration first resets and then restores state."
        ]
    }
}
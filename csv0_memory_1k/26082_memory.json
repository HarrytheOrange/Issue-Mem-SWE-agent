{
    "search_index": {
        "description_for_embedding": "Home Assistant config_entries progress API was migrated from an HTTP REST endpoint to a WebSocket command. The old GET /api/config/config_entries/flow endpoint, which listed non-user-initiated config flows (e.g., discovered devices requiring user interaction), was disabled (returns HTTP 405) and replaced with a WebSocket command `config_entries/flow/progress` registered via websocket_api with admin-only access. Tests were updated to use the WebSocket client and validate both authorized and unauthorized behavior.",
        "keywords": [
            "Home Assistant",
            "config_entries",
            "config entries flow progress",
            "websocket_api",
            "REST to WebSocket migration",
            "HTTP 405 Method Not Allowed",
            "admin-only API",
            "unauthorized websocket error",
            "async_setup_component",
            "hass_ws_client",
            "data_entry_flow"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant team converted the 'config entries progress' API from a REST endpoint to a WebSocket-based API to align with a broader goal of moving internal APIs to WebSockets. Previously, `ConfigManagerFlowIndexView.get` served GET requests at `/api/config/config_entries/flow`, returning a JSON list of configuration flows that were in progress but not initiated by a user (for example, a discovered Hue hub needing user interaction). Access to this endpoint required admin privileges and enforced auth via HTTP (401 for unauthorized). The change disabled the HTTP GET handler by having it raise `aiohttp.web_exceptions.HTTPMethodNotAllowed('GET', ['POST'])`, effectively returning a 405 for GET and signaling that the endpoint is no longer available for listing progress. The functionality was moved into a WebSocket command:\n\n- A new command `config_entries/flow/progress` was registered in `async_setup` via `hass.components.websocket_api.async_register_command(config_entries_progress)`.\n- The new handler `config_entries_progress` is decorated with `@websocket_api.require_admin` and `@websocket_api.websocket_command({\"type\": \"config_entries/flow/progress\"})`, enforcing admin-only access and defining the message schema.\n- It responds with `connection.send_result(msg[\"id\"], [...])`, returning the same list of non-user-initiated flows that the REST endpoint previously returned.\n\nTests were updated accordingly:\n\n- `test_get_progress_index` was converted from using the HTTP test client to using `hass_ws_client`. The test sets up the `config` component and a mock config flow (`TestFlow`) with `async_step_hassio` and `async_step_account` using async/await instead of `@asyncio.coroutine`. It initializes a flow with `hass.config_entries.flow.async_init(\"test\", context={\"source\": \"hassio\"})`, then sends a WebSocket message `{ \"id\": 5, \"type\": \"config_entries/flow/progress\" }`. The response is asserted to be successful, with the `result` list containing the expected flow entry.\n- `test_get_progress_index_unauth` now verifies that non-admin users cannot access the WebSocket command. It removes the admin user’s groups (`hass_admin_user.groups = []`), connects via `hass_ws_client`, sends the same WebSocket request, and asserts `response[\"success\"]` is `False` and `response[\"error\"][\"code\"] == \"unauthorized\"`, matching the websocket_api’s standardized error semantics instead of an HTTP 401.\n\nThis change was merged explicitly to unblock a frontend release that depends on the WebSocket API for config flow progress.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices:\n\n1. **Migrating from REST to WebSocket APIs**: When internal APIs evolve from HTTP endpoints to WebSocket commands, it is often desirable to preserve semantics while changing transport. The same logical behavior (listing in-progress config flows) is provided through a different interface. The implementation uses WebSocket-specific patterns (`websocket_command` decorators, `send_result`, and message IDs) while the core business logic (filtering flows by source) stays the same.\n\n2. **Gracefully disabling old endpoints**: Rather than silently changing the behavior of an existing HTTP endpoint or leaving it orphaned, the REST handler explicitly raises an `HTTPMethodNotAllowed` error for methods that are no longer supported. This provides clear signaling to any accidental callers that the method is not allowed anymore (HTTP 405), differentiating it from authorization issues (401/403).\n\n3. **Centralized authorization on WebSocket APIs**: Decorating WebSocket command handlers with `@websocket_api.require_admin` centralizes permission enforcement. This is analogous to auth checks in HTTP views but uses the framework’s WebSocket-level mechanisms, returning structured error messages (`{\"success\": False, \"error\": {\"code\": \"unauthorized\", ...}}`) instead of HTTP status codes.\n\n4. **Maintaining test coverage through API migrations**: When changing the transport layer (HTTP → WebSocket), tests must be updated to use the appropriate test helpers (`hass_ws_client` instead of `client.get`) and assertions must be adapted from HTTP status codes and JSON bodies to WebSocket message formats (checking `success`, `result`, and `error.code`). The business logic is verified through the new interface to ensure client code that depends on it works correctly.\n\n5. **Async/await modernization**: The tests and config flow steps were updated from `@asyncio.coroutine` + `yield from` to native `async def` and `await`, reflecting current best practices in modern Python async codebases.\n\n6. **Separation of concerns**: The data retrieval logic (`hass.config_entries.flow.async_progress()` and filtering by `context['source'] != SOURCE_USER`) is kept independent of the transport layer. The handler simply adapts that data to WebSocket responses, making it easier to move or reuse logic in the future.\n\nThese patterns apply generally to any system migrating internal or semi-private APIs from one transport protocol to another, especially in event-driven or real-time applications.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix (or perform) similar REST-to-WebSocket migrations for internal APIs:",
            "Step 1: Identify the existing REST endpoint and its behavior.\n- Locate the HTTP view (e.g., a class derived from a framework’s View or similar) and understand what it returns and under what conditions.\n- Note authorization logic, response schemas, and which clients depend on it.",
            "Step 2: Extract and isolate the core business logic.\n- Identify the logic that fetches or computes the data (e.g., listing in-progress config flows via `hass.config_entries.flow.async_progress()` and filtering them).\n- If needed, refactor that logic into a helper function or keep it clearly separated from the HTTP-specific request/response handling.",
            "Step 3: Implement the new WebSocket command.\n- Define a new WebSocket handler function with the framework’s decorators, e.g. `@websocket_api.websocket_command({\"type\": \"your/command\"})`.\n- Apply authorization decorators such as `@websocket_api.require_admin` (or the appropriate permission level) to mirror or improve the security model of the original REST endpoint.\n- In the handler, call the same business logic as the old HTTP endpoint used, then send the result via `connection.send_result(msg[\"id\"], result_data)` or equivalent.",
            "Step 4: Register the WebSocket command during setup.\n- In the integration’s setup or initialization function (e.g. `async_setup(hass)`), register the new WebSocket command with the websocket API subsystem, e.g. `hass.components.websocket_api.async_register_command(config_entries_progress)`.\n- Ensure that the setup of the integration/module is invoked in tests (e.g., `assert await async_setup_component(hass, \"config\", {})`).",
            "Step 5: Disable or deprecate the old REST endpoint.\n- Decide on the strategy: immediate removal, deprecation, or disabling.\n- If disabling but leaving the route in place, have the handler raise an appropriate HTTP error like `HTTPMethodNotAllowed('GET', ['POST'])` or `HTTPNotFound` to clearly signal that the old method is no longer supported.\n- Avoid returning misleading status codes; use 405 for disallowed methods, 404 if the endpoint is gone, and 401/403 for auth issues.",
            "Step 6: Update and extend tests to use WebSocket clients.\n- Replace HTTP client calls (e.g., `client.get(...)`) with WebSocket test clients (e.g., `ws_client = await hass_ws_client(hass)`).\n- Send requests using the WebSocket schema: `await ws_client.send_json({\"id\": 1, \"type\": \"your/command\", ...})`.\n- Receive responses with `await ws_client.receive_json()` and assert on `response[\"success\"]`, `response[\"result\"]`, and/or `response[\"error\"]` instead of HTTP status codes.\n- For unauthorized tests, manipulate user permissions (e.g., clear admin groups) and verify the WebSocket returns `success == False` and an appropriate `error.code` (e.g., \"unauthorized\").",
            "Step 7: Modernize async code if needed.\n- If the old code uses `@asyncio.coroutine` and `yield from`, convert to `async def` and `await` to align with current Python async best practices.\n- Ensure test helpers and flow steps are updated consistently.",
            "Step 8: Verify dependent clients (e.g., frontend) and roll out.\n- Ensure any frontend or other clients are updated to call the new WebSocket command instead of the deprecated REST endpoint.\n- Run the full test suite (`tox` or equivalent) and manually test the relevant UI flows to confirm that behavior is unchanged except for the transport layer.",
            "Step 9: Communicate non-breaking nature for internal APIs.\n- If the API is internal (not public), note that the change is non-breaking for external users, but document it for developers and maintainers.\n- Use comments or commit messages to indicate the rationale (e.g., \"migrating to WebSocket to unblock frontend release\")."
        ]
    }
}
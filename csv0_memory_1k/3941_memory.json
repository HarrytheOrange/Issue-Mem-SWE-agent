{
    "search_index": {
        "description_for_embedding": "Bug fix in napari stack creation where per-channel attributes containing None (e.g. [(1, 2), None]) were not respected. The sequence utility ensure_sequence_of_iterables treated None as non-iterable, collapsing or repeating values instead of preserving None for specific channels. Fix introduces an allow_none flag to is_iterable and ensure_sequence_of_iterables and uses it in split_channels so that None can be a valid element in per-channel configuration lists.",
        "keywords": [
            "napari",
            "image stack",
            "stack creation",
            "split_channels",
            "stack_utils",
            "ensure_sequence_of_iterables",
            "is_iterable",
            "allow_none",
            "None handling",
            "per-channel attributes",
            "sequence utilities",
            "iterable detection bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari had a subtle bug when creating image stacks with per-channel attributes. The utility function ensure_sequence_of_iterables was used by layers/utils/stack_utils.split_channels to normalize keyword arguments like per-channel contrast limits or other attributes. Internally, ensure_sequence_of_iterables relied on is_iterable, which always treated None as non-iterable.\n\nThis caused a problem for configurations where a list contained a mix of valid iterable values and None, e.g. [(1, 2), None]. Conceptually, this should mean: for channel 0, use the tuple (1, 2); for channel 1, set the attribute to None. However, because is_iterable(None) returned False, the check `all(is_iterable(el) for el in obj)` failed, causing ensure_sequence_of_iterables to treat the entire object as a scalar (or otherwise mis-normalize), rather than as a sequence of iterables containing None. As a result, users could not reliably set a particular channel's attribute to None during stack creation; the configuration would be misinterpreted and potentially repeated or rejected.\n\nThe fix added an allow_none parameter to both is_iterable and ensure_sequence_of_iterables. When allow_none=True, is_iterable considers None to be iterable for the purposes of the sequence check. ensure_sequence_of_iterables passes this flag into is_iterable and exposes allow_none in its own API. In stack_utils.split_channels, the call to ensure_sequence_of_iterables for certain kwargs now sets allow_none=True, ensuring that lists like [(1, 2), None] are preserved as-is and mapped correctly to channels. A targeted test, test_sequence_of_iterables_allow_none, was added to verify that ensure_sequence_of_iterables([(1, 2), None], allow_none=True) returns the original input list unchanged. The docstring was updated to demonstrate the new behavior.",
        "semantic_memory": "This change illustrates a general pattern with utility functions that inspect or normalize collections: the treatment of sentinel values like None must be context-aware. A generic is_iterable helper that blindly treats None as non-iterable can break higher-level logic that wants to accept None as a valid element in a sequence (e.g., using None to explicitly disable or clear a setting on one item in a collection).\n\nKey concepts:\n- Iterable detection is not one-size-fits-all. The notion of 'iterable' should sometimes be configurable, especially when a sentinel type (such as None) is used both as a special value and as a legitimate element in sequences.\n- Utility functions used in many call sites should be flexible. Adding parameters like allow_none avoids forking or duplicating nearly identical helpers for slightly different semantics.\n- When normalizing nested data structures (e.g., 'sequence of iterables' for per-channel configuration), strong assumptions about element types can lead to misinterpretation of mixed-type sequences (e.g., tuples and None). Tools like `all(is_iterable(el) for el in obj)` should consider edge cases explicitly.\n- Tests should capture problematic real-world patterns (like [(1, 2), None]) so that future refactors don’t regress the behavior.\n\nMore broadly, any library that auto-broadcasts or normalizes user configuration across multiple dimensions (channels, layers, axes) must carefully distinguish between 'missing / broadcast this scalar to all' and 'explicit per-element values including None'. Configurability flags (allow_none, allow_scalars, treat_dicts_as_scalars, etc.) are a robust way to handle these distinctions.",
        "procedural_memory": [
            "Step-by-step guide to diagnose and fix similar iterable/None handling issues in configuration-normalization utilities:",
            "Step 1: Identify the symptom",
            "Observe unexpected behavior when passing per-item configuration lists that include None (e.g., attributes like color, contrast_limits, or other settings). Typical symptoms include: values being broadcast to all items instead of respecting per-item values; ValueErrors about unexpected lengths; or ignored None values that should disable a feature for a specific item.",
            "Step 2: Isolate a minimal reproducible example",
            "Write a small test or script that passes an input like [(1, 2), None] or [value_for_item0, None] into the relevant API. Confirm the bug by printing or asserting the resulting per-item configuration. Ensure that the problem only manifests when None is present.",
            "Step 3: Trace where the configuration is normalized",
            "Search for utility functions that reshape or validate the data, such as ensure_sequence_of_iterables, normalize_sequence, broadcast_to_shape, etc. Add temporary logging or breakpoints to see how they interpret the problematic input.",
            "Step 4: Inspect iterable/sequence detection helpers",
            "Look for helper functions like is_iterable, is_sequence, is_list_like. Check whether they treat None in a special way (often they return False for None). Examine how these helpers are used in logic such as `all(is_iterable(el) for el in obj)` that determines if an object is a 'sequence of iterables'.",
            "Step 5: Decide on the desired semantics for None",
            "Clarify the intended semantics in this context: Should None be allowed as a valid element in a configuration list (e.g., to explicitly clear or disable a setting for one item)? Or should None always mean 'no sequence / scalar, broadcast this'? Once the semantics are clear, design a way to express them in the utility API.",
            "Step 6: Add a configurability flag to the utility",
            "Introduce an explicit parameter (e.g., allow_none=False by default) to the core helper (e.g., is_iterable) and to any higher-level function (e.g., ensure_sequence_of_iterables) that uses it. Use this flag to alter the behavior so that when allow_none=True, None is treated as acceptable within sequences for the relevant checks.",
            "Step 7: Propagate the flag to call sites that need the special behavior",
            "Find the specific call paths where None should be accepted as a valid element (e.g., in stack_utils.split_channels when normalizing per-channel kwargs). Update those call sites to pass allow_none=True. Leave other call sites unchanged so existing semantics stay intact where None should be treated as a scalar/sentinel.",
            "Step 8: Add targeted tests",
            "Create tests that capture the intended behavior, for example: `ensure_sequence_of_iterables([(1, 2), None], allow_none=True) == [(1, 2), None]`. Also test legacy behavior without allow_none to ensure no regressions. If possible, add higher-level tests that exercise the real API (e.g., creating stacks with per-channel attributes containing None) to ensure end-to-end correctness.",
            "Step 9: Update documentation and examples",
            "Update docstrings and usage examples to show how to use the new parameter (e.g., ensure_sequence_of_iterables([(1, 2), None], allow_none=True)). Explicitly document how None is treated in each mode to avoid confusion for future maintainers and users.",
            "Step 10: Run the full test suite and review impact",
            "Run the full test suite (including CI) to ensure the change didn’t introduce regressions in other areas that rely on the utility functions. If coverage reports highlight affected files, inspect them to confirm that the changed semantics are compatible with existing usage.",
            "Step 11: Generalize the pattern for future work",
            "For other sentinel types or special cases (e.g., empty sequences, dictionaries, NumPy arrays used as scalars), consider applying the same pattern: keep generic utilities but make their behavior configurable with explicit flags. This reduces the need for ad-hoc workarounds and keeps behavior transparent and testable."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant template binary_sensor was only extracting entity_ids from value_template, ignoring entities referenced in icon_template and entity_picture_template. This caused state updates to be missed when only those templates referenced entities. The fix aggregates entity IDs from all templates (value, icon, entity_picture), correctly handles MATCH_ALL, and respects manually configured entity_ids.",
        "keywords": [
            "Home Assistant",
            "binary_sensor",
            "template binary sensor",
            "entity_ids extraction",
            "template.extract_entities",
            "MATCH_ALL",
            "icon_template",
            "entity_picture_template",
            "template not updating",
            "event listener configuration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant template binary_sensor platform was not correctly tracking all entities used within a sensor's templates. The code previously obtained the entity_ids to watch by calling value_template.extract_entities() and did not inspect icon_template or entity_picture_template. As a result, if a binary sensor's icon or entity_picture depended on some entity's state (and the value_template itself did not reference that entity or match all entities), the binary sensor would not be subscribed to changes in that entity. This subtle bug was masked by tests that used a value_template that either did not reference specific entities or effectively matched all states, meaning changes would still be picked up.\n\nThe fix refactored async_setup_platform for the template binary_sensor. Instead of only using value_template.extract_entities(), it now iterates over value_template, icon_template, and entity_picture_template. For each non-None template, it sets template.hass = hass, then calls template.extract_entities(). It aggregates these into a set of entity_ids, with special handling for the MATCH_ALL sentinel: if any template returns MATCH_ALL, the combined entity_ids is set to MATCH_ALL. If the user explicitly configures ATTR_ENTITY_ID in the sensor config, that manual list overrides any auto-extracted entities. If not MATCH_ALL and not manual, the aggregated set is converted to a list and used as the entity_ids for the sensor.\n\nThe patch also adds tests. Existing tests for icon_template and entity_picture_template were updated so their value_template references a specific entity ({{ states.sensor.xyz.state }}) instead of using a non-entity constant, making the dependency explicit. A new test, test_match_all, mocks BinarySensorTemplate._async_render and asserts that a binary sensor whose value_template is a constant expression ({{ 42 }}) uses MATCH_ALL so that state changes in any entity (sensor.any_state) will trigger a re-render. Together, these changes ensure that entity_ids are correctly extracted from all relevant templates, that MATCH_ALL is handled properly, and that tests actually cover this behavior instead of hiding it.",
        "semantic_memory": "Template-based integrations or components that depend on dynamic data often need to register which underlying entities they should watch for state changes. When multiple templates (e.g., value, icon, image) can independently reference entities, relying on just one template (such as the value_template) to infer entity dependencies is insufficient. If any template can reference entities, the system must aggregate dependencies across all of them.\n\nA robust pattern is:\n- For each template field (value, icon, image, etc.), set its context (e.g., template.hass) before using it.\n- Call a dedicated extraction method (like extract_entities) to obtain the entities referenced by that template.\n- Aggregate these entity IDs, handling special cases such as a MATCH_ALL sentinel that indicates the template depends on any state change.\n- If configuration provides explicit entity_ids, treat those as authoritative and override auto-detected ones.\n\nTests can inadvertently mask these bugs when they use templates that reference no entities or that match all entities, because the system appears to update correctly even if entity dependency extraction is incomplete. Therefore, tests for template-driven behavior should intentionally reference specific entities and verify that changes in those entities trigger updates, while unrelated entities do not, and also explicitly test MATCH_ALL behavior.\n\nMore generally, when building systems that auto-subscribe to dependencies derived from user-defined logic, it is important to:\n- Consider all fields that can define dependencies, not just a primary one.\n- Provide a way to override auto-detection with explicit configuration.\n- Properly handle wildcards or catch-all semantics (like MATCH_ALL) in dependency tracking.",
        "procedural_memory": [
            "When a template-based entity (sensor, binary_sensor, etc.) does not update in response to expected state changes, investigate whether all relevant templates are contributing to the dependency list.",
            "Step 1: Reproduce the problem in a minimal configuration. Define a template-based entity where, for example, icon_template or entity_picture_template references a specific entity, and ensure that value_template does not reference it. Confirm that changing the referenced entityâ€™s state does not trigger updates.",
            "Step 2: Inspect the setup code for the component. Look for where entity_ids (or equivalent dependency lists) are derived. Check if it only reads from one template (e.g., value_template) and ignores others (icon_template, entity_picture_template, attribute templates, etc.).",
            "Step 3: Verify how templates are initialized. Ensure each template has its execution context set (e.g., template.hass = hass) before calling methods like extract_entities() or rendering.",
            "Step 4: Implement aggregation of dependencies. For each template field that can reference entities, perform:\n- If template is not None, set template.hass.\n- Call template.extract_entities().\n- If the result is a wildcard/MATCH_ALL sentinel, propagate that to the overall entity_ids and stop accumulating specific IDs.\n- Otherwise, union these entities into a set of dependencies.",
            "Step 5: Respect manual configuration. If the configuration allows explicit entity_ids (ATTR_ENTITY_ID or similar), check for this first or last according to design, and ensure that when manual entity_ids is provided, it overrides auto-detected dependencies.",
            "Step 6: Normalize the result. After aggregation, if the final entity_ids is not MATCH_ALL and not manually set, convert the set to a list (or the appropriate type) and store it in the entity configuration or instance.",
            "Step 7: Add or refine tests to capture the bug and prevent regressions:\n- Write tests where value_template references one entity and icon/entity_picture templates reference different entities, and assert that changes in each referenced entity trigger updates.\n- Add a test for the wildcard case (MATCH_ALL) by using a constant template and verifying that changes in arbitrary entities trigger re-rendering.\n- Avoid using constant templates in tests unless specifically testing MATCH_ALL behavior, as they can hide missing dependency extraction logic.",
            "Step 8: Run the full test suite and, if applicable, manual tests in a running instance to confirm that template-based entities now update correctly when any referenced entity changes, regardless of whether the reference is in value_template, icon_template, or entity_picture_template."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant quantum_gateway device_tracker refactor: moved QuantumGatewayScanner import from inside the QuantumGatewayDeviceScanner.__init__ method to the top of the module to comply with style guidelines and avoid in-function imports.",
        "keywords": [
            "quantum_gateway",
            "device_tracker",
            "QuantumGatewayScanner",
            "in-function import",
            "local import",
            "move imports to top",
            "Home Assistant style",
            "linting",
            "code quality"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant quantum_gateway integration (device_tracker platform), the QuantumGatewayScanner class was being imported inside the QuantumGatewayDeviceScanner.__init__ method via a local statement: `from quantum_gateway import QuantumGatewayScanner`. This violated the project's coding standards that require all imports to be at the module level and can also interfere with static analysis and tooling. The fix moved this import to the top of the file alongside the other imports (`logging`, `requests.exceptions`, `voluptuous`, etc.), and removed the in-function import from __init__. No functional behavior changed; this is a refactor to improve code quality and satisfy style/lint checks.",
        "semantic_memory": "In Python projects with strict style and tooling (like Home Assistant), imports should generally be defined at the top of the module rather than inside functions or methods. In-function imports can hide dependencies from static analyzers, make dependency management harder, and sometimes lead to subtle bugs (e.g., repeated imports, circular import workarounds, or confusing performance characteristics). Moving imports to the top-level clarifies module dependencies, supports codeowners and dependency validation tools, and aligns with common style guides (PEP8). The only typical exceptions are when conditional or optional imports are truly required, in which case they should be clearly documented.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Scan the codebase (or the specific module) for import statements inside functions, methods, or class bodies. Look for patterns like `from x import y` or `import x` that are nested within def blocks.",
            "Step 2: Determine if the import truly needs to be conditional or lazy (e.g., optional dependency, heavy module only used in rare code paths). If not, plan to move it to the top of the module.",
            "Step 3: Move the import statement to the module-level import section, typically right after the module docstring and before any other code. Maintain proper import ordering/grouping (standard library, third-party, local).",
            "Step 4: Remove the now-redundant import from inside the function or method to avoid duplicate imports and keep the function body clean.",
            "Step 5: Run the project's test suite and linting tools (e.g., tox, flake8, mypy, or project-specific checks) to ensure no new issues were introduced and that style guidelines are satisfied.",
            "Step 6: If there are circular import errors after moving the import, reassess the design: consider refactoring shared code into a new module, or—if absolutely necessary—keep a clearly documented conditional import with comments explaining why the exception is required.",
            "Step 7: Document the change in the PR description, making clear that it is a code-quality/style fix (e.g., 'Move imports to top-level for <module> to comply with project guidelines and support tooling')."
        ]
    }
}
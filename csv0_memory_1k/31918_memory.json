{
    "search_index": {
        "description_for_embedding": "Home Assistant ONVIF camera feature: add per-camera RTSP transport configuration (tcp/udp/udp_multicast/http) and plumb it through Camera.stream_options into the stream integration. RTSP streams still default to prefer_tcp via ffmpeg options, but caller-provided options are merged and can override defaults.",
        "keywords": [
            "Home Assistant",
            "ONVIF",
            "camera",
            "rtsp_transport",
            "RTSP",
            "ffmpeg options",
            "stream_options",
            "prefer_tcp",
            "TCP vs UDP",
            "configuration.yaml",
            "stream integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the integration for ONVIF cameras in Home Assistant was extended to allow users to configure the RTSP transport protocol (e.g., tcp, udp, udp_multicast, http) per camera. Previously, the stream integration would implicitly prefer TCP for RTSP streams by setting ffmpeg options (rtsp_flags=prefer_tcp, stimeout=5000000) whenever the source URL began with 'rtsp://', and individual camera entities had no way to inject their own ffmpeg options.\n\nTo implement the feature, a new configuration option 'rtsp_transport' was added to the ONVIF platform schema with allowed values ['tcp', 'udp', 'udp_multicast', 'http'] and default 'tcp'. The Camera base class was extended with a 'stream_options' dictionary, initialized in the constructor. The ONVIFCamera class then sets self.stream_options[CONF_RTSP_TRANSPORT] based on the configuration.\n\nAll call sites that request a stream for a camera (async_request_stream, preload_stream, the WebSocket camera stream handler, and the play_stream service handler) were updated to pass camera.stream_options into stream.request_stream(). In the stream component, the RTSP default behavior was refactored: for RTSP sources, an 'options' dict is now constructed as {'rtsp_flags': 'prefer_tcp', 'stimeout': '5000000', **options}. This ensures that default ffmpeg options for RTSP are applied, but any caller-provided options (including rtsp_transport) are merged in and can override defaults where keys overlap. The field on Camera was deliberately named 'stream_options' (instead of a generic 'options') to better reflect its purpose and avoid confusion.\n\nThe end result is that ONVIF cameras can now explicitly control the RTSP transport while still benefiting from the default TCP preference and timeout behavior in the stream integration. The change was tested locally, and no breaking changes to existing configuration were introduced.",
        "semantic_memory": "This change illustrates a general pattern for exposing low-level streaming or network options in a high-level integration while preserving sensible defaults:\n\n1. **Per-entity options propagation**: When a subsystem (e.g., a streaming backend) supports a variety of options (like ffmpeg flags), it's useful to have a dedicated per-entity options container (here, `Camera.stream_options`). This allows each entity to carry its own transport/connection preferences without altering the global behavior of the streaming component.\n\n2. **Configurable transport protocols**: For protocols like RTSP that support multiple transports (TCP, UDP, multicast, HTTP tunneling), exposing the transport via configuration (and constraining allowed values via validation) provides flexibility for real-world devices and network conditions, while preventing invalid or dangerous values.\n\n3. **Merging defaults with user-provided options**: A robust pattern for option handling is to define default options and then merge user-provided options in a way that lets the user override defaults when necessary. In Python, this is elegantly done via dictionary unpacking, e.g., `{**defaults, **user_options}` or the reversed order depending on which should win. In this case, defaults for RTSP (`rtsp_flags=prefer_tcp`, `stimeout=5000000`) are combined with any existing `options` so that specific keys can be overridden.\n\n4. **Consistent plumbing across call sites**: Once an entity exposes a `stream_options` attribute, every code path that initiates a stream needs to be updated to pass these options through. This includes direct service calls, WebSocket handlers, and background preloading routines. Forgetting a call site would result in inconsistent behavior where some uses respect the configuration and others do not.\n\n5. **Clear naming to reduce ambiguity**: Using a specific name like `stream_options` instead of a generic `options` helps communicate that these options are meant for the streaming backend (ffmpeg) and not for arbitrary entity configuration. Clear naming reduces confusion and collision risk with other frameworks or base classes.\n\nOverall, the fix exemplifies how to cleanly introduce a new configurable behavior that threads through config validation, entity state, and a shared subsystem, while keeping backward-compatible defaults.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the need for per-entity backend options.\n- Observe that a device integration (e.g., ONVIF camera) needs to influence low-level behavior of a shared subsystem (e.g., streaming or ffmpeg), such as transport protocol or timeouts.\n- Confirm that the shared subsystem already accepts an options structure (like an `options` dict) but that it is not currently wired from the entity configuration.",
            "Step 2: Add configuration schema for the new option.\n- Define a new constant for the configuration key (e.g., `CONF_RTSP_TRANSPORT = \"rtsp_transport\"`).\n- Extend the platform or integration schema to include this option with appropriate validation:\n  - Provide a default value.\n  - Use an `In`/enum validator to restrict allowed values (e.g., `['tcp', 'udp', 'udp_multicast', 'http']`).\n- Update examples and documentation to show how the new option is set in configuration (e.g., `rtsp_transport: udp`).",
            "Step 3: Store the option on the entity in a dedicated options dict.\n- In the entity's `__init__`, ensure there is a dedicated container for streaming/backend options (e.g., `self.stream_options = {}` in the base class).\n- In the specific integration entity (e.g., ONVIFCamera), assign the config value to that container, e.g.:\n  - `self.stream_options[CONF_RTSP_TRANSPORT] = config.get(CONF_RTSP_TRANSPORT)`.\n- Avoid using overly generic attribute names (like `options`) if they might collide with framework attributes or cause confusion; choose a specific name (`stream_options`).",
            "Step 4: Plumb options through all stream request paths.\n- Locate all code paths that initiate a stream for the entity:\n  - Generic helpers (`async_request_stream`).\n  - Background or preload routines (`preload_stream`).\n  - WebSocket handlers for live streaming.\n  - Service handlers (e.g., `play_stream`).\n- Update each of these to pass `camera.stream_options` into the streaming request function, e.g.:\n  - `request_stream(hass, source, fmt=fmt, keepalive=..., options=camera.stream_options)`. ",
            "Step 5: Merge default backend options with user-provided options.\n- In the shared subsystem (e.g., stream integration), identify where defaults are applied (such as default RTSP flags).\n- Instead of only applying defaults when no options are provided, merge defaults with the `options` dict so both are respected.\n- Use a merge strategy that clearly defines precedence. For example, to let caller-provided options override defaults:\n  - `options = {\"rtsp_flags\": \"prefer_tcp\", \"stimeout\": \"5000000\", **options}`.\n- Ensure that this logic still only applies when appropriate (e.g., when the source URL starts with `rtsp://`).",
            "Step 6: Test and verify behavior.\n- Configure devices with different values of the new option (e.g., rtsp_transport: tcp, udp).\n- Confirm that the underlying backend (ffmpeg) receives the expected options and that the stream works as intended.\n- Verify that existing configurations without the new option continue to work with default behavior (e.g., prefer TCP).",
            "Step 7: Review for consistency and maintainability.\n- Check that the new option is consistently named across config, entity attributes, and backend options.\n- Ensure there is no unused or dead code (e.g., remove any obsolete constants or variables like a no-longer-needed `PREFER_TCP` constant).\n- Consider adding or updating tests to validate that the streaming options are passed correctly and that merges produce the expected option sets."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant HomeKit integration enhancement to allow a thermostat (climate entity) accessory to expose and keep in sync a linked humidity sensor via an optional 'linked_humidity_sensor' configuration parameter. The implementation adds HomeKit characteristic mapping, entity config validation, async state tracking, and tests.",
        "keywords": [
            "Home Assistant",
            "HomeKit",
            "thermostat",
            "climate",
            "humidity",
            "linked_humidity_sensor",
            "CHAR_CURRENT_HUMIDITY",
            "async_track_state_change",
            "convert_to_float",
            "entity_config validation",
            "CLIMATE_SCHEMA",
            "homeassistant.components.homekit"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant HomeKit integration was enhanced to let a HomeKit thermostat accessory expose a humidity reading by linking it to a separate Home Assistant humidity sensor entity.\n\nPreviously, HomeKit thermostats in this integration only exposed temperature-related characteristics (current temperature, target temperature, thresholds) even though HomeKit supports an optional Current Relative Humidity characteristic on thermostats. Users with thermostats that have a separate humidity sensor could not see humidity in HomeKit through this accessory.\n\nTo address this, the developer introduced a new configuration option `linked_humidity_sensor` in `homeassistant/components/homekit/const.py` and wired it through the climate-specific configuration validation in `homeassistant/components/homekit/util.py`. A `CLIMATE_SCHEMA` was added that allows `CONF_LINKED_HUMIDITY_SENSOR` but restricts it to entities in the `sensor` domain. The general `validate_entity_config` function was updated to apply this schema when the configured entity's domain is `climate`.\n\nIn `type_thermostats.py`, the thermostat accessory class was extended:\n- A new attribute `linked_humidity_sensor` reads the configuration value.\n- If present, `CHAR_CURRENT_HUMIDITY` is added to the thermostat's characteristic list and configured on the HomeKit service.\n- An async `run_handler` method was overridden to, after the accessory driver starts, fetch the initial state of the linked humidity sensor and schedule an update, then register an `async_track_state_change` listener on the linked sensor entity.\n- A callback `update_linked_humidity` (decorated with `@ha_callback`) is invoked on state changes and schedules `update_humidity` in the executor.\n- `update_humidity` uses `convert_to_float` to safely parse the humidity value from the sensor's state; if parsing fails (non-numeric), it aborts without changing the characteristic, avoiding errors. On success, it updates `char_current_humidity` and logs a debug message.\n\nTests were added and extended:\n- `tests/components/homekit/test_type_thermostats.py` includes `test_thermostat_linked_humidity_sensor` to verify: the linked sensor is registered, the initial humidity characteristic is 0, the value is updated after `run` is called based on the current state, subsequent state changes update the characteristic, and non-numeric states do not cause errors or changes.\n- `tests/components/homekit/test_util.py` was updated to test that invalid configs (e.g., `linked_humidity_sensor` pointing to a `switch`) are rejected, and valid configs (e.g., `sensor.demo_humidity`) are accepted by `validate_entity_config`.\n\nThe PR was ultimately closed with a note that new, future functionality would solve the same problem in a different way. Nonetheless, this change set provides a clear pattern for adding optional linked sensors and extra characteristics to HomeKit accessories in Home Assistant.",
        "semantic_memory": "This case illustrates a pattern for extending a smart home integration (Home Assistant's HomeKit bridge) with optional linked sensors while respecting configuration validation, async/event-driven state updates, and robustness against bad data.\n\nKey concepts:\n1. **Linked entities for composite accessories**: A single logical accessory (e.g., a thermostat in HomeKit) may be backed by multiple Home Assistant entities (a `climate` entity for temperature control and a `sensor` entity for humidity). The integration can expose an optional configuration field (like `linked_humidity_sensor`) to connect these entities and surface a richer accessory in the target platform.\n\n2. **Characteristic-driven design**: HomeKit accessories are constructed from sets of characteristics. Adding a behavior (e.g., humidity exposure) involves defining a new characteristic constant, adding it conditionally based on configuration, and wiring it to update logic that listens to the relevant HA entity.\n\n3. **Per-domain configuration schemas**: To prevent misconfiguration, entity configurations are validated with domain-specific schemas. For climate entities, a schema that allows `linked_humidity_sensor` and constrains it to the `sensor` domain ensures users cannot accidentally point this option to arbitrary or incompatible entities.\n\n4. **Asynchronous event handling**: In Home Assistant, integrations must operate correctly within the async event loop. This fix uses `async_track_state_change` to subscribe to state changes, an `@ha_callback` function to react synchronously to these events, and `async_add_executor_job` to offload any blocking or potentially slow operations into a separate thread. The accessory-specific `run_handler` is used to initialize state and register listeners once the accessory driver is running.\n\n5. **Robust parsing and error handling**: Sensor values are strings in HA states. The `convert_to_float` helper is used to gracefully handle non-numeric values by returning `None` instead of raising exceptions. The update logic checks for `None` and early-returns to avoid corrupting the characteristic or spamming error logs.\n\n6. **Test-driven integration development**: New functionality comes with tests that verify config validation, initial state propagation, dynamic updates, and error handling. Tests simulate HA state changes for the linked sensor and assert that the HomeKit characteristic mirrors valid values and ignores invalid ones.\n\nThis pattern generalizes to any integration where a primary entity needs to expose additional capabilities driven by secondary entities (e.g., linking battery sensors, motion sensors, or remotes), especially in bridges between home automation platforms.",
        "procedural_memory": [
            "When adding optional linked sensors or extra characteristics to a composite accessory in a home automation integration (like HomeKit in Home Assistant), follow these steps to design, validate, implement, and test the feature in a robust, async-safe way.",
            "Step 1: Define a clear configuration option",
            "- Choose a descriptive and specific config key (e.g., `linked_humidity_sensor`).",
            "- Add a constant for it in the integration's constants module (e.g., `CONF_LINKED_HUMIDITY_SENSOR`).",
            "- Document the expected entity domain (e.g., `sensor`) and usage in configuration examples (e.g., `entity_config` entries).",
            "Step 2: Extend the configuration validation logic",
            "- Create or extend a domain-specific schema (e.g., `CLIMATE_SCHEMA` for climate entities) using a validation library such as `voluptuous`.",
            "- Add the new configuration option as `vol.Optional(CONF_LINKED_HUMIDITY_SENSOR): cv.entity_domain(sensor.DOMAIN)` to enforce that the linked entity is in the correct domain.",
            "- In the global validation function (e.g., `validate_entity_config`), dispatch to the domain-specific schema when the entity domain matches (e.g., `elif domain == climate.const.DOMAIN: config = CLIMATE_SCHEMA(config)`).",
            "- Add negative test cases for invalid configurations (wrong domain, wrong type, missing keys) and positive test cases for valid ones.",
            "Step 3: Wire the configuration into the accessory/entity class",
            "- In the accessory or platform entity class constructor (`__init__`), read the configuration value, e.g.: `self.linked_humidity_sensor = self.config.get(CONF_LINKED_HUMIDITY_SENSOR)`. ",
            "- Based on the presence of this config, conditionally extend the set of characteristics you add to the accessory (e.g., add `CHAR_CURRENT_HUMIDITY` if `linked_humidity_sensor` is defined).",
            "- Create and store the configured characteristic object (e.g., `self.char_current_humidity = serv.configure_char(CHAR_CURRENT_HUMIDITY, value=0)`).",
            "Step 4: Initialize and track state asynchronously",
            "- If the integration has a lifecycle hook for when the accessory is started (e.g., `async def run_handler(self)`), override it and call `await super().run_handler()` to preserve base behavior.",
            "- On startup, get the current state of the linked sensor from `self.hass.states.get(self.linked_humidity_sensor)` and schedule an update of the characteristic based on that state.",
            "- Use `async_track_state_change` to subscribe to state changes of the linked entity:",
            "  - `async_track_state_change(self.hass, self.linked_humidity_sensor, self.update_linked_humidity)`.",
            "- Define `update_linked_humidity` as an `@ha_callback` to be invoked on state change events, and use `self.hass.async_add_executor_job(self.update_humidity, new_state)` to move any synchronous processing into a thread pool.",
            "Step 5: Implement robust value parsing and characteristic updates",
            "- In the synchronous method (e.g., `update_humidity`), parse the state using a helper like `convert_to_float(new_state.state)` instead of direct casting to handle edge cases (empty strings, non-numeric values, or 'unknown').",
            "- If parsing returns `None`, exit early without modifying the characteristic or raising errors.",
            "- Otherwise, call the characteristic's `set_value` method with the parsed value (e.g., `self.char_current_humidity.set_value(humidity_value)`).",
            "- Log at debug level for traceability without polluting logs on normal operation.",
            "Step 6: Add tests to validate behavior end-to-end",
            "- Write unit tests for configuration validation to ensure that:",
            "  - Invalid linked entity domains are rejected.",
            "  - Valid linked entities are accepted and normalized.",
            "- Write integration-level tests for the accessory/entity behavior:",
            "  - Initialize the HA state for the primary entity (e.g., climate) and the linked sensor.",
            "  - Instantiate the accessory with `linked_humidity_sensor` set in config and assert that the characteristic is present and initially set to a default (e.g., `0`).",
            "  - Run the accessory (`await hass.async_add_job(acc.run)` and `await hass.async_block_till_done()`) and assert that the characteristic reflects the initial sensor state.",
            "  - Simulate state changes on the linked sensor and assert that the characteristic updates accordingly.",
            "  - Simulate a non-numeric or invalid state and assert that the characteristic remains unchanged and no errors are logged.",
            "Step 7: Ensure async and threading correctness",
            "- Keep HA callbacks lightweight and non-blocking by using `@ha_callback` for pure event handlers.",
            "- Offload potentially blocking or CPU-bound operations into executor jobs using `async_add_executor_job`.",
            "- Always call `await hass.async_block_till_done()` in tests after state changes and after scheduling jobs to ensure all callbacks have run before asserting results.",
            "Step 8: Consider future extensibility",
            "- When adding a new linked characteristic, do so in a way that can be reused for other types of linked entities (e.g., battery sensors, occupancy sensors, remotes).",
            "- Keep constants, validation schemas, and patterns consistent so future contributors can follow and extend them easily.",
            "- If the platform later introduces new built-in abstractions that solve the same problem, be prepared to replace custom linked-sensor logic with more generic mechanisms."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Somfy Tahoma cover integration: extend stop_cover behavior to send the 'my' command (favorite position) for additional Somfy RTS device types (VenetianBlind, DualCurtain, ExteriorVenetianBlind) instead of the generic stopIdentify action.",
        "keywords": [
            "Home Assistant",
            "Somfy",
            "Tahoma",
            "cover.tahoma",
            "MY position",
            "favorite position",
            "stop_cover",
            "device type mapping",
            "rts:VenetianBlindRTSComponent",
            "rts:DualCurtainRTSComponent",
            "rts:ExteriorVenetianBlindRTSComponent",
            "integration bug",
            "feature support",
            "Home Assistant cover platform"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant Somfy Tahoma cover integration, certain Somfy RTS devices did not behave correctly when issuing the stop command. The integration’s stop_cover method had logic that, for specific device types (originally only 'rts:BlindRTSComponent' and 'io:ExteriorVenetianBlindIOComponent'), sent the 'my' action to move the cover to its preset favorite position (the MY position). For all other device types it used 'stopIdentify', which does not invoke the MY behavior. Users with other Somfy RTS device variants (e.g., Venetian blinds and dual curtains) could not use the MY position via stop_cover. The fix expanded the list of device types that trigger the 'my' action to include 'rts:VenetianBlindRTSComponent', 'rts:DualCurtainRTSComponent', and 'rts:ExteriorVenetianBlindRTSComponent' (and redundantly kept 'rts:BlindRTSComponent'). Now, when stop_cover is called on these device types, Home Assistant correctly sends the 'my' command, enabling the MY favorite-position functionality instead of the generic stopIdentify action.",
        "semantic_memory": "When integrating with external device ecosystems (like Somfy Tahoma), the mapping between internal logical actions (e.g., stop_cover) and the vendor’s specific commands (e.g., 'my' vs. 'stopIdentify') must be carefully aligned with each supported device type. Many ecosystems expose multiple device type identifiers for similar physical behaviors (blinds, curtains, venetian blinds) that should share the same command semantics. Failing to account for all relevant device type identifiers can result in inconsistent user experiences where some devices support a feature (like a favorite MY position) and others do not, even though the hardware is capable. A robust integration typically centralizes and enumerates these device-type-to-command mappings and tests behavior across all known variants. Extending feature support often means auditing all device-type strings, consulting vendor documentation, and updating conditional logic to ensure all appropriate types receive the same specialized command instead of a generic fallback.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the inconsistent behavior: Observe that some devices in a family (e.g., Somfy blinds vs. venetian blinds) respond differently to a given logical action (like stop_cover), especially for advanced features such as favorite/MY positioning.",
            "Step 2: Inspect the integration’s code: Locate the method handling the action (e.g., stop_cover in the Tahoma cover platform) and look for conditionals keyed on device type identifiers or capabilities.",
            "Step 3: Enumerate device types: From logs, configuration, or vendor APIs, list all device type identifiers that correspond to the physical devices exhibiting the problem (e.g., 'rts:VenetianBlindRTSComponent', 'rts:DualCurtainRTSComponent').",
            "Step 4: Compare mappings: Check which device types currently receive special handling (e.g., 'my' command) and which fall through to a generic action (e.g., 'stopIdentify'). Determine whether the devices lacking the feature should logically use the same special command.",
            "Step 5: Consult vendor documentation: Verify that the additional device types support the desired command (e.g., that these Somfy RTS device variants expose the MY/favorite position via the 'my' action).",
            "Step 6: Update the conditional logic: Extend the set/tuple/list of device types associated with the special command so that all appropriate types trigger the correct action. For example, add 'rts:VenetianBlindRTSComponent', 'rts:DualCurtainRTSComponent', and 'rts:ExteriorVenetianBlindRTSComponent' to the condition that calls apply_action('my').",
            "Step 7: Avoid duplication and centralize mappings: Where possible, move device-type constants into a shared collection or mapping (e.g., FAVORITE_POSITION_TYPES = {...}) to avoid subtle errors and make future extensions easier.",
            "Step 8: Test locally: Use real devices if available or mocks to confirm that all targeted device types now perform the correct behavior (moving to MY/favorite position) when the logical action is triggered. Verify that other device types still behave correctly.",
            "Step 9: Add or update tests: Create or modify unit/integration tests to cover each device type and ensure the correct command (e.g., 'my' vs. 'stopIdentify') is sent. This prevents regressions as new device types are added later.",
            "Step 10: Document behavior: Update user-facing documentation (if applicable) to state which devices support the special behavior (like MY position) so users know what to expect and can verify correct operation."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix to allow Home Assistant scripts/automations to use complex Jinja templates inside dict-based delay configurations (e.g., delay: { seconds: '{{ ... }}' }). The change expands the config schema and runtime delay handling to accept and render template dictionaries, enabling dynamic milliseconds/days etc. and aligning dict-based delays with string-based delay templates.",
        "keywords": [
            "Home Assistant",
            "script delay",
            "automation delay",
            "complex template",
            "template_complex",
            "Jinja templates",
            "time_period",
            "voluptuous schema",
            "configuration validation",
            "dict-based delay",
            "render_complex",
            "dynamic delay"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant users could use Jinja templates when specifying a delay as a single time string (e.g., `- delay: \"00:00:{{ ... }}\"`), but not when using the recommended dict-based syntax (e.g., `- delay: { seconds: \"{{ ... }}\" }`). The config schema for scripts only allowed `delay` to be either a `time_period`/`positive_timedelta` or a single template, but not a dictionary of templates. Runtime logic in `helpers/script.py` only handled the case where `delay` was a `template.Template` string and did nothing special if the delay was a dict, so templated fields inside the dict were never rendered, causing config validation or runtime errors.\n\nTo fix this, the developer updated `SCRIPT_SCHEMA` in `homeassistant/helpers/config_validation.py` so that `delay` accepts three forms: a validated time period, a single template, or a `template_complex` structure (i.e., a dict whose values are templates). The schema change went from `vol.Any(vol.All(time_period, positive_timedelta), template)` to `vol.Any(vol.All(time_period, positive_timedelta), template, template_complex)`. On the runtime side, in `homeassistant/helpers/script.py`, the delay handling was extended: if `delay` is a `template.Template`, it is rendered and validated as before; if `delay` is a `dict`, the code now uses `template.render_complex(delay, variables)` to render all templated fields, populates a new `delay_data` dict, and converts that to a `timedelta` via `cv.time_period(delay_data)`. An initial use of `collections.Mapping` for type checking was simplified to a plain `dict` check.\n\nTwo tests were added in `tests/helpers/test_script.py`: `test_delay_complex_template` verifies that a delay with `{'seconds': '{{ 5 }}'}` pauses execution for 5 seconds and then fires the second event. `test_delay_complex_invalid_template` verifies that if a complex template fails (`'{{ invalid_delay }}'`), an error is logged and the script stops without hanging, and the subsequent valid delay is not executed. This ensures both successful dynamic dict-based delays and graceful handling of invalid templates. After these changes, dict-based delays support complex templates for milliseconds, seconds, minutes, hours, and days, aligning behavior with string-based delay templates and making the configuration consistent and more powerful.",
        "semantic_memory": "This fix illustrates a common pattern in configuration-driven systems with templating:\n\n1. **Feature parity between configuration forms:** When an API or configuration supports multiple syntaxes for the same concept (like string vs dict delays), they should share capabilities. If only one path supports templating, users experience confusing limitations. Ensuring parity often requires updating both the validation layer and runtime handling.\n\n2. **Schema and runtime must align:** Voluptuous (or any schema validator) needs to describe all supported shapes, including templated variants. At the same time, runtime code must correctly interpret those shapes: render any templates, then convert the result into internal types. Forgetting either step creates subtle bugs or inconsistent behavior.\n\n3. **Complex templating in structured data:** Allowing templates inside a dict (e.g., fields like `seconds`, `minutes`, `days`) is more powerful than only templating entire strings. Implementations typically use a `template_complex`-style helper and a `render_complex` function that traverses nested data and renders template values, then passes the rendered data into standard converters.\n\n4. **Error handling for templated configuration:** When templates fail to render, the system should log clear error messages and fail gracefully rather than leaving processes in an indeterminate state. Tests should verify how errors are logged and how execution proceeds after a failure.\n\n5. **Type checks for templated structures:** When extending behavior based on input type, use robust type checks. For dict-based templates, checking for `dict` or a known schema is safer than broad interfaces like `Mapping` if your code assumes concrete dict behavior (e.g., serialization, mutation).\n\nThese patterns generalize to any system where user configuration supports interpolation or templating within structured objects, not just Home Assistant scripts.",
        "procedural_memory": [
            "When you need to support dynamic templating inside structured configuration (e.g., dicts for time periods, payloads, or options), you must update both the validation schema and runtime processing to recognize and render those templates.",
            "Step 1: Identify the config field and supported shapes.\n- Locate the schema definition (e.g., Voluptuous `Schema` for `SCRIPT_SCHEMA`).\n- Determine what shapes are currently allowed (e.g., a time object, a string template) and what new shapes you need (e.g., dict of templates).",
            "Step 2: Extend the validation schema to accept complex templates.\n- If using Voluptuous, add an additional alternative to the `vol.Any(...)` or similar construct.\n- For example, change something like:\n  - `vol.Required('delay'): vol.Any(vol.All(time_period, positive_timedelta), template)`\n  to:\n  - `vol.Required('delay'): vol.Any(vol.All(time_period, positive_timedelta), template, template_complex)`\n- Ensure that `template_complex` (or equivalent) is defined to represent dicts/lists containing templates.",
            "Step 3: Update runtime logic to handle the new shape.\n- Find the code that consumes the config field at runtime (e.g., delay handling in a script executor).\n- Add type-handling branches:\n  - If value is a simple template, render it and pass to the existing converter.\n  - If value is a dict (or complex structure), call a helper like `render_complex` with the current variables/context to render all template fields.\n  - After rendering, pass the result into the same conversion function you use for static data (e.g., `time_period` -> `timedelta`).\n- Example pattern:\n  - `if isinstance(delay, template.Template): delay = cv.time_period(delay.async_render(vars))`\n  - `elif isinstance(delay, dict): rendered = template.render_complex(delay, vars); delay = cv.time_period(rendered)`",
            "Step 4: Implement robust error handling.\n- Wrap template rendering and conversion in try/except blocks.\n- Catch template rendering errors and schema/conversion errors (e.g., `TemplateError`, `vol.Invalid`).\n- Log a clear error message including the context (script name, field name) so users can fix their configuration.\n- Decide whether to abort the current action or the whole script/flow; avoid leaving processes partially scheduled.",
            "Step 5: Add tests for both success and failure paths.\n- Write a test using a valid complex template (e.g., `{'seconds': '{{ 5 }}'}`) and verify behavior:\n  - Execution pauses for the expected duration.\n  - Events before and after the delay occur in the right order.\n- Write a test using an invalid complex template (e.g., undefined variable) and verify:\n  - An error is logged.\n  - The script does not hang or proceed incorrectly.\n  - Overall state is consistent with your failure policy (e.g., script stops, last event fired, etc.).",
            "Step 6: Ensure type checks are appropriate.\n- Use `dict` (or a precise type) when you specifically expect a dictionary, rather than a broad interface like `collections.Mapping`, unless your code genuinely supports any mapping.\n- This avoids unexpected behavior in tests or in user code that passes custom mapping types.",
            "Step 7: Document the new capability.\n- Update user documentation to show examples of using templates inside dict-based configurations (e.g., dynamic seconds, minutes, days, milliseconds).\n- Explicitly note that both string-based and dict-based forms now support templating so users can choose the more expressive form."
        ]
    }
}
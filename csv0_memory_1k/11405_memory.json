{
    "search_index": {
        "description_for_embedding": "Home Assistant apple_tv media_player integration was emitting 5–6 state_changed events per second while playing, due to frequent play status updates. A PR attempted to rate-limit the playstatus_update callback using the ratelimit library, but maintainers rejected it as a hack that masked the real issue. The correct fix is to adjust how media_position_updated_at and play status events are generated (likely in pyatv) so that only meaningful state changes (e.g., playing/paused/stopped) trigger updates, rather than every timestamp or metadata change.",
        "keywords": [
            "apple_tv",
            "pyatv",
            "homeassistant.components.media_player.apple_tv",
            "media_player",
            "media_position_updated_at",
            "state_changed event spam",
            "rate limiting callbacks",
            "ratelimit dependency",
            "excessive logging",
            "play status updates"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant apple_tv media_player integration was causing excessive state_changed events, logging roughly 5–6 updates per second when media was playing. The log samples showed that most updates differed only in media_position_updated_at (and sometimes media_position) while the rest of the state (title, duration, etc.) stayed the same. A contributor proposed a PR that introduced a new dependency, ratelimit==1.4.1, and decorated the playstatus_update callback in homeassistant/components/media_player/apple_tv.py with @rate_limited(1) to restrict updates to once per second. This change reduced log spam but was criticized by core maintainers for several reasons: it masked the underlying problem instead of fixing it, could drop legitimate updates, introduced an unnecessary global dependency (and was not fully wired into Home Assistant's REQUIREMENTS mechanism), and violated the intended semantics of media_position_updated_at. The maintainers clarified that media_position_updated_at should only change when the media player state (playing/paused/stopped) changes, not on every status update, and that spurious updates should be filtered in the underlying pyatv library or apple_tv integration rather than rate-limited at the Home Assistant layer. They requested debug logs from pyatv (with pyatv.net and pyatv.daap set to debug) to inspect the raw events and determine why the Apple TV (notably in YouTube and iTunes apps) was sending such frequent updates. The PR was ultimately closed with the instruction that the root cause (likely in pyatv’s metadata/time-change events and how media_position_updated_at is handled) must be fixed instead of adding a rate-limiting workaround.",
        "semantic_memory": "When an integration generates very frequent state updates (e.g., several per second), blindly rate-limiting callbacks at the top level is a risky workaround. It can hide the real problem and may drop legitimate events. For entity frameworks like Home Assistant, certain fields have specific semantics: for example, media_position_updated_at should typically represent the moment when playback state changed (e.g., transitioned from paused to playing) so that the frontend can extrapolate progress locally, not the moment of every poll or metadata refresh. If underlying hardware or libraries send frequent updates where only a timestamp or minor metadata changes, those should be filtered or coalesced in the integration or the upstream library itself, rather than rate-limited at the application layer. Additionally, introducing new dependencies just to support such a workaround is undesirable in large projects: it increases maintenance cost and should only be done when the solution is conceptually correct, not for stopgap patches. A better approach is to: (1) log and inspect the low-level events (e.g., debug logging of protocol/libraries), (2) identify which fields actually change, and (3) adjust the event generation logic so updates are only emitted when meaningful state changes occur (like play/pause/stop or track changes). Rate limiting may still be useful in some cases, but it should be applied with awareness of event semantics, not as a blanket fix for noisy logs.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Confirm the symptom: Identify that an entity (e.g., media_player.apple_tv) is generating unusually frequent state_changed events or log entries (multiple times per second) without meaningful state changes.",
            "Step 2: Inspect entity state deltas: Compare old_state and new_state across consecutive events to see which fields are changing. Pay special attention to timestamps (like media_position_updated_at), positions, and metadata (title, duration, etc.).",
            "Step 3: Enable low-level debug logging: Turn on debug logging for the underlying library or protocol (e.g., pyatv.net and pyatv.daap for Apple TV) to capture the raw events/packets the integration receives.",
            "Step 4: Correlate raw events with state changes: Map each high-level state_changed event to the underlying raw event. Determine whether the device/library is actually sending a new meaningful state, or only trivial changes (e.g., a monotonically increasing time value).",
            "Step 5: Revisit field semantics: Check how fields like media_position, media_position_updated_at, or similar timestamps are supposed to be used. Ensure that timestamps represent state transitions (e.g., when playback starts/resumes) rather than every periodic status poll. Adjust the code to only update those fields when the corresponding semantic event occurs (e.g., play→paused, paused→playing, stopped, or track change).",
            "Step 6: Fix event generation at the correct layer: If the underlying library (e.g., pyatv) is publishing too many events, add logic there to suppress or merge events that do not represent meaningful state changes. If the integration is misinterpreting the events (e.g., updating media_position_updated_at for every metadata refresh), fix that logic instead of wrapping it in a rate limiter.",
            "Step 7: Avoid workaround rate limiting in core callbacks: Resist the urge to add decorators or throttling (like @rate_limited(1)) at top-level callbacks for state updates, especially if it requires new dependencies. Such rate limiting can drop real changes and obscures the root cause. Use it only when you have validated that events beyond a given rate are truly redundant and semantically safe to ignore.",
            "Step 8: Validate with tests and logs: After adjusting event filtering/semantics, re-run with debug logs and verify that (a) log spam is reduced, (b) the UI still reflects accurate media position and state changes, and (c) integration tests or tox tests pass.",
            "Step 9: Handle dependencies properly if absolutely needed: If you ultimately decide rate limiting is the correct design, choose a lightweight approach and integrate dependencies according to project guidelines (e.g., add to REQUIREMENTS and requirements_all.txt, import only where used). But prefer protocol-level or integration-level semantic fixes over library-level throttling."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant LimitlessLED lights: turning them off via Home Assistant applied a fade-out transition to 0% brightness before sending the off command. This caused bulbs to remember a very low brightness and, when later toggled by a wall switch, they turned back on at minimum brightness. The fix introduced a per-group boolean 'fade' configuration (default false) that controls whether a fade-out transition is applied before turning the lights off, making transitions opt-in instead of always on.",
        "keywords": [
            "Home Assistant",
            "LimitlessLED",
            "MiLight",
            "light component",
            "fade out behavior",
            "brightness reset",
            "pipeline.transition",
            "hardware internal state",
            "configuration option",
            "boolean fade",
            "breaking change",
            "UX issue with physical switch",
            "homeassistant.components.light.limitlessled"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's LimitlessLED (MiLight) integration always applied a fade-out transition when turning lights off. Specifically, the `turn_off` logic used the pipeline to transition brightness to 0.0 and then called `off()`. Many LimitlessLED bulbs internally remember the last 'on' brightness, so this sequence made the bulb's stored 'on' state equal to minimum brightness. As a result, if a user turned off a light via Home Assistant (which faded to 0%) and later toggled the power using a wall switch, the bulb would turn back on at a very dim brightness, which was frustrating and confusing.\n\nThere was prior history: transitions were added to avoid a different UX problem (100%-on flashing briefly when turning on at low brightness). However, users reported that the fade-out behavior caused more practical issues when mixing Home Assistant control with physical switches or vendor apps. Discussion among maintainers concluded that the fade-out should become configurable rather than hard-coded.\n\nThe PR implemented a per-group `fade` option. Initially proposed as an enum (`none`/`out`), it was refined to a boolean for simplicity: `fade: true` means apply a fade-out transition before turning off; `fade: false` (the new default) means turn off immediately without altering brightness. The configuration schema was updated (with `CONF_FADE`, default `False`), and that config is passed into each `LimitlessLEDGroup` (and its subclasses). The `turn_off` method was changed from always doing `pipeline.transition(transition_time, brightness=0.0).off()` to conditionally do `pipeline.transition(..., brightness=0.0)` only when `fade` is enabled, and always follow with `pipeline.off()`. Voluptuous defaults are relied upon, so there is no manual fallback to the default in code. This change is marked as a breaking change because fade transitions are now opt-in instead of always applied.\n\nThe net result: by default, LimitlessLED lights now turn off without a Home Assistant-managed fade-out, preserving the bulb's previous brightness state so that manual wall switch toggles restore a normal brightness. Users who like the old smooth fade behavior can re-enable it per group via `fade: true` in configuration.",
        "semantic_memory": "This case illustrates several generalizable patterns when integrating with hardware that maintains internal state:\n\n1. **Automatic transitions can interfere with device state semantics**: Applying a fade-out by setting brightness to 0 before powering off seems visually pleasing, but for devices that persist their last 'on' brightness, it effectively overwrites the remembered usable brightness with zero/minimum. Any other controller (wall switch, vendor app, different automation system) that later turns the device on will see the side effects of the integration's transition logic.\n\n2. **User experience across multiple controllers matters more than a single nice effect**: In home automation, devices are often controlled from many places (physical switches, native apps, automation hubs). An integration that optimizes for a smooth UI effect (fade) but breaks expected behavior when the device is used outside that integration leads to confusion. Defaults should respect the most common, intuitive expectations across all control pathways.\n\n3. **Transitions and pipelines should be opt-in when they affect stateful hardware**: A default transition applied to every command can be surprising and have non-obvious side effects on hardware state. Making such behavior explicitly configurable (e.g., a `fade` boolean) keeps the default behavior simple and predictable, while still allowing advanced users to enable the richer behavior.\n\n4. **Configuration granularity matters**: The fade behavior is configured per group, not globally. That allows users to tailor behavior depending on how each group of lights is physically wired and used (some behind relays, some only controlled via Home Assistant, etc.). Per-entity configuration is a useful pattern when hardware environments differ.\n\n5. **Let validation libraries enforce defaults**: Using a schema/validation library (like voluptuous) to specify defaults simplifies code. Once the schema declares `vol.Optional(CONF_FADE, default=False): cv.boolean`, consuming code can safely access `group_conf[CONF_FADE]` without redundant fallback logic.\n\n6. **Consider both types of regressions when changing behavior**: The initial introduction of transitions fixed one UX defect (on-flash at 100% before fading) but introduced another (lights coming back on dim after a physical switch toggle). Evaluating which behavior is more problematic, and then making the more opinionated behavior opt-in, is a good strategy to minimize breaking changes while allowing flexibility.\n\n7. **Document and flag breaking changes where defaults change**: Changing from 'always fade' to 'no fade unless configured' breaks prior expectations. Explicitly marking such a PR as a breaking change and updating documentation ensures downstream users know they may need to update configurations if they relied on the old default behavior.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and characterize the symptom\n- Observe the real-world behavior: e.g., lights turned off via the integration come back on at unexpected brightness when toggled by a physical switch.\n- Try sequences that involve both the integration and other controllers (vendor app, hardware switches, other hubs) to see how state persists across them.",
            "Step 2: Inspect integration logic for transitions and state mutation\n- Locate the code paths for `turn_on` and `turn_off` (or equivalent) in the integration.\n- Look for any transition or animation logic (e.g., pipelines, `transition()`, fade-to-zero commands) that modify brightness or other state before sending the final on/off command.\n- Check if these transitions are unconditional (applied on every command) and how they relate to the hardware's internal state behavior.",
            "Step 3: Understand device state semantics\n- Consult device documentation or test directly to see what the hardware remembers when turning off: does it persist last brightness, color, temperature, etc.?\n- Experiment: set brightness to different levels, then power-cycle via hardware, and observe what level it resumes at.\n- Determine if sending brightness=0 (or similar) before `off` changes what the device considers its 'last on' state.",
            "Step 4: Identify the conflicting behavior\n- Map the software's transition behavior to what the hardware does. For example, software sets brightness to 0, then off; hardware stores brightness=0 as the last on state, causing dim-on on next power toggle.\n- Decide which behavior is more desirable as a default from a user standpoint, considering multi-controller usage.",
            "Step 5: Design a configuration-based solution\n- Introduce a configuration option that controls the transition behavior (e.g., a per-entity `fade` boolean or a `transition` policy).\n- Default to the most intuitive and least surprising behavior (e.g., no fade, preserve last usable brightness).\n- Ensure the configuration is defined in the schema/validation layer with clear defaults (e.g., `vol.Optional('fade', default=False): cv.boolean`).",
            "Step 6: Implement the conditional logic\n- Pass the configuration into the relevant entity/group classes when constructing them.\n- Update the `turn_off` (and possibly `turn_on`) methods to apply transitions only when the config option is enabled. For example:\n  - Before: `pipeline.transition(transition_time, brightness=0.0).off()` (always fades)\n  - After: `if self.config['fade']: pipeline.transition(transition_time, brightness=0.0); pipeline.off()`\n- Keep off/on commands themselves (`off()`, `on()`) unconditional to ensure deterministic state changes.",
            "Step 7: Clean up defaults and validation\n- Remove redundant fallback-to-default logic in code if the validation library already applies defaults, and use direct indexing (`group_conf[CONF_FADE]`) for clarity.\n- Ensure all new config options are documented and validated to prevent runtime errors from malformed configs.",
            "Step 8: Test across scenarios\n- Test with `fade` disabled (default): verify that turning off via the integration does not alter the device’s stored brightness and that toggling via wall switch restores expected brightness.\n- Test with `fade` enabled: confirm that the visual fade-out works and note any remaining quirks (e.g., flash on turn-on) are acceptable to users who opt into this behavior.\n- If possible, test across device versions (e.g., v5 vs v6 bridges) because built-in device transitions may differ.",
            "Step 9: Communicate and document the breaking change\n- Clearly note that transitions/fade behavior is now opt-in instead of default, as this may change the perceived behavior for existing users.\n- Update user-facing documentation with examples of how to enable or disable fade per group/entity.\n- In release notes, explain the rationale: improved compatibility with physical switches and other controllers.",
            "Step 10: Generalize for future work\n- When adding fancy UX features (animations, transitions, auto-dimming) to device integrations, always:\n  - Check how they interact with the device’s persistent state.\n  - Provide configuration controls for non-trivial behavior.\n  - Prefer conservative defaults that match typical hardware expectations and multi-controller setups."
        ]
    }
}
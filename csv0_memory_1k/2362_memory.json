{
    "search_index": {
        "description_for_embedding": "Fix for napari octree/tiled image RGB rendering being broken due to an incorrect blanket dtype conversion to float32 before passing textures to vispy/OpenGL. Introduces a shared fix_data_dtype helper that enforces vispy-compatible texture dtypes (int8/uint8/int16/uint16/float32) and uses it in both the standard image layer and experimental octree texture atlas, plus tests for tiled RGB and contrast limit behavior.",
        "keywords": [
            "napari",
            "vispy",
            "octree",
            "tiled image",
            "rgb rendering bug",
            "dtype conversion",
            "texture_dtypes",
            "fix_data_dtype",
            "OpenGL texture",
            "multiscale image",
            "uint8",
            "float32",
            "contrast_limits",
            "experimental renderer"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the napari experimental octree/tiled image renderer started displaying RGB data incorrectly. The regression was introduced in a previous PR where the image tile data passed to vispy was always cast to float32. While this didn't immediately fail, it broke the expected behavior for RGB uint8 textures used by the tiled octree renderer. The symptoms were incorrect RGB rendering in multiscale tiled images: a uniform gray RGB image did not appear as the expected gray when rendered via the octree backend.\n\nInvestigation showed that the texture pipeline had duplicated and inconsistent logic for dtype handling: vispy_image_layer defined its own `texture_dtypes` list and casting logic, while the experimental `texture_atlas` simply cast all data to `np.float32`. This blanket cast changed the dtype of RGB tiles from uint8 to float32, which was not aligned with how vispy/OpenGL textures are expected to be provided and could lead to misinterpretation or unexpected visual results.\n\nTo fix this, a new utility function `fix_data_dtype` was added to `napari/_vispy/utils_gl.py`. It defines a single canonical list of allowed texture dtypes (`int8`, `uint8`, `int16`, `uint16`, `float32`) and ensures that any incoming NumPy array is either left as-is if already in an allowed type, or safely cast based on its `dtype.kind` (integers to `int16`/`uint16`, floats to `float32`, booleans to `uint8`). Unsupported dtypes raise a clear `TypeError`.\n\n`fix_data_dtype` is then used in two places:\n- In `vispy_image_layer._set_node_data`, replacing the previous ad hoc `texture_dtypes` logic and the `_data_astype` helper.\n- In the experimental `texture_atlas.add_tile`, replacing the unconditional `data.astype(np.float32)` and ensuring octree tiles use a vispy-compatible dtype while preserving uint8 RGB data.\n\nTests were updated/added in `test_vispy_tiled_image.py` to verify that:\n- Multiscale tiled RGB data (uint8, value 128) renders as a gray center pixel with black borders in a screenshot (`test_tiled_rgb`).\n- Changing contrast limits on tiled scalar data correctly changes the visual output (`test_tiled_changing_contrast_limits`).\n\nDue to environment constraints (the `NAPARI_OCTREE` env var cannot be dynamically set during the test run), the new/updated tests are marked with `@pytest.mark.skip`, but they pass locally and serve as regression checks for the rendering logic.",
        "semantic_memory": "This fix highlights several general principles about handling image data dtypes in GPU/visualization pipelines:\n\n1. **GPU / library texture dtype constraints must be respected.** Visualization backends like vispy/OpenGL only support a limited set of dtypes for textures. Passing arbitrary NumPy dtypes will either fail or render incorrectly. You must enforce a supported set (e.g., int8, uint8, int16, uint16, float32) at the boundary where data enters the rendering library.\n\n2. **Avoid blanket casting of image data.** Unconditionally converting all incoming data to a single dtype (e.g., float32) seems convenient but can break semantics, especially for RGB/RGBA or other special formats that are conventionally uint8. It can also add unnecessary overhead. Casting should be intentional and informed by the library's requirements and the data's role.\n\n3. **Centralize dtype handling logic.** Having multiple modules implement their own lists of allowed dtypes and conversion rules leads to inconsistency and bugs when one place changes and the other doesn't. A single shared helper (like `fix_data_dtype`) used across all rendering paths ensures consistency and makes future changes easier and safer.\n\n4. **Use dtype.kind and mapping to generalize conversions.** Instead of hard-coding conversions for every possible dtype, use `dtype.kind` (e.g., 'i', 'u', 'f', 'b') to map whole families of dtypes (all ints, all floats, booleans) to canonical GPU-friendly types. This makes the code more robust to new or uncommon dtypes.\n\n5. **Test visual behavior, not just numerical operations.** Bugs in rendering pipelines may not throw exceptions; they manifest as wrong pixels. Automated screenshot-based tests that assert on pixel colors at key locations (center, borders) are effective at catching regressions in rendering behavior, especially for RGB vs. scalar, multiscale, and contrast limit interactions.\n\n6. **Account for environment-dependent rendering features.** Experimental features toggled by env vars (like `NAPARI_OCTREE`) can complicate testing. Where dynamic env configuration is not possible in CI, tests may need to be conditionally skipped but still exist as documented regression tests and for local verification.\n\n7. **Prefer clear errors for unsupported dtypes.** When encountering a truly unsupported dtype, failing fast with a clear `TypeError` and a list of supported dtypes is better than attempting to guess a conversion that may silently distort data.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the visual bug.\n- Create the smallest possible example that triggers the rendering issue (e.g., a simple viewer with a single RGB or scalar image layer).\n- Use consistent, well-known values (like 0, 128, 255) so you can easily reason about what the output pixels should look like.\n- Capture the screen or use a screenshot API to get pixel data for assertions.",
            "Step 2: Inspect the data and dtype along the pipeline.\n- Inspect the original array's `shape`, `dtype`, and value range at the point of layer creation.\n- Trace where the data is passed from the high-level layer (e.g., napari Image layer) to the renderer (e.g., vispy node, texture atlas).\n- Log or breakpoint to check `dtype` just before the call to the rendering library (e.g., vispy's Texture2D or similar). Look for unexpected casts (e.g., uint8 -> float32).",
            "Step 3: Check library dtype requirements.\n- Consult the documentation for the rendering backend (e.g., vispy/OpenGL textures) to determine which dtypes are supported for textures.\n- Enumerate a canonical set of allowed dtypes (e.g., int8, uint8, int16, uint16, float32 for textures).",
            "Step 4: Centralize dtype normalization logic.\n- Implement a helper function, similar to `fix_data_dtype(data: np.ndarray) -> np.ndarray`, that:\n  - Accepts a NumPy array.\n  - Checks if `data.dtype` is in the allowed set; if so, returns the data unchanged.\n  - Otherwise, uses `dtype.kind` (e.g., 'i', 'u', 'f', 'b') to map entire families of dtypes to canonical texture types (e.g., ints -> int16/uint16, floats -> float32, bool -> uint8).\n  - Raises a clear `TypeError` for unsupported or non-numeric kinds.\n- Keep this helper in a shared module (e.g., a `utils_gl` or `rendering_utils`) that can be imported by all renderer components.",
            "Step 5: Replace ad hoc casting with the shared helper.\n- Search the codebase for all places where image data is cast before rendering (e.g., `.astype(np.float32)` or bespoke conversion logic).\n- Replace these with calls to your centralized `fix_data_dtype` (or equivalent) function.\n- Remove duplicated `texture_dtypes` lists and local conversion helpers to avoid future drift.",
            "Step 6: Add or update regression tests focusing on visual outputs.\n- Write tests that create representative layers (e.g., multiscale RGB, scalar with contrast limits) under the problematic renderer (e.g., octree/tiled).\n- Use a known viewer size and wait for rendering to complete (using waits or signals as appropriate).\n- Take a screenshot and assert on specific pixels (center, borders) having the expected RGBA values.\n- For dynamic behaviors (e.g., changing contrast limits), assert that the screenshot changes accordingly after the update.",
            "Step 7: Handle environment-dependent rendering features in tests.\n- If the renderer is enabled via an environment variable (e.g., `NAPARI_OCTREE=1`), use test fixtures or monkeypatching to set it where possible.\n- If CI cannot support dynamic env changes, mark tests as skipped with a clear reason, but maintain them for local regression testing.\n- Document any limitations so future maintainers understand why the tests are skipped.",
            "Step 8: Validate performance and behavior with different dtypes.\n- Test with common dtypes: uint8 RGB, uint16 scalar, float32 images, and float64 inputs.\n- Confirm that:\n  - Supported dtypes are not unnecessarily cast (no unexpected copies).\n  - Unsupported dtypes either convert predictably to a canonical type or raise clear errors.\n  - Visual output matches expectations across these cases.",
            "Step 9: Monitor for regressions and keep dtype rules in one place.\n- When adding new rendering paths or backends, always route their dtype handling through the centralized helper.\n- If the backend library's supported dtypes change, update the helper in one place and re-run the visual tests to ensure consistency."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Z-Wave integration change: introduce a per-node entity (zwave.<node_name>) that tracks node status (Ready/Sleeping/Dead, query stage, awake/failed, capabilities, neighbors, battery level, wakeup interval, etc.), move location/battery/wakeup attributes from individual platform entities (sensors, locks, etc.) to this node entity, add a shared ZWaveBaseEntity with debounced state updates, adjust Z-Wave discovery schemas, and remove dedicated Z-Wave battery sensor entities to reduce entity count.",
        "keywords": [
            "homeassistant",
            "home-assistant",
            "zwave",
            "Z-Wave",
            "node entity",
            "per-node entity",
            "battery sensor removal",
            "battery_level attribute",
            "wakeup_interval",
            "location attribute",
            "ZWaveBaseEntity",
            "debounced updates",
            "dispatcher",
            "SIGNAL_NODE",
            "SIGNAL_NOTIFICATION",
            "openzwave",
            "entity explosion",
            "performance",
            "discovery_schemas"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set for Home Assistant's Z-Wave integration, a new concept of a per-node entity was introduced. Previously, Z-Wave only exposed entities corresponding to specific values (lights, sensors, locks, etc.), and some per-device attributes like battery level, wakeup interval, and location were duplicated as attributes on many of those entities. Additionally, there was a dedicated Z-Wave battery sensor entity, increasing the total number of entities per device.\n\nThe goal of the PR was to create a single entity per physical Z-Wave node (e.g., `zwave.fibaro`), whose primary role is to represent the node's lifecycle and static attributes. The new `ZWaveNodeEntity` class exposes state such as Ready/Sleeping/Dead and query stage, and attributes like `node_id`, `is_awake`, `is_ready`, `is_failed`, `is_info_received`, `max_baud_rate`, `is_zwave_plus`, capabilities, neighbors, `battery_level`, and `wake_up_interval`. It also picks up the node's location. The entity is now visible by default in the UI (reversing the original idea of hiding it), and can be hidden/ignored via standard configuration.\n\nTo avoid duplicated logic around scheduling state updates for Z-Wave entities, a new base class `ZWaveBaseEntity` was created. It encapsulates a `maybe_schedule_update` method and a small debounce mechanism via `_schedule_update`, which ensures that rapid consecutive value changes are coalesced into a single delayed `async_update_ha_state` call. `ZWaveDeviceEntity` (the existing per-value entity used for lights/sensors/etc.) was refactored to inherit from this base class and to call `maybe_schedule_update()` inside its value change handler instead of containing its own scheduling logic.\n\nThe integration's main module (`zwave/__init__.py`) was updated to:\n- Use a centralized `DOMAIN` constant from `zwave.const`.\n- Use a shared `node_name` utility for consistent naming and slugification of nodes.\n- Create an `EntityComponent` for the Z-Wave domain and register a `node_added` callback listening to `ZWaveNetwork.SIGNAL_NODE_ADDED`, which instantiates and registers a `ZWaveNodeEntity` for each node (unless marked ignored in `device_config`).\n- Adjust `ZWaveDeviceEntityValues` and discovery logic to work with a unified `DISC_VALUES` schema instead of separate `DISC_NODE_VALUES`/`DISC_INSTANCE_VALUES`.\n\nThe discovery schemas were simplified: `DISC_INSTANCE_VALUES` and `DISC_NODE_VALUES` were collapsed into a single `DISC_VALUES` map, and all platform schemas (binary_sensor, climate, cover, light, lock, sensor, switch) were updated accordingly. This also removed the explicit association of battery-related values with individual entities, since battery is now served off the node entity.\n\nAn important behavioral change is the removal of Z-Wave battery sensor entities. The Z-Wave sensor platform's `get_device` function no longer treats `COMMAND_CLASS_BATTERY` as a separate sensor and no longer creates `ZWaveSensor` devices for it. Instead, the battery level is exposed solely as an attribute on the node entity (`battery_level`). All tests related to battery sensors were removed from `tests/components/sensor/test_zwave.py`, and the discovery schemas stopped listing `COMMAND_CLASS_BATTERY` as a trigger for sensor discovery.\n\nTo support the new behavior and guard against regressions, a comprehensive test suite was added for `node_entity`:\n- Tests for `ZWaveBaseEntity` ensure that `maybe_schedule_update()` schedules exactly one update even if called multiple times in quick succession. The test replaces `loop.call_later` with `call_soon` to make the scheduling deterministic and uses a mock `async_update_ha_state` to verify it is called once.\n- Tests for `ZWaveNodeEntity` use mocked Z-Wave nodes and values to verify:\n  - The node entity subscribes correctly to `SIGNAL_VALUE_CHANGED`, `SIGNAL_NODE`, and `SIGNAL_NOTIFICATION` and only reacts to events relevant to its node_id.\n  - `node_changed()` correctly populates required and non-empty optional attributes, and that wakeup interval and battery level are populated via `node.can_wake_up()`, `node.get_values(COMMAND_CLASS_WAKE_UP)` and `node.get_battery_level()`.\n  - The `state` property correctly derives the user-facing state string based on `is_ready`, `is_awake`, `is_failed`, and `query_stage` (e.g., 'Ready', 'Ready (Dynamic)', 'Sleeping', 'Sleeping (Dynamic)', 'Dead', 'Dead (Dynamic)'), and returns `None` before any update.\n  - `should_poll` is false, confirming that updates are driven by OpenZWave events, not polling.\n  - The helper `sub_status` formats combined status and stage as expected.\n\nTo support testing, the Z-Wave test mocks were extended:\n- New dispatcher signal constants `SIGNAL_NODE` and `SIGNAL_NOTIFICATION` with helpers `node_changed` and `notification`.\n- `MockNode` gained attributes/behaviors like `can_wake_up_value`, `can_wake_up()`, `get_battery_level()`, and support for arbitrary keyword attributes.\n- Tests selectively stub `node.get_values` to return a wakeup interval value when needed.\n\n.coveragerc was updated to refine which Z-Wave files are excluded from coverage (keeping `node_entity.py` fully covered while omitting core integration and certain helper modules). After the changes, test coverage for the new file was confirmed, and the PR was accepted after a reviewer discussion that also decided to remove battery entities in favor of the new node-entity attributes.",
        "semantic_memory": "This PR illustrates several generalizable patterns for designing device integrations, especially in event-driven home automation systems:\n\n1. **Introduce a dedicated per-device entity for shared attributes and lifecycle**:\n   - Many physical devices expose multiple logical entities (e.g., sensor, switch, light) but also share attributes like battery level, location, firmware, or connectivity status. Duplicating these on every platform entity increases state size, confuses users, and complicates maintenance.\n   - A single 'node' or 'device' entity that owns device-level attributes and status (e.g., Ready/Sleeping/Dead, online/offline) provides a cleaner model. Other entities represent specific functions (e.g., light brightness) but refer to the same underlying node.\n   - This pattern reduces entity count, avoids attribute duplication, and gives a canonical place to look for device health and metadata.\n\n2. **Centralize update scheduling logic in a shared base class**:\n   - Many entity classes may receive frequent event callbacks from lower-level libraries. If each implements its own scheduling/debouncing logic, code becomes duplicated and error-prone.\n   - A shared base entity (here `ZWaveBaseEntity`) that encapsulates a `maybe_schedule_update()` + `_schedule_update()` pattern ensures consistent behavior: coalesce rapid changes, avoid redundant state updates, and respect lifecycle concerns (e.g., don't update before the entity has been fully set up in Home Assistant).\n   - This pattern is widely applicable: in any system where multiple entity subclasses respond to callbacks, centralize the backpressure/debounce mechanism.\n\n3. **Use event filtering to handle shared dispatcher signals**:\n   - OpenZWave exposes high-level signals (`SIGNAL_VALUE_CHANGED`, `SIGNAL_NODE`, `SIGNAL_NOTIFICATION`) that may carry events for any node. Each entity must carefully filter events based on identifiers (node_id, args['nodeId']) and ignore irrelevant ones.\n   - Encapsulating this filtering logic (e.g., in `network_node_changed`) protects the rest of the entity code from accidental cross-node updates, a pattern useful whenever multiple entities listen on a shared pub/sub channel or dispatcher.\n\n4. **Prefer attributes on a single entity over many small dedicated entities when entity count and performance matter**:\n   - The debate in the review highlights the trade-off between having many fine-grained entities (e.g., one per battery) and limiting entity count for performance and UI usability.\n   - Exposing battery level as an attribute on the node entity rather than as a separate sensor reduces the number of entities roughly by the number of battery-powered devices. For low-end systems or user interfaces that become cluttered with too many entities, this approach scales better.\n   - The general principle: if a value is mainly meta/health information about a device and rarely the main subject of automations, it can reasonably live as an attribute. Values that are primary automation targets or require their own history/graphs might deserve standalone entities.\n\n5. **Schema simplification and consolidation**:\n   - The original discovery model distinguished between `DISC_NODE_VALUES` and `DISC_INSTANCE_VALUES`. Over time, this grew complex and required extra merging logic.\n   - Collapsing these into a single `DISC_VALUES` schema simplifies both the discovery definitions and the runtime logic that scans values. This reduces sources of misconfiguration and makes future schema extensions easier.\n   - When designing discovery/config schemas, avoid unnecessary bifurcation unless there is a clear behavioral difference that requires it.\n\n6. **Careful handling of optional attributes and partial state**:\n   - Some attributes (like neighbor lists, capabilities, wakeup interval, battery level) may be absent or only become available after a query stage completes.\n   - The entity logic selectively includes required attributes always, and optional attributes only if they are non-empty, so the state payload remains minimal and truthful.\n   - It also returns `None` for state before the node has been fully initialized, avoiding misleading default states. This pattern is important when representing devices whose initialization is asynchronous and multi-stage.\n\n7. **Testing event-driven entities with mocks and dispatcher signals**:\n   - The tests introduce mock dispatcher signals and helper functions (`value_changed`, `node_changed`, `notification`) to emulate the behavior of the underlying Z-Wave network without requiring real hardware.\n   - They stub node methods (`can_wake_up`, `get_values`, `get_battery_level`) to simulate various device capabilities and ensure entity behavior is robust.\n   - More generally, when dealing with event-driven hardware integrations, building a small mock framework around the event bus and device model greatly improves test coverage and confidence in refactors.\n\n8. **Align coverage configuration with testing reality**:\n   - The PR tweaks `.coveragerc` to exclude large integration modules that are impractical to fully cover, while making sure new modules like `node_entity.py` are included and thoroughly tested.\n   - Selective coverage exclusion is a practical tool: use it sparingly, but don't let it discourage adding tests for newly introduced isolated logic.\n\nTogether these lessons form a pattern for structuring complex hardware integrations: use a layered entity model (node vs function), centralize cross-cutting concerns like update scheduling, simplify and unify configuration schemas, and build strong tests around event handling and device capability modeling.",
        "procedural_memory": [
            "When introducing per-device entities and refactoring attributes from child entities in an event-driven device integration, follow these steps:",
            "Step 1: Identify shared per-device attributes and lifecycle signals",
            "  - Inspect your integration to find values that logically belong to the physical device rather than individual functional entities: e.g., battery level, wakeup interval, location, firmware version, neighbors, capabilities, online/offline state, query stage.",
            "  - Identify the set of underlying library events (e.g., OpenZWave's SIGNAL_NODE, SIGNAL_VALUE_CHANGED, SIGNAL_NOTIFICATION) that indicate changes in those attributes or node status.",
            "Step 2: Introduce a per-device (node) entity class",
            "  - Create a new entity class that represents the physical device/node (e.g., ZWaveNodeEntity).",
            "  - Store a reference to the underlying node object and its unique identifier (e.g., node_id).",
            "  - Implement a consistent naming function (e.g., node_name()) to produce entity IDs like `domain.slugified_name_nodeid`.",
            "  - Decide which attributes are required vs optional. Always include required ones; include optional ones only if non-empty to avoid noisy states.",
            "  - Implement the `state` property to reflect device lifecycle (Ready, Sleeping, Dead) derived from flags such as is_ready, is_failed, is_awake, and query_stage. Consider a helper like `sub_status(status, stage)` to support sub-states (e.g., 'Dead (Dynamic)').",
            "Step 3: Centralize update scheduling in a base entity",
            "  - Create a shared base class (e.g., ZWaveBaseEntity) that subclasses your framework's Entity base.",
            "  - In this base, implement a flag `_update_scheduled` and a method `maybe_schedule_update()` that queues state updates only if the entity has a valid `hass`/context and is not already scheduled.",
            "  - Implement an internal `_schedule_update()` that uses your event loop (e.g., `loop.call_later(0.1, callback)`) to call `async_update_ha_state` once after a short delay. This coalesces multiple rapid events.",
            "  - Refactor existing entity classes (like ZWaveDeviceEntity or similar) to inherit from this base and call `maybe_schedule_update()` in their event handlers instead of having duplicated scheduling logic.",
            "Step 4: Wire the node entity into your integrationâ€™s event system",
            "  - In your main integration setup (e.g., `__init__.py`), create an entity component/registry for the device domain if not already present.",
            "  - Register callback functions for node creation events (e.g., `node_added` listening to `ZWaveNetwork.SIGNAL_NODE_ADDED`).",
            "  - In `node_added`, instantiate your node entity, check per-device configuration (ignored/hidden flags), and add the entity to the component.",
            "  - Inside the node entity's initializer, subscribe to relevant dispatcher signals (e.g., `SIGNAL_VALUE_CHANGED`, `SIGNAL_NODE`, `SIGNAL_NOTIFICATION`). In the callback, filter events by `node_id` and call a `node_changed()` method to refresh attributes.",
            "Step 5: Move shared attributes from child entities to the node entity",
            "  - For attributes like battery level, wakeup interval, and location, remove their handling from individual platform entities (sensors, locks, etc.).",
            "  - In the node entity's `node_changed()` implementation, compute these values via node methods (e.g., `node.get_battery_level()`, `node.can_wake_up()`, `node.get_values(COMMAND_CLASS_WAKE_UP)`, `node.location`).",
            "  - Expose them via `device_state_attributes` on the node entity (e.g., add `ATTR_BATTERY_LEVEL`, `ATTR_WAKEUP`, `ATTR_NODE_ID`).",
            "  - Ensure that child entities no longer expose these attributes to avoid duplication and confusion.",
            "Step 6: Simplify and consolidate discovery schemas",
            "  - Review your discovery schemas. If you use separate structures like `DISC_NODE_VALUES` and `DISC_INSTANCE_VALUES`, consider merging them into a single `DISC_VALUES` dictionary.",
            "  - Update runtime discovery logic to refer consistently to `DISC_VALUES` for primary and auxiliary values.",
            "  - Clean up any now-unused constants or schema fields (e.g., remove `DISC_INSTANCE_VALUES` if everything uses `DISC_VALUES`).",
            "Step 7: Remove redundant dedicated entities (e.g., battery sensors) if appropriate",
            "  - Identify entities whose only role is to expose attributes now provided by the node entity (such as a battery sensor).",
            "  - Update your platform's `get_device` or discovery logic to stop instantiating those entities (e.g., no longer treat `COMMAND_CLASS_BATTERY` as a separate sensor).",
            "  - Remove tests that depended on the old behavior, and ensure documentation and release notes communicate where those attributes are now available.",
            "Step 8: Add and adjust tests for the new behavior",
            "  - Create unit tests for the new base entity class to ensure `maybe_schedule_update()` schedules exactly one update and uses your event loop correctly. Override or mock `loop.call_later` for determinism.",
            "  - Add tests for the node entity to validate:\n    - Correct subscription to dispatcher signals and proper filtering by node_id.\n    - Correct population of required and optional attributes in `device_state_attributes`.\n    - State derivation (Ready/Sleeping/Dead with and without query stage) for various combinations of node flags.\n    - That `should_poll` is false if updates are event-driven.",
            "  - Extend or create mocks for your underlying device model (e.g., Z-Wave nodes and values) to provide methods like `can_wake_up`, `get_values`, and `get_battery_level` so tests can drive different scenarios.",
            "Step 9: Update coverage and configuration as needed",
            "  - Ensure your coverage configuration includes the new module(s) and excludes only those that are infeasible to test thoroughly.",
            "  - Run your test suite and confirm that new code paths are covered (especially the event-handling and scheduling logic).",
            "Step 10: Communicate breaking or behavioral changes to users",
            "  - Note in release notes or documentation that battery values (and other moved attributes) are now exposed as attributes on the node entity instead of separate sensor entities.",
            "  - Provide guidance on how to reference the new attributes in automations and templates (e.g., `state_attr('zwave.device_name', 'battery_level')`).",
            "  - For users who relied on stand-alone entities, suggest how to create template sensors if they still need separate entities while keeping the core integration lean."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Samsung TV integration: fix configuration flow crashes for newer WebSocket-based Samsung TVs by adjusting connection probing timeouts and catching WebSocket exceptions, treating such TVs as 'not supported' instead of raising unhandled errors.",
        "keywords": [
            "Home Assistant",
            "samsungtv",
            "Samsung TV",
            "config_flow",
            "websocket",
            "WebSocketException",
            "WebSocketProtocolException",
            "UnhandledResponse",
            "samsungctl.Remote",
            "device discovery",
            "not_supported",
            "bugfix",
            "timeout",
            "exception handling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Samsung TV integration was failing when users tried to add newer Samsung TVs that use WebSocket communication. During the config flow, the integration probed the TV using the samsungctl.Remote client with two methods ('websocket' and 'legacy') and a fixed long timeout (31 seconds). For newer WebSocket-based TVs, the WebSocket handshake or protocol handling triggered WebSocket-related exceptions (e.g., WebSocketProtocolException) that were not caught explicitly. As a result, the configuration flow could crash or surface raw exceptions instead of gracefully reporting that the device wasn't supported.\n\nTo fix this, the developer refactored the connection probing logic in `homeassistant/components/samsungtv/config_flow.py`. Instead of using a generic METHODS constant from `const.py`, they introduced a local `SUPPORTED_METHODS` tuple with method-specific timeouts: a very short timeout (`timeout: 1`) for the 'websocket' method to avoid hanging on newer TVs, and a longer timeout (`timeout: 31`) for the 'legacy' method, because waiting for the TV's authentication popup can be just an open socket and needs more time. Each candidate config is built from a base dict and then updated with the method-specific configuration.\n\nMore importantly, the `_try_connect` method now catches `WebSocketException` (from the `websocket` library) in addition to `UnhandledResponse` from `samsungctl.exceptions`. When either `UnhandledResponse` or `WebSocketException` occurs, the logic logs that the configuration is 'working but unsupported' and returns `RESULT_NOT_SUPPORTED`, causing the config flow to abort with a 'not_supported' reason instead of crashing. An `AccessDenied` exception is still treated as an authentication issue (`RESULT_AUTH_MISSING`), and OS-level errors still map to `RESULT_NOT_SUCCESSFUL`.\n\nThe tests in `tests/components/samsungtv/test_config_flow.py` were updated accordingly: the expected timeout for the autodetected WebSocket config was adjusted to 1 second, and a new test (`test_ssdp_not_supported_2`) was added to simulate `WebSocketProtocolException` being raised by `Remote`. This test verifies that the SSDP discovery flow proceeds to the confirm step and then aborts with the 'not_supported' reason when the WebSocket protocol error occurs.\n\nOverall, the change prevents unhandled exceptions when adding newer Samsung TVs, but at the cost of not adding those TVs as entities: they are now explicitly treated as 'not supported' by this integration, which is a deliberate step back in functionality but an improvement in robustness.",
        "semantic_memory": "This fix illustrates a common integration pattern: when auto-detecting or probing device capabilities over a network, unhandled protocol-level exceptions from underlying client libraries (e.g., WebSocket, HTTP, or custom protocol implementations) must be explicitly caught and mapped to higher-level, user-facing states (like 'unsupported device', 'authentication required', or 'connection failed'). Without this mapping, configuration flows or discovery processes can crash, producing a poor user experience.\n\nThe change also highlights the importance of method-specific connection policies. Different communication methods (e.g., WebSocket vs. legacy TCP) may require different timeouts and error interpretations. Using a single, overly long timeout for all methods can cause the system to hang or be slow to react, whereas a short timeout for protocols that either succeed quickly or fail from unsupported versions results in a more responsive UI.\n\nIn general, robust device discovery/configuration should:\n- Separate method-specific parameters (timeouts, protocol options) from generic config state.\n- Treat protocol or library exceptions as part of the logical decision tree (unsupported vs. failed vs. requires auth) instead of as unexpected errors.\n- Provide clear, stable abort reasons or error codes so that the UI and users understand why a device isn't added.\n- Include tests that explicitly simulate protocol-layer failures (e.g., raising WebSocketProtocolException) to ensure that error handling stays correct over time.\n\nAnother generalizable lesson is avoiding global constants that require uniform handling for disparate methods. Instead, using structured per-method configuration (like a tuple of dicts) allows more granular control of how each communication path is probed and handled.",
        "procedural_memory": [
            "When diagnosing and fixing crashes caused by newer devices using updated protocols (e.g., WebSocket TVs), follow these steps:",
            "Step 1: Reproduce the issue in a controlled environment.\n- Attempt to add or discover the problematic device using the integration's normal configuration or discovery flow.\n- Observe logs and stack traces to identify where the failure occurs, looking for protocol-specific exceptions (e.g., WebSocketException, WebSocketProtocolException, UnhandledResponse).",
            "Step 2: Identify where the communication is initiated.\n- Locate the code responsible for connecting to the device (e.g., config flow logic using a client library like samsungctl.Remote).\n- Look for loops that probe multiple methods or configurations (e.g., websocket vs. legacy) and note timeouts and exception handling.",
            "Step 3: Classify exceptions into semantic categories.\n- Map exceptions like AccessDenied or explicit 401/403 responses to an 'authentication required' state.\n- Map protocol errors (e.g., WebSocketException, WebSocketProtocolException, UnhandledResponse) to an 'unsupported device or protocol' state.\n- Map network-level errors (OSError, timeouts, connection refused) to a generic 'connection failed' or 'not successful' state.",
            "Step 4: Implement explicit exception handling.\n- Wrap the connection/probing call(s) in try/except blocks.\n- Catch the relevant protocol/library exceptions (e.g., `except (UnhandledResponse, WebSocketException):`) and return or raise a domain-specific result (e.g., RESULT_NOT_SUPPORTED) instead of letting them bubble up.\n- Keep separate branches for authentication problems vs. unsupported devices vs. transient connection errors.",
            "Step 5: Adjust method-specific configuration.\n- If you probe multiple communication methods, define a structured configuration for each (e.g., a list/tuple of dicts containing method and timeout).\n- Assign shorter timeouts to methods that should fail fast (e.g., WebSocket) and longer timeouts where waiting is expected (e.g., legacy sockets waiting for UI auth popups).\n- Iterate through these configurations, updating a base config dict, and attempt each method in turn until one succeeds or a decisive result is obtained.",
            "Step 6: Map internal results to user-visible outcomes.\n- In config flows or discovery flows, return consistent abort reasons or step results (e.g., 'not_supported', 'not_successful', 'missing_auth').\n- Ensure the UI uses these reasons to display clear messages, so users understand that the device is unsupported rather than assuming a bug or crash.",
            "Step 7: Add or update tests.\n- Create unit tests that patch the client library (`Remote` or equivalent) to raise the targeted exceptions (e.g., WebSocketProtocolException).\n- Verify that the flow progresses to the expected step and then aborts with the correct reason.\n- Update any test expectations involving method configs (e.g., timeouts or selected methods) to reflect the new behavior.",
            "Step 8: Refactor constants and configuration as needed.\n- If a global constant (like METHODS) no longer fits the new handling, replace it with a local or more structured definition (e.g., SUPPORTED_METHODS with method-specific attributes).\n- Keep the configuration definitions close to where they are used when they are tightly coupled to a specific flow, to reduce the risk of inconsistent use elsewhere.",
            "Step 9: Document limitations.\n- If the fix intentionally steps back from a previous behavior (e.g., no longer adding newer TVs at all but preventing crashes), note this in the issue/PR and release notes.\n- Clarify that the devices are treated as 'not supported' until a more complete protocol implementation is added."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Adds a new Home Assistant Plaato Airlock integration using a webhook-based config flow and event-driven sensors. It validates webhook JSON with a voluptuous schema, stores per-device data in hass.data, creates/upgrades sensors via async_dispatcher, marks sensors as non-polling, moves config_flow/domain to dedicated modules, unsubscribes dispatcher listeners on unload, and fixes a dict-iteration bug and error-handling/logging for malformed webhook payloads.",
        "keywords": [
            "Home Assistant",
            "Plaato Airlock",
            "webhook integration",
            "config_entry_flow.register_webhook_flow",
            "async_dispatcher_connect",
            "async_dispatcher_send",
            "sensor.should_poll False",
            "voluptuous MultipleInvalid",
            "webhook payload validation",
            "dict iteration bug",
            "config_entry async_setup_entry",
            "async_unload_entry cleanup",
            "hass.data storage pattern",
            "push-based sensor",
            "plaato component"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduces a new Plaato Airlock integration for Home Assistant, implemented as a webhook-driven, config-flow-based component.\n\nThe core behavior:\n- A `plaato` integration is defined with `config_flow: true` in `manifest.json` and a documentation URL. The domain constant is moved to `const.py` (DOMAIN = 'plaato').\n- A config flow is registered in `config_flow.py` using `config_entry_flow.register_webhook_flow(DOMAIN, 'Webhook', {...})`, enabling users to set up Plaato via the UI and obtain a webhook URL.\n- The main logic in `__init__.py` registers a webhook handler with Home Assistant's `webhook` component when a config entry is set up. The webhook ID comes from the config entry data (`CONF_WEBHOOK_ID`).\n- Incoming webhook requests are parsed in `handle_webhook`. The request body is read as JSON and validated using a `voluptuous` schema (`WEBHOOK_SCHEMA`). The schema enforces the presence and types of Plaato fields: device metadata (name, id, temperature and volume units) and measurements (temperature, BPM, SG, OG, ABV, CO2 volume, batch volume, bubbles).\n- On success, a per-device ID is computed (`<device_name>_<device_id>`), attributes and sensor values are extracted, and the data is stored in `hass.data[DOMAIN][device_id]` under two keys: `PLAATO_DEVICE_ATTRS` and `PLAATO_DEVICE_SENSORS`.\n- An update signal is emitted via `async_dispatcher_send(hass, SENSOR_UPDATE, device_id)` to notify the sensor platform that new data is available.\n- The webhook handler responds with an HTTP 200 (`HTTP_OK`) and a text message indicating which device_id was updated.\n\nError handling:\n- Initially, malformed webhook payloads caused the handler to return a `422 Unprocessable Entity` with the voluptuous error message. This was later changed to instead log a warning (`_LOGGER.warning(\"An error occurred when parsing webhook data <%s>\", error)`) and simply return, dropping the bad request but not crashing the handler. The unused `HTTP_UNPROCESSABLE_ENTITY` import was removed to satisfy static tests.\n\nSensor platform details:\n- `sensor.py` provides the Plaato sensor entities. Setup of the platform via YAML (`async_setup_platform`) is intentionally empty, as configuration is via config entries.\n- `async_setup_entry` connects a dispatcher listener: `async_dispatcher_connect(hass, SENSOR_UPDATE, _update_sensor)`. The unsubscribe callback is stored in `hass.data[SENSOR_DATA_KEY]` (where `SENSOR_DATA_KEY = 'plaato.sensor'`) so it can be called when the integration is unloaded.\n- `_update_sensor(device_id)` is invoked whenever the webhook handler sends `SENSOR_UPDATE`. The function:\n  - Checks `hass.data[PLAATO_DOMAIN]` for the device.\n  - Uses `get_device_sensors(device_id)` to get the sensor data.\n  - On first update for that device, it creates one `PlaatoSensor` entity per sensor type (key in the sensors dict) and adds all of them via `async_add_entities(entities, True)`, caching them in a `devices` dict.\n  - On subsequent updates, it simply calls `entity.async_schedule_update_ha_state()` on each entity for that device so Home Assistant will read the updated state.\n\nBugs and fixes during development:\n- Dict iteration bug: Initially, the sensor creation loop used `for sensor_type, value in sensors.items():` but then changed to `for sensor_type in sensors.items():`, which made `sensor_type` become a `(key, value)` tuple instead of a string. This would mislabel sensor entities. It was fixed by iterating `for sensor_type in sensors:` so that `sensor_type` is just the key.\n- Polling behavior: Since data is pushed by webhook and delivered via dispatcher, the sensors should not be polled. A `should_poll` property was added to `PlaatoSensor` to return `False`.\n- State update location: Originally, `async_update` fetched and computed the new sensor values onto an internal `_state`, and the `state` property just returned `_state`. To align better with push-based updates (and avoid unnecessary async_update usage), the logic was moved into the `state` property itself. Now, `state` reads current data from `hass.data` on each access, applies rounding by type (ABV: 2 decimals, temperature: 1 decimal, CO2 volume: 2 decimals), and returns the appropriate raw or rounded value.\n- Conditional structure cleanups: Several `if/elif/else` chains for computing units and state rounding were simplified to avoid unreachable branches and satisfy linting.\n- Dispatcher cleanup: `async_unload_entry` originally unregistered the webhook and unloaded the sensor entry but did not remove the dispatcher listener. This could leave a stale callback and potential memory leak. The integration now stores the dispatcher unsubscribe function on setup (`hass.data[SENSOR_DATA_KEY] = async_dispatcher_connect(...)`) and calls it on unload (`hass.data[SENSOR_DATA_KEY]()`), ensuring proper cleanup when the config entry is removed.\n\nAdditional integration hygiene:\n- Localization: A Swedish translation file (`sv.json`) was initially added but was removed per project policy (only `en.json` goes directly into the repo, other translations come via Lokalise). Instead, an English translation file `.translations/en.json` was added, and strings.json contains matching config-flow copy.\n- Config flow registration: `homeassistant/generated/config_flows.py` was regenerated to include `\"plaato\"` so the UI can discover and start the Plaato config flow.\n- Coverage and ownership: The component was added to `.coveragerc` (excluded from coverage) and `CODEOWNERS` (assigned to `@JohNan`).",
        "semantic_memory": "Generalizable patterns and best practices derived from this change:\n\n1. Webhook-based integrations in Home Assistant:\n- Use `config_entry_flow.register_webhook_flow` to register a webhook-based config flow, supplying the integration's domain and docs URL. This lets users set up integrations via the UI and automatically get a webhook URL.\n- Store the generated webhook ID in the config entry and register the webhook at `async_setup_entry` using `hass.components.webhook.async_register(domain, name, webhook_id, handler)`.\n- Implement the webhook handler as an async function receiving `(hass, webhook_id, request)`, parse JSON with `await request.json()`, validate with a schema, and then trigger platform-level updates via dispatcher or direct writes to `hass.data`.\n- When the config entry is unloaded, unregister the webhook in `async_unload_entry` to avoid stale HTTP endpoints.\n\n2. Validating webhook payloads:\n- Define a strict `voluptuous` schema for incoming webhook data to ensure the integration receives correctly-typed fields. Use `vol.Required` with type coercion (`vol.Coerce(float)`, `cv.positive_int`, etc.) to convert raw JSON into usable types.\n- Catch `vol.MultipleInvalid` exceptions around schema validation. Instead of exposing internal error details directly to the client, log the error for debugging and return gracefully. This avoids breaking the integration on malformed payloads while still giving operators visibility into issues.\n\n3. Data flow and storage model:\n- For push-based devices, it is effective to treat `hass.data[DOMAIN]` as a small in-memory data store keyed by device ID, containing both a map of attributes (`ATTR_*`) and sensor values.\n- Use a dispatcher signal (`async_dispatcher_send`) to notify platforms that new data has arrived. The sensor platform should subscribe with `async_dispatcher_connect` and update or create entities accordingly.\n- Maintain a per-device entity list in memory so the platform can distinguish between the first time a device appears (create entities) and subsequent updates (just refresh state).\n\n4. Event-driven sensors vs polling:\n- For components where the external system pushes data to Home Assistant, sensor entities should set `should_poll = False`. Their state should be derived from the latest data in `hass.data` instead of relying on scheduled polling.\n- When sensors are push-based, it is often cleaner to move the state computation into the `state` property (reading from the shared data store) instead of using `async_update`. Dispatcher-triggered `async_schedule_update_ha_state()` will cause Home Assistant to call `state` and thus reflect the new data without network I/O.\n\n5. Dict iteration correctness:\n- When iterating over a dict, be explicit about whether you want keys or key/value pairs. `for key in d:` yields keys; `for key, value in d.items():` yields pairs. Accidentally using `for key in d.items():` and then treating `key` as a string will cause subtle bugs because it will actually be a `(key, value)` tuple.\n\n6. Cleanup of subscriptions and listeners:\n- When registering callbacks (dispatcher, events, etc.), always store the unsubscribe callable and invoke it during component unloading (`async_unload_entry`). This prevents memory leaks, avoids unexpected callbacks after an integration has been removed, and aligns with Home Assistant’s lifecycle expectations.\n\n7. Localization and integration metadata:\n- For integrations in Home Assistant, only include `en.json` directly and rely on the L10N pipeline for other translations. This keeps localization consistent across components.\n- Keep constants like DOMAIN in a dedicated `const.py` to avoid repetition and make refactoring simpler.\n\nOverall, this PR demonstrates a standard pattern for implementing a push-based, webhook-backed integration in an event-driven home automation framework: validate incoming payloads, cache state centrally, notify entities via dispatcher, avoid polling, and clean up external resources and listeners on unload.",
        "procedural_memory": [
            "How to design and debug a webhook-based, push-driven sensor integration similar to Plaato:",
            "Step 1: Define the integration domain and metadata",
            "  - Create a `manifest.json` with `domain`, `name`, `documentation`, `config_flow: true`, `dependencies` (e.g., `[\"webhook\"]`), `codeowners`, and `requirements` as needed.",
            "  - Add a `const.py` file with a `DOMAIN = \"<your_domain>\"` constant so the domain is only defined in one place.",
            "  - Update `config_flows.py` (or regenerate it using the project’s tooling) to include your domain in the list of supported config flows.",
            "",
            "Step 2: Register a webhook-based config flow",
            "  - In `config_flow.py`, call `config_entry_flow.register_webhook_flow(DOMAIN, 'Webhook', {'docs_url': '<docs-url>'})`.",
            "  - Provide localized UI strings in `.translations/en.json` and `strings.json` describing the setup steps and the webhook URL.",
            "",
            "Step 3: Implement `async_setup_entry` and `async_unload_entry`",
            "  - In `__init__.py`, implement `async_setup_entry(hass, entry)` to:",
            "    - Initialize `hass.data[DOMAIN]` if it does not exist.",
            "    - Extract the `CONF_WEBHOOK_ID` from the `entry.data`.",
            "    - Register the webhook handler via `hass.components.webhook.async_register(DOMAIN, 'Human Name', webhook_id, handle_webhook)`.",
            "    - Forward the config entry to the sensor platform with `hass.config_entries.async_forward_entry_setup(entry, SENSOR_DOMAIN)`.",
            "  - Implement `async_unload_entry(hass, entry)` to:",
            "    - Unregister the webhook via `hass.components.webhook.async_unregister(entry.data[CONF_WEBHOOK_ID])`.",
            "    - Call any stored dispatcher unsubscribe function(s). Store these in `hass.data` when connecting the dispatcher.",
            "    - Forward entry unload to each platform using `await hass.config_entries.async_forward_entry_unload(entry, SENSOR_DOMAIN)`.",
            "",
            "Step 4: Define a strict schema for webhook payloads",
            "  - Use `voluptuous` to define a schema that precisely describes the JSON payload fields: required names, types, and valid unit values.",
            "  - Example: `vol.Required('temp'): vol.Coerce(float)`, `vol.Required('bpm'): cv.positive_int`, `vol.Required('temp_unit'): vol.Any(TEMP_CELSIUS, TEMP_FAHRENHEIT)`, etc.",
            "  - This ensures the integration receives clean, strongly-typed data and can fail fast on malformed payloads.",
            "",
            "Step 5: Implement the webhook handler",
            "  - Create an async `handle_webhook(hass, webhook_id, request)` function that:",
            "    - Calls `await request.json()` to read the body.",
            "    - Wraps schema validation (`WEBHOOK_SCHEMA(data)`) in a try/except for `vol.MultipleInvalid`.",
            "    - On validation error:",
            "      - Log a warning with enough context to debug (e.g., `_LOGGER.warning('An error occurred when parsing webhook data <%s>', error)`.",
            "      - Return early without raising, so the handler doesn't crash (depending on framework, return an appropriate response or rely on defaults).",
            "    - On success:",
            "      - Derive a stable device identifier from the payload (e.g., name + numeric ID).",
            "      - Extract attribute metadata (units, name, manufacturer-specific info) and sensor readings.",
            "      - Store them in `hass.data[DOMAIN][device_id]` under keys like `PLAATO_DEVICE_ATTRS` and `PLAATO_DEVICE_SENSORS`.",
            "      - Notify the sensor platform that new data is available via `async_dispatcher_send(hass, SENSOR_UPDATE, device_id)`.",
            "      - Return a success HTTP response (e.g., 200 OK) to the caller with a simple text body.",
            "",
            "Step 6: Implement the sensor platform using dispatcher and push updates",
            "  - In `sensor.py`, implement `async_setup_entry(hass, config_entry, async_add_entities)`:",
            "    - Maintain a local dict mapping `device_id` to a list of entity instances so you can differentiate first-time creation from updates.",
            "    - Implement helper methods like `get_device_sensors(device_id)` that read from `hass.data[DOMAIN][device_id]`.",
            "    - Define an inner async function `_update_sensor(device_id)` that:",
            "      - If the device is new and present in `hass.data`, creates one sensor entity per sensor key in the device's sensor dict and adds them via `async_add_entities(entities, True)`.",
            "      - If the device already exists, calls `entity.async_schedule_update_ha_state()` for each entity so the new state is fetched.",
            "    - Connect a dispatcher listener: `unsubscribe = async_dispatcher_connect(hass, SENSOR_UPDATE, _update_sensor)`.",
            "    - Store `unsubscribe` somewhere accessible (e.g., `hass.data[SENSOR_DATA_KEY] = unsubscribe`) so you can call it on unload.",
            "",
            "Step 7: Implement sensor entities for push data",
            "  - Create a sensor entity class (e.g., `PlaatoSensor(Entity)`) that:",
            "    - Stores `device_id` and the specific `sensor_type` key it represents.",
            "    - Returns a human-readable `name` and a `unique_id` composed of device and sensor type.",
            "    - Implements `device_info` with identifiers and manufacturer/model for device registry.",
            "    - Implements `should_poll` to return `False` to indicate push-only updates.",
            "    - Reads its values from `hass.data` in the `state` property instead of `async_update`:",
            "      - Fetch the latest sensor dict via a helper.",
            "      - If no data is available, log debug and return a neutral value (e.g., 0 or `None`).",
            "      - Apply type-specific rounding or formatting (e.g., ABV to 2 decimals, temperature to 1 decimal).",
            "      - Return the computed value.",
            "    - Implements `unit_of_measurement` based on sensor type and device attributes (e.g., temperature unit, volume unit, '%' for ABV).",
            "",
            "Step 8: Correctly iterate over dicts when creating entities",
            "  - When creating entities from a dict of sensor values, ensure you use the correct iteration style:",
            "    - `for sensor_type in sensors:` or `for sensor_type in sensors.keys():` if you only need the keys.",
            "    - `for sensor_type, value in sensors.items():` if you need both keys and values.",
            "  - Avoid using `for sensor_type in sensors.items():` and then treating `sensor_type` as a string; this will give you `(key, value)` tuples.",
            "",
            "Step 9: Ensure proper cleanup on unload",
            "  - In `async_unload_entry`, in addition to unregistering the webhook, call any dispatcher unsubscribe callbacks you stored earlier:",
            "    - Example: `hass.data[SENSOR_DATA_KEY]()`.",
            "  - This prevents callbacks from firing after the integration has been removed and avoids memory leaks.",
            "",
            "Step 10: Conform to project policies on translations and coverage",
            "  - Only ship `.translations/en.json` in the component. Other languages should be added via the project's translation platform, not in the repo directly.",
            "  - Add the component to `.coveragerc` if test coverage exclusion is required, and to `CODEOWNERS` for maintenance responsibilities."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant MQTT platforms were using permissive voluptuous schemas (extra=vol.ALLOW_EXTRA), allowing misspelled or unknown configuration keys like 'status_topic' to pass silently. The fix switches to a strict base platform schema, updates MQTT discovery handling to strip internal metadata keys before validation, aligns tests and configs to use correct options like 'state_topic', and adds missing options (e.g., retain) to schemas.",
        "keywords": [
            "Home Assistant",
            "MQTT",
            "PLATFORM_SCHEMA_BASE",
            "PLATFORM_SCHEMA_2",
            "voluptuous",
            "config validation",
            "extra=vol.ALLOW_EXTRA",
            "strict schema",
            "state_topic vs status_topic",
            "MQTT discovery",
            "ATTR_DISCOVERY_HASH",
            "TOPIC_BASE",
            "schema_basic",
            "schema_json",
            "schema_template"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, MQTT platforms in Home Assistant were using a permissive validation schema derived from cv.PLATFORM_SCHEMA with extra=vol.ALLOW_EXTRA. This allowed configuration payloads (including those from MQTT discovery) to contain unknown or misspelled keys without raising errors. For example, tests and configs were using 'status_topic' where the platform actually defined 'state_topic', and extra keys like 'command_topic' were present on entities that only support 'state_topic'. As part of moving to stricter validation, the project introduced PLATFORM_SCHEMA_BASE (here cv.PLATFORM_SCHEMA_2) which does not allow extra keys. Switching MQTT_BASE_PLATFORM_SCHEMA to this strict base schema immediately surfaced several issues: (1) discovery payloads included internal metadata fields like ATTR_DISCOVERY_HASH and TOPIC_BASE that were not part of the component schemas; (2) MQTT light had a special schema selection mechanism ('schema': 'basic'|'json'|'template') that needed to be integrated with the strict base schemas; and (3) tests and sample configs relied on outdated or incorrect field names.\n\nThe fix addressed all of these points:\n- MQTT_BASE_PLATFORM_SCHEMA now uses cv.PLATFORM_SCHEMA_2.extend(SCHEMA_BASE), disabling ALLOW_EXTRA for all MQTT platforms that use this base.\n- Discovery callbacks for alarm_control_panel, binary_sensor, cover, fan, light, lock, sensor, switch, and vacuum were updated to use discovery_payload.pop(ATTR_DISCOVERY_HASH) so the internal discovery hash is removed before the config is validated.\n- The MQTT discovery module now pops TOPIC_BASE from the payload (base = payload.pop(TOPIC_BASE, None)) and then rewrites any topic fields that start with the base placeholder. This ensures TOPIC_BASE is treated as an internal helper, not part of the validated configuration.\n- For MQTT lights, a shared MQTT_LIGHT_SCHEMA_SCHEMA was introduced to centralize the 'schema' option definition. The concrete schemas in schema_basic.py, schema_json.py, and schema_template.py now extend MQTT_LIGHT_SCHEMA_SCHEMA.schema, gaining strict schema handling while still sharing the 'schema' field. The top-level PLATFORM_SCHEMA in mqtt/light/__init__.py still uses an intermediate vol.Schema with extra=vol.ALLOW_EXTRA, but the config is then passed through validate_mqtt_light, which dispatches to the schema-specific strict validators.\n- Imports for schema_basic, schema_json, and schema_template were moved inside functions (validate_mqtt_light and _async_setup_entity) to avoid circular imports after introducing MQTT_LIGHT_SCHEMA_SCHEMA in the shared module.\n- The alarm_control_panel platform schema was updated to explicitly include an optional 'retain' (CONF_RETAIN) option with a default value.\n- Tests were updated to conform to the stricter schemas: 'status_topic' was replaced by 'state_topic' across alarm_control_panel, light, json light, template light, sensor, switch, and lock tests; extraneous or invalid fields like 'command_topic' on sensor/binary_sensor or 'effect_command_topic' on template light were removed where they are not part of the platform schema; and entity device info tests no longer include unsupported fields. Additionally, discovery-related tests were updated to match the corrected field names and schemas.\n\nAfter these changes, MQTT platform configuration and discovery payloads are strictly validated, so users get errors for misspelled or unknown options instead of those options being silently ignored. This is a breaking change but improves configuration reliability and surfaces mistakes earlier.",
        "semantic_memory": "This fix illustrates several generalizable patterns about configuration validation and dynamic schema handling:\n\n1. **Prefer strict schemas over permissive ones for user configuration**: Using voluptuous or similar libraries, allowing extra keys (`extra=vol.ALLOW_EXTRA`) can hide bugs: typos or outdated option names become silent no-ops. Switching to a strict base schema (like PLATFORM_SCHEMA_BASE) ensures invalid or unexpected keys raise errors early, improving reliability and user feedback.\n\n2. **Treat internal metadata separately from user config**: Discovery protocols or internal wiring often attach metadata (e.g., discovery hashes, base prefixes) to configuration payloads. When moving to strict validation, these internal keys must be removed or separated before applying user-facing schemas. Otherwise, the validator will reject valid configs just because of internal metadata fields.\n\n3. **Centralize shared schema fragments**: When multiple variants of a component (e.g., different MQTT light schemas: basic/json/template) share common configuration fields (like the 'schema' selector), defining a shared schema fragment (MQTT_LIGHT_SCHEMA_SCHEMA) and extending it in each variant reduces duplication and keeps behaviour consistent across implementations.\n\n4. **Incrementally tighten validation**: Tightening a schema (disabling ALLOW_EXTRA) usually exposes inconsistencies in tests, examples, or real configs. A systematic fix includes: updating test fixtures to use correct field names, removing or moving any internal-only fields, and ensuring that public documentation and examples align with the schema. This creates a feedback loop that improves the overall API quality.\n\n5. **Manage circular imports when sharing schema constants**: When moving common schema pieces into a shared module, importing those modules at the top level can cause circular imports. A practical pattern is to perform certain imports inside functions (lazy imports) so that the interpreter can construct all modules before evaluating those dependent imports.\n\n6. **Discovery updates and strict validation**: Dynamic configuration updates (e.g., via MQTT discovery) must handle additional internal keys like discovery hashes carefully. Using `dict.pop` to remove these keys before schema validation both satisfies strict validators and ensures that subsequent update handlers receive a clean configuration object.\n\nOverall, the change underscores best practices: keep configuration schemas strict and explicit, separate internal protocol/metadata from user-facing configuration, and centralize shared schema logic to maintain consistency across variants.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify permissive schemas and their impact\n- Search for configuration schemas using a validation library (e.g., voluptuous) that specify `extra=vol.ALLOW_EXTRA` or otherwise allow unknown keys.\n- Check whether these schemas apply to user-facing configuration (YAML config files, discovery payloads, etc.). If so, note the potential for typos or obsolete options to pass silently.\n\nStep 2: Inspect for internal-only metadata in config payloads\n- Review how configuration objects are constructed, especially for discovery or dynamic configuration paths.\n- Identify internal metadata fields (e.g., hashes, IDs, base prefixes) that are added to the config payload but are not part of the public schema.\n- Confirm whether these fields are being removed before validation; if not, they will cause validation failures once the schema is made strict.\n\nStep 3: Introduce or switch to a strict base schema\n- If your framework provides both permissive and strict base schemas (e.g., `PLATFORM_SCHEMA` vs `PLATFORM_SCHEMA_BASE` / `PLATFORM_SCHEMA_2`), update your platform schemas to extend the strict variant.\n- Example: change `MY_BASE_SCHEMA = PLATFORM_SCHEMA.extend(SCHEMA_BASE)` to `MY_BASE_SCHEMA = PLATFORM_SCHEMA_BASE.extend(SCHEMA_BASE)`.\n- Ensure that `extra` is not set to `ALLOW_EXTRA` unless there is a specific reason.\n\nStep 4: Strip internal fields before validation\n- For every path where you receive a config payload (e.g., discovery callbacks), remove internal keys using `dict.pop` before passing the payload to the schema validator.\n- Example: `discovery_hash = payload.pop(ATTR_DISCOVERY_HASH)`; `base = payload.pop(TOPIC_BASE, None)`.\n- After popping, operate on the cleaned payload when calling your schema: `config = PLATFORM_SCHEMA(payload)`.\n\nStep 5: Centralize shared schema fragments\n- If multiple variants of a component share config fields (like a 'schema' selector or common attributes), define a shared schema fragment in a common module.\n- Example: `COMMON_SCHEMA = vol.Schema({ vol.Optional('schema', default='basic'): vol.Any('basic', 'json', 'template') })`.\n- In each variant’s module, extend this shared schema: `variant_schema = base_schema.extend(...).extend(COMMON_SCHEMA.schema)`.\n\nStep 6: Avoid circular imports when sharing schema pieces\n- When a shared schema constant is defined in a module that also imports its variants, move variant imports inside functions that need them instead of at the top of the file.\n- Example: inside `validate_config(value): from . import variant_a, variant_b`.\n- This prevents circular import errors when the module graph becomes more tightly coupled due to shared schema definitions.\n\nStep 7: Update tests and sample configurations\n- Run the test suite to surface failures caused by stricter validation.\n- Fix test payloads and sample configurations by:\n  - Replacing obsolete or incorrect keys (e.g., 'status_topic' → 'state_topic').\n  - Removing fields not part of the public schema (e.g., extraneous 'command_topic' on read-only entities, unsupported options like 'effect_command_topic').\n  - Ensuring that internal metadata fields are absent from the validated payloads.\n- Re-run tests until all validation errors are resolved and coverage reflects the stricter behaviour.\n\nStep 8: Communicate breaking changes\n- Mark the change as breaking where appropriate (e.g., documentation, release notes, labels), especially when removing ALLOW_EXTRA and enforcing strict field names.\n- Document the correct field names and supported options so users can fix their configurations.\n\nStep 9: Verify runtime behaviour\n- After adjustments, test real or mocked discovery flows and static configurations to ensure that:\n  - Valid configs load and update correctly.\n  - Invalid or misspelled options now raise clear validation errors.\n  - Internal protocol metadata is handled without impacting user configuration."
        ]
    }
}
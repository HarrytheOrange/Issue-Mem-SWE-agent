{
    "search_index": {
        "description_for_embedding": "Added MQTT availability (online/offline) handling to Home Assistant MQTT binary sensors using an availability_topic and configurable payloads. Sensor now reports STATE_UNAVAILABLE when device is offline and starts in an 'unknown' state instead of defaulting to 'off' when no retained state message exists. Implementation subscribes to both state and availability topics and exposes an 'available' property.",
        "keywords": [
            "Home Assistant",
            "MQTT",
            "binary_sensor",
            "availability_topic",
            "LWT",
            "last will",
            "online offline",
            "STATE_UNAVAILABLE",
            "unknown initial state",
            "mqtt.py",
            "async_subscribe",
            "payload_available",
            "payload_not_available"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the MQTT binary sensor platform in Home Assistant lacked awareness of device availability and misleadingly defaulted its state to 'off' when no retained message existed on the MQTT state_topic. This could make an actually 'on' device look 'off' in the UI if Home Assistant started after the device had already published a non-retained 'on'. The fix introduced support for an MQTT availability_topic (typically used for LWT/birth messages) plus configurable payloads for 'available' and 'not available'.\n\nSpecifically, the platform schema was extended to accept availability_topic, payload_available (default 'online'), and payload_not_available (default 'offline'), using valid_subscribe_topic for validation. The MqttBinarySensor constructor now accepts these parameters, stores them, and tracks availability via a new _available attribute. If no availability_topic is configured, the sensor assumes available; if it is configured, the sensor starts as not available until it receives an availability payload.\n\nThe sensor's initial _state was changed from False to None to avoid incorrectly reporting 'off' before any state has been received. The async_added_to_hass method now subscribes to the state topic and a new availability topic. The state_message_received callback processes the value_template (if present), compares payloads to payload_on/payload_off, updates _state accordingly, and schedules a state update. The availability_message_received callback toggles _available based on matching payload_available/payload_not_available and also schedules a state update. The available property was added to expose availability to Home Assistant, which then maps unavailable devices to STATE_UNAVAILABLE.\n\nTests were added to verify: (1) when no availability_topic is configured, the sensor's state is not STATE_UNAVAILABLE; (2) when an availability_topic is configured with default payloads, the sensor starts as STATE_UNAVAILABLE, becomes available upon receiving 'online', and returns to STATE_UNAVAILABLE upon receiving 'offline'; (3) the same behavior works with custom payload_available/payload_not_available values. A small follow-up change only moved the state subscription call so that it appears right after the state listener function for clarity.",
        "semantic_memory": "This change illustrates several general patterns for robust MQTT-based integrations and Home Assistant entities:\n\n1. **Device availability handling via MQTT LWT/birth messages**: Many MQTT devices publish a 'birth' message when they come online and a 'last will' (LWT) message when they go offline. Exposing an `availability_topic` and configurable `payload_available`/`payload_not_available` allows the platform to surface real device availability (e.g., mapping to an `available` property and ultimately to `STATE_UNAVAILABLE`). This pattern should be reused across all MQTT-based entities for consistent offline/online semantics.\n\n2. **Avoiding misleading default states**: Defaulting an entity state to a concrete value like 'off' when the system has not actually received any state information is misleading. Using a `None` internal state that maps to an 'unknown' or equivalent UI state more accurately reflects reality. This is especially important when state_topic messages are not retained and the integration may start after the last update.\n\n3. **Configurable payloads instead of hard-coded strings**: Different devices may use various strings for online/offline and on/off. Providing configuration options like `payload_available`, `payload_not_available`, `payload_on`, and `payload_off` increases flexibility and prevents fragile hard-coded logic. The pattern is: define constants for defaults, add them to the schema, and allow override via configuration.\n\n4. **Symmetric topic subscription design**: When a component relies on multiple MQTT topics (state and availability), each should have a dedicated callback and subscription, registered in `async_added_to_hass`. This keeps logic separated and clear, and ensures both state changes and availability changes are handled asynchronously in the event loop.\n\n5. **Schema validation for topic configuration**: Using helper validators like `valid_subscribe_topic` at configuration time catches invalid topics early rather than failing at runtime. This pattern applies to any user-supplied MQTT topic configuration.\n\n6. **Testing behavior-driven state transitions**: For MQTT-driven components, tests should simulate topic messages (using helpers like `fire_mqtt_message`) and assert the resulting Home Assistant states, including edge cases like initial state, no availability topic, default vs custom payloads, and offline transitions. This pattern ensures new behavior remains stable and prevents regressions.\n\nOverall, the fix showcases best practices for representing uncertainty and availability in distributed systems: never assume state without data, and expose explicit availability semantics based on reliable signals (like MQTT LWT/birth topics).",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify misleading or missing availability behavior.\n- Observe how an entity behaves when its backing device is offline or when Home Assistant (or your system) restarts.\n- Check if entities remain 'on' or 'off' even when the device is disconnected, or if they default to a concrete state (e.g., 'off') before any messages are received.\n- Determine whether the MQTT device publishes LWT/birth messages (availability) and whether your integration currently uses them.",
            "Step 2: Design availability semantics and configuration.\n- Decide on configuration knobs: at minimum, `availability_topic`, `payload_available`, and `payload_not_available`.\n- Define sensible defaults for payloads (e.g., 'online' / 'offline') but allow them to be overridden by the user.\n- Define how availability maps into your framework (e.g., an `available` property in Home Assistant that maps to `STATE_UNAVAILABLE`).\n- Decide initial availability: usually, if `availability_topic` is not set, default to available; if it is set, default to not available until an 'online' message is seen.",
            "Step 3: Extend the configuration schema.\n- Add new configuration keys to the platform schema (e.g., `CONF_AVAILABILITY_TOPIC`, `CONF_PAYLOAD_AVAILABLE`, `CONF_PAYLOAD_NOT_AVAILABLE`).\n- Use appropriate validators (e.g., `valid_subscribe_topic` for MQTT topics, `cv.string` for payloads).\n- Provide default values for payloads so that a minimal configuration works out-of-the-box.",
            "Step 4: Update the entity class to track availability and initial state.\n- Add fields to the entity for `availability_topic`, `payload_available`, `payload_not_available`, and an internal `_available` flag.\n- Set `_available` based on the presence of `availability_topic` (true if no topic, false if topic exists but no 'available' signal yet).\n- Change the initial state from a concrete `False`/`off` to `None` (or a similar sentinel) so the framework can represent 'unknown' until a real state message is received.\n- Add or update the `available` property (or equivalent) to expose `_available` to the framework.",
            "Step 5: Subscribe to both state and availability topics.\n- In the entity's lifecycle hook (e.g., `async_added_to_hass`), create a callback for state messages that:\n  - Applies any value template if configured.\n  - Compares payload with `payload_on`/`payload_off` and sets the internal `_state` accordingly.\n  - Calls the appropriate method to schedule a state update (e.g., `async_schedule_update_ha_state()`).\n- Register the state callback via the MQTT client (e.g., `yield from mqtt.async_subscribe(self.hass, self._state_topic, state_message_received, self._qos)`).\n- If an `availability_topic` is configured, create an `availability_message_received` callback that:\n  - Compares the payload with `payload_available` and `payload_not_available`.\n  - Sets `_available` accordingly.\n  - Schedules a state update.\n- Subscribe to the availability topic in the same lifecycle hook.",
            "Step 6: Adjust state mapping and UI representation.\n- Ensure that `None` (or your internal sentinel) maps to an 'unknown' state in your framework rather than 'off'.\n- Confirm that when `available` is false, the framework presents the entity as unavailable (e.g., `STATE_UNAVAILABLE` in Home Assistant), usually overriding any specific on/off state in the UI.\n- Verify that when availability switches back to true, the entity reverts to showing its last known or updated state.",
            "Step 7: Add tests to cover availability and initial state.\n- Create tests that configure the entity without `availability_topic` and assert that it is not marked as unavailable on startup.\n- Create tests that configure `availability_topic` with default payloads and assert:\n  - Initial state is unavailable.\n  - An 'online' payload changes the entity to available.\n  - An 'offline' payload changes it back to unavailable.\n- Create tests that configure custom `payload_available` and `payload_not_available` and assert the same behavior using those custom payloads.\n- Optionally, add tests confirming that initial `_state` is treated as unknown until a first state message is received.",
            "Step 8: Validate configuration and code structure.\n- Ensure new options are documented and examples updated.\n- Confirm the schema uses validation helpers (like `valid_subscribe_topic`).\n- Organize callbacks and subscriptions for readability (e.g., define callback functions and immediately follow with their subscriptions).",
            "Step 9: Run tests and manual verification.\n- Run the unit test suite (e.g., `tox`) to ensure full coverage and no regressions.\n- In a test environment, set up an MQTT device publishing an availability topic (birth/LWT) and observe the entity:\n  - Start your system and verify initial availability and unknown state behavior.\n  - Disconnect/reconnect the device, verify `STATE_UNAVAILABLE` transitions.\n- Adjust or refine behavior based on real-world observations."
        ]
    }
}
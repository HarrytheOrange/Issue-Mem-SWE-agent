{
    "search_index": {
        "description_for_embedding": "Refactor PokemonGo-Bot from direct logger.log calls to a centralized event-based logging system that also drives websocket updates, with multibot support, unicode-safe logging, and test fixes (float precision, FakeBot setup). Introduces EventManager, LoggingHandler, SocketIoHandler, BaseTask.emit_event, websocket server and remote control API.",
        "keywords": [
            "logger.log deprecation",
            "event_manager",
            "LoggingHandler",
            "SocketIoHandler",
            "BaseTask.emit_event",
            "websocket server",
            "multibot websocket",
            "remote control",
            "unicode logging",
            "float precision test",
            "follow_cluster_test",
            "FakeBot event_manager",
            "spin_fort events",
            "incubate_eggs events"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the project migrated away from ad-hoc `logger.log` calls scattered across tasks and core code to a centralized event-based system that feeds both traditional logs and websocket clients.\n\nThe core change was the introduction and wiring of an `EventManager` alongside two handlers: `LoggingHandler` (which converts events into standard Python logging output) and `SocketIoHandler` (which publishes events to a socket.io server). `PokemonGoBot._setup_event_system` now constructs these handlers based on configuration, creates the `EventManager`, registers all events in `_register_events`, and optionally prints a report of all registered events if `--show_events` is passed, then exits.\n\nAll task classes (e.g., `CatchVisiblePokemon`, `CatchLuredPokemon`, `CollectLevelUpReward`, `EvolveAll`, `MoveToFort`, `SpinFort`, `TransferPokemon`, `IncubateEggs`, `NicknamePokemon`, `SleepSchedule`, `HandleSoftBan`, `FollowCluster`, `FollowPath`, `FollowSpiral`, `RecycleItems`) were refactored to stop using `logger.log` and instead emit structured events. To make this easier, `BaseTask` gained an `emit_event` helper that wraps `self.bot.event_manager.emit`. `PokemonCatchWorker` now inherits from `BaseTask` so it can use `emit_event` too.\n\n`PokemonGoBot.__init__` gained a logger instance and `_register_events` defines a large set of events (login events, position updates, pokestop/fort events, catching and evolving pokémon, incubating eggs, items discard, softban handling, inventory, rename/sleep events, etc.) with parameter schemas. `EventManager.emit` validates that `data` keys match the registered parameter names; it then interpolates the `formatted` message and forwards the event to all handlers.\n\nCLI startup (`pokecli.py`) was updated to use Python's `logging` directly for CLI messages (`logger.info`) and to emit `bot_start`, `bot_exit`, and `not_logged_in` events instead of `logger.log`. A `--show_events` flag was added to dump the event registry and exit, making it easier for UI developers to inspect available events and their payloads.\n\nWebsocket support was expanded: the embedded socket.io server in `socketio_server/app.py` was simplified to just route requests and broadcasts. A new `SocketIoRunner` utility already existed; this PR added `ws_server.py` to run a standalone websocket server. `SocketIoHandler` was updated to hold a long-lived socket.io connection and, importantly, now includes the account username in each broadcast. On the server side, events are now namespaced per account by suffixing event names (e.g., `event_name:username`) and including the `account` field, allowing multiple bots to share a single websocket server. A new `WebsocketRemoteControl` component listens to `bot:process_request:<username>` and emits `bot:send_reply` with account tagging; an example command `get_player_info` is implemented.\n\nSeveral bugs and rough edges from the refactor were fixed along the way:\n- Float precision differences on different platforms broke `follow_cluster_test`. The tests were updated to use `assertAlmostEqual` with a small delta instead of exact list equality, and expected coordinates were slightly adjusted.\n- Tests previously assumed no event system; `tests/__init__.py` now defines a `FakeBot` that constructs an `EventManager`, calls `_setup_event_system`, and disables websocket features (`websocket_server_url=False`, `show_events=False`) so tests run without a real server.\n- Typo fixes in event emission: `formatted` vs `formmated`/`formatted_msg`, `data` vs `date`, wrong event names (e.g., `pokestop_empty` instead of `empty_pokestop`), and parameters mismatches (e.g., `egg_hatched` uses `exp` instead of `xp`, added `fort_name` to `lured_pokemon_found` event).\n- Unicode issues were addressed by adding UTF-8 headers, using `from __future__ import unicode_literals`, and simplifying encoding/decoding logic in `LoggingHandler`, `SocketIoHandler`, and tasks like `MoveToFort` and `SpinFort`. Formatting now relies on Python's normal string handling instead of manual `.encode/.decode` calls.\n- The old `pokemongo_bot/logger.py` module was removed but later reintroduced as a minimal compatibility shim: `logger.log` now logs via Python logging and raises a loud `DeprecationWarning` telling developers to use the event system or `self.logger` in tasks.\n- `SpinFort` and other tasks were updated to compute structured items data for events, correctly handle inventory-full and cooldown states, and emit appropriate events (e.g., `pokestop_out_of_range`, `pokestop_on_cooldown`, `inventory_full`, `softban`).\n\nIn summary, this PR implements the event-driven logging and websocket architecture, migrates virtually all task-level logging to events, adds multibot-safe websocket routing and remote control, fixes test flakiness around float precision, and cleans up unicode and logging issues introduced by the refactor.",
        "semantic_memory": "This change embodies several generalizable patterns:\n\n1. **Replace ad-hoc logging with a structured event system**: Instead of scattering direct logging calls throughout the codebase, define a central `EventManager` with a registry of events and their parameter schemas. Components emit semantic events (e.g., `pokemon_caught`, `spun_pokestop`) rather than free-form log strings. Handlers (e.g., log output, metrics sinks, websocket broadcasters) subscribe to these events and can be extended independently.\n\n2. **Decouple producers and consumers with handlers**: `EventManager` knows nothing about how events are consumed; it simply forwards them to any registered `EventHandler`. This matches a publish/subscribe architecture that makes it easy to add new outputs (web UI, metrics, file logging) without touching business logic.\n\n3. **Enforce event schemas**: Register each event with an explicit list of parameters. At emit time, validate that the `data` keys match the schema. This catches typos and payload mismatches early, which is crucial as the event catalog grows and UIs/microservices depend on it.\n\n4. **Provide ergonomic helpers in base classes**: Adding `BaseTask.emit_event` dramatically reduces boilerplate and encourages consistent usage among all task implementations. Similarly, having tasks inherit from a base class that gives them a `logger` means any remaining imperative logs are consistent.\n\n5. **Multi-tenant websocket routing**: When many bots share a single websocket server, events must be namespaced by account. This PR does that by including the `account` field, and by naming channels with a suffix (e.g., `event_name:username`). This pattern is generally applicable to any multi-client websocket/pub-sub system.\n\n6. **Remote control via event channels**: The remote control flow uses a symmetrical request/response event scheme: clients emit `remote:send_request` with `account` and command, server forwards to `bot:process_request:<account>`, the bot responds on `bot:send_reply`, which the server maps back to an account-specific reply event. This pattern can be reused for remote procedure calls over websockets in other systems.\n\n7. **Test robustness across platforms**: Floating-point computations (like clustering/geo calculations) often yield slightly different binary results on different OSes or Python builds. Tests should avoid strict equality on floats and instead use tolerance-based comparisons (`assertAlmostEqual` or distance thresholds). This PR adjusts tests accordingly.\n\n8. **Unicode-safe logging and messaging**: When events may contain non-ASCII strings (names, locations, etc.), it's better to standardize on Unicode strings at the Python layer (`unicode_literals`) and avoid manual encoding/decoding, letting the logging/websocket libraries handle encoding on output. Over-encoding leads to hard-to-debug errors.\n\n9. **Backward compatibility with deprecation warnings**: Removing a widely-used interface (`logger.log`) in one shot can break many downstream consumers. Introducing a thin shim that continues to work but emits a strong `DeprecationWarning` is a practical way to migrate large codebases incrementally.\n\n10. **Config-driven capabilities and introspection**: Features like `--show_events` provide introspection into the event system for developers and UI authors, making it easier to maintain agreement between backend events and frontend expectations.\n\nThese patterns are broadly useful for any application that wants to move from unstructured logs to a robust, extensible, real-time observability and control layer.",
        "procedural_memory": [
            "Step-by-step approach to migrate from ad-hoc logging to a structured event and websocket system, and to avoid regressions (tests, unicode, multi-client routing).",
            "Step 1: Design an Event Manager\n- Create an `EventManager` class that:\n  - Maintains a registry of events and their expected parameters (e.g., `register_event(name, parameters=[...])`).\n  - Holds a list of `EventHandler` instances.\n  - Provides `emit(event, sender, level, formatted, data)` that:\n    - Verifies the event is registered, otherwise raises an `EventNotRegisteredException`.\n    - Validates that `data` keys match the registered parameter list, raising an error for unexpected keys.\n    - Renders `formatted` using `formatted.format(**data)`.\n    - Dispatches the event to all handlers via `handler.handle_event(event, sender, level, formatted_msg, data)`.\n\nStep 2: Implement Event Handlers\n- Implement a `LoggingHandler(EventHandler)`:\n  - In `handle_event`, obtain a logger per sender class (`logging.getLogger(type(sender).__name__)`).\n  - Construct a message like `[event_name] formatted_msg` or `event_name: data`.\n  - Call `getattr(logger, level)(message)`.\n- Implement a `SocketIoHandler(EventHandler)`:\n  - Accept the bot instance and websocket URL in the constructor.\n  - Maintain a long-lived socket.io `SocketIO(host, port)` instance.\n  - In `handle_event`, add a `msg` entry to `data` if formatted is non-empty.\n  - Emit `bot:broadcast` with payload containing `event`, `account` (e.g., bot username), and `data`.\n\nStep 3: Wire the Event System into the Core Bot\n- In the bot class (e.g., `PokemonGoBot`):\n  - Add `_setup_event_system` that:\n    - Instantiates `LoggingHandler` by default.\n    - If websocket config is present, optionally start the embedded websocket server (`SocketIoRunner`) and then add `SocketIoHandler`.\n    - Creates `self.event_manager = EventManager(*handlers)`.\n    - Calls a `_register_events` method to register all known events.\n    - Optionally, if a CLI flag like `--show_events` is set, call `event_manager.event_report()` to print event names and parameters, then exit.\n  - Ensure `_setup_event_system` is called before any events are emitted (e.g., during `start()` or test initialization).\n\nStep 4: Define All Events and Schemas\n- In `_register_events`, register every semantic event your system will emit. Examples:\n  - Core lifecycle: `login_started`, `login_failed`, `login_successful`, `bot_start`, `bot_exit`.\n  - Location: `location_found(position, location)`, `position_update(current_position, last_position, distance, distance_unit)`, `load_cached_location`, `location_cache_error`, `location_cache_ignored`.\n  - Fort/pokestop: `moving_to_fort(fort_name, distance)`, `moving_to_lured_fort(fort_name, distance, lure_distance)`, `spun_pokestop(pokestop, exp, items)`, `pokestop_empty`, `pokestop_on_cooldown`, `pokestop_out_of_range`, `inventory_full`, `softban`, `softban_fix`, etc.\n  - Pokémon: `catchable_pokemon(...)`, `pokemon_appeared(...)`, `pokemon_catch_rate(...)`, `threw_berry`, `threw_pokeball`, `pokemon_caught`, `pokemon_fled`, `pokemon_vanished`, `pokemon_evolved`, `pokemon_evolve_fail`, `vip_pokemon`.\n  - Eggs: `next_egg_incubates(distance_in_km)`, `incubate_try`, `incubate`, `egg_hatched(pokemon, cp, iv, exp, stardust, candy)`.\n  - Items and inventory: `item_discarded`, `item_discard_fail`, `inventory_full`.\n  - Other tasks: `keep_best_release`, `future_pokemon_release`, `pokemon_release`, `rename_pokemon`, `pokemon_nickname_invalid`, `unset_pokemon_nickname`, `next_sleep`, `bot_sleep`, etc.\n\nStep 5: Refactor Tasks to Use Events Instead of Direct Logging\n- Add a base class `BaseTask` used by all tasks:\n  - Store `self.bot` and `self.config`.\n  - Give it `self.logger = logging.getLogger(type(self).__name__)` for any remaining direct logs.\n  - Implement an `emit_event` helper that wraps `self.bot.event_manager.emit`.\n- Update each task (e.g., `CatchVisiblePokemon`, `SpinFort`, `MoveToFort`, `IncubateEggs`, `TransferPokemon`, `NicknamePokemon`, `SleepSchedule`, `HandleSoftBan`, `FollowCluster`, `FollowPath`, `FollowSpiral`, `RecycleItems`):\n  - Replace `logger.log('message', 'color')` with structured event emissions using `emit_event('event_name', level='info'/'debug'/'warning', formatted='template', data={...})`.\n  - Keep direct logs only where strictly necessary, through `self.logger`, not via deprecated modules.\n- Ensure that data passed to `emit_event` uses keys exactly matching the event’s registered parameters.\n\nStep 6: Handle Websocket Routing and Multibot Support\n- On the bot side (SocketIoHandler):\n  - Always include the `account` identifier (e.g., username) in the broadcast payload.\n- On the server side (`socketio_server/app.py`):\n  - For remote control requests: listen on `remote:send_request` and forward to `bot:process_request:<account>`.\n  - For bot replies: listen on `bot:send_reply`, extract `command` and `account`, and emit to `<command>:<account>`.\n  - For broadcasts: listen on `bot:broadcast`, extract `event` and `account`, and emit to `<event>:<account>` with the `data` payload.\n- Implement a remote control helper on the bot (`WebsocketRemoteControl`):\n  - Connect to the websocket server and subscribe to `bot:process_request:<username>`.\n  - On receiving commands, dispatch to bot methods (e.g., `get_player_info`) and respond via `bot:send_reply` with the `account` field.\n\nStep 7: Make Tests Aware of the Event System\n- For unit tests, create a `FakeBot` that:\n  - Has a `config` object with websocket features disabled (e.g., `websocket_server_url=False`, `show_events=False`).\n  - Initializes `self.event_manager = EventManager()` and calls `_setup_event_system()`.\n- Update tests that depend on locations or clusters to handle float precision:\n  - Instead of asserting equality on coordinate lists, use `assertAlmostEqual` with a small delta (`delta=1e-11` or a spatial distance threshold) for each coordinate.\n\nStep 8: Normalize Unicode Handling in Logging and Events\n- At the top of modules dealing with text, add `# -*- coding: utf-8 -*-` and `from __future__ import unicode_literals`.\n- Remove manual `.encode()` and `.decode()` on strings when formatting log messages or events; let logging and socket.io handle encoding.\n- Ensure `formatted` strings for events are plain Unicode strings and rely on `.format(**data)` to substitute values.\n\nStep 9: Provide a Backward-Compatible Logger Shim\n- For legacy code that still calls `pokemongo_bot.logger.log`:\n  - Implement a minimal `logger.py` with `log(msg, color=None)` that:\n    - Emits a `DeprecationWarning` explaining that `logger.log` is deprecated and instructing developers to use `emit_event` or `self.logger`.\n    - Logs the message via a standard `logging.getLogger('generic').info(msg)`.\n- This allows the repository to remain stable while third-party code migrates.\n\nStep 10: Expose the Event Catalog for Tooling\n- Implement `EventManager.event_report()` that prints each registered event and its parameters.\n- Wire a CLI flag (e.g., `--show_events`) to:\n  - Build the bot.\n  - Call `event_manager.event_report()`.\n  - Exit without running the bot loop.\n- Use this to keep frontend/websocket consumers in sync with backend event definitions.\n\nBy following these steps, a developer can systematically refactor an existing logging-heavy system into a structured event-based observability and control layer, while maintaining compatibility and test stability."
        ]
    }
}
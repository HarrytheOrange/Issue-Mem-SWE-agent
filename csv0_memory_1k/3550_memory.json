{
    "search_index": {
        "description_for_embedding": "Fix for PokemonGo bot inventory/moveset logic: corrected Venonat charged move list and multiple BaseDefense/BaseStamina stats and type info in pokemon.json, introduced CP multiplier static data and robust CP/moveset calculations, and changed unexpected moveset handling from raising exceptions (crashing the bot) to logging an error and using a fallback moveset.",
        "keywords": [
            "Venonat charged attacks",
            "pokemon.json BaseDefense BaseStamina swap",
            "PokemonGo bot inventory",
            "moveset DPS calculation",
            "LevelToCPm",
            "STAB damage",
            "unexpected moveset fallback",
            "KeyError unknown attack",
            "crash to log-and-fallback",
            "Pokemons STATIC_DATA",
            "ChargedAttacks FastAttacks"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the PokemonGo bot had incorrect static game data and brittle handling of movesets, which together could crash the bot. Specifically, Venonat's list of charged attacks in data/pokemon.json did not match the actual game: the JSON listed 'Dazzling Gleam' and 'Shadow Ball' while the correct set is 'Poison Fang', 'Psybeam', and 'Signal Beam'. Additionally, many Pokemon entries had BaseDefense and BaseStamina values swapped, and some Fairy-related type info (Clefairy, Clefable, Jigglypuff, Wigglytuff, Mr. Mime) was wrong. The inventory code precomputes movesets (fast+charged) from pokemon.json and the fast/charged move tables. When it encountered a Pokemon with a move combination not present in these precomputed movesets, it raised an exception ('Unexpected moveset [...] for #id Name') and terminated the bot. There was also no centralized, test-backed CP multiplier data; CP precision and level calculations relied on implicit assumptions.\n\nThe fix had several parts:\n- Reapplied a previously reverted inventory enhancement patch ('Better inventory: attacks & movesets, IV CP perfection, pokemon level, etc.') and extended it.\n- Introduced a new static data abstraction (_StaticInventoryComponent) and static components for Pokemon, moves, and CP multipliers: LevelToCPm with level_to_cpm.json, FastAttacks and ChargedAttacks, and richer Pokemons metadata (types, attacks converted to Attack/ChargedAttack objects, precomputed movesets with DPS, attack/defense perfection, and max CP per species).\n- Corrected many pokemon.json entries by swapping BaseDefense and BaseStamina where they had been mixed up, and fixed type data for Mr. Mime, Clefairy, Clefable, Jigglypuff, and Wigglytuff. CaptureRate zeros were normalized to numeric 0. The Golbat, Rattata, and other derived values were updated accordingly, and tests were adjusted to new expected CP-perfection and CP-percent values.\n- Fixed Venonat's Special Attack list to the correct set: ['Poison Fang', 'Psybeam', 'Signal Beam'].\n- Enhanced Pokemon object construction: it now reads cp_multiplier and additional_cp_multiplier, uses LevelToCPm to infer the pokemon level, computes exact CP via the known formula, asserts that the rounded CP matches the server-provided CP (with min 10), computes IV perfection and CP-based IV perfection (ivcp) using max-level CP of the best evolution, and derives cp_percent against a per-species max_cp.\n- Changed moveset resolution in Pokemon._get_moveset: instead of raising an exception on an unknown moveset combination, it logs an error suggesting pokemon.json be updated and then constructs a fallback Moveset on the fly using the actual fast and charged Attack objects and types from static data. This prevents the bot from crashing when Niantic changes move availability or the local JSON is slightly out-of-sync.\n- Added comprehensive unit tests in tests/inventory_test.py for Pokemons STATIC_DATA ranges, evolution graph consistency, LevelToCPm behavior, Attack collections (BY_NAME/BY_TYPE/BY_DPS), and a couple of concrete Pokemon samples (Golbat and Rattata) to validate level, IV, ivcp, max_cp, cp_percent, and moveset DPS/perfection. The tests were updated to align with corrected base stats and the new CP calculations.\n\nAs a result, the bot now uses corrected static data for Venonat and many other Pokemon, has a proper CP multiplier table, validates CP computations, and handles unexpected movesets gracefully with logging and fallback behavior instead of killing the process.",
        "semantic_memory": "This fix encodes several generalizable lessons about working with game-like static data and combat calculations in bots or simulators:\n\n1. **Static data must be authoritative and consistent**: Many systems rely on static JSON-like metadata (e.g., pokemon.json) for core behavior. Errors in base stats (like swapped BaseDefense/BaseStamina) or type information propagate into all dependent calculations (CP, damage, rankings). Maintaining accurate, test-validated canonical data is critical.\n\n2. **Precomputed structures depend on input data correctness**: The inventory layer precomputes derived values: Pokemon types, Attack/ChargedAttack objects, movesets, STAB-adjusted DPS, and species max CP. These derived structures assume underlying data (move lists, types, stats) is valid. When underlying data changes or is wrong, it can invalidate assumptions. Therefore, there should be both validation tests and runtime safeguards.\n\n3. **Be resilient to unknown or evolving data**: In live games, the server can introduce new move combinations or alter existing ones. Relying on static lists of allowed movesets and raising exceptions when encountering an unknown combination makes the system brittle. Instead, code can detect unexpected combinations, log clear diagnostic messages, and fall back to a reasonable default (e.g., dynamically constructing a Moveset with current fast/charged moves and known types). This preserves functionality while surfacing issues for later data updates.\n\n4. **Centralize and test core formulas and constants**: CP and level calculations depend on a set of constants (CP multipliers per level) and a widely-known formula. Centralizing these into a dedicated component (LevelToCPm) and validating both directions (level->CPm, CPm->level) in tests makes the logic more robust and easier to maintain. An assert tying computed CP back to the server-supplied CP also protects against regressions in formula or data.\n\n5. **Represent domain concepts as rich objects, not raw dicts**: Wrapping moves into Attack/ChargedAttack classes and movesets into a Moveset class with methods/fields (DPS, STAB-adjusted DPS, type-relative ranking) simplifies reasoning and makes the rest of the system more expressive. The same applies to Pokemon objects that expose level, IV, IVCP, CP percent, and evolution relationships instead of just raw JSON.\n\n6. **Use tests to enforce invariants and data quality**: The new tests assert that all 151 Pokemon have sensible ranges for base stats, capture/flee rates, weaknesses, movesets, and evolution requirements. They also confirm that move tables are consistent across lookups (BY_NAME, BY_TYPE, BY_DPS) and that CP calculations for example Pokemon match expectations. These tests act as guards against future data or code changes that could silently break calculations.\n\n7. **Logging and messaging over hard failure in non-critical paths**: For a background bot, encountering a previously unseen moveset is usually not a reason to crash. Changing the behavior from raising an exception to logging a detailed error and using a fallback moveset strikes a better balance between visibility of issues and operational robustness. The error message also suggests how to fix the underlying data and encourages contributions (update pokemon.json and open a PR), which is a good pattern for community-driven projects.",
        "procedural_memory": [
            "When dealing with crashes or incorrect behavior tied to static metadata (like pokemon.json) and combat calculations, follow these steps:",
            "Step 1: Reproduce and capture the error.",
            "If the bot crashes, capture the exact exception, stack trace, and context. In this case, errors like 'Unexpected moveset [fast, charged] for #id Name' or KeyErrors for unknown attack names indicated a mismatch between live game data and local static data.",
            "Step 2: Check static data for the affected entity.",
            "Inspect the relevant JSON entries (e.g., for the specific Pokemon that caused the issue). Verify fields such as BaseAttack, BaseDefense, BaseStamina, Type I/II, and move lists (Fast Attack(s), Special Attack(s)) against a trusted external source (official documentation, community datamine, or gamepress-style databases). Correct any inconsistencies, such as swapped defense/stamina or wrong type (e.g., Normal instead of Fairy) or outdated move lists. For Venonat, update its Special Attack(s) from old values to the correct ['Poison Fang', 'Psybeam', 'Signal Beam'].",
            "Step 3: Validate derived data construction.",
            "If you precompute derived data (movesets, DPS, max CP, types), check the processing code. For this fix, Pokemons.process_static_data now generates types, replaces move names with Attack/ChargedAttack objects, precomputes movesets, and calculates max_cp per species. Ensure this pipeline runs at startup and that STATIC_DATA is properly initialized.",
            "Step 4: Add or verify a canonical constants source.",
            "For formulas that rely on constants (like CP multipliers per level), create a dedicated static component (e.g., LevelToCPm) loading from a JSON map (level_to_cpm.json). Implement helper methods for cp_multiplier_for(level) and level_from_cpm(cp_multiplier), and precompute key values (MAX_LEVEL, MAX_CPM). This prevents ad-hoc duplication of the constants in multiple places.",
            "Step 5: Compute and assert core derived metrics.",
            "Implement a clear CP calculation function (e.g., _calc_cp) that encapsulates the domain formula: CP = (BaseAtk + IV_A) * sqrt(BaseDef + IV_D) * sqrt(BaseSta + IV_S) * CP_Mult^2 / 10. Use this in your Pokemon class to compute cp_exact from base stats, IVs, and CP multiplier, then assert that the server-provided CP matches (within rules, e.g., max(int(cp_exact), 10) == cp). Also compute level via LevelToCPm.level_from_cpm(cp_multiplier) and expose IV and CP perfection metrics (iv, ivcp, cp_percent).",
            "Step 6: Replace hard failures on unexpected combinations with logging + fallback.",
            "In code that assumes a finite set of valid combinations (e.g., Pokemon._get_moveset scanning a precomputed movesets list), handle misses gracefully. Instead of raising an exception, log a detailed error explaining the unexpected combination and pointing to where to update static data (\"please update info in pokemon.json and create issue/PR\"). Then construct a fallback structure that uses the best information available, for example: Moveset(current_fast_attack, current_charged_attack, types_from_static_data, pokemon_id). This ensures the system continues functioning while alerting developers.",
            "Step 7: Normalize and validate numeric ranges in tests.",
            "Add tests that enforce reasonable ranges for all key stats in static data: BaseAttack/BaseDefense/BaseStamina within known bounds, CaptureRate and FleeRate between 0 and 1, sane CP ranges (max_cp), non-empty Weaknesses, and valid name lengths. Adjust tests if you correct swapped values (e.g., Defense and Stamina bounds swapped). Ensure evolution requirements are consistent (Next Evolution Requirements family matches first_evolution_id, candy name matches the family name, and candy amount is in expected range).",
            "Step 8: Validate move tables and attack abstractions.",
            "Wrap raw move dicts into Attack/ChargedAttack classes with properties like damage, duration (seconds), energy, DPS, STAB-adjusted damage, and type-relative ranking (rate_in_type). Build indexes BY_NAME, BY_TYPE, and BY_DPS. Write tests that ensure consistency across these indices: every attack should be reachable by id, name, and type list; DPS should be non-increasing across BY_DPS; and type lists should be sorted by DPS.",
            "Step 9: Validate sample instances end-to-end.",
            "Instantiate a few representative entities (e.g., Golbat and Rattata) with realistic server-provided fields: cp, cp_multiplier, additional_cp_multiplier, individual_attack/defense/stamina, moves, favorite flag, etc. Assert that the derived fields (level, iv, ivcp, max_cp, cp_percent, moveset.dps, moveset.attack_perfection, moveset.defense_perfection) match expected values based on the corrected static data and formulas.",
            "Step 10: Ensure initialization order and helpers are correct.",
            "Initialize static components at module import (e.g., LevelToCPm(), FastAttacks(), ChargedAttacks()) so they are ready before creating Pokemon objects. Provide small helper functions (levels_to_cpm, fast_attacks, charged_attacks) to access these components. Verify that your global inventory object uses the updated components and that the tests run without needing an actual server inventory.",
            "Step 11: Monitor logs and iterate.",
            "After deploying the fix, monitor logs for the error message emitted by the fallback path on unexpected movesets. If such errors appear, update pokemon.json and/or moves JSON files with the new move combinations and add tests to cover them. This iterative process keeps the static data and derived logic in sync with live game updates without sacrificing bot stability."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Foscam camera component migrated from direct HTTP calls and the old pyfoscam dependency to a new forked library libpyfoscam. The fix updates REQUIREMENTS, imports, and requirements_all.txt so the correct package is installed and used for motion detection and snapshots.",
        "keywords": [
            "foscam camera",
            "homeassistant.components.camera.foscam",
            "pyfoscam",
            "libpyfoscam",
            "dependency mismatch",
            "requirements_all.txt",
            "REQUIREMENTS constant",
            "third-party library fork",
            "ImportError",
            "motion detection enable/disable"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the Home Assistant Foscam camera integration was first enhanced to support enabling and disabling motion detection. The initial implementation did this by constructing HTTP CGI URLs manually with requests, including custom query parameters for sensitivity, schedule, and detection areas.\n\nDuring review, this approach was replaced with a dedicated third-party library. The component was updated to declare REQUIREMENTS = ['pyfoscam==1.2'], imported FoscamCamera from that package, and used its APIs for snapshot capture and motion detection control. The requirements_all.txt was updated accordingly via script/gen_requirements_all.py.\n\nLater, it turned out that the pyfoscam package and its upstream library situation were problematic (upstream unresponsive, need for a maintained fork). A new library, libpyfoscam, was published to PyPI with the same functionality but a different package name and import path. Because the component still depended on pyfoscam, Home Assistant installations could suffer from ImportError or missing/incorrect functionality if the expected package was not available or updated.\n\nThe specific fix in this PR was to switch the Foscam camera integration from pyfoscam to libpyfoscam. Concretely:\n- The REQUIREMENTS constant in homeassistant/components/camera/foscam.py was changed from ['pyfoscam==1.2'] to ['libpyfoscam==1.0'].\n- The import was changed from `from foscam.foscam import FoscamCamera` (or `from foscam import FoscamCamera` in an earlier iteration) to `from libpyfoscam import FoscamCamera`, matching the new library structure.\n- requirements_all.txt was updated to remove the pyfoscam entry and add a new section for `# homeassistant.components.camera.foscam` with `libpyfoscam==1.0`.\n- While updating requirements_all.txt, a duplicate python-mirobo entry was inadvertently generated and later removed, ensuring there is only a single, correct entry.\n\nAdditionally, the component’s runtime logic was adjusted to use the library’s return codes instead of broad try/except blocks: camera_image() now checks the result code from snap_picture_2() and returns None on communication error; enable_motion_detection() and disable_motion_detection() inspect the return code (FOSCAM_COMM_ERROR) and log debug output when communication fails, updating the internal _motion_status accordingly. Lint and style issues raised by the CI bots (HoundCI, Travis, etc.) were fixed incrementally (line wrapping, docstring mood, unused imports). Ultimately, this PR ensures that the Foscam camera platform consistently installs and imports the maintained libpyfoscam library via Home Assistant’s dependency management, and that the feature set (snapshots and motion detection toggling) works reliably.",
        "semantic_memory": "This PR illustrates several generalizable lessons about dependency management and integration design:\n\n1. **Keep the code’s imports aligned with declared dependencies.** If a component imports from a package (e.g., `from libpyfoscam import FoscamCamera`), the REQUIREMENTS constant and any global requirements files (like requirements_all.txt) must declare that exact package name and version. Mismatches (e.g., still requiring `pyfoscam` while importing from `libpyfoscam`) will cause runtime ImportError or missing-feature issues.\n\n2. **Use dedicated libraries instead of ad-hoc HTTP calls for device integrations.** The initial Foscam implementation built CGI URLs manually. Moving to a specific Foscam library centralized protocol details, reduced duplication, and made the code easier to maintain. Libraries can also expose higher-level semantics (enable/disable motion detection, schedules) instead of raw URL parameters.\n\n3. **When upstream libraries are unmaintained, a fork may be necessary, but it must be clearly reflected in dependency metadata.** The team created or adopted a fork (libpyfoscam) because the original pyfoscam maintainer was not responsive. This required:\n   - Publishing the fork under a distinct name on PyPI.\n   - Updating the integration to import from the new package.\n   - Updating dependency declarations so deployment tooling installs the forked package.\n   Without synchronizing these pieces, users end up with the wrong library installed.\n\n4. **Automated generation of requirements files must be handled carefully.** The project uses script/gen_requirements_all.py to generate requirements_all.txt (and requirements_test_all.txt). It is important to:\n   - Run the generator against a clean, up-to-date dev branch.\n   - Check the diff for unintended downgrades/upgrades of unrelated dependencies.\n   - Remove accidental duplicate entries (like python-mirobo) before merging.\n\n5. **Return-code-based error handling is preferable to catching broad exceptions.** The Foscam library uses explicit error codes (e.g., FOSCAM_COMM_ERROR = -8). The integration was updated to inspect these return codes rather than using blanket try/except clauses. This makes error handling more explicit, predictable, and easier to log/debug.\n\n6. **Internal state should reflect actual device state, but only after verifying communication succeeded.** When toggling motion detection, the component now only changes `_motion_status` based on the library’s return code. This pattern—\"only update local state after confirmed success\"—helps avoid UI inconsistencies and stale state in home automation systems.\n\n7. **Linting and style automation catch subtle maintainability issues early.** HoundCI, pydocstyle, and other linters drove improvements: using imperative mood in docstrings, removing unused imports, wrapping long lines, and avoiding bare except clauses. Integrating and responding to CI feedback is part of maintaining a healthy codebase.\n\nOverall, the fix is an example of how to properly transition an integration from direct HTTP calls to a third-party SDK, and then how to safely update that SDK dependency when the underlying library ecosystem changes.",
        "procedural_memory": [
            "When an integration that uses a third-party device library starts failing due to ImportError, missing symbols, or upstream changes, verify and align the dependency and import configuration.",
            "Step 1: Identify the actual library in use.\n- Inspect the integration’s source code to see what is imported (e.g., `from libpyfoscam import FoscamCamera`).\n- Check the library’s documentation or repository to confirm the correct PyPI package name and version.\n\nStep 2: Align the component’s REQUIREMENTS with the imports.\n- In Home Assistant-style components, locate the REQUIREMENTS constant (e.g., `REQUIREMENTS = ['libpyfoscam==1.0']`).\n- Update this list to reference the correct package name and desired version.\n- Remove or change any outdated references (e.g., `pyfoscam` → `libpyfoscam`).\n\nStep 3: Update global requirements files if the project uses them.\n- Run the project’s generator script (e.g., `script/gen_requirements_all.py`) to regenerate requirements_all.txt and requirements_test_all.txt.\n- If regeneration is not available, manually add or update the relevant section:\n  - Add a comment indicating the owning component (e.g., `# homeassistant.components.camera.foscam`).\n  - Add the new dependency line (e.g., `libpyfoscam==1.0`).\n  - Remove the old dependency line (e.g., `pyfoscam==1.2`).\n- Review the diff for unrelated changes or duplicates introduced by the generator (e.g., duplicate python-mirobo entries) and clean them up.\n\nStep 4: Fix the imports and object creation code.\n- Update any imports to match the new library: `from old_package import Foo` → `from new_package import Foo`.\n- Adjust object construction signatures as needed to match the new library’s API (e.g., adding a verbose flag or adjusting parameter order).\n- Ensure any constants used for error codes (e.g., FOSCAM_COMM_ERROR) match the new library’s semantics.\n\nStep 5: Refactor error handling to use library-specific return codes.\n- Replace broad try/except blocks with explicit return code checks when the library supports them.\n- Example pattern:\n  - `result, payload = client.snap_picture_2()`\n  - If `result == ERROR_CODE`, log and return None.\n  - Otherwise, return the payload.\n- For state-changing calls, only update your internal state if the call reports success.\n\nStep 6: Run tests and static checks.\n- Run the project’s test suite (e.g., `tox`, `pytest`) to ensure the dependency change did not break other components.\n- Run any linting tools (flake8, pydocstyle, HoundCI) and fix reported issues: long lines, unused imports, non-imperative docstrings, and bare except clauses.\n\nStep 7: Validate behavior against actual devices.\n- For device integrations like cameras, perform manual tests:\n  - Confirm snapshots are retrieved successfully.\n  - Toggle motion detection on and off, and verify both the device and the integration’s internal state reflect the change.\n- Check logs for communication error messages and ensure they are informative but not overly noisy.\n\nStep 8: Keep forks and upstream in mind.\n- If you have to fork an unmaintained library:\n  - Publish it under a distinct PyPI name.\n  - Update all references in your project (REQUIREMENTS, requirements_all, imports).\n  - Document the rationale and, if possible, track a plan for moving back to upstream if/when it becomes active again."
        ]
    }
}
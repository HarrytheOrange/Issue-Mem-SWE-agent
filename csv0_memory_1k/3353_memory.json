{
    "search_index": {
        "description_for_embedding": "Pack configuration prompts in StackStorm were shown in an arbitrary order instead of the order defined in config.schema.yaml. The fix adds end-to-end ordering by using OrderedDict in YAML loading, MongoEngine storage, MongoDB retrieval, and JSON deserialization in the client, plus a mongoengine version bump.",
        "keywords": [
            "StackStorm",
            "pack config",
            "config.schema.yaml",
            "YAML mapping order",
            "OrderedDict",
            "mongoengine DynamicField container_class",
            "bson.CodecOptions document_class",
            "JSON object_pairs_hook",
            "ordering of prompts",
            "configuration schema ordering bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, users reported that the order of configuration prompts shown by the StackStorm CLI (e.g., `st2 pack config <pack>`) did not match the order defined in the pack's `config.schema.yaml`. This inconsistency was confusing and made it harder to use pack configuration as intended. The root cause was that the config schema flowed through multiple layers that all used unordered mappings: YAML parsing into plain dicts, MongoEngine storing the attributes in standard dicts, MongoDB returning them as dicts, and the st2client deserializing JSON responses into dicts. At each step, the inherent non-guaranteed ordering of dictionaries meant the final prompt order was effectively arbitrary.\n\nTo fix this, the PR introduced ordered mappings (OrderedDict) across the entire data path:\n\n1. **YAML loader**: `st2common.content.loader` temporarily overrides the default YAML mapping constructor for `SafeLoader` so that YAML mappings are loaded as `OrderedDict` via `OrderedDict(loader.construct_pairs(node))`. After loading, it restores the original constructor to avoid side effects on other YAML loads.\n\n2. **MongoEngine model**: The `ConfigSchemaDB` model in `st2common.models.db.pack` is updated so that its `attributes` field (EscapedDynamicField) uses `container_class=OrderedDict`. This instructs MongoEngine to store and manage that field as an OrderedDict internally.\n\n3. **MongoDB retrieval layer**: A new base class `StormFoundationDBInOrder` in `st2common.models.db.stormbase` overrides `_get_collection` to call `collection.with_options(codec_options=bson.CodecOptions(document_class=OrderedDict))`. This makes MongoDB return documents as OrderedDicts instead of plain dicts. `ConfigSchemaDB` is changed to inherit from this new base class so the schema attributes retain insertion order when loaded from the database.\n\n4. **Client JSON deserialization**: In `st2client.models.core`, `Resource.deserialize` is extended to accept kwargs passed to `json.loads`. `ResourceManager.get_by_id` now calls `self.resource.deserialize(response.text, object_pairs_hook=OrderedDict)` instead of using `response.json()`. This ensures that JSON objects from the API responses are parsed into OrderedDicts and the attribute order is preserved on the client side.\n\n5. **Dependency update**: The PR bumps `mongoengine` from `0.11.0` to `0.12.0` in `requirements.txt` because the `container_class` parameter for `DynamicField` is only supported starting in MongoEngine 0.12.0.\n\nUnit tests were added/updated to verify the behavior:\n- `test_register_pack_config_schema_in_order` asserts that the stored `ConfigSchemaDB.attributes.keys()` match the expected order from the schema.\n- `test_load_config_schema_in_order` verifies that fetching a ConfigSchema from persistence preserves the attribute order.\n- `test_resource_get_in_order` in the client tests ensures that resource attributes deserialized from JSON remain in the original order.\n\nThis coordinated change across YAML loading, ORM, database codec options, and client deserialization ensures that the pack configuration prompts now respect the order defined in `config.schema.yaml`.",
        "semantic_memory": "This fix illustrates a general pattern: when a system must preserve the order of key-value data across multiple layers (file parsing, ORM, database, API, and client), you must explicitly use ordered data structures and serialization mechanisms at every boundary. Simply relying on default dictionary behavior in languages and libraries that treat mappings as unordered (or implementation-defined) will lead to nondeterministic ordering, especially when data is serialized/deserialized or passed through multiple components.\n\nKey generalizable lessons:\n\n1. **YAML and ordering**: YAML mappings are conceptually unordered. If application logic depends on the order of fields, use a custom YAML loader that maps YAML mappings to an ordered type (e.g., OrderedDict) via a custom constructor for the default mapping tag.\n\n2. **Datastore / ORM configuration**: ORMs often have options to control the container type used for dynamic or generic fields (e.g., `container_class` in MongoEngine's `DynamicField`). Setting this to an ordered container ensures that once data reaches the ORM, key order is preserved in-memory and when re-serialized.\n\n3. **Database drivers and codecs**: Many database drivers offer codec or decoder options that determine the type used for documents or JSON objects (e.g., `bson.CodecOptions(document_class=OrderedDict)` for PyMongo). Leveraging these options can enforce ordering at the lowest layer that interacts with the raw database.\n\n4. **JSON deserialization and order**: Standard JSON parsers often return plain dictionaries. If the order of fields matters to the application (such as prompt ordering in a UI or CLI), use `object_pairs_hook` (Python) or equivalent hooks in other languages to deserialize into ordered containers.\n\n5. **End-to-end consistency requirement**: Ordering guarantees must be maintained end-to-end; it is not sufficient to enforce ordering at a single layer. If any layer converts to an unordered type, the overall system loses ordering guarantees.\n\n6. **Dependency feature awareness**: When relying on specific library features (e.g., `container_class` support in MongoEngine), you must ensure that project dependencies are updated accordingly. A mismatch between code and library capabilities can introduce subtle bugs or runtime errors.\n\n7. **Testing order-sensitive behavior**: When order matters, tests should explicitly assert on the sequence (e.g., `list(mapping.keys()) == [expected, order]`) rather than just checking for key existence. This codifies the ordering contract and prevents regressions.",
        "procedural_memory": [
            "When you encounter a system where configuration or JSON/YAML-defined data appears in the wrong order (e.g., UI prompts, CLI questions, ordered workflows), follow these steps to diagnose and fix the ordering issues:",
            "Step 1: Identify where order matters.\n- Determine exactly which data structure's order is user-visible or logically significant (e.g., config prompts, form fields, step sequences).\n- Trace this structure from its source (file, API, DB) to its final consumer (CLI, UI, service).",
            "Step 2: Trace the full data path.\n- Map out each layer the data passes through: file format (YAML/JSON), parser, in-memory model (dict vs OrderedDict), ORM/ODM, database driver, API serialization, client deserialization.\n- For each layer, note which type is used to represent mappings.",
            "Step 3: Inspect parsers and loaders.\n- For YAML: Check if you're using a loader like `yaml.SafeLoader` that maps to plain dicts.\n- If order is required, implement or enable a constructor that converts YAML mappings into an ordered container (e.g., `SafeLoader.add_constructor(DEFAULT_MAPPING_TAG, lambda loader, node: OrderedDict(loader.construct_pairs(node)))`).\n- If you temporarily patch global loader state, ensure you save and restore the original constructors to avoid side effects.",
            "Step 4: Ensure ORM/ODM respects ordering.\n- For dynamic or generic fields (like MongoEngine's `DynamicField`), configure the container type (e.g., `container_class=OrderedDict`).\n- Update model classes that need ordered attributes to use ordered base classes if available (like a custom `StormFoundationDBInOrder`).\n- Confirm that the ORM library version supports these features; if not, update the dependency.",
            "Step 5: Configure the database driver for ordered documents.\n- For MongoDB/PyMongo: use `collection.with_options(codec_options=bson.CodecOptions(document_class=OrderedDict))` to fetch documents as OrderedDict.\n- For other databases or drivers, look for equivalent configuration (e.g., options to choose the mapping type for documents or JSON columns).",
            "Step 6: Fix API and client serialization/deserialization.\n- On the server side, ensure JSON serialization preserves the order of keys in the in-memory objects (usually automatic if the objects themselves are ordered and the serializer respects insertion order).\n- On the client side, avoid generic `response.json()` or default JSON loaders if they return unordered dicts.\n- Use JSON deserialization hooks (e.g., `json.loads(text, object_pairs_hook=OrderedDict)`) to preserve ordering in the client models.",
            "Step 7: Add order-sensitive tests.\n- Write unit tests that fully cover the data path: from file read, through storage and retrieval, to deserialization in the client.\n- In tests, assert on the exact sequence of keys: `self.assertEqual(list(obj.keys()), ['expected', 'key', 'order'])`.\n- Include both server-side tests (model loading, persistence) and client-side tests (resource fetch, deserialization).",
            "Step 8: Validate behavior end-to-end.\n- Run the actual user flow (e.g., CLI command `st2 pack config <pack>` or the equivalent in your system) and verify that prompts/fields are in the expected order.\n- Check for any remaining layer that might accidentally convert ordered structures back to plain dicts.",
            "Step 9: Document the ordering contract.\n- Document that the order in the configuration schema or source file is significant and intentionally preserved.\n- Clarify that changes to schema order will be reflected in the user-facing order, so future developers understand the implications of reordering fields."
        ]
    }
}
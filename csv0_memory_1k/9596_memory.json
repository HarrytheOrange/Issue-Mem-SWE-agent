{
    "search_index": {
        "description_for_embedding": "Home Assistant threshold binary sensor enhancement adding a configurable hysteresis attribute to prevent rapid state flapping around the threshold. The fix introduces a hysteresis configuration option, updates state transition logic to use upper/lower bands, exposes the hysteresis as an attribute, and adds tests to validate the new behavior.",
        "keywords": [
            "Home Assistant",
            "threshold binary sensor",
            "hysteresis",
            "binary_sensor.threshold",
            "sensor flapping",
            "chattering",
            "state transition logic",
            "configuration schema",
            "async_update",
            "tests"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant `binary_sensor.threshold` platform needed more robust behavior around a threshold to avoid rapid toggling when the input sensor value hovered near the configured limit. Originally, the binary sensor simply compared the monitored entity's value to a fixed threshold: for an 'upper' type, `state = value > threshold`; for a 'lower' type, `state = value < threshold`. This could cause the sensor to rapidly flip between on and off when the source value oscillated around the threshold.\n\nTo address this, a new `hysteresis` configuration option and attribute were added. The changes were made in `homeassistant/components/binary_sensor/threshold.py`:\n- Introduced `CONF_HYSTERESIS` and `ATTR_HYSTERESIS`, and a `DEFAULT_HYSTERESIS = 0.0`.\n- Extended the configuration schema with an optional `hysteresis` float field, defaulting to 0.0.\n- Updated `async_setup_platform` and `ThresholdSensor.__init__` to accept and store the hysteresis value.\n- Renamed the internal state variable from `_deviation` to `_state` for clarity.\n- Exposed the hysteresis value via `device_state_attributes` so it appears as an attribute on the binary sensor entity.\n\nThe core logic change was in `async_update`:\n- If `hysteresis == 0` and `sensor_value == threshold`, the binary sensor is explicitly turned off (`_state = False`), as the value is neither strictly lower nor strictly upper.\n- If `sensor_value > threshold + hysteresis`, the state is set to `is_upper` (for an 'upper' threshold, this means `on`).\n- If `sensor_value < threshold - hysteresis`, the state is set to `not is_upper` (for an 'upper' threshold, this means `off`).\n- If the value lies between `threshold - hysteresis` and `threshold + hysteresis`, the state is left unchanged, providing the hysteresis band.\n\nA new test, `test_sensor_hysteresis`, was added to `tests/components/binary_sensor/test_threshold.py`. It configures a threshold sensor with `threshold: 15` and `hysteresis: 2.5`, then walks the monitored sensor through values 20 → 13 → 12 → 17 → 18, checking that the binary sensor only changes state when crossing the threshold ± hysteresis boundaries and otherwise holds its previous state. Several iterations of the patch cleaned up naming, centralized the default hysteresis value, fixed linter issues, and moved explanatory comments into documentation.\n\nThe result is a threshold binary sensor that supports configurable hysteresis, avoids flapping around the threshold, and exposes its hysteresis configuration in the entity's attributes.",
        "semantic_memory": "This change illustrates a general pattern in sensor and control logic design: when a system's state changes based only on a single threshold comparison, it is susceptible to chattering when the input signal hovers around that threshold. Introducing hysteresis—distinct activation and deactivation thresholds—stabilizes the system and prevents rapid oscillations.\n\nKey generalizable concepts:\n1. **Hysteresis for state stability**: For any binary decision based on a continuous value (temperature, humidity, power, etc.), it's often better to define a band (threshold ± hysteresis) rather than a single cutoff. The system flips state only when crossing the outer edges of that band, not every time the input crosses the central threshold.\n2. **Separate configuration from behavior**: The hysteresis value is added as a configuration option (`hysteresis`) with a default. This allows different use cases to tune responsiveness vs. stability without changing the code.\n3. **Stateful vs. stateless logic**: With hysteresis, the new state depends not only on the current measurement but also on the previous state. The logic must explicitly preserve state when the input lies within the hysteresis band. This is a common pattern for any state machine dealing with noisy inputs.\n4. **Clear naming and exposure of internal parameters**: Renaming `_deviation` to `_state` makes the code more readable and intention-revealing. Exposing `hysteresis` as an entity attribute allows debugging, introspection, and automation logic that can depend on or verify the configured behavior.\n5. **Backward-compatible defaults**: The default hysteresis is set to 0.0 to preserve existing behavior unless the user opts in to the new feature. Special-case handling for `hysteresis == 0` and `value == threshold` clarifies how ties should be handled, reducing ambiguity.\n6. **Testing edge cases and transitions**: Tests walk through values on both sides of the threshold and within the hysteresis band to ensure the state transitions only at the appropriate points. This pattern—explicitly testing crossing points and maintenance within bands—is crucial when implementing hysteresis or any stateful threshold logic.\n\nThese ideas apply broadly to home automation, hardware control, rate limiters, debouncing circuits, hysteresis in UI events, and any domain where thresholds and noisy inputs interact.",
        "procedural_memory": [
            "When you see a binary sensor or control output rapidly toggling around a threshold, consider adding hysteresis to the decision logic.",
            "Step 1: Identify the flapping behavior\n- Observe the binary sensor or control output and identify if it toggles frequently when the monitored value hovers near a threshold.\n- Confirm that the current logic uses a simple `>` or `<` comparison against a single threshold.\n\nStep 2: Design the hysteresis behavior\n- Decide on the semantics: for an \"upper\" threshold, when should the output turn on and when should it turn off? Similarly for a \"lower\" threshold.\n- Define a hysteresis band around the threshold, e.g. `threshold ± hysteresis`.\n  - Activation point: threshold + hysteresis (for an upper threshold) or threshold - hysteresis (for a lower threshold).\n  - Deactivation point: threshold - hysteresis (for an upper threshold) or threshold + hysteresis (for a lower threshold).\n- Decide what to do when the hysteresis value is zero and the input equals the threshold (e.g. explicitly off to avoid ambiguity).\n\nStep 3: Add configuration and defaults\n- Introduce a configuration key for hysteresis (e.g., `hysteresis`) in the platform/component schema.\n- Provide a reasonable default value (often `0.0` to preserve backward compatibility).\n- Update any constants (`CONF_HYSTERESIS`, `DEFAULT_HYSTERESIS`) and schemas (e.g., with `vol.Optional(CONF_HYSTERESIS, default=DEFAULT_HYSTERESIS): vol.Coerce(float)`).\n\nStep 4: Extend the entity/component to store hysteresis\n- Update the entity's initializer to accept and store the hysteresis configuration value.\n- Ensure the value is accessible where the state decision logic runs (e.g., in `async_update`).\n- Optionally, expose it as an attribute so the runtime configuration can be inspected (`device_state_attributes` including `ATTR_HYSTERESIS`).\n\nStep 5: Implement stateful hysteresis logic\n- Replace stateless comparison logic with stateful transitions. For example:\n  - Keep a `_state` boolean representing the current on/off state.\n  - On update:\n    - If `hysteresis == 0` and `value == threshold`, set `_state = False` (or another well-defined rule).\n    - Else if `value > threshold + hysteresis`, set `_state = is_upper` (or the appropriate 'on' state).\n    - Else if `value < threshold - hysteresis`, set `_state = not is_upper` (or the appropriate 'off' state).\n    - Otherwise, leave `_state` unchanged so the current state persists within the hysteresis band.\n- Ensure the `is_on` property returns this `_state` variable.\n\nStep 6: Write tests for boundaries and transitions\n- Add tests that:\n  - Configure the component with a specific threshold and hysteresis value.\n  - Set the monitored value well above the upper boundary and assert the state is on (for an upper threshold) or off (for a lower threshold).\n  - Move the value into the hysteresis band and assert the state does not change.\n  - Move the value beyond the opposite boundary and assert the state flips.\n  - Optionally test the `hysteresis == 0` case and equality with the threshold.\n\nStep 7: Run linters and fix style issues\n- Run the project's linting/formatting tools (e.g., `tox`, `flake8`, `pylint`).\n- Fix long lines, indentation, and naming issues (e.g., break long `vol.Optional` or `async_add_devices` calls across lines).\n\nStep 8: Update documentation\n- Document the new `hysteresis` option, its default value, and the semantics (when the sensor turns on/off).\n- Add example configuration snippets showing typical use cases.\n\nStep 9: Validate in a real or simulated environment\n- Deploy the updated component in a test environment.\n- Feed it a signal that oscillates around the threshold and confirm the state changes only when crossing the hysteresis boundaries.\n- Adjust the hysteresis default if necessary based on real-world behavior and user expectations."
        ]
    }
}
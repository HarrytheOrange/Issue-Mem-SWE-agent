{
    "search_index": {
        "description_for_embedding": "Home Assistant PR adding a new Ness D8X/D16X alarm integration using the nessclient library. Implements a core ness_alarm component plus alarm_control_panel and binary_sensor platforms, wiring state via dispatcher signals and exposing panic/aux services. Iteratively fixes issues around config validation defaults, async entity setup naming (async_add_entities), service name constants, version sync of requirements, coverage settings, and consolidating tests to use mocked nessclient.",
        "keywords": [
            "ness_alarm",
            "Ness D8X",
            "Ness D16X",
            "nessclient",
            "homeassistant.components.ness_alarm",
            "alarm_control_panel.ness_alarm",
            "binary_sensor.ness_alarm",
            "async_setup",
            "async_add_entities",
            "dispatcher",
            "signals",
            "voluptuous",
            "config_validation",
            "asyncio",
            "MockDependency",
            "asynctest",
            "service registration",
            "requirements_all.txt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR introduced a new Home Assistant integration for Ness D8X/D16X alarm panels, built on top of the external nessclient library. The integration is split into a core component (homeassistant/components/ness_alarm.py) and two platforms: an alarm_control_panel (homeassistant/components/alarm_control_panel/ness_alarm.py) and a binary_sensor platform (homeassistant/components/binary_sensor/ness_alarm.py).\n\nThe core ness_alarm component:\n- Defines configuration schema (host, port, optional zones) using voluptuous, with a DEFAULT_ZONES list to avoid missing-key logic.\n- Declares REQUIREMENTS = ['nessclient==0.9.9'] and keeps requirements_all.txt in sync with the same version.\n- Instantiates nessclient.Client with host, port, and hass.loop.\n- Registers dispatcher-based callbacks:\n  - on_zone_change(zone_id, state) -> emits SIGNAL_ZONE_CHANGED with a ZoneChangedData namedtuple.\n  - on_state_change(arming_state) -> emits SIGNAL_ARMING_STATE_CHANGED with the nessclient.ArmingState value.\n- Schedules client.keepalive() and client.update() as background tasks at startup.\n- Registers two domain services using constants and schemas:\n  - SERVICE_PANIC(code) -> client.panic(code)\n  - SERVICE_AUX(output_id, state=True) -> client.aux(output_id, state)\n- Ensures client.close() is called once at EVENT_HOMEASSISTANT_STOP.\n\nThe alarm_control_panel platform creates a single NessAlarmPanel entity. It subscribes to SIGNAL_ARMING_STATE_CHANGED and translates nessclient.ArmingState values into Home Assistant alarm states: UNKNOWN -> STATE_UNKNOWN, DISARMED -> STATE_ALARM_DISARMED, ARMING/EXIT_DELAY -> STATE_ALARM_ARMING, ARMED -> STATE_ALARM_ARMED_AWAY, ENTRY_DELAY -> STATE_ALARM_PENDING, TRIGGERED -> STATE_ALARM_TRIGGERED. It exposes async_alarm_disarm, async_alarm_arm_away, async_alarm_arm_home, and async_alarm_trigger methods that call the corresponding nessclient methods. The entity is non-polling and has a numeric code_format.\n\nThe binary_sensor platform instantiates one NessZoneBinarySensor per configured zone, driven by discovery_info from the core component. Each zone sensor:\n- Subscribes to SIGNAL_ZONE_CHANGED.\n- Checks if the incoming ZoneChangedData.zone_id matches its own, then updates its _state and schedules an update.\n- Exposes is_on based on state and device_class based on configured zone type.\n\nDuring development the author iterated to satisfy Home Assistant’s standards and test suite:\n- Initially added availability tracking on entities, but later removed it entirely with a follow-up commit to simplify the implementation and tests.\n- Fixed a mismatch between REQUIREMENTS (0.9.6/0.9.8) and requirements_all.txt (0.9.5) by bumping both to nessclient==0.9.9.\n- Renamed async_add_devices to async_add_entities in the binary_sensor platform to match the updated integration API.\n- Replaced literal service names in async_register (\"panic\", \"aux\") with the SERVICE_PANIC and SERVICE_AUX constants for consistency.\n- Adjusted the config schema to use a default empty list for CONF_ZONES instead of using conf.get(CONF_ZONES, []).\n- Removed the new component from .coveragerc so it is included in coverage.\n- Consolidated and refocused tests: deleted dedicated alarm_control_panel and binary_sensor test files and moved the essential behavioral tests into tests/components/test_ness_alarm.py.\n\nTesting uses pytest, asynctest, and MockDependency to isolate nessclient. The tests:\n- Patch nessclient.Client to return a single MagicMock implementing the expected async methods and callbacks.\n- Patch nessclient.ArmingState with a local Enum to test state mapping deterministically.\n- Validate that the panic and aux services are registered and dispatch to client.panic and client.aux with the correct arguments.\n- Ensure that async_setup_component wires up binary_sensor.zone_1, binary_sensor.zone_2, and alarm_control_panel.alarm_panel entities.\n- Assert that keepalive() and update() are scheduled exactly once.\n- Confirm that on_state_change and on_zone_change callbacks drive the entity states correctly (e.g., zone_1 becomes 'on' when on_zone_change(1, True) is fired; the alarm panel transitions across all ArmingState values into the expected HA states, with UNKNOWN mapping to STATE_UNKNOWN).\n\nThe outcome is a fully functional Ness alarm integration that adheres to Home Assistant’s async patterns, configuration validation, service registration best practices, and testing requirements, with all external interactions properly mocked and requirements pinned.",
        "semantic_memory": "General patterns and best practices illustrated by this PR that apply beyond this specific Ness alarm integration:\n\n1. **Home Assistant integration architecture**\n- Split a feature into a core component module plus platform modules (e.g., alarm_control_panel, binary_sensor) for clear separation of concerns.\n- The core component is responsible for: parsing configuration, managing the lifecycle of the third-party client object, wiring up dispatcher signals, registering domain services, and triggering platform discovery via async_load_platform.\n- Platform modules should be thin: they receive discovery_info, create entities, subscribe to dispatcher signals, and expose HA-facing methods that simply delegate to the underlying client.\n\n2. **Dispatcher-based event propagation**\n- For asynchronous updates from external libraries, use Home Assistant’s dispatcher helpers:\n  - async_dispatcher_send(hass, signal, payload) to broadcast events from the core component.\n  - async_dispatcher_connect(hass, signal, callback) in platform entities to receive updates.\n- Encapsulate multi-field payloads in namedtuples (e.g., ZoneChangedData) for readability and type safety instead of passing raw tuples or loosely structured dicts.\n- This pattern decouples third-party callbacks from the entity classes and makes it easier to test and evolve the integration.\n\n3. **Config validation with voluptuous**\n- Use a module-level CONFIG_SCHEMA and platform-specific schemas to validate options like host, port, and nested structures (zones with id, name, type).\n- Prefer explicit defaults in the schema (e.g., vol.Optional(CONF_ZONES, default=[]) ) over runtime dict.get with manual defaulting. This keeps downstream code simpler and type-stable.\n- Reuse existing constants and enumerations from Home Assistant (like binary_sensor.DEVICE_CLASSES) to constrain config values.\n\n4. **Service registration best practices**\n- Use named constants for service names (SERVICE_PANIC, SERVICE_AUX) and attributes (ATTR_CODE, ATTR_OUTPUT_ID, ATTR_STATE) instead of hard-coded strings in async_register. This helps avoid typos and keeps service usage consistent across the codebase and tests.\n- Provide voluptuous schemas for each service to guarantee required parameters and types, making the integration more robust against invalid calls.\n\n5. **Async programming and lifecycle management**\n- Use async_setup for components and async_* entity methods to integrate with Home Assistant’s event loop.\n- When interacting with long-lived network clients, register clean-up callbacks on EVENT_HOMEASSISTANT_STOP to gracefully close connections.\n- Schedule background client tasks (keepalive, initial update) with hass.loop.create_task or hass.async_create_task rather than blocking inside async_setup.\n- Entities implemented as non-polling should rely on dispatcher events to update state and call async_schedule_update_ha_state() when their internal state changes.\n\n6. **Testing integrations that depend on third-party libraries**\n- Use MockDependency to prevent importing real external dependencies during tests and patch the client class (here, nessclient.Client) to return a MagicMock with the required methods.\n- For enumerations / constants (like ArmingState), replace them with local Enums in tests so the state mapping logic can be verified without depending on the external library’s implementation.\n- Assert service behavior using hass.services.async_call with blocking=True and verify interactions with the mocked client using assert_awaited_once_with or call_count checks for async methods.\n- Trigger dispatcher-driven state changes by calling the mocked callback that was registered via on_state_change / on_zone_change and then using hass.async_block_till_done() before asserting entity states.\n- Keep requirements pinned in both the component’s REQUIREMENTS and requirements_all.txt to avoid version drift between test and production environments.\n\n7. **Maintaining style and coverage quality**\n- Align function names and signatures (async_add_entities instead of async_add_devices) with current Home Assistant standards to avoid deprecation issues.\n- Do not permanently omit new modules from coverage; instead, add meaningful tests, then remove omit entries from .coveragerc.\n- Consolidate tests when possible to reduce duplication: integration tests that cover entity behavior via the core component can often replace smaller, tightly coupled unit tests on individual platform modules.\n\nThese practices improve maintainability, testability, and reliability for any event-driven, async integration with external devices or libraries in Home Assistant-like ecosystems.",
        "procedural_memory": [
            "Step-by-step process to design, implement, and verify a new Home Assistant integration that wraps a third-party async client, similar to the Ness alarm component:",
            "Step 1: Design the component and platform boundaries",
            "Decide which responsibilities belong to the core component vs. platforms:\n- Core component: configuration parsing, client lifecycle, dispatcher wiring, services, and platform discovery.\n- Platforms (alarm_control_panel, binary_sensor, etc.): entity definitions, state mapping, and direct delegation of commands to the client.",
            "Step 2: Define configuration schema with voluptuous",
            "In the component module, define CONFIG_SCHEMA using voluptuous and Home Assistant’s config_validation helpers:\n- Use vol.Schema({ DOMAIN: vol.Schema({...}) }, extra=vol.ALLOW_EXTRA).\n- Validate required fields (e.g., host, port) with proper types.\n- For optional lists (e.g., zones), use vol.Optional(key, default=[]) with vol.All(cv.ensure_list, [subschema]) so downstream code can assume the presence and type of the key without extra get() logic.",
            "Step 3: Instantiate the third-party client in async_setup",
            "In async_setup(hass, config):\n- Import the client class from the third-party library inside the function (to respect Home Assistant’s lazy import pattern).\n- Read configuration values from conf = config[DOMAIN].\n- Instantiate the client using the Home Assistant loop (client = Client(host=..., port=..., loop=hass.loop)).\n- Store the client in hass.data[DATA_DOMAIN] for reuse in platforms.",
            "Step 4: Manage lifecycle and background tasks",
            "Register a shutdown handler to close the client cleanly:\n- Define an async _close(event) that awaits client.close().\n- Use hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, _close).\nSchedule background tasks:\n- Use hass.loop.create_task(client.keepalive()) and hass.loop.create_task(client.update()) to start background communication without blocking setup.",
            "Step 5: Wire client callbacks to Home Assistant via dispatcher",
            "Define dispatcher signals and payload types:\n- SIGNAL_* constants for each event type.\n- Namedtuples (e.g., ZoneChangedData) for structured payloads.\nRegister callbacks on the client:\n- client.on_zone_change(on_zone_change) where on_zone_change() uses async_dispatcher_send(hass, SIGNAL_ZONE_CHANGED, ZoneChangedData(...)).\n- client.on_state_change(on_state_change) where on_state_change() sends SIGNAL_ARMING_STATE_CHANGED with the ArmingState value.",
            "Step 6: Load platform modules with discovery_info",
            "In async_setup, schedule platform loading:\n- hass.async_create_task(async_load_platform(hass, 'binary_sensor', DOMAIN, {CONF_ZONES: zones}, config)).\n- hass.async_create_task(async_load_platform(hass, 'alarm_control_panel', DOMAIN, {}, config)).\nEnsure that the platform code expects discovery_info and contains a guard that returns early if discovery_info is None/empty.",
            "Step 7: Implement platform entities",
            "In alarm_control_panel.<integration>.py:\n- Create an entity class that extends the appropriate base (e.g., AlarmControlPanel).\n- In async_added_to_hass, subscribe to dispatcher signals using async_dispatcher_connect and a callback method.\n- Implement async_* methods (async_alarm_disarm, async_alarm_arm_away, etc.) that call the corresponding client methods stored in self._client.\n- Implement state mapping in the dispatcher callback: translate client enum states to HA states and call async_schedule_update_ha_state().\n\nIn binary_sensor.<integration>.py:\n- Implement async_setup_platform(hass, config, async_add_entities, discovery_info=None).\n- Iterate over discovery_info[CONF_ZONES] to create one entity per zone.\n- Each entity subscribes to SIGNAL_ZONE_CHANGED and updates internal state only when the zone_id matches, then calls async_schedule_update_ha_state().",
            "Step 8: Register services with schemas",
            "Define service name and attribute constants (e.g., SERVICE_PANIC, SERVICE_AUX, ATTR_CODE, ATTR_OUTPUT_ID, ATTR_STATE).\nDefine voluptuous schemas for each service to validate expected inputs.\nRegister services in async_setup:\n- hass.services.async_register(DOMAIN, SERVICE_PANIC, handle_panic, schema=SERVICE_SCHEMA_PANIC)\n- hass.services.async_register(DOMAIN, SERVICE_AUX, handle_aux, schema=SERVICE_SCHEMA_AUX)\nIn handle_* functions, call the appropriate async client method, awaiting it.",
            "Step 9: Keep requirements in sync",
            "Add the third-party package and exact version to the component’s REQUIREMENTS list.\nUpdate requirements_all.txt with the same version and a comment indicating the component using it.\nIf the version changes, update both places together and re-run any requirement-generation tooling if applicable.",
            "Step 10: Implement robust tests with mocked dependencies",
            "Use MockDependency and patching:\n- In tests, use MockDependency('nessclient') to prevent importing the real library.\n- Patch nessclient.Client with a factory returning a MagicMock implementing the async methods you use.\n- Patch nested enums (e.g., nessclient.ArmingState) with a local Enum that has the values you rely on.\nSet up the component via async_setup_component(hass, DOMAIN, VALID_CONFIG) and await hass.async_block_till_done().\nAssert:\n- Services are registered (hass.services.has_service(DOMAIN, SERVICE_PANIC)).\n- Expected entities exist in hass.states.\n- Client methods are called as expected when services are invoked (using assert_awaited_once_with or call_count for async mocks).\n- Dispatcher callbacks correctly change entity states by invoking the stored on_state_change/on_zone_change callbacks and awaiting hass.async_block_till_done().",
            "Step 11: Align with HA style and coverage expectations",
            "Ensure platform setup functions use the current signature names (async_add_entities rather than deprecated names).\nAvoid leaving new modules out of coverage; write tests and remove omit entries from .coveragerc.\nPrefer integration-level tests that verify HA state and service interactions over narrow unit tests that rely on internal implementation details.",
            "Step 12: Iterate and refine",
            "Remove features that are not fully baked (e.g., availability tracking) if they complicate the current PR; plan to reintroduce them in a separate, focused PR.\nAddress linting feedback (indentation, line length, import locations, naming consistency) promptly.\nAvoid squashing commits mid-review in repos where reviewers rely on incremental changes; fix issues in follow-up commits to make the review history easier to follow."
        ]
    }
}
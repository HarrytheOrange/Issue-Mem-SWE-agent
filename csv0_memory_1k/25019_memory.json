{
    "search_index": {
        "description_for_embedding": "Fix for a flaky Ecobee climate test in Home Assistant caused by ambiguous and order-dependent HVAC mode mapping between Ecobee API modes and Home Assistant HVAC modes. The solution uses an OrderedDict and reorders mappings so that 'heat' maps to 'heat' rather than 'auxHeatOnly', ensuring deterministic reverse mapping and stable tests.",
        "keywords": [
            "Home Assistant",
            "Ecobee",
            "climate",
            "HVAC mode mapping",
            "flaky test",
            "non-deterministic dict order",
            "bidirectional mapping",
            "auxHeatOnly",
            "OrderedDict",
            "reverse mapping bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Ecobee climate integration for Home Assistant, a flaky test was observed around setting the HVAC mode to 'heat'. The mapping from Ecobee HVAC modes (e.g., 'heat', 'cool', 'auxHeatOnly') to Home Assistant HVAC modes used a standard Python dict: both 'heat' and 'auxHeatOnly' mapped to HVAC_MODE_HEAT. Somewhere in the code, a reverse lookup from Home Assistant mode back to Ecobee mode was done by iterating that dict, depending on key order to choose which Ecobee mode represents HVAC_MODE_HEAT. Because dict ordering was effectively relied upon (and historically not guaranteed / stable), the reverse mapping could sometimes resolve to 'auxHeatOnly' rather than 'heat', causing the behavior and the unit test to be flaky.\n\nA user noticed and asked whether the change in order (mapping 'heat' to 'auxHeatOnly') was intentional. The maintainer clarified that setting HVAC mode to 'heat' should map to the Ecobee 'heat' mode, not 'auxHeatOnly'. To fix this, the mapping was changed from a plain dict to a collections.OrderedDict with a deliberate order: 'heat', 'cool', 'auto', 'off', then 'auxHeatOnly' (all mapped to appropriate Home Assistant modes). A comment was added noting that order matters because for reverse mapping we do not want to map HEAT to AUX. The test `test_set_hvac_mode` was updated to assert that calling `set_hvac_mode('heat')` results in `ecobee.set_hvac_mode(1, 'heat')` instead of `auxHeatOnly`. This eliminated the flakiness and enforced the desired canonical mapping.",
        "semantic_memory": "When multiple external states map to the same internal canonical state (e.g., several vendor-specific HVAC modes mapping to a single platform mode), reverse mappings become ambiguous. If code derives the external mode by inverting such a mapping, relying on dict iteration order is fragile and can lead to nondeterministic behavior and flaky tests.\n\nBest practices:\n- Never implicitly rely on mapping inversion from a many-to-one mapping without explicitly defining which external value is canonical when going back.\n- If order must matter for a mapping (e.g., for reverse lookup), make that explicit via an ordered data structure (OrderedDict or an ordered list of rules) and document it with comments.\n- Ensure tests assert on the canonical external representation you want to expose (e.g., 'heat' vs 'auxHeatOnly') to catch regressions in mapping logic.\n- For integrations with device APIs, differentiate between primary operating modes (e.g., 'heat') and special modes (e.g., 'auxHeatOnly') even if they share the same logical HVAC_MODE_HEAT internally; be explicit about which one should be used when a user selects a generic mode.\n\nMore generally, flaky tests often stem from hidden nondeterminism: unordered collections, time-dependent behavior, or reliance on external state. Making ordering and canonical choices explicit removes such hidden sources of randomness.",
        "procedural_memory": [
            "Identify and diagnose flaky tests caused by ambiguous or order-dependent mappings between external and internal states.",
            "Step 1: Reproduce the flakiness.\n- Run the specific test repeatedly (e.g., with `pytest -k test_name -n auto --maxfail=1 --reruns` or a loop) to confirm that it intermittently fails.\n- Observe whether failures are inconsistent in terms of which value is returned or asserted.",
            "Step 2: Inspect mapping logic.\n- Locate the mapping between external API values and internal enum/constants (e.g., vendor HVAC modes to platform HVAC modes).\n- Check if the mapping is many-to-one (multiple external keys mapping to the same internal value). This is a red flag for reverse lookups.\n- Search for code that performs reverse mapping or inversion, such as comprehensions like `{v: k for k, v in MAP.items()}` or loops that choose the first matching key.",
            "Step 3: Detect hidden order dependencies.\n- Determine whether the reverse mapping relies on dictionary iteration order to pick one of several candidate keys.\n- Consider Python version behavior: even when dicts are ordered in modern Python, relying on that order for logic is fragile, especially if the order is not clearly enforced or documented.\n- Check if test expectations match one specific external value when multiple would be technically valid.",
            "Step 4: Define a canonical external representation.\n- Decide which external API mode should represent each internal state when converting back (e.g., prefer 'heat' over 'auxHeatOnly' for HVAC_MODE_HEAT).\n- Document the rationale: user expectations, device semantics, or compatibility requirements.",
            "Step 5: Make the mapping order explicit and stable.\n- Replace plain dicts with an ordered structure if order affects reverse mapping (e.g., `collections.OrderedDict` or a list of `(external, internal)` tuples).\n- Arrange entries so that the canonical external modes appear before fallback/special-case modes.\n- Add a code comment explaining that order matters due to reverse mapping or prioritization logic.",
            "Step 6: Adjust reverse mapping implementation.\n- Implement reverse mapping logic that respects the desired order, e.g., iterating the ordered mapping and returning the first key whose value matches the internal mode.\n- Avoid building naive inverted dicts from many-to-one mappings; they will silently discard all but one key and may choose the wrong one.",
            "Step 7: Update and harden tests.\n- Update existing tests to assert on the canonical external value you expect (e.g., `ecobee.set_hvac_mode(1, 'heat')` rather than `auxHeatOnly`).\n- Add tests covering all relevant modes, especially where multiple external values map to the same internal value.\n- If possible, add tests that indirectly exercise the reverse mapping logic, not just the forward mapping.",
            "Step 8: Run the test suite repeatedly.\n- Re-run the full test suite, potentially multiple times or in parallel, to confirm that the flakiness is resolved.\n- Inspect any other areas where similar many-to-one mappings exist and apply the same pattern if necessary.",
            "Step 9: Document the decision.\n- In code comments and/or integration docs, clarify that some external modes are considered secondary (like auxHeatOnly) and that the platform will prefer the primary mode when a generic internal mode is chosen.\n- This makes future maintenance and refactors less likely to reintroduce nondeterministic behavior."
        ]
    }
}
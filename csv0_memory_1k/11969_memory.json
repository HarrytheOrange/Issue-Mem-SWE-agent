{
    "search_index": {
        "description_for_embedding": "Home Assistant Xiaomi Aqara sensor integration was discarding valid temperature readings below -20°C due to an overly restrictive validation range. The fix extended the acceptable temperature range down to -50°C, preventing valid low-temperature measurements from being dropped.",
        "keywords": [
            "Home Assistant",
            "Xiaomi Aqara",
            "temperature sensor",
            "data validation",
            "value range check",
            "sensor integration",
            "discarded measurements",
            "homeassistant.components.sensor.xiaomi_aqara",
            "parsing",
            "filtering logic"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant project, the Xiaomi Aqara sensor component contained logic that parsed sensor data and applied bounds checking to filter out obviously invalid readings. For temperature, it rejected any value below -20°C or above 60°C. However, the physical Aqara sensor can report temperatures below -20°C (even if accuracy may degrade), so these low readings were legitimate but were being discarded. This caused users in very cold environments to lose valid sensor data. The fix was a minimal change in `homeassistant/components/sensor/xiaomi_aqara.py`: in the `parse_data` method, the temperature validation lower bound was adjusted from -20 to -50, allowing values between -50°C and 60°C to pass while still filtering out clearly impossible values.",
        "semantic_memory": "When integrating hardware sensors or external data sources, range-based validation logic must reflect the real capabilities and expected operating ranges of the underlying devices. Overly strict or incorrect bounds can silently discard legitimate data, leading to inaccurate state representation and user confusion. It is often better to align validation thresholds with device specifications (or a safe superset of them) rather than arbitrary assumptions. Additionally, rejecting data should be done cautiously and transparently, especially in systems where environmental extremes (e.g., very low temperatures) are plausible. A small off-by-range logic decision can have a large impact in specific use cases (e.g., cold climates), so validation logic should be reviewed with domain knowledge and, ideally, verified against manufacturer specs or empirical observations.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of missing or unrealistic sensor data. Look for user reports or logs showing that certain plausible readings (e.g., very low temperatures) are never recorded or appear as gaps in time series data.",
            "Step 2: Inspect the sensor integration or parsing code. Locate where raw data is converted and validated (e.g., `parse_data`, `validate`, or similar functions). Search for range checks or filters that discard values based on being too low, too high, or out of expected bounds.",
            "Step 3: Compare validation ranges to device specifications. Check vendor documentation or known operating ranges for the sensor. Confirm whether the current code’s min/max thresholds are aligned with reality or are overly restrictive.",
            "Step 4: Reproduce the issue with controlled data if possible. Feed known low or high values (within the device’s spec range) into the parsing logic (via tests or logs) and verify whether they are incorrectly rejected.",
            "Step 5: Adjust the validation logic. Update the conditional checks to widen the acceptable range or otherwise match the sensor’s true capabilities. For this case, lower the minimum allowed temperature from -20°C to -50°C while keeping the upper bound at 60°C.",
            "Step 6: Add or update tests. Create unit or integration tests that cover edge cases at and beyond the boundaries (e.g., -50, -20, 60, 61) to ensure correct behavior and to prevent regressions.",
            "Step 7: Consider logging and monitoring. When values are rejected as invalid, log the raw value and reason. This helps diagnose future misconfigurations or unexpected real-world conditions without silently losing data.",
            "Step 8: Communicate behavior in documentation. Document the accepted sensor ranges and any assumptions in the component’s docs or code comments so future maintainers understand why the specific thresholds were chosen.",
            "Step 9: Validate in real-world usage. After deploying the change, confirm with affected users or through telemetry that previously missing valid values (e.g., very low temperatures) are now correctly recorded and that no obviously wrong values are being accepted."
        ]
    }
}
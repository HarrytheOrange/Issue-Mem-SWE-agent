{
    "search_index": {
        "description_for_embedding": "Home Assistant media_player: introduced a standardized STATE_STANDBY in the base entity model and wired it through HomeKit, Universal media_player, device conditions, and state reproduction. Fixed PS4 media_player toggle behavior so that standby is treated like off for power actions, preventing Lovelace and HomeKit from misreporting or mis-controlling the device.",
        "keywords": [
            "Home Assistant",
            "media_player",
            "STATE_STANDBY",
            "entity model",
            "PS4 integration",
            "HomeKit",
            "Universal media_player",
            "device_condition",
            "state reproduction",
            "toggle behavior",
            "power state mapping",
            "Lovelace media_player card"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the developer addressed inconsistent handling of a 'standby' state across the Home Assistant media_player ecosystem, particularly affecting the PS4 integration, HomeKit, and the Universal media_player.\n\nObserved problems:\n- The PS4 media_player exposed a standby state, but the core media_player entity model did not treat STATE_STANDBY as a standard base state.\n- In Lovelace, pressing the power button on the media_player card while the PS4 was in standby caused a 'turn_off' call rather than a 'turn_on', because standby was effectively treated as a powered-on state by the base logic.\n- HomeKit and the Universal media_player component misreported or mishandled standby: HomeKit considered standby as 'on', Universal treated it as active instead of off-like, and device automations could not directly condition on standby.\n\nRoot cause:\n- The base media_player integration only considered STATE_OFF as off, so helper functions (like media_player.is_on) and integrations that derived on/off or active/inactive from states did not understand STATE_STANDBY.\n- There was no standardized treatment of standby in device conditions, state reproduction, HomeKit mappings, or the Universal media_player's OFF_STATES list.\n- PS4 relied on the base async_toggle implementation, which had no special logic for standby, so toggling from standby called turn_off instead of turn_on.\n\nFix details:\n1. Core media_player behavior:\n- Imported STATE_STANDBY into homeassistant.components.media_player.__init__.\n- Updated media_player.is_on() so that an entity is considered 'on' only if its state is neither STATE_OFF nor STATE_STANDBY. This means standby is treated as effectively off for high-level 'on' checks.\n\n2. Device conditions and automations:\n- Extended media_player/device_condition.py:\n  - Added a new condition type 'is_standby' to CONDITION_TYPES.\n  - async_get_conditions now exposes an 'is_standby' device condition for each media_player.\n  - async_condition_from_config maps 'is_standby' to STATE_STANDBY so automations can trigger on that state.\n- Added tests in tests/components/media_player/test_device_condition.py to verify that:\n  - 'is_standby' appears in the generated device conditions; and\n  - automations using 'is_standby' only fire when the entity state is STATE_STANDBY.\n\n3. State reproduction:\n- Updated media_player/reproduce_state.py so that when reproducing STATE_STANDBY, the system calls SERVICE_TURN_OFF (same as OFF), ensuring consistent handling of standby as a power-off state from the perspective of state reproduction.\n- Added a test case in tests/components/media_player/test_reproduce_state.py verifying that reproducing STATE_STANDBY maps to 'media_player.turn_off'.\n\n4. HomeKit integration:\n- Modified homeassistant/components/homekit/type_media_players.py so that HomeKit treats STATE_STANDBY as off/inactive:\n  - For the generic media player accessory, FEATURE_ON_OFF is now set to False when the state is STATE_OFF, STATE_STANDBY, STATE_UNKNOWN, or 'None'. Previously, it only checked STATE_OFF and STATE_UNKNOWN.\n  - For the television accessory, CHAR_ACTIVE is set to inactive (0) when state is STATE_OFF, STATE_STANDBY, or STATE_UNKNOWN.\n- Adjusted import ordering (pylint fix) to include STATE_STANDBY and maintain linting rules.\n- Added tests in tests/components/homekit/test_type_media_players.py to confirm:\n  - When a media_player switches to STATE_STANDBY, the HomeKit on/off characteristic reflects 'off'.\n  - When a television entity is in STATE_STANDBY, CHAR_ACTIVE is 0 (inactive).\n\n5. PS4 media_player integration:\n- Updated homeassistant/components/ps4/media_player.py:\n  - Imported STATE_IDLE, STATE_PLAYING, and STATE_STANDBY from the base media_player module instead of const.\n  - Added a PS4Device.async_toggle implementation that treats standby as off:\n    - If self.state == STATE_STANDBY, toggle calls async_turn_on().\n    - For any other state, toggle calls async_turn_off().\n  - This ensures that from standby, pressing the toggle (e.g., via Lovelace power button) turns the PS4 on instead of sending another standby/off command.\n- Added tests in tests/components/ps4/test_media_player.py:\n  - test_toggle covers the three key states:\n    - STATE_STANDBY: toggling calls async_turn_on but not async_turn_off.\n    - STATE_IDLE: toggling calls async_turn_off but not async_turn_on.\n    - STATE_PLAYING: toggling calls async_turn_off but not async_turn_on.\n\n6. Universal media_player integration:\n- Updated homeassistant/components/universal/media_player.py:\n  - Imported STATE_STANDBY.\n  - Extended OFF_STATES to include STATE_STANDBY: OFF_STATES = [STATE_IDLE, STATE_OFF, STATE_STANDBY, STATE_UNAVAILABLE].\n  - This makes Universal treat standby as off-like for its on/off logic.\n- Updated tests in tests/components/universal/test_media_player.py:\n  - In test_active_child_state, when a child media_player goes to STATE_STANDBY, Universal correctly maintains or chooses the active child state consistent with the updated semantics.\n\nImpact:\n- This PR standardized how STATE_STANDBY is treated across media_player-related subsystems in Home Assistant, aligning PS4 behavior, HomeKit representation, Universal media_player logic, device automations, and state reproduction.\n- The core architectural decision (adding STATE_STANDBY to the base media_player model) required discussion in the architecture repo; the maintainer closed the PR pending that process, but the code illustrates the full set of changes needed to support a new, quasi-off state consistently.",
        "semantic_memory": "Key generalizable concepts from this fix:\n\n1. Standardizing new entity states across an ecosystem\nWhen you introduce a new state for a core entity model (like a media_player's STATE_STANDBY), you must update every subsystem that interprets or derives behavior from that state:\n- Core helpers (e.g., is_on / is_off / OFF_STATES) that abstract raw states into logical 'on' vs 'off'.\n- Device automations (device_condition) so automations can explicitly check or react to the new state.\n- State reproduction logic (reproduce_state) so the system knows what services to call when trying to recreate a state.\n- Integrations that map internal states to external ecosystems (HomeKit, Google, Alexa, etc.).\n- Aggregating or proxy entities (like Universal media_player) that combine states from multiple children and use OFF_STATES or similar lists.\n- Any device-specific overrides for behavior that conceptually depends on on/off semantics, such as 'toggle', must be aware of the new state.\n\n2. Treating \"standby\" as off-like but distinct\n\"Standby\" is a nuanced power state: the device is not fully on, but not fully off either. Best practices:\n- For high-level boolean power indicators (e.g., is_on, HomeKit On characteristic, UI power buttons), treat standby as off if the user expectation is that the device is not actively in use.\n- For automations and advanced logic, expose standby as a distinct state so users can differentiate, e.g., conditions like \"if TV is standby\" vs \"if TV is fully off\".\n- For state reproduction, map standby to the same service as off (turn_off) unless the domain requires a unique service.\n\n3. Toggle semantics depend on state classification\nThe meaning of 'toggle' can be ambiguous when there are more than two states:\n- If you have ON, OFF, and STANDBY, toggling from standby often should behave like toggling from off (i.e., turn on), not like sending another 'off' command.\n- Implement device-specific async_toggle (or equivalent) when core logic cannot express this nuance; toggle should respect the semantic grouping of states into on-like vs off-like categories.\n\n4. Integration layers must align with core state semantics\nExternal integrations (HomeKit, Universal wrappers, etc.) usually map internal states to simple boolean or enumerated characteristics. When adding new internal states:\n- Decide whether the new state should map to the external representation of \"on\", \"off\", or a special case.\n- Update all conditionals in those integrations that previously assumed a two-state model (e.g., \"state not OFF means on\") to handle the new state explicitly.\n\n5. Test-driven refactoring for new states\nWhen changing entity models, tests are crucial to avoid regressions:\n- Add tests that simulate the entity being in the new state across all impacted subsystems (UI helpers, automations, reproducer, integrations).\n- Ensure each test asserts both correct behavior for the new state and that existing states still behave as before (ON/OFF/IDLE/PLAYING/PAUSED, etc.).\n\n6. Governance/architecture process for core model changes\nFor platforms like Home Assistant, changes to the core entity model must go through an architecture or design-review process:\n- Before merging code that adds new standard states or attributes, propose the change centrally (e.g., architecture repo) for discussion.\n- This ensures consistency across all integrations and prevents fragmented or conflicting semantics for shared entity types.",
        "procedural_memory": [
            "Step-by-step guide: Adding a new entity state (e.g., STATE_STANDBY) and fixing related behavior",
            "Step 1: Design and get architectural approval",
            "Clarify the semantics of the new state (e.g., 'standby' is off-like but distinct from 'off').",
            "Determine how it should behave relative to existing states for: on/off checks, UI behavior, automations, and external integrations.",
            "If working in a framework with architectural governance (like Home Assistant), create an architecture proposal describing: the new state, motivation, expected behavior, and affected integrations. Get agreement before deep implementation.",
            "Step 2: Introduce the state into the core entity model",
            "Add the new state constant to the core domain(s), e.g., media_player.__init__ or shared const modules.",
            "Update any core helper APIs that interpret states:",
            "- For example, change is_on() to treat the new state appropriately (e.g., not is_on when STATE_STANDBY).",
            "- Update global lists such as OFF_STATES/ON_STATES or any other classification the framework uses.",
            "Step 3: Update state reproduction logic",
            "Find the code responsible for reproducing states (e.g., reproduce_state.py).",
            "Decide which service(s) should be called to reach the new state. For standby, it's often equivalent to 'turn_off' or a dedicated 'standby' service.",
            "Add a branch in the reproduction function that maps the new state (e.g., STATE_STANDBY) to the chosen service(s).",
            "Write/extend tests to verify that reproducing the new state calls the expected service(s).",
            "Step 4: Update device automations and conditions",
            "Locate device_condition (or equivalent) logic for the domain.",
            "Add the new condition type to the allowed list (e.g., 'is_standby' to CONDITION_TYPES).",
            "Update any mapping function (e.g., async_condition_from_config) so the new type returns a condition checking the new state.",
            "Update async_get_conditions (or equivalent) so the new condition is exposed for every relevant entity.",
            "Add tests that:",
            "- Confirm the new condition type is returned in the set of available device conditions.",
            "- Confirm automations using the new condition fire only when the entity is in the new state.",
            "Step 5: Update external/system integrations (HomeKit, Universal, etc.)",
            "Identify all integrations that map internal states to external characteristics or aggregated states.",
            "For each, audit logic that decides on/off/active/inactive based on internal states:",
            "- Replace simple checks like 'state != OFF' with explicit sets (e.g., state not in {STATE_OFF, STATE_STANDBY, STATE_UNKNOWN}).",
            "- Ensure the new state maps to the correct external value (e.g., HomeKit 'On' = false when standby).",
            "Add or extend tests that put entities into the new state and verify the external representation (e.g., HomeKit characteristic values, Universal media_player OFF_STATES behavior).",
            "Step 6: Fix device-specific behaviors like toggle",
            "Search for places where core behavior assumes a two-state model, especially toggle-like operations.",
            "For devices with special semantics (e.g., PS4), implement a device-specific async_toggle (or equivalent) that:",
            "- Treats the new state as off-like when toggling (e.g., from standby go to turn_on).",
            "- Treats any truly on-like state (idle/playing) as off when toggling (turn_off).",
            "Write tests that:",
            "- Put the device into each relevant state (OFF, STANDBY, IDLE, PLAYING, etc.).",
            "- Call the toggle service and assert the correct underlying method (turn_on vs turn_off) is called.",
            "Step 7: Update any aggregating/proxy entities",
            "For entities like Universal media_player that combine child entities:",
            "- Update OFF_STATES (or similar lists) to include the new state if it should be treated as off-like.",
            "- Ensure logic choosing the active child state remains correct with the new state considered.",
            "Add or adjust tests to confirm behavior with the new state, especially when multiple children are in different states.",
            "Step 8: Regression testing and validation",
            "Run the full test suite (e.g., tox) to catch regressions in other modules.",
            "Manually simulate key flows if possible:",
            "- UI behavior (e.g., pressing the power button when in standby).",
            "- Automation triggers and conditions on the new state.",
            "- External integrations (HomeKit/others) reflecting the correct power state.",
            "Step 9: Document the new state and its semantics",
            "Update developer and user documentation to explain:",
            "- What the new state represents.",
            "- How it behaves relative to standard states.",
            "- Any special integration behavior (e.g., standby maps to off in HomeKit).",
            "Include examples for automations using the new state (e.g., device condition 'is_standby')."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Implemented a Home Assistant sensor for AVM FritzBox routers that listens to the call monitor TCP port 1012, parses incoming/outgoing call events (RING, CALL, CONNECT, DISCONNECT), maps them to sensor states (idle, dialing, ringing, talking) with rich attributes, and runs the listener in a daemon thread with timeout and automatic reconnection if the socket disconnects.",
        "keywords": [
            "FritzBox",
            "call monitor",
            "Home Assistant sensor",
            "TCP socket listener",
            "threading daemon",
            "automatic reconnect",
            "RING CALL CONNECT DISCONNECT",
            "non-polling entity",
            "network integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request added a new Home Assistant sensor platform `fritzbox_callmonitor` to integrate AVM FritzBox routers' call monitor feature. FritzBox devices can expose call events on TCP port 1012 when `#96*5*` is dialed. The author implemented a `FritzBoxCallSensor` entity whose state represents the call status (`idle`, `dialing`, `ringing`, `talking`) and whose attributes contain metadata such as caller, callee, device, timestamps, and call duration.\n\nA companion class, `FritzBoxCallMonitor`, opens a TCP socket to the configured host and port, receives the plain-text call monitor lines, and parses the different event types: `RING` (incoming call), `CALL` (outgoing call), `CONNECT` (call answered), and `DISCONNECT` (call ended). Each event updates the sensor's state and attributes, then triggers `update_ha_state()` so Home Assistant can react immediately without polling.\n\nInitially, the listener thread was started without being marked as daemon and used a simple buffer-based loop to accumulate data, which could be brittle if the connection dropped or no data arrived. During review and testing, the author found and fixed operational issues: they set the thread to `daemon=True` so Home Assistant shutdown is not blocked by the background listener, added a socket timeout (`settimeout(10)`), and implemented reconnect logic. If a `recv` times out, the code simply retries; if `recv` returns an empty response (indicating a closed connection), the sensor treats it as a disconnect, sets `self.sock` to `None`, and repeatedly attempts to reconnect at a fixed interval (`INTERVAL_RECONNECT = 60` seconds) until successful.\n\nThe PR also addressed code style and linting concerns (docstrings, pylint `too-few-public-methods` suppression, whitespace) and added the new file to `.coveragerc`. A failing test (`test_statemachine_remove_from_slave`) was identified as a flaky, unrelated test by a maintainer and did not block the merge.",
        "semantic_memory": "This change illustrates several general patterns for building robust, event-driven integrations with external devices over TCP in Home Assistant (or similar frameworks):\n\n1. **Non-polling, event-driven design:** For sources that push events (like FritzBox call monitor), it's better to attach a one-way listener and drive state changes from incoming messages rather than polling. In Home Assistant, this means implementing `Entity.should_poll` as `False` and triggering `update_ha_state()` when events are received.\n\n2. **Background listener threads:** Long-lived network listeners should run in background threads so they do not block the main application. Marking them as `daemon=True` ensures that they do not prevent process shutdown. This is especially important in services that need clean restarts or upgrades.\n\n3. **Robust socket handling:** Network connections can time out or drop. Robust integrations should:\n   - Set reasonable socket timeouts to avoid blocking forever on `recv`.\n   - Distinguish between timeout (no data yet) and connection loss (empty `recv` or explicit error).\n   - Implement reconnection logic with a backoff or fixed interval.\n   - Avoid tight loops; include a sleep or wait between reconnect attempts to prevent CPU spin and connection storms.\n\n4. **Parsing line-based protocols safely:** When dealing with simple text protocols (e.g., `timestamp;event_type;...`), parse lines carefully, handle date/time format conversions, and convert to standardized formats (e.g., ISO 8601). Map protocol-specific events (`RING`, `CALL`, `CONNECT`, `DISCONNECT`) into domain-specific concepts (`ringing`, `dialing`, `talking`, `idle`) for a clean abstraction.\n\n5. **API surface of integration entities:** A clean separation between transport (monitor class) and representation (sensor entity) keeps the entity minimal and focused on state and attributes, while the monitor handles I/O and parsing. This separation promotes testability and easier extension.\n\n6. **Dealing with unrelated flaky tests:** When a new feature triggers test failures that are unrelated (e.g., known flaky tests elsewhere in the suite), check CI logs and consult maintainers. Do not overfit your code to fix unrelated failures; instead recognize and document them as external flakiness.",
        "procedural_memory": [
            "Step-by-step instructions on how to design and implement a similar event-driven TCP integration in Home Assistant or comparable systems:",
            "Step 1: Understand the external device protocol.\n- Obtain the device's documentation (e.g., FritzBox call monitor format).\n- Identify connection details (host, port, TCP vs UDP, line format, terminators).\n- Enumerate event types and fields (e.g., RING, CALL, CONNECT, DISCONNECT, timestamps, numbers).",
            "Step 2: Define the entity model.\n- Decide on the high-level states you want to expose (e.g., idle, ringing, dialing, talking).\n- Decide which fields should be sensor attributes (caller, callee, device, duration, timestamps).\n- Implement an `Entity` subclass with:\n  - `_state` and `_attributes` members.\n  - `should_poll` returning `False`.\n  - `state`, `name`, and `device_state_attributes` properties.\n  - Small setter methods to update state/attributes.",
            "Step 3: Implement the TCP monitor/transport class.\n- Create a separate class (e.g., `FritzBoxCallMonitor`) responsible for:\n  - Opening a socket: `socket.socket(AF_INET, SOCK_STREAM)`.\n  - Setting a timeout: `sock.settimeout(<seconds>)` to avoid blocking forever.\n  - Connecting to the device in a `connect()` method.\n- In `connect()`, handle connection errors:\n  - Catch `socket.error`.\n  - Log a useful error message with host/port and exception details.\n  - Ensure `self.sock` is set to `None` on failure.",
            "Step 4: Start a daemon listener thread.\n- After a successful `connect()`, spawn a background thread:\n  - `threading.Thread(target=self._listen, daemon=True).start()`.\n- Marking the thread as daemon ensures that the application can shut down even if the listener is still running.",
            "Step 5: Implement the `_listen` loop robustly.\n- Use a `while True` loop that:\n  - Calls `recv()` in a try/except block to catch timeouts or errors.\n  - On `socket.timeout`, simply continue (no data yet).\n  - On `recv()` returning an empty result, treat it as a lost connection:\n    - Set `self.sock` to `None`.\n    - Sleep for a configured interval (e.g., 60 seconds) between reconnect attempts.\n    - Call `connect()` inside a loop until `self.sock` is not `None`.\n- Parse each non-empty response (e.g., split on `\\n` and take the first line) and pass it to a parser method.",
            "Step 6: Parse incoming lines into domain events.\n- Implement a `_parse(line)` method that:\n  - Splits the line by its delimiter (e.g., `;`).\n  - Parses the timestamp using the documented format (`datetime.strptime`).\n  - Converts it to a standard format (e.g., ISO 8601) for attributes.\n  - Branches on the event type (e.g., `line[1] == 'RING'`) and maps fields to attributes.\n  - Sets the sensor state and attributes accordingly.\n  - Calls `sensor.update_ha_state()` to notify Home Assistant of the change.",
            "Step 7: Wire the platform into Home Assistant.\n- Implement `setup_platform(hass, config, add_devices, discovery_info=None)`:\n  - Read configuration options (host, port, name) with sensible defaults.\n  - Instantiate the sensor and pass it to `add_devices`.\n  - Instantiate the monitor with host/port/sensor and call `connect()`.\n  - If `monitor.sock` is `None` after `connect()`, return `False` to signal setup failure; otherwise return `True`.",
            "Step 8: Handle style, linting, and coverage configuration.\n- Add pylint pragmas only where necessary (e.g., `too-few-public-methods` for small helper classes).\n- Ensure docstrings adhere to project style.\n- Update coverage configuration (e.g., `.coveragerc`) if the project requires it.\n- Run the test suite and static analysis tools (e.g., `tox`) locally before pushing.",
            "Step 9: Deal with CI failures.\n- If CI fails, inspect logs to determine whether failures are in your new code or elsewhere.\n- For known flaky tests in other modules, confirm with maintainers rather than trying to 'fix' them in your feature branch.\n- Focus fixes on bugs or robustness issues in the new integration (e.g., thread behavior, reconnection logic)."
        ]
    }
}
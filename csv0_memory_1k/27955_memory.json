{
    "search_index": {
        "description_for_embedding": "Home Assistant HomeKit integration was generating HomeKit accessory IDs (AIDs) by directly applying zlib.adler32 to entity_id strings, which have low entropy and limited character variety. This caused frequent hash collisions, leading to duplicate or conflicting accessories in HomeKit. The PR mitigates this by first hashing the entity_id with SHA-512 and then feeding the binary digest into adler32, significantly improving the distribution of AIDs and reducing collisions (though not eliminating them), and updates tests to the new AID values.",
        "keywords": [
            "Home Assistant",
            "homeassistant.components.homekit",
            "HomeKit",
            "AID generation",
            "accessory ID",
            "hash collision",
            "adler32",
            "sha512",
            "low-entropy identifiers",
            "breaking change",
            "duplicate accessories",
            "entity_id hashing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant HomeKit integration was suffering from hash collisions when generating HomeKit accessory identifiers (AIDs). The code used Python's zlib.adler32 directly on the entity_id string (e.g., 'light.demo', 'demo.test', 'sonoff-0001'). Because entity IDs are short and drawn from a limited character set, adler32 produced many collisions. Users observed issues like 'double' or conflicting HomeKit devices and exceptions related to duplicate AIDs.\n\nThe contributor reproduced the problem by iterating over 1000 entity IDs like 'sonoff-0000'...'sonoff-0999', computing adler32(entity_id), and counting collisions, which showed hundreds of collisions in this small space. They then tested an alternative scheme: compute sha512(entity_id).digest() and feed that binary digest into adler32. In this test, collisions dropped to zero for that 1000-ID sample, demonstrating a much better distribution.\n\nThe concrete code change in homeassistant/components/homekit/__init__.py was:\n- Add `import hashlib`.\n- Change generate_aid from:\n  `aid = adler32(entity_id.encode(\"utf-8\"))`\n  to:\n  `aid = adler32(hashlib.sha512(entity_id.encode(\"utf-8\")).digest())`\n- Preserve the existing guard that returns None if the resulting AID is 0 or 1.\n\nCorresponding tests in tests/components/homekit/test_homekit.py were updated to expect the new deterministic AID values generated by the new scheme (e.g., the AID for 'light.demo' changed from 363398124 to 1730485127, etc.).\n\nReviewers pointed out that this is a breaking change for existing HomeKit pairings: AIDs must be stable for the lifetime of a pairing according to the HomeKit spec. Changing the AID generation function means iOS will see existing accessories as removed and new ones added, causing users to lose room assignments, scenes, and automations configured in the Home app. They also noted that even with the SHA-512 pre-hash, adler32 is still a 32-bit checksum and cannot guarantee absence of collisions.\n\nA suggested long-term 'proper' fix was to avoid hashing altogether and instead store a persistent mapping from an entity's unique_id to a stable AID, allocating new AIDs sequentially or randomly while ensuring no collisions. This could be introduced with a migration strategy to avoid breaking existing setups. However, given the lack of a HomeKit maintainer, the immediate PR was framed as a pragmatic but imperfect mitigation that substantially reduces collisions for affected users (who can manually apply the patch, e.g., via a Docker wrapper script) while acknowledging it is not a complete or collision-free solution.",
        "semantic_memory": "Generalizable lessons from this fix:\n\n1. **Don't use checksums as unique ID hashes**:\n   - zlib.adler32 and similar functions (e.g., CRCs) are designed as fast checksums, not as collision-resistant hash functions.\n   - They are particularly poor when applied directly to short, structured, low-entropy inputs (like short ASCII identifiers with constrained character sets), leading to many collisions in practice.\n\n2. **Pre-hashing can improve distribution but not capacity**:\n   - Applying a cryptographic hash (e.g., SHA-512) to an identifier and then passing its binary digest to a checksum function can greatly improve the effective distribution of the checksum values, because the checksum now sees high-entropy, uniform-looking input.\n   - However, the output space size remains bounded by the checksum's bit width (32 bits for adler32), so collisions are still mathematically inevitable if enough IDs are generated.\n\n3. **ID derivation changes are breaking changes in external protocols**:\n   - When IDs are part of an external protocol or pairing (e.g., HomeKit AIDs), the way you derive those IDs becomes part of the persistent contract with the external system.\n   - Changing the derivation algorithm will effectively change every ID, which for HomeKit means iOS will treat all accessories as removed and re-added, wiping rooms, scenes, and automations.\n   - Such changes must be treated as intentional breaking changes, with clear migration steps and communication to users.\n\n4. **Prefer stable, stored mappings over derived hashes for persistent IDs**:\n   - For long-lived identifiers that must remain stable and unique across restarts and migrations, relying solely on a hash of other mutable properties (like entity_id) is brittle.\n   - A better pattern is to use a persistent storage mapping from a stable intrinsic identifier (e.g., unique_id) to an external ID (AID). The external ID can be allocated sequentially or randomly, with checks for collisions, and stored on disk.\n   - This allows renaming of entities (changing user-facing IDs) without breaking external integrations.\n\n5. **Test determinism when changing ID generation**:\n   - When you change how IDs are generated, update tests to pin exact expected values for representative inputs. This guards against accidental changes in the hashing algorithm and ensures determinism across versions.\n\n6. **Quick mitigation vs. proper fix**:\n   - Sometimes the quick mitigation (e.g., wrapping adler32 in SHA-512) can vastly improve the situation and help affected users immediately, but may not meet long-term correctness guarantees.\n   - It's useful to clearly distinguish between 'mitigation' and 'proper fix' and document the trade-offs (collision probability, breaking changes, migration impact).",
        "procedural_memory": [
            "Step-by-step approach to diagnosing and fixing similar ID-collision issues in integrations like HomeKit:",
            "Step 1: Identify symptoms of ID collisions",
            "  - Look for errors or logs indicating duplicate IDs or conflicts (e.g., exceptions when registering accessories, or 'double' entries appearing in a UI like Apple's Home app).",
            "  - Confirm whether the system uses a derived ID (e.g., a hash/checksum of a string identifier) for external identifiers.",
            "Step 2: Inspect the ID generation function",
            "  - Locate the function responsible for generating the external IDs (e.g., generate_aid in the HomeKit integration).",
            "  - Check whether it uses a short, structured string (like entity_id) directly as input to a non-cryptographic checksum (e.g., adler32, CRC32).",
            "  - Verify if there are any guards for special values (e.g., disallowing 0 or 1).",
            "Step 3: Quantify collision behavior",
            "  - Write a small script to generate a realistic set of identifiers (e.g., 'light.demo', 'demo.test', 'sonoff-0000'...'sonoff-0999').",
            "  - Compute the current hash/checksum for each and count how many distinct identifiers map to the same output.",
            "  - Example pattern (Python):",
            "    - Use a dict or collections.defaultdict(int) to count occurrences of each hash value.",
            "    - At the end, sum counts for hash values where count > 1 to see how many collisions you have.",
            "Step 4: Prototype an improved hashing approach",
            "  - If you must continue using a constrained-size numeric ID, consider pre-hashing inputs with a cryptographic hash function to increase input entropy:",
            "    - NewID = Checksum( SHA-512( identifier ).digest() )",
            "  - Re-run the collision analysis with the new scheme to see if collisions are significantly reduced.",
            "  - Understand that this is still limited by the bit width of the final checksum (e.g., 32 bits) and cannot guarantee zero collisions as the ID space grows.",
            "Step 5: Evaluate protocol and backward-compatibility impact",
            "  - Determine whether the external system requires IDs to remain stable across restarts/pairings (e.g., HomeKit AIDs must be stable for the lifetime of a pairing).",
            "  - If the hashing change will alter existing IDs, treat it as a breaking change:",
            "    - Document what will happen (e.g., loss of room assignments, scenes, automations on the external side).",
            "    - Provide migration guidance (e.g., delete cached state, re-pair devices, re-create scenes).",
            "Step 6: Design a long-term, robust solution",
            "  - Prefer storing a persistent mapping between a stable internal identifier (like unique_id) and the external ID:",
            "    - On first run or during migration, generate an external ID for each entity (sequential or random) and store it in a dedicated storage file or database.",
            "    - On subsequent runs, reload this mapping so external IDs remain stable even if the entity_id or other properties change.",
            "    - Implement collision checks when allocating new IDs to guarantee uniqueness.",
            "  - Plan a migration path from the old hashed IDs to the new stored mapping:",
            "    - For existing pairings, you might initially populate the mapping using the legacy hash-derived IDs to avoid breaking users.",
            "    - For new entities, use the new allocation strategy.",
            "Step 7: Implement and test",
            "  - Implement the revised ID generation logic (whether the interim mitigation or the full mapping-based approach).",
            "  - Update any tests that assert specific ID values to match the new logic.",
            "  - Add new tests for collision detection behavior if applicable (e.g., verifying that the system does not accept duplicate IDs and handles conflicts gracefully).",
            "Step 8: Communicate and document",
            "  - Clearly document in release notes if the change is breaking, including:",
            "    - What users will observe (e.g., HomeKit devices appearing as new, loss of Home app scenes/rooms).",
            "    - Recommended remediation steps (e.g., remove the bridge from Home app, re-add, reconfigure rooms/scenes).",
            "  - If providing an interim mitigation (like SHA-512 + adler32), note its limitations and the intention to follow up with a more robust solution.",
            "Step 9: Provide workaround for advanced users (optional)",
            "  - If the official fix will take time (e.g., due to lack of a maintainer), consider documenting a small patch or wrapper script that advanced users can apply locally (as the contributor did with a Docker bootstrap script that patches generate_aid before starting Home Assistant).",
            "  - Ensure such workarounds are clearly marked as unofficial and explain the trade-offs (e.g., breaking change, possible residual collisions)."
        ]
    }
}
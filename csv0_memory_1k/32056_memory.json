{
    "search_index": {
        "description_for_embedding": "MQTT fan integration enhancement: adds support for a Jinja2 speed_command_template so outgoing speed commands can be transformed (e.g., remap human-friendly speed labels to device-specific numeric protocols like Tuya/Tasmota). Falls back to legacy payload mapping when no template is defined.",
        "keywords": [
            "Home Assistant",
            "MQTT",
            "fan",
            "speed_command_template",
            "speed_value_template",
            "templating",
            "Tuya",
            "Tasmota",
            "payload transformation",
            "mqtt.fan",
            "command topic",
            "configuration schema"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, a user needed to control an MQTT-based pedestal fan whose physical speeds are labeled 1–8, but the device firmware (Tasmota with a Tuya MCU) uses 0–7 on the wire and requires a TuyaSend4 command with a prefixed DpId. Home Assistant's MQTT fan platform already supported speed_value_template for transforming incoming speed state, but there was no equivalent for transforming the outgoing speed command payload. This meant the user could display speeds correctly in the UI but could not emit the required transformed command format (e.g., '3,<speed-1>').\n\nTo solve this, the PR added a new configuration option, speed_command_template, to the MQTT fan integration. The config schema was updated to accept this new template field, it was stored in the entity's internal template mapping, and the async_set_speed method was modified to check for this template. If speed_command_template is defined, the outgoing MQTT payload is generated by rendering that template with a context containing the selected speed as value. If no template is provided, the existing behavior remains: map SPEED_LOW, SPEED_MEDIUM, SPEED_HIGH to predefined payloads. An abbreviation spd_cmd_tpl was added in abbreviations.py so that the new option can be used in the compact MQTT discovery format.\n\nThe end result: the user can now map UI speeds 1–8 to underlying protocol speeds 0–7 and construct complex TuyaSend4 payloads directly from the speed selection, without breaking existing configurations that rely on static payloads.",
        "semantic_memory": "This change illustrates a general pattern in IoT and MQTT-based integrations: devices often expose raw, protocol-specific command values that do not align with user-friendly representations (e.g., indexes vs. labels, different ranges, or compound command formats). Providing symmetric templating on both state and command paths is a robust way to bridge this gap.\n\nKey ideas:\n- Symmetry between state and command: If an integration allows templating on incoming values (state_value_template, speed_value_template), it is often necessary to also allow templating on outgoing commands (command_template, speed_command_template). This symmetry gives users full control over value transformations in both directions.\n- Backward-compatible feature extension: When adding new configuration options, preserve existing behavior as the default. In this case, the legacy speed-to-payload mapping remains the fallback if no speed_command_template is provided.\n- Configuration schema evolution: New options should be added to the validation schema (e.g., via voluptuous) and any discovery/abbreviation mapping so that they can be used both in YAML and auto-discovery payloads.\n- Template rendering with context: Outgoing payload templates should receive enough context (e.g., {'value': speed}) so users can build arbitrary protocol strings while keeping the implementation simple and generic.\n\nMore broadly, this demonstrates a best practice in home automation integrations: expose flexible, template-based hooks at integration boundaries (MQTT topics, HTTP payloads, etc.) instead of trying to support every protocol quirk directly in core code.",
        "procedural_memory": [
            "When an integration supports templating for state but not for commands, and users need to transform outgoing values (e.g., for non-trivial device protocols), add a command template option with backward-compatible behavior.",
            "Step 1: Identify the asymmetry or limitation",
            "- Confirm that the integration allows templating for incoming state (e.g., speed_value_template, state_value_template) but not for outgoing commands.",
            "- Review user requirements: do they need to remap ranges (e.g., 1–8 to 0–7), or build structured payloads (e.g., 'DpId,value')?",
            "- Check the existing command handling function (e.g., async_set_speed) to see how it builds MQTT payloads.",
            "Step 2: Design the new configuration option",
            "- Choose a clear, parallel name (e.g., speed_command_template to complement speed_value_template).",
            "- Decide on the template context: minimally include the selected value under a stable key (e.g., {'value': speed}).",
            "- Ensure the default behavior remains unchanged when the new option is not provided.",
            "Step 3: Update config schema and discovery/abbreviations",
            "- In the integration's configuration schema, add the new optional key with template validation (e.g., vol.Optional(CONF_SPEED_COMMAND_TEMPLATE): cv.template).",
            "- If the integration uses discovery or shorthand keys, update the abbreviation mapping (e.g., add 'spd_cmd_tpl': 'speed_command_template' in abbreviations.py).",
            "- Run or update configuration-related tests to cover the presence of the new key.",
            "Step 4: Store and initialize the template",
            "- In the entity setup (e.g., _setup_from_config), add the new template to the internal template dictionary (e.g., self._templates[CONF_SPEED_COMMAND_TEMPLATE] = config.get(CONF_SPEED_COMMAND_TEMPLATE)).",
            "- Ensure templates are prepared/attached to the Home Assistant context if needed (e.g., by calling async_render or attaching before use).",
            "Step 5: Integrate templating into the command path",
            "- In the method that sends the command (e.g., async_set_speed), load the template instance from self._templates.",
            "- Implement logic: if a command template exists, render it with the appropriate context to produce the MQTT payload; otherwise, fall back to the legacy payload mapping.",
            "- Example pattern:\n  - tpl = self._templates[CONF_SPEED_COMMAND_TEMPLATE]\n  - if tpl: mqtt_payload = tpl.async_render({'value': speed})\n  - else: use existing SPEED_LOW/SPEED_MEDIUM/SPEED_HIGH mapping.",
            "Step 6: Maintain backward compatibility",
            "- Verify that existing configurations without the new template option behave exactly as before (same default payloads, topics, and behavior).",
            "- Add or adjust tests to confirm both paths: with template and without template.",
            "Step 7: Provide configuration examples for users",
            "- Document a YAML example showing how to map user-facing values to device values and construct complex payloads, e.g.:\n  - speed_value_template: \"{{ value.split(',')[1] | int + 1 }}\" (for incoming 0–7 to 1–8)\n  - speed_command_template: \"3,{{ value | int - 1 }}\" (for outgoing 1–8 to '3,<0–7>').",
            "Step 8: Validate and test end-to-end",
            "- Run local tests and static analysis / linters to ensure no regressions.",
            "- Test with a real or simulated device: verify that selecting speeds in the UI results in correctly formatted MQTT messages on the command topic and that state updates still render as expected.",
            "Step 9: Generalize for future work",
            "- Apply the same pattern to other domains (lights, switches, covers) where command templating symmetry with state templating would be beneficial.",
            "- Consider adding similar command_template options for other attributes (e.g., brightness, color temperature) if users need protocol-specific transformations."
        ]
    }
}
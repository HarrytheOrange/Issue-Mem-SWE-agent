{
    "search_index": {
        "description_for_embedding": "Fix GTFS sensor departure lookup that failed around midnight by querying yesterday, today, and optionally tomorrow and building an in-memory timetable that correctly handles post-midnight trips and exposes new attributes for day, first, and last departures.",
        "keywords": [
            "GTFS",
            "Home Assistant",
            "departure lookup",
            "midnight crossover",
            "post-midnight trips",
            "schedule across days",
            "SQL date time handling",
            "include_tomorrow",
            "sensor attributes day first last",
            "public transit integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant GTFS sensor only retrieved departures scheduled for the current calendar date and time, using an SQL query filtered by the current weekday and time > now. This caused two practical issues:\n\n1. Trips that operationally belong to 'today' but are scheduled after midnight (e.g., 00:15 after a 23:30 departure) were not being returned, because the SQL condition only looked at trips with departure time greater than the current time on the current calendar day.\n2. When it was after midnight, trips that started the previous evening but had stops shortly after midnight were not considered, so the sensor would incorrectly report that there were no more departures.\n\nAdditionally, there was no option to fetch the next departure for tomorrow when there were no more departures for the current day; the sensor would always report 'No more departures today', even if tomorrow's services were available and known.\n\nThe fix replaced the simplistic single-day SQL query with a more robust, multi-day approach and additional metadata:\n\n- The `get_next_departure` function signature was extended to take an `include_tomorrow` boolean and return an optional dict. A new configuration key `include_tomorrow` (defaulting to `False`) was added to the platform schema and passed through to the sensor.\n- Instead of querying only the current day, the code now constructs a single SQL query that retrieves all candidate trips for **yesterday**, **today**, and optionally **tomorrow**. The SQL returns:\n  - Origin and destination times (as `time()`), plus the origin departure date (via `date(origin_stop_time.departure_time)`),\n  - Calendar flags indicating whether the service runs on yesterday, today, and optionally tomorrow, along with service start and end dates.\n- A large limit is set for the query (up to 2 days worth of departures; 3 if including tomorrow) to ensure all relevant rows are fetched.\n- The Python code then builds an in-memory `timetable` keyed by full datetime strings (e.g., `YYYY-MM-DD HH:MM:SS`). It:\n  - Adds entries from yesterday that depart after midnight (i.e., calendar day is yesterday, but departure_date is later than the first departure date) and maps them onto today’s date so they can be considered as early-morning departures.\n  - Adds today’s entries, tracking the first and last departures for the day, taking into account that some \"today\" services may be scheduled after midnight (rolled into tomorrow's calendar date).\n  - Optionally adds tomorrow’s entries when `include_tomorrow` is `True`, ensuring they are within the calendar service date range.\n- The code then flags the last departure for yesterday and today by setting a `last` boolean in the timetable entries.\n- The next departure is chosen by iterating over the sorted timetable keys and picking the first departure whose parsed datetime is strictly greater than `now` (which includes any configured offset).\n- The return payload from `get_next_departure` now includes new fields: `day` (`'yesterday'`, `'today'`, or `'tomorrow'`), and `first`/`last` booleans indicating whether this trip is the first or last departure of its day (or `None` when not reliably determinable).\n- The sensor entity (`GTFSDepartureSensor`) was updated to store `include_tomorrow`, call `get_next_departure` with this flag, and augment attributes:\n  - On no departure found: it now sets `Info` to \"No more departures\" when `include_tomorrow` is `True`, otherwise \"No more departures today\" for backward-compatible behavior.\n  - On a valid departure: it sets attributes `arrival`, `day`, `first` (when not `None`), `last` (when not `None`), and `offset` (in minutes). The name and icon logic remain consistent with route and agency data.\n\nAs a result, the GTFS sensor correctly reports next departures around midnight, properly handles service-day vs calendar-day ambiguities, and optionally surfaces the first valid departure of the next calendar day when the current day has no more trips.",
        "semantic_memory": "This fix illustrates several generalizable patterns and best practices around time-based scheduling, especially when working with transit or similar time series data:\n\n1. **Service day vs calendar day:** In many domains (public transit, airlines, broadcast schedules), the \"operational day\" doesn't align with the calendar day. Services scheduled at 00:15 may logically belong to the previous operational day. Naively filtering by current date and time can miss these, so logic must be aware of service-day semantics.\n\n2. **Avoid over-reliance on SQL for complex time semantics:** SQL can filter by dates and times but isn't always the best place to encode non-trivial logic like \"treat after-midnight trips as part of yesterday's service\". A more robust pattern is to:\n   - Use SQL to fetch a superset of candidate rows (e.g., yesterday + today + tomorrow),\n   - Perform the nuanced time interpretation and selection in higher-level code (Python here), where it's easier to express complex rules and maintain them.\n\n3. **Build an in-memory timetable for flexible queries:** For schedule-based systems, constructing a normalized in-memory timetable keyed by absolute datetimes allows easy operations: finding the next event, computing first/last events of the day, looking across boundaries (e.g., midnight), and supporting future features like fetching multiple upcoming departures.\n\n4. **Introduce explicit metadata for day and boundaries:** Exposing additional attributes like `day` (yesterday/today/tomorrow) and `first`/`last` flags makes the system more understandable and allows downstream consumers (UI, automations, other services) to make smarter decisions (e.g., special handling for first/last train).\n\n5. **Configurable behavior for cross-day lookups:** Providing a configuration flag (`include_tomorrow`) allows users to choose between strict daily behavior and more helpful cross-day behavior. This is especially important for backward compatibility in widely used integrations.\n\n6. **Time offset handling combined with cross-day logic:** When supporting time offsets (e.g., to ask \"next departure X minutes from now\"), the offset should be applied before cross-day lookup. The selection logic (e.g., sorted timetable and first departure after `now + offset`) should work relative to this effective now, not the system clock alone.\n\n7. **Graceful messaging depending on feature flags:** User-facing messages should adapt to new behavior. When tomorrow's departures are considered, saying \"No more departures today\" becomes inaccurate; a generic \"No more departures\" better reflects \"no more in the configured search window\".\n\nThese patterns apply to any time-schedule integration where the notion of day and boundaries (midnight, DST changes, end-of-service windows) do not align with naive calendar filters or where you need to query adjacent days to avoid missing edge cases.",
        "procedural_memory": [
            "When debugging and fixing schedule-related bugs around midnight or service-day transitions, follow these steps:",
            "Step 1: Reproduce and characterize the issue",
            "- Simulate times just before and after midnight and verify the system's behavior.",
            "- Use test data where trips start before midnight and continue after midnight (e.g., origin at 23:30, intermediate stops at 00:05, 00:15).",
            "- Confirm whether the system misses:\n  - Late-night departures that belong to the current service day but after midnight,\n  - Early-morning departures belonging to the previous service day when it's past midnight.",
            "- Log or trace the exact SQL queries and filters (date, weekday, time) used for selection.",
            "Step 2: Identify the time model (service vs calendar day)",
            "- Determine whether the domain you're working with (e.g., GTFS, airline schedules) treats days as:\n  - Pure calendar days, or\n  - Service days (e.g., 4 AM to 3:59 AM) where post-midnight events belong to the previous day.",
            "- Inspect the source schema (e.g., GTFS `calendar`, `trips`, `stop_times`) to see how days, dates, and times are represented.",
            "- Map the system’s notion of \"today\" to the domain’s notion of \"service day\" and note where they diverge.",
            "Step 3: Replace single-day SQL filters with multi-day queries",
            "- Instead of querying only for the current day with a `WHERE` clause like `calendar.today = 1 AND time > now`, broaden the query to include adjacent days:\n  - Query yesterday, today, and optionally tomorrow using OR conditions on the weekly flags (e.g., `calendar.monday`, `calendar.tuesday`, etc.).\n  - Include `start_date` and `end_date` from `calendar` to ensure the service is active on those days.",
            "- Select both time and date components. For example:\n  - `time(origin_stop_time.departure_time)` as `depart_time`,\n  - `date(origin_stop_time.departure_time)` as `depart_date`.",
            "- Use a generous `LIMIT` to fetch a superset of candidate departures for these days without excessive overhead (e.g., enough to cover all possible departures over 2–3 days, based on expected frequency).",
            "Step 4: Build an in-memory timetable keyed by absolute datetimes",
            "- In application code, iterate over the SQL rows and construct a dictionary/map keyed by a fully qualified datetime string, e.g., `YYYY-MM-DD HH:MM:SS`.",
            "- For each row:\n  - Determine which logical day it belongs to (`yesterday`, `today`, `tomorrow`) based on calendar flags and service date constraints.\n  - Compute the proper date part of the key:\n    - For classic 'today' trips, use today's date.\n    - For after-midnight trips that belong to yesterday's service but should be considered for today's early hours, map them to the corresponding calendar date (e.g., today) as appropriate.\n  - Store the row along with extra metadata: `day`, placeholders for `first`/`last`, and any additional needed fields.",
            "Step 5: Mark first and last departures per logical day",
            "- While building or after building the timetable:\n  - Track the first departure for each logical day by noting the earliest key for that day.\n  - Track the last departure for each logical day by noting the latest key for that day.\n  - Add boolean flags `first` and `last` to the associated entries.",
            "- If a day’s boundaries cannot be reliably determined (e.g., only a partial window is fetched), set these flags to `None` instead of incorrectly assuming first/last.",
            "Step 6: Select the next departure using the timetable",
            "- Compute `now` as the current time plus any configured offset (`now = current_time + offset`).",
            "- Sort the timetable keys (they are strings representing datetimes) and iterate in order.",
            "- Parse each key into a datetime and pick the first entry where `departure_datetime > now`.",
            "- If no such entry exists, treat it as \"no more departures\" within the search window.",
            "Step 7: Expose meaningful metadata to consumers",
            "- Update the returned departure object to include:\n  - `day`: 'yesterday', 'today', or 'tomorrow',\n  - `first`: boolean indicating if this is the first departure of the day (or `None`),\n  - `last`: boolean indicating if this is the last departure of the day (or `None`).",
            "- In the sensor/entity object, propagate these into attributes so front-ends and automations can use them.",
            "- For example, set attributes:\n  - `arrival`: the arrival datetime of the destination,\n  - `day`, `first`, `last`,\n  - `offset`: the effective offset in minutes.",
            "Step 8: Make behavior configurable and maintain backward compatibility",
            "- Introduce a configuration option such as `include_tomorrow` (default `False`) to control whether tomorrow's departures are considered when there are no more today.",
            "- Thread this option from configuration, through the platform setup, into the function that selects departures.",
            "- Adjust user-facing messages appropriately:\n  - If `include_tomorrow` is `False`, keep legacy behavior such as `\"No more departures today\"`.\n  - If `include_tomorrow` is `True`, use a more generic message like `\"No more departures\"` when nothing is found in the multi-day window.",
            "Step 9: Add tests for edge cases",
            "- Create tests that cover:\n  - Trips that cross midnight but belong to the previous service day.\n  - Times just before and just after midnight with and without `include_tomorrow`.\n  - First and last departures for each logical day.\n  - Behavior when there truly are no more departures for today and tomorrow.",
            "- Validate that the system returns the correct next departure and sets `day`, `first`, and `last` flags correctly.",
            "Step 10: Log and debug effectively",
            "- Add debug logging to emit the constructed timetable keys and the chosen departure, to help diagnose any future issues.",
            "- Example: log sorted timetable keys and the selected departure key and attributes, as done with `_LOGGER.debug(\"Timetable: %s\", sorted(timetable.keys()))` and a follow-up log when a departure is found."
        ]
    }
}
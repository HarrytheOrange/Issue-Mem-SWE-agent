{
    "search_index": {
        "description_for_embedding": "StackStorm Python runner now throws clear, user-friendly exceptions when the action metadata references a Python script that is missing or has invalid syntax. The wrapper catches loader errors from action_loader.register_plugin, wraps them with context (file path, likely cause), preserves the traceback, and improves the error when no action class is found.",
        "keywords": [
            "StackStorm",
            "Python runner",
            "python_action_wrapper",
            "action_loader.register_plugin",
            "user-friendly error message",
            "missing action script",
            "invalid action script syntax",
            "No such file or directory",
            "ImportError",
            "plugin loading error",
            "traceback"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, users of the StackStorm Python runner were getting confusing or low-level exceptions when an action's metadata referenced a Python script that either did not exist or contained invalid syntax. The Python runner used action_loader.register_plugin(Action, file_path) to load the action class, but when this failed (e.g., because the file was missing or contained import/syntax errors), the resulting exceptions were not very user-friendly and were inconsistent with the error behavior in the sensor container.\n\nThe fix was implemented in python_action_wrapper._get_action_instance. The call to action_loader.register_plugin is now wrapped in a try/except block. If any exception is raised, the wrapper:\n- Captures the full traceback via traceback.format_exc().\n- Builds a descriptive error message that includes the file path and a hint that the script likely does not exist or contains invalid syntax.\n- Appends the original traceback to the message.\n- Re-raises an exception of the same type as the original (type(e)), but with the improved message.\n\nAdditionally, when the plugin loading succeeds but there is no action class found in the file (actions_cls is empty), the code now raises: `File \"<path>\" has no action class or the file doesn't exist.` This is more explicit than the previous generic message.\n\nNew tests were added to verify the behavior:\n- A test ensures a friendly error when the action script file does not exist, both in a non-package location (`/tmp/doesnt.exist`) and in a fixtures pack where the entry point points to a non-existent Python file (`list_repos_doesnt_exist.py`).\n- A test ensures a friendly error when the action script file exists but contains invalid syntax or import errors (a file importing a non-existent module in `invalid_syntax.py`). The tests assert that the raised exceptions' messages match regexes describing the friendly messages and include phrases like `No such file or directory` or `No module named invalid`.\n\nThe change was also documented in the CHANGELOG as an improvement, and a temporary debug print statement added during development was removed in the final patch.",
        "semantic_memory": "This fix illustrates a general pattern for improving error handling in dynamic plugin or script loading systems.\n\nKey concepts and best practices:\n- **Wrap low-level loader errors with domain context:** When dynamically loading user code (e.g., plugins, actions, scripts), raw exceptions such as ImportError, IOError, or SyntaxError are often too cryptic for end users. Wrapping them in higher-level messages that mention the specific resource (file path, action id, etc.) and the likely cause improves usability.\n- **Preserve the original exception type:** Re-raising exceptions using `type(e)(new_message)` preserves the exception class (e.g., ImportError, IOError), which is important for callers that may rely on catching specific error types while still allowing improved messaging.\n- **Include the traceback for debugging:** Combining a human-friendly summary with the full traceback (`traceback.format_exc()`) gives both clarity to users and sufficient detail for developers to debug issues without needing direct reproduction.\n- **Be explicit about common failure modes:** When a referenced file either does not exist, has invalid syntax, or contains no expected class, explicitly naming these conditions in the error message reduces guesswork and support overhead.\n- **Consistency across components:** Aligning error semantics and message styles between similar subsystems (e.g., Python runner vs. sensor container) makes the platform more predictable and easier to troubleshoot.\n- **Test error messages and failure modes:** Unit tests that intentionally trigger loader failures (missing files, bad imports, invalid syntax, missing classes) and assert against regexes of the error messages help lock in both behavior and user-facing clarity.\n\nThese patterns apply broadly to any system that:\n- Loads user-provided code or configuration at runtime.\n- Needs to present clear, actionable errors to end users or operators.\n- Wants to maintain debuggability while improving UX around failures.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the loader failure",
            "Trigger the problematic code path where user scripts/plugins are loaded (e.g., executing an action whose metadata references a Python entry_point). Confirm that the current error message is confusing, low-level, or lacks context (e.g., a bare ImportError or IOError without the action/script name).",
            "Step 2: Identify the loader boundary",
            "Locate the central place where user code is dynamically loaded or registered (e.g., a function like action_loader.register_plugin or equivalent). Find the wrapper or orchestrator that calls this loader in your runtime (e.g., python_action_wrapper._get_action_instance). This is where you will add error handling.",
            "Step 3: Add contextual error handling",
            "Wrap the loader call in a try/except block. In the except block:\n- Capture the original exception `e` and its traceback via `traceback.format_exc()`.\n- Construct a new, user-friendly message that includes:\n  - The resource being loaded (file path, module name, action id).\n  - Likely causes (e.g., the file does not exist, contains invalid syntax, or missing imports).\n- Append the full traceback to this message for debugging.\n- Re-raise an exception of the same type using something like:\n  `exc_cls = type(e)`\n  `raise exc_cls(new_message)`",
            "Step 4: Clarify behavior when no expected class/function is found",
            "If the loader returns successfully but no expected actionable object is found (e.g., actions_cls is empty or None), explicitly detect this. Raise a clear error such as: `File \"<path>\" has no action class or the file doesn't exist.` Tailor this message to the domain (e.g., plugin class, handler function).",
            "Step 5: Add regression tests for failure cases",
            "Write unit tests that cover the major failure modes:\n- A metadata/descriptor referencing a non-existent script file.\n- A script file that exists but imports a non-existent module or has syntax errors.\n- A script file that exists but does not define the expected class/function.\nIn each test, call the wrapper/loader method and assert that the raised exception:\n- Has the expected type (or is at least Exception if type specificity is not required).\n- Contains a friendly, descriptive message using regex matching to allow variable parts (paths, error text).",
            "Step 6: Ensure consistency with other subsystems",
            "Check similar loaders in other parts of the system (e.g., sensors, other runners, plugin managers). Align the style and content of error messages across these components so users get a coherent experience regardless of where the failure occurs.",
            "Step 7: Update documentation and changelog",
            "Document the improved error behavior in release notes or a changelog so users and operators know that they can expect more descriptive messages when scripts are missing or invalid. Optionally, update troubleshooting documentation to reference these new error messages.",
            "Step 8: Remove temporary debugging artifacts",
            "If any debug print/log statements were added during development (e.g., printing loader return values), remove or gate them behind proper logging levels before merging to keep production output clean."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant MQTT climate (HVAC) entities in non-optimistic mode (with state topics configured) were initialized with default values for temperature, fan mode, operation mode, and swing mode. After a Home Assistant restart, this caused incorrect UI state and history graphs until new MQTT state messages arrived. The fix ensures these attributes start as unknown (None) when state topics are present and only use configured defaults in optimistic mode (no state topic). Tests were updated accordingly.",
        "keywords": [
            "Home Assistant",
            "MQTT climate",
            "MQTT HVAC",
            "optimistic mode",
            "pessimistic mode",
            "state topic",
            "initial state",
            "history graph wrong after restart",
            "target temperature",
            "fan mode",
            "operation mode",
            "swing mode",
            "unknown state",
            "None initialization",
            "homeassistant.components.climate.mqtt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, MQTT-based climate (HVAC) entities in Home Assistant showed incorrect values after a restart when configured in non-optimistic mode (i.e., with MQTT state topics defined). Users observed that the temperature graph and various mode attributes (fan mode, current operation mode, swing mode) displayed a specific value immediately after startup, even though no state had yet been received from the MQTT device. This led to misleading history graphs and UI state.\n\nRoot cause: The MQTT climate component’s constructor always seeded several internal attributes from configuration defaults regardless of whether a corresponding state topic was defined. Specifically, `self._target_temperature`, `self._current_fan_mode`, `self._current_operation`, and `self._current_swing_mode` were initialized with configured default values even when `CONF_TEMPERATURE_STATE_TOPIC`, `CONF_FAN_MODE_STATE_TOPIC`, `CONF_MODE_STATE_TOPIC`, or `CONF_SWING_MODE_STATE_TOPIC` were present. In non-optimistic (pessimistic) mode, the device’s MQTT state should be the source of truth; pre-populating these values resulted in fake initial states surviving across restarts.\n\nThe fix changed the initialization logic in `homeassistant/components/climate/mqtt.py`:\n- All of `self._target_temperature`, `self._current_fan_mode`, `self._current_operation`, and `self._current_swing_mode` are first set to `None`.\n- Each attribute is then given its configured default value **only if** the corresponding state topic is `None` (i.e., optimistic mode). For example, `self._target_temperature` is set from `target_temperature` only when `CONF_TEMPERATURE_STATE_TOPIC` is `None`; similarly for fan mode, operation mode, and swing mode with their respective state topics.\n\nAs a result, in non-optimistic mode, these attributes and the entity state now start as `None`/`\"unknown\"` until real state messages are received from MQTT. The test suite (`tests/components/climate/test_mqtt.py`) was updated to expect `None` instead of concrete values for these attributes before any MQTT state messages arrive, and to expect the entity state to be `\"unknown\"` instead of `\"off\"` in pessimistic operation-mode tests.\n\nBinary-like attributes such as away mode and auxiliary heat, which only have 'on'/'off' states and are presented as switches, were intentionally left with default 'off' since representing 'unknown' there is less meaningful in the current UI.",
        "semantic_memory": "Generalizable lessons from this fix:\n\n1. **Do not fabricate state when an external source of truth exists**: When a component is configured with an explicit state source (e.g., MQTT state topics, hardware sensors, or remote APIs), the system should treat the state as unknown until data is received. Pre-populating attributes with default or remembered values can create misleading UI and incorrect history.\n\n2. **Differentiate optimistic vs pessimistic modes clearly**: \"Optimistic\" control modes assume that commands sent to a device succeed and use local assumptions as the source of truth. In that context, it is reasonable to initialize attributes from configuration defaults. Conversely, in \"pessimistic\" modes where the device must confirm state through state topics or callbacks, initial values should typically be `None`/unknown.\n\n3. **Use `None`/unknown explicitly to represent missing state**: For stateful entities, representing absent information as `None` (or an equivalent 'unknown' state) is important. It allows UI layers and history/logging components to distinguish between a valid 'off' or '0' and the absence of any data. This is especially important around service restarts and reconnections.\n\n4. **Initialization logic must respect configuration contracts**: Logic that sets initial values should be conditional on configuration options (e.g., presence/absence of state topics). A one-size-fits-all initialization path can silently break semantics in different modes.\n\n5. **Tests should validate pre-state-message behavior**: Regression tests should not only verify behavior after state updates but also the initial conditions on startup. For components that rely on external state, tests should assert that initial entity attributes are `None`/unknown until a state event is injected.\n\n6. **Binary vs multi-valued attributes may need different treatment**: For simple on/off switches, it can be pragmatically acceptable to default to 'off' if 'unknown' cannot be represented cleanly in the UI. For multi-valued attributes (mode, fan speed, etc.), defaulting can be misleading because it implies a specific physical state that may not be true.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the restart behavior\n- Identify an entity whose state is sourced from an external system (e.g., MQTT, hardware device).\n- Configure it with state topics or callbacks (non-optimistic/pessimistic mode).\n- Restart the application/service and observe the entity’s initial attributes and history graphs before any fresh state messages arrive.\n- Look for attributes that appear with concrete values instead of being unknown, and verify whether those values are actually confirmed by the device.",
            "Step 2: Inspect the initialization code\n- Locate the component/entity constructor or initialization routine.\n- Check how internal state variables (e.g., temperature, modes, flags) are initialized.\n- Identify whether these attributes are always assigned from configuration defaults or previous states, regardless of whether a state source (e.g., state topic, callback) is configured.\n- Confirm whether there is a concept of optimistic vs pessimistic mode and how it is determined (e.g., presence of state topics).",
            "Step 3: Map configuration options to state ownership\n- Enumerate configuration flags and topics that indicate where the source of truth lies (e.g., `*_STATE_TOPIC` options, polling flags).\n- For each attribute, decide: should the system trust its own defaults (optimistic) or wait for external state (pessimistic)?\n- Document this mapping: for example, if `temperature_state_topic` is present, then the device owns the target temperature state.",
            "Step 4: Correct the initialization logic\n- In the constructor, set all externally owned attributes to `None` by default.\n- Conditionally apply configuration defaults only when the corresponding external state channel is absent. For example:\n  - `self._attribute = None`\n  - `if state_topic is None: self._attribute = configured_default`\n- Avoid assigning any non-None default to attributes whose state is expected from external messages.",
            "Step 5: Update entity state semantics\n- Ensure that when core attributes are `None`, the primary entity state reflects an appropriate 'unknown' state instead of a valid operational state (e.g., map missing operation mode to an 'unknown' entity state rather than 'off').\n- Confirm that UI components and history graphs correctly handle `None`/unknown values (either by not plotting them or by distinguishing them visually).",
            "Step 6: Enhance and adjust tests\n- Add or update tests to explicitly check the initial state *before* any external state messages are injected.\n- For non-optimistic configurations:\n  - Assert that attributes like temperature, fan mode, operation mode, swing mode are `None` initially.\n  - Assert that the overall entity state is 'unknown' when key attributes are missing.\n- For optimistic configurations:\n  - Assert that the same attributes are initialized from configuration defaults in the absence of state topics.\n- Simulate incoming external messages (e.g., MQTT `fire_mqtt_message`) and verify that attributes transition from `None` to the correct values.",
            "Step 7: Consider attribute-specific semantics\n- For multi-valued attributes (modes, speeds, etc.), prefer `None`/unknown when state is not yet known.\n- For binary attributes (on/off flags like away mode, aux heat), decide whether defaulting to 'off' is acceptable given UI and user expectations, or whether you need a way to represent 'unknown'. Document this behavior clearly.",
            "Step 8: Prevent regressions\n- Add regression tests that explicitly model restart scenarios: bring up the system, check initial state, then inject state messages.\n- When adding new configuration options or state topics in the future, mirror this pattern: initialize to `None` for externally owned attributes and only use defaults when no state source is configured."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Honeywell thermostat integration was updated to expose and control the HVAC system operation mode (heat/cool/etc.) via the standard thermostat API. New `operation` properties and `set_hvac_mode` methods were added to the Honeywell Round and US thermostat entities, delegating to the underlying device's `system_mode` attribute, with accompanying unit tests and type hints. This change enables setting and retrieving the HVAC mode, but requires that the underlying client library actually implement `system_mode`, otherwise it can raise AttributeError on some non-US (Evohome) devices.",
        "keywords": [
            "Honeywell thermostat",
            "HVAC mode",
            "system_mode",
            "operation property",
            "set_hvac_mode",
            "homeassistant.components.thermostat.honeywell",
            "EvohomeClient",
            "AttributeError",
            "Home Assistant",
            "Python typing",
            "unit tests"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Honeywell thermostat platforms did not previously expose the HVAC system operation mode (e.g., heat, cool, off) via the standard thermostat interface. Users could set target temperatures, but they could not query or change the current system mode through Home Assistant services.\n\nTo resolve this, the pull request modified `homeassistant/components/thermostat/honeywell.py` for both the Honeywell Round and Honeywell US entities:\n- For the Honeywell Round entity, an `operation` property was added to return `self.device.system_mode`, and a `set_hvac_mode(self, hvac_mode)` method was added that assigns `self.device.system_mode = hvac_mode`.\n- For the Honeywell US entity, an `operation` property was added to return `self._device.system_mode`, and a `set_hvac_mode(self, hvac_mode)` method was added that assigns `self._device.system_mode = hvac_mode`.\n- Existing thermostat interfaces (like `set_temperature`, `target_temperature`, away mode methods) were left intact.\n\nUnit tests in `tests/components/thermostat/test_honeywell.py` were extended to cover the new behavior for both entity types. New tests confirmed that calling `set_hvac_mode('cool')` or `set_hvac_mode('heat')` updated both the entity's `operation` property and the underlying device's `system_mode`. Later patches added type hints to the new methods and tests (e.g., annotating `operation` to return `str`, and `set_hvac_mode` to accept a `str` and return `None`).\n\nAfter this change, a user with non-US Honeywell (Evohome) devices reported a regression: `AttributeError: 'EvohomeClient' object has no attribute 'system_mode'`, which caused the platform to fail to load. This showed that the fix assumed the existence of `system_mode` on all Honeywell-related device clients, which is not true for some regional implementations (like Evohome). The immediate PR focused on exposing HVAC mode for the Honeywell Round and US thermostats and verifying it with tests, but it also highlighted the need for capability checks or fallbacks when integrating across multiple device variants.",
        "semantic_memory": "General lessons from this change:\n\n1. **Adding feature coverage to a wrapper needs capability awareness**: When exposing new functionality (like HVAC mode) from a third-party device library through a higher-level integration, you must verify that the underlying client provides the necessary attributes or methods across all supported device variants. Assuming a property like `system_mode` exists for all devices can cause runtime errors (e.g., AttributeError) in environments where it is not implemented (such as non-US Evohome devices).\n\n2. **Align integration API with framework expectations**: Home Assistant's thermostat entities expect standard properties (`operation`) and methods (`set_hvac_mode`) to manage system state. Correctly mapping these to the underlying client (e.g., `device.system_mode`) is important for consistent automation behavior and UI features. This pattern—adapter properties/methods that simply forward to the underlying device—is common and should be used whenever possible.\n\n3. **Type hints and tests should accompany API surface changes**: Whenever new public methods or properties are added to an integration, they should be accompanied by unit tests validating the behavior and, where the project allows, type annotations to make the API contract explicit. This PR added tests confirming that `set_hvac_mode` updates both the entity and the backing device, and typed the methods accordingly.\n\n4. **Avoid regressions by testing different device classes/regions**: Integrations that cover multiple device types or regional backends (e.g., US Honeywell vs. Evohome) must be tested against each variant. A feature implemented for one class of devices (US thermostats) can break others (Evohome) if the integration code assumes a uniform backend API. Capability detection (`hasattr`, feature flags, or checking client version) or conditional behavior is often necessary.\n\n5. **Use adapter patterns rather than directly exposing backend attributes**: Directly reading/writing `device.system_mode` from entity properties and methods is convenient but brittle. An adapter layer that translates between generic operations and backend-specific capabilities makes it easier to handle missing or differently named attributes, and to provide fallbacks (e.g., returning a default operation or raising a clear, handled error) without breaking platform initialization.",
        "procedural_memory": [
            "When adding or fixing device features that depend on third-party client capabilities, follow a structured process:",
            "Step 1: Identify the missing or desired capability in the framework integration.",
            "  - Inspect the integration (e.g., Home Assistant thermostat entity) to see what standardized properties/methods are expected (`operation`, `set_hvac_mode`, etc.).",
            "  - Confirm that the missing feature (e.g., getting/setting HVAC mode) is supported by the underlying device client library for at least some devices.",
            "Step 2: Map framework-level API to device-level API.",
            "  - Determine the appropriate attribute or method on the device client (e.g., `system_mode`).",
            "  - Implement adapter properties/methods on the integration entity, such as:",
            "      @property",
            "      def operation(self) -> str:",
            "          return self.device.system_mode",
            "      def set_hvac_mode(self, hvac_mode: str) -> None:",
            "          self.device.system_mode = hvac_mode",
            "  - Keep these adapter methods thin; they should primarily translate framework calls into device operations.",
            "Step 3: Check capabilities across all supported device variants.",
            "  - Review the client library (and any mocking used in tests) to ensure attributes like `system_mode` exist for all relevant device types and regions (e.g., US Honeywell vs. Evohome).",
            "  - If an attribute is not universally available, either:",
            "      - Implement conditional logic on the integration side (e.g., `hasattr(self.device, 'system_mode')`) and handle the missing capability gracefully (fallback mode, raise a clear Home Assistant friendly error, or disable the feature for that device), or",
            "      - Extend or wrap the client library to provide a unified interface.",
            "Step 4: Add and update unit tests.",
            "  - Create tests that verify new methods and properties behave as expected for each device type you support:",
            "      - After `set_hvac_mode('cool')`, ensure the entity's `operation` property returns `'cool'` and the device client's `system_mode` is `'cool'`.",
            "      - Repeat for other modes like `'heat'`.",
            "  - If devices differ in capability, include tests for both capable and incapable variants, asserting correct behavior (or graceful failure) in each case.",
            "Step 5: Add type hints and keep the API explicit.",
            "  - Annotate new integration methods and properties to clarify expected types (e.g., `def operation(self) -> str`, `def set_hvac_mode(self, hvac_mode: str) -> None`).",
            "  - This improves static analysis and makes it harder to misuse the API in future changes.",
            "Step 6: Run the full test suite and test in a representative environment.",
            "  - Run `tox` or the project’s standard test command to ensure all tests (including new ones) pass.",
            "  - If possible, test with actual devices or realistic mocks for different regions/models to catch issues like `AttributeError` arising from missing backend attributes.",
            "Step 7: If a regression appears (e.g., AttributeError on some devices), diagnose and patch.",
            "  - Inspect the stack trace to identify which entity property or method is accessing a missing attribute (e.g., `device.system_mode`).",
            "  - Confirm through code or documentation whether the backend client truly lacks that attribute for the failing device type.",
            "  - Implement defensive coding (capability checks, default values, or alternate code paths) so that unsupported devices do not cause the entire platform to fail to load.",
            "  - Add regression tests that mimic the failing scenario and verify the integration now behaves correctly (either supports the feature or degrades gracefully)."
        ]
    }
}
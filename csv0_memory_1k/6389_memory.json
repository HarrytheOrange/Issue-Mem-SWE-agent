{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant's Discord notification service where using discord.Client.login() and sending messages immediately caused connection / readiness issues. The component was updated to use discord.Client.start() with an on_ready event handler to send messages after the bot is ready, then cleanly logout and close the connection. A pylint unused-variable warning for the dynamically registered on_ready callback is suppressed.",
        "keywords": [
            "discord notification",
            "homeassistant.components.notify.discord",
            "discord.py",
            "Client.start vs login",
            "on_ready event",
            "asyncio coroutine",
            "connection lifecycle",
            "logout and close",
            "pylint unused-variable",
            "Discord connect fix",
            "issue #5688"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident (Home Assistant PR fixing issue #5688), the Discord notification platform had problems connecting/sending messages using the Discord API. The original implementation created a discord.Client and called discord_bot.login(self.token), then immediately iterated over the target channels and called send_message(), followed by logout() and close(). With newer discord.py behavior, this pattern was unreliable because it did not respect the client's event-driven lifecycle or wait for the bot to be ready before sending messages.\n\nThe fix rewired the notification flow to use discord.Client.start(self.token) instead of login(), and to send messages inside an on_ready event handler. In async_send_message(), a discord.Client is initialized with Home Assistant's event loop. A coroutine on_ready() is defined and decorated with @discord_bot.event, so discord.py automatically invokes it when the client is fully connected and ready. Inside on_ready(), the code loops through kwargs[ATTR_TARGET], constructs a discord.Object for each channel ID, sends the message to each channel using send_message(), and then calls logout() and close() to terminate the session cleanly. Because the on_ready function is only referenced via the event decorator and never called directly, pylint reported it as an unused variable; this was resolved by adding an inline disable comment: `# pylint: disable=unused-variable` on the on_ready definition. No configuration changes were needed for users; this was an internal implementation fix to restore reliable Discord notifications.",
        "semantic_memory": "This fix illustrates several general principles for integrating with event-driven async libraries like discord.py:\n\n1. **Respect the library's connection lifecycle.** Many async clients (including discord.py) distinguish between low-level login/connect calls and higher-level `start()` or `run()` methods that manage the lifecycle and event loop. Calling `login()` and immediately attempting to use the client can fail or behave inconsistently if the connection isn't fully established. Using the recommended `start()` API and reacting to readiness events (such as `on_ready`) is more robust.\n\n2. **Use event callbacks for \"ready\" state before performing operations.** For services that require a ready or authenticated state before sending messages or performing actions, it's better to hook into lifecycle events (e.g., `on_ready`, `on_connect`) than to assume readiness right after constructing the client. This pattern applies broadly to web socket clients, chat bots, and other async SDKs.\n\n3. **Ensure clean shutdown of async clients.** Properly logging out and closing connections (`logout()` then `close()`) avoids resource leaks, hanging connections, or undefined behavior on subsequent uses. Even if an operation appears to complete successfully without an explicit close, closing explicitly is a good practice for long-running hosts like Home Assistant.\n\n4. **Linter awareness for dynamically used callbacks.** Static analyzers like pylint or flake8 may mark event handler functions as unused if they're only referenced via decorators or registration functions. In such cases, it's acceptable to suppress the specific warning with a targeted disable comment, documenting why the function appears unused but is in fact required by the framework.\n\n5. **Async integration with a host event loop.** When embedding a third-party async client into a larger system (e.g., Home Assistant), it's important to pass and reuse the host's event loop rather than creating a new one, to keep resource usage predictable and avoid competing loops.\n\nThese practices apply beyond Discord and Home Assistant to any async, event-driven integrations in Python.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Confirm the symptoms and context\n- Observe that messages are not being sent, connections fail, or behavior is intermittent when using an async client library (e.g., discord.py) in a host application.\n- Check logs for connection, login, or readiness-related errors, or for exceptions raised during send operations.",
            "Step 2: Review the integration code and library lifecycle\n- Inspect how the client is created and used: are you calling low-level `login()`/`connect()` and then immediately performing operations?\n- Check whether the library offers higher-level `start()` or `run()` methods and event hooks like `on_ready`, `on_connect`, or similar.\n- Verify that the client is using the correct event loop (e.g., passing the host's loop rather than creating a new one).",
            "Step 3: Consult the library's documentation and API reference\n- Read the docs for the connection methods: understand the differences between `login()`, `start()`, `run()`, `logout()`, and `close()`.\n- Look for recommended patterns for one-shot operations (e.g., connect, send one message, disconnect) versus long-lived bots.",
            "Step 4: Refactor to use event-driven readiness\n- Replace direct `login()` + immediate operations with `start()` (or the recommended lifecycle method).\n- Define a readiness handler, such as:\n  - `@client.event`\n  - `@asyncio.coroutine`\n  - `def on_ready(): ...`\n- Inside the handler, perform the operations that require a ready connection (e.g., sending notifications to target channels or users).",
            "Step 5: Implement clean shutdown\n- After the operations in the readiness handler complete, call the appropriate shutdown methods:\n  - `yield from client.logout()` to log out.\n  - `yield from client.close()` if the library distinguishes between logging out and closing the underlying connection.\n- Ensure that `start()` is awaited so that the coroutine completes after the client shuts down.",
            "Step 6: Handle linter warnings for dynamically used callbacks\n- If the readiness handler (e.g., `on_ready`) is reported as an unused variable, confirm that it is indeed required by the event framework and not meant to be called directly.\n- Add a targeted inline suppression, with a comment, e.g.:\n  - `def on_ready():  # pylint: disable=unused-variable`\n- Keep the suppression as narrow as possible and update the docstring to clarify the function's purpose.",
            "Step 7: Test the integration end-to-end\n- Run the host application's test suite (e.g., `tox` for Home Assistant).\n- Manually trigger the notification or operation that uses the async client and confirm that:\n  - The client connects and becomes ready.\n  - The message is successfully sent to the intended targets.\n  - The client logs out and closes without leaving hanging connections.\n- Check logs to ensure there are no uncaught exceptions.",
            "Step 8: Final cleanup and documentation\n- Remove any temporary debug logging.\n- Ensure imports are still inside functions if required by the host project's conventions.\n- Document any non-obvious patterns (like the need for `on_ready` and the linter suppression) in comments, so future maintainers understand why the structure is necessary."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant CityBikes integration implemented as an async component. It queries the CityBikes API to auto-detect the closest bike-sharing network by latitude/longitude, validates responses with voluptuous schemas, periodically fetches station data using aiohttp and async_timeout, dynamically creates non-polled station entities, and includes custom retry logic when network autodetection fails (using EVENT_TIME_CHANGED listeners instead of standard time helpers).",
        "keywords": [
            "Home Assistant",
            "citybikes",
            "async component",
            "aiohttp",
            "async_timeout",
            "voluptuous schema",
            "location-based network detection",
            "distance calculation",
            "EVENT_TIME_CHANGED",
            "time-based retry",
            "external API integration",
            "dynamic entity creation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request adds a new asynchronous CityBikes component to Home Assistant, replacing an earlier platform-style implementation.\n\nThe goal was to integrate the CityBikes public API so that Home Assistant can expose bike-sharing station data (free bikes, empty slots, etc.) as entities and support automations (e.g., recommend the best station when leaving home).\n\nImplementation details:\n- A new module `homeassistant/components/citybikes.py` was created.\n- Configuration is defined under the `citybikes:` domain as a list of location configs. Each location config can specify:\n  - `network`: explicit CityBikes network ID, or leave empty to auto-detect.\n  - `latitude` / `longitude`: optional; defaults to the Home Assistant instance location.\n  - Either `radius` (monitor all stations within radius) or `stations` (explicit list of station IDs / UIDs). The config schema enforces that at least one of these is present and that they are mutually exclusive.\n- The component uses aiohttp and async_timeout to call the CityBikes API asynchronously:\n  - `DEFAULT_ENDPOINT` = `https://api.citybik.es/{uri}`.\n  - `NETWORKS_URI` (`v2/networks`) returns a list of networks; the code auto-selects the nearest network using `homeassistant.util.location.distance`.\n  - `STATIONS_URI` (`v2/networks/{uid}?fields=network.stations`) returns station data for a given network.\n- Voluptuous schemas were defined to validate the JSON responses:\n  - `NETWORK_SCHEMA` and `NETWORKS_RESPONSE_SCHEMA` validate id, name, and location (using constants like `ATTR_LOCATION`, `ATTR_LATITUDE`, `ATTR_LONGITUDE`).\n  - `STATION_SCHEMA` and `STATIONS_RESPONSE_SCHEMA` validate per-station fields such as `free_bikes`, `empty_slots`, `latitude`, `longitude`, `id`, `name`, `timestamp`, and optional `extra.uid`.\n  - Extra fields are removed (using `extra=vol.REMOVE_EXTRA`) to keep only the needed keys.\n- A helper coroutine `_get_closest_network_id(hass, latitude, longitude)` fetches all networks, validates the response, and computes the nearest network by distance. It handles timeout, network errors, non-JSON responses, and schema validation errors with clear log messages.\n\nRuntime structure:\n- `async_setup(hass, config)` iterates over each `citybikes` config entry:\n  - It defines an inner coroutine `async_setup_single_network(config)` that resolves the network ID (via config or auto-detection) and sets up monitoring for areas or stations.\n  - If auto-detection fails (e.g., network error or bad response), it schedules a retry using a custom `EVENT_TIME_CHANGED` listener that will re-call `async_setup_single_network(config)` after `SCAN_INTERVAL` (5 minutes). This custom logic is needed because the standard `async_track_point_in_utc_time` helper only passes `now` to callbacks, but here the original `config` dict must be passed.\n  - Once a network ID is determined, a `CityBikesNetwork` instance is created (if not already present) and an immediate update is triggered (`network.async_update(dt.utcnow())`). Multiple configs can share the same network instance while monitoring different areas/stations.\n  - For each config, either `start_monitoring_stations(*stations)` or `start_monitoring_area(latitude, longitude, radius)` is called on the network object.\n\n`CityBikesNetwork`:\n- This is not an Entity; it is a plain class that manages periodic fetching and creates station entities as needed.\n- Attributes:\n  - `_network_id` (CityBikes network ID)\n  - `_stations_data` (raw station list from API)\n  - `_stations` (dict mapping station IDs to `CityBikesStation` instances)\n  - `_monitored_areas` (set of `(lat, lon, radius)` tuples)\n  - `_monitored_stations` (set of station IDs/UIDs to monitor explicitly)\n- In `__init__`, it registers `async_track_time_interval(self.hass, self.async_update, SCAN_INTERVAL)` so `async_update(now)` is called every 5 minutes.\n- `_fetch_stations` makes the network-specific stations API call, validates the JSON response via the schemas, and populates `_stations_data`. It logs errors with proper `%s` formatting instead of string `.format()`.\n- `async_update(now)`:\n  - Calls `_fetch_stations()`.\n  - For each station in `_stations_data`:\n    - For each monitored area `(lat, lon, radius)`, it computes the distance to the station and, if less than the radius, ensures a station entity exists by calling `_add_station_entity(station)`.\n    - It also checks whether the station should be monitored by ID or by `extra.uid` being in `_monitored_stations`, and similarly calls `_add_station_entity(station)`.\n    - If a station entity already exists in `_stations`, it calls its `async_update_data(station)` coroutine to refresh attributes and state.\n  - `_add_station_entity(station)` uses a deterministic entity_id: `CityBikesStation.make_entity_id(self._network_id, station[ATTR_ID])`, which slugifies the network ID (to handle dashes, etc.) and combines it with the station ID. If `hass.states` does not already contain that entity ID, it instantiates a `CityBikesStation` and stores it in `_stations`.\n- `start_monitoring_area` and `start_monitoring_stations` both update internal sets and then trigger an immediate `async_update(dt.utcnow())` via `hass.async_add_job`, so new monitoring configurations take effect immediately rather than waiting for the next interval.\n\n`CityBikesStation` (Entity):\n- Represents a single bike-sharing station.\n- Static method `make_entity_id(network_id, station_id)` returns an entity ID of the form `citybikes.<slugified_network_id>_<station_id>`.\n- The constructor stores `hass`, `_network_id`, and `_station_data`.\n- Entity properties:\n  - `should_poll = False` – station entities are not polled directly; they receive updates from their parent `CityBikesNetwork`.\n  - `name` – the station name from `_station_data[ATTR_NAME]`.\n  - `entity_id` – returned by `make_entity_id`.\n  - `state` – the current number of free bikes (`_station_data.get(ATTR_FREE_BIKES)`).\n  - `device_state_attributes` – merges a CityBikes attribution string with the raw station data dict.\n  - `unit_of_measurement` – fixed as `'bikes'`.\n  - `icon` – `'mdi:bike'`.\n- `async_update_data(station_data)` updates the stored `_station_data` and calls `async_update_ha_state()` to push changes to Home Assistant.\n\nAdditional changes:\n- `SCAN_INTERVAL` was set to 5 minutes to avoid hammering the CityBikes API.\n- The component was added to `.coveragerc` to be omitted from coverage calculations.\n- Several style and lint fixes were applied over multiple commits: import ordering, constant usage (`ATTR_*`), using `extra=vol.REMOVE_EXTRA` in schemas, logging parameterization with `%s`, and minor refactors for clarity.\n\nOutcome: Home Assistant now has an asynchronous CityBikes component that can auto-detect the nearest bike-sharing network, monitor stations either within a radius or by explicit ID, and expose each station as an entity with real-time bike availability. The implementation demonstrates robust async HTTP usage, schema validation of external APIs, dynamic entity creation, and resilient setup with retry logic when network detection fails.",
        "semantic_memory": "Generalizable insights from this implementation:\n\n1. **Asynchronous external API integrations in Home Assistant**\n   - Use `aiohttp` plus `async_timeout` for non-blocking HTTP requests in integrations.\n   - Always retrieve the shared session via `async_get_clientsession(hass)` rather than creating your own, to leverage connection pooling and consistent configuration.\n   - Guard external calls with timeouts and catch both `asyncio.TimeoutError` and `aiohttp.ClientError` so that failures fail fast and are logged cleanly.\n\n2. **Schema validation for external JSON APIs**\n   - Before using data from a third-party API, run it through a `voluptuous` schema.\n     - Define small, composable schemas for individual entities (e.g., `STATION_SCHEMA`, `NETWORK_SCHEMA`).\n     - Then wrap them in response schemas (e.g., `STATIONS_RESPONSE_SCHEMA`, `NETWORKS_RESPONSE_SCHEMA`).\n   - Use `extra=vol.REMOVE_EXTRA` for API responses to ignore fields you don't care about but still enforce the fields you depend on.\n   - Catch `vol.Invalid` exceptions and log them explicitly; treat unexpected JSON as a real error rather than silently ignoring it.\n\n3. **Location-based auto-detection and filtering**\n   - To auto-select a resource (like a network) based on coordinates, retrieve the full list, compute a distance metric (e.g., via `homeassistant.util.location.distance`), and choose the closest.\n   - To filter entities by geographic radius, keep a set of `(lat, lon, radius)` tuples and, during updates, compute distances from each candidate to all monitored areas.\n   - This pattern lets you add new monitored areas on the fly without reconfiguring the underlying source.\n\n4. **Decoupling data managers from entities**\n   - Using a plain class (`CityBikesNetwork`) as the data manager and separate Entity subclasses (`CityBikesStation`) for each entity provides clear separation of concerns:\n     - The manager handles fetching and distributing data and scheduling periodic updates.\n     - The entities simply present data and push state changes to the platform.\n   - This pattern is generally useful in HA for integrations that represent many entities from a single upstream resource.\n\n5. **Dynamic entity creation based on runtime data**\n   - Entities can be created lazily when new data arrives that matches monitoring criteria (e.g., a station falls within a configured radius or matches a requested ID).\n   - A deterministic `make_entity_id()` helps ensure that the same upstream resource always maps to the same entity_id, even across restarts.\n   - Slugify user- or API-provided identifiers (such as network IDs) to ensure entity IDs are valid and stable.\n\n6. **Non-polled entities with centralized updates**\n   - Entities that represent data from a single API call can set `should_poll = False` and rely on the shared manager to push updates.\n   - In these cases, the manager calls an entity method like `async_update_data()` that updates internal state and calls `async_update_ha_state()`.\n   - This reduces redundant API calls, as the data is fetched once per network rather than per entity.\n\n7. **Retry logic when initial setup depends on external services**\n   - Initial configuration may need to do a network-dependent step (like auto-detecting a network). If that fails, schedule a retry rather than failing permanently.\n   - If your retry callback must receive arguments other than `now`, the standard time helpers (`async_track_point_in_utc_time`) may not work directly because they only pass the current time.\n   - A robust pattern is to implement a small wrapper around `EVENT_TIME_CHANGED` that captures your required closure data (`config`, etc.), calculates a `later_time`, and in the event listener, checks `now` and a `run` sentinel attribute to ensure it executes once at/after the desired time.\n\n8. **Logging and lint best practices**\n   - Use parameterized logging (`_LOGGER.error(\"message %s\", err)`) instead of string `.format()` to play well with logging systems and avoid needless string formatting when log level is higher.\n   - Group imports logically (std lib, third party, then project-specific) and keep code style consistent for maintainability.\n\nOverall, this PR demonstrates a clean pattern for building async Home Assistant integrations around a third-party REST API: validate everything with schemas, centralize data fetching, create entities dynamically, and design resilient setup with retry mechanisms.",
        "procedural_memory": [
            "How to design an async Home Assistant integration with a third-party REST API, including auto-detection by location, dynamic entity creation, and robust retry logic.",
            "Step 1: Define configuration schema\n- Decide the configuration model for your integration (domain key, list vs single entry, etc.).\n- Use `homeassistant.helpers.config_validation` (aliased as `cv`) and `voluptuous` to enforce required and optional keys.\n- Use helpers like `cv.has_at_least_one_key` and `vol.Exclusive` / `vol.Inclusive` to ensure mutually exclusive or jointly required options.\n- Example: require either a `radius` or `stations` list, but not both, and allow optional `latitude`/`longitude` with defaults to `hass.config.latitude` / `hass.config.longitude`.",
            "Step 2: Model and validate API responses\n- Read the external API documentation and identify the fields you rely on.\n- Define small `vol.Schema` objects for individual entities:\n  - For example, a `STATION_SCHEMA` with required keys like `free_bikes`, `empty_slots`, `latitude`, `longitude`, `id`, `name`, `timestamp`, and optional `extra.uid`.\n- Wrap those in top-level response schemas (e.g., `STATIONS_RESPONSE_SCHEMA` with `network` -> `stations` list).\n- Use `extra=vol.REMOVE_EXTRA` so that unexpected extra fields are stripped but do not cause validation errors.\n- In your code, always run API responses through these schemas before using the data. Catch `vol.Invalid` and log helpful error messages.",
            "Step 3: Implement asynchronous HTTP calls\n- Use `async_get_clientsession(hass)` to obtain the shared aiohttp session.\n- Wrap HTTP requests in `async_timeout.timeout` to bound the time spent waiting for the API:\n  - `with async_timeout.timeout(5, loop=hass.loop): req = await session.get(url)`\n- Call `await req.json()` to parse JSON responses.\n- Surround calls with `try/except` blocks to catch `asyncio.TimeoutError`, `aiohttp.ClientError`, `ValueError` (for JSON decoding), and `vol.Invalid` (schema validation failures).\n- Log distinct messages for each error type so that diagnosing issues in production is clear.",
            "Step 4: Implement location-based selection logic (if needed)\n- If your integration needs to choose among many API resources based on a location (e.g., nearest network):\n  - Fetch the full list of resources.\n  - Validate with your response schema.\n  - For each candidate, compute distance using `homeassistant.util.location.distance(lat1, lon1, lat2, lon2)`.\n  - Track the minimal distance and associated ID.\n- Return the chosen ID or `None` on failure, letting the caller decide how to handle retries.",
            "Step 5: Design a data manager class separate from entities\n- Create a non-Entity class (e.g., `MyIntegrationNetwork`) that:\n  - Holds identifiers and configuration state.\n  - Owns the list/dict of raw data items and associated Entity instances.\n  - Contains all logic for fetching data and distributing it to entities.\n- In its constructor, register a recurring update via `async_track_time_interval(hass, self.async_update, SCAN_INTERVAL)`.\n- Implement `_fetch_data()` inside the manager to hit the API and update internal data structures.\n- Implement `async_update(now)` to call `_fetch_data()`, then:\n  - For each item, decide whether it should be represented as an entity (e.g., based on area, filters, or config).\n  - Create or update entities accordingly.",
            "Step 6: Implement dynamic entity creation\n- Decide on a deterministic naming scheme for entity IDs to ensure the same upstream resource always maps to the same entity ID. Consider slugifying any user/API-provided parts using `homeassistant.util.slugify`.\n- Implement a static helper like `make_entity_id(network_id, item_id)` to encapsulate this logic.\n- In your manager's update method:\n  - Construct the expected entity ID.\n  - Check `if not hass.states.get(entity_id)` before creating a new entity object to avoid duplicates.\n  - Store entities in a dict keyed by the upstream ID (`self._items[item_id] = entity`).\n- In each Entity's method that receives new data (e.g., `async_update_data()`), update its internal data and call `await self.async_update_ha_state()`.",
            "Step 7: Create non-polled entities and central updates\n- For entities whose data is always sourced from a shared manager and not from individual API calls:\n  - Set `should_poll = False` in the Entity subclass.\n  - Omit `async_update()` in the entity; instead, define a method like `async_update_data(self, data)` that the manager will call whenever it has fresh data.\n  - Inside `async_update_data`, update internal attributes and then `await self.async_update_ha_state()`.\n- This approach prevents redundant external calls and centralizes error handling and retries in the manager.",
            "Step 8: Add immediate update triggers when configuration changes\n- When users add new monitored areas or filters at runtime (or when the integration reads multiple locations during setup), you often want changes to apply immediately.\n- After adding new areas or IDs to your manager's internal sets (e.g., `_monitored_areas` or `_monitored_items`), schedule an immediate update:\n  - `hass.async_add_job(manager.async_update(dt.utcnow()))`\n- This ensures that new entities or state changes appear without having to wait for the next periodic interval.",
            "Step 9: Implement robust retry logic for setup-time failures\n- If part of your setup (e.g., auto-detecting a network ID) depends on a remote API and can fail temporarily, do not fail setup permanently; instead, schedule a retry:\n  - If you only need `now`, you can use `async_track_point_in_utc_time(hass, callback, when)`.\n  - If your callback also needs the original config or other arguments, you can:\n    - Implement a custom listener for `EVENT_TIME_CHANGED`.\n    - Capture the desired `config` in the closure.\n    - Compute a `later_time = dt.utcnow() + SCAN_INTERVAL`.\n    - In the listener, check `if now < later_time or hasattr(listener, 'run'):` to ensure execution only once after the desired time.\n    - On first execution, set `listener.run = True`, unsubscribe the listener, and then call your setup coroutine with the original `config` via `hass.async_run_job(setup_coroutine, config)`.\n- This pattern allows you to re-attempt network-dependent setup steps without blocking or silently failing.",
            "Step 10: Ensure logging and style quality\n- Use parameterized logging (`_LOGGER.error(\"Received unexpected JSON: %s\", err)`) instead of string interpolation. This avoids unnecessary formatting when logs are disabled and keeps log messages consistent.\n- Maintain clear import ordering: standard library, third-party packages, then Home Assistant imports.\n- Use Home Assistant constants (e.g., `ATTR_LATITUDE`, `ATTR_LONGITUDE`, `ATTR_LOCATION`) instead of raw strings to be consistent with the rest of the codebase.\n- Add your new component to `.coveragerc` if necessary (e.g., when it is hard to test or not yet tested) so that coverage tools don’t fail your build prematurely."
        ]
    }
}
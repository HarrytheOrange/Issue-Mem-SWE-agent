{
    "search_index": {
        "description_for_embedding": "Fixes Qt menu teardown in napari to prevent widget leaks during tests by replacing reliance on closeEvent with an explicit _destroy method that clears QAction data, recursively destroys child menus, and removes menus from a global instance list.",
        "keywords": [
            "Qt",
            "QMenu",
            "QAction",
            "widget leak",
            "test leak",
            "pytest-qt",
            "teardown",
            "closeEvent",
            "explicit destroy",
            "napari",
            "_INSTANCES list",
            "segfault",
            "menu teardown"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, napari had a bug where Qt menus were not being properly torn down, causing widget leaks in tests and sometimes segfaults (especially visible on Windows CI). The menu implementation tracked instances in a class-level _INSTANCES list and relied on QMenu.close() and an overridden closeEvent() to perform cleanup: closeEvent would clear each QAction's data (which held references to application objects) and then remove the menu from _INSTANCES. In practice, during test teardown, some menus were already considered completed or closed by Qt, and calling close() could cause asynchronous close events or double-cleanup issues, leading to leaked widgets or crashes.\n\nThe fix introduces an explicit _destroy() method on the menu class in napari/_qt/menus/_util.py. This method iterates over all actions, sets each QAction's data to None to break references, attempts to call ax._destroy() on actions that themselves have a destroy method (supporting recursive cleanup), and then removes the menu instance from _INSTANCES if present. The previous closeEvent override is removed. In the main window teardown (napari/_qt/qt_main_window.py::_teardown), instead of calling menu.close() for each menu in file_menu._INSTANCES, the code now calls menu._destroy(), catching RuntimeError as before. This shifts cleanup from the Qt event system into a deterministic, explicit teardown path, preventing lingering references and widget leaks during tests.",
        "semantic_memory": "This fix illustrates a general pattern when working with GUI frameworks (like Qt) and test environments: relying solely on framework lifecycle events (e.g., closeEvent) for cleanup can be fragile, especially when tests control object lifetimes in non-standard ways. If teardown relies on the GUI event loop to fire certain events, those events may be delayed, skipped, or fired after the test has technically completed, leading to resource leaks or crashes.\n\nKey concepts:\n- GUI object cleanup should be idempotent and explicit. An explicit destroy/cleanup method that can be safely called at teardown is often more reliable than relying on window close events.\n- Global or class-level registries (such as a _INSTANCES list) need symmetrical, reliable removal logic. If removal is tied only to events that might not fire, references may be retained, preventing garbage collection.\n- QAction.data (or similar generic data slots) can hold strong references to Python objects (viewers, models, callbacks). If those are not cleared, objects can remain alive even after UI components are closed. Clearing these references in teardown is essential to avoid memory leaks.\n- Recursive cleanup: when menus contain actions or submenus that themselves manage resources, the cleanup should recurse (e.g., calling ax._destroy() if present) to ensure nested components are also released.\n- For test stability (especially in CI and on platforms like Windows), minimizing dependence on asynchronous GUI events during teardown reduces intermittent leaks and segfaults.\n\nThe broader best practice is to design GUI components with a clear, explicit destruction API (destroy/cleanup methods) that can be invoked deterministically from test harnesses or application shutdown paths, independent of the GUI's own close events.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Detect the symptom.\n- Look for tests that intermittently fail with widget-leak warnings (e.g., pytest-qt complaining about uncollected widgets) or platform-specific crashes (segfaults) at or after teardown.\n- On Qt-based projects, pay attention to menus, dialogs, and global registries of widgets that might outlive the test scope.",
            "Step 2: Identify persistent references.\n- Search for class-level or module-level registries (e.g., _INSTANCES, global lists, or caches) that hold references to GUI objects.\n- Inspect components like QAction.data, userData, or other fields that can hold arbitrary Python objects. These often hide strong references that prevent garbage collection.",
            "Step 3: Trace teardown behavior.\n- Examine the test teardown code and application shutdown paths (e.g., MainWindow._teardown, fixtures’ finalizers) to see what is called on GUI objects.\n- Check if cleanup relies on GUI lifecycle methods like close(), deleteLater(), or framework events like closeEvent or destroyed signals.\n- Verify whether those events are guaranteed to run before the test ends; in CI, they may be delayed or suppressed.",
            "Step 4: Reproduce and inspect leaks locally.\n- Run the specific failing tests with high verbosity and with pytest-qt’s leak detection enabled.\n- Use breakpoints or logging in closeEvent and teardown methods to confirm whether they are actually executed when tests finish.\n- On intermittent issues, run tests in a loop or under a stress mode (e.g., multiple repetitions) to trigger the leak reliably.",
            "Step 5: Introduce an explicit, idempotent destroy method.\n- On the leaking widget/menu class, add a method (e.g., _destroy or destroy) that:\n  - Clears all references that can keep objects alive (e.g., for each QAction in a menu, call ax.setData(None)).\n  - Disconnects signals and event listeners where necessary.\n  - Recursively calls child destroy methods if subcomponents support them (e.g., try: ax._destroy(); except AttributeError: pass).\n  - Removes the instance from any global/class-level registry only if it is present.\n- Ensure calling this method multiple times is safe (idempotent): guard removals with membership checks and handle missing attributes or already-destroyed children gracefully.",
            "Step 6: Refactor teardown to use the explicit destroy method.\n- Replace calls to close() or other lifecycle methods in teardown with the new explicit destroy method where appropriate.\n- Example: instead of iterating menus and calling menu.close() (which triggers closeEvent indirectly), iterate and call menu._destroy().\n- If you still need to show/close UI in normal runtime, keep close() for user interaction, but do not rely solely on closeEvent for critical cleanup needed by tests.",
            "Step 7: Remove fragile closeEvent-based cleanup (if safe).\n- If cleanup was previously implemented in closeEvent, move that logic into the explicit destroy method.\n- Optionally keep closeEvent minimal or default (super().closeEvent(event)) if the GUI still needs visual closure behavior, but not for memory management.\n- This decouples GUI behavior (window closing) from resource management (destroy).",
            "Step 8: Harden against double teardown and race conditions.\n- Wrap operations that may fail on already-destroyed objects in try/except blocks (e.g., RuntimeError, AttributeError) to avoid teardown-time crashes.\n- Check for membership before removing from global lists: if self in self._INSTANCES: self._INSTANCES.remove(self).",
            "Step 9: Re-run tests and monitor.\n- Run the full test suite, especially GUI and widget tests, on all targeted platforms (including Windows CI if relevant).\n- Confirm that widget-leak warnings disappear and that there are no new crashes.\n- Use coverage reports to ensure the destroy code is executed by tests (add or adjust tests if necessary).",
            "Step 10: Document the pattern.\n- Document in developer docs or code comments that resource cleanup for these components must go through the explicit destroy method, not just through close().\n- Encourage future contributors to follow the same pattern for new GUI components: maintain explicit, test-friendly teardown paths rather than relying solely on GUI events."
        ]
    }
}
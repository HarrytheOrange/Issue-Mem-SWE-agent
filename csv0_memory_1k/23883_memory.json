{
    "search_index": {
        "description_for_embedding": "Home Assistant template light was extended to support custom brightness ranges via brightness_min and brightness_max. This allows mapping the standard 0–255 UI brightness slider onto arbitrary backend ranges (including negative values) used by scripts or input_number entities. The implementation updates the template light schema, scales brightness values between the UI and backend, and adds tests for various min/max configurations.",
        "keywords": [
            "home-assistant",
            "template light",
            "template.lights",
            "brightness_min",
            "brightness_max",
            "custom brightness range",
            "value scaling",
            "input_number",
            "set_level",
            "configuration schema",
            "feature enhancement"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, a user wanted template lights in Home Assistant to work with custom brightness ranges rather than being hard‑wired to 0–255. Their specific use case involved driving a light from an input_number entity whose values ranged from -257 to 255, using a negative sentinel value to represent 'off'.\n\nTo support this, the template light platform was extended with two new configuration options under the `lights` configuration:\n- `brightness_min` (default 0, allowed to be negative)\n- `brightness_max` (default 255)\n\nThe schema was updated using voluptuous to validate these as integers with allowed negative ranges, while preserving the existing behaviour when not set.\n\nInside `LightTemplate`:\n- The constructor now accepts `brightness_min` and `brightness_max` and stores them as `_brightness_min` and `_brightness_max`.\n- It computes a brightness interval (number of discrete backend steps between `brightness_min` and `brightness_max`) and a scaling factor `_brightness_div = DEFAULT_BRIGHTNESS_MAX / brightness_interval` to map between Home Assistant’s 0–255 brightness and the custom range.\n\nWhen turning on the light (`async_turn_on`):\n- If there is no `level_template` and a brightness is provided, the code uses the 0–255 brightness from the service call, scales it into the configured custom range, and sets the internal `_brightness` to that custom value.\n- If a `set_level` script is configured, it is invoked with the scaled brightness (in the custom range), not the raw 0–255 value.\n\nWhen updating from a `level_template` (`async_update`):\n- The brightness value from the template is interpreted as the custom‑range brightness.\n- If it falls within `[brightness_min, brightness_max]`, it is scaled back into a 0–255 representation for the light’s internal brightness value; otherwise an error is logged and `_brightness` is set to None.\n\nSeveral tests were added to `tests/components/template/test_light.py`:\n- `test_brightness_max`: Only `brightness_max` set to 1000; turning on with brightness 255 results in the script receiving `brightness: '1000'` and the light entity’s brightness reflecting 1000.\n- `test_brightness_min`: Only `brightness_min` set to 15; turning on with brightness 1 sends `brightness: '15'` and the state brightness is 15.\n- `test_brightness_min_max`: `brightness_min: 100`, `brightness_max: 355`; a mid‑range 0–255 brightness is mapped appropriately into that interval.\n- `test_brightness_min_max_negative`: `brightness_min: -257`, `brightness_max: 255`; verifies that the mapping works even when the minimum is negative, as in the user’s input_number example.\n\nThis change allows template lights to integrate cleanly with non‑standard brightness ranges, especially where a sentinel value is used to represent 'off', without breaking the existing 0–255 behaviour for users who do not configure custom bounds.",
        "semantic_memory": "This change illustrates a general pattern for integrating systems that use different numeric ranges for the same conceptual value (here, light brightness):\n\n1. **Expose a canonical range at the platform boundary**: Home Assistant’s light entity model standardizes brightness to 0–255 to keep the UI and automations consistent.\n2. **Allow configurable mapping to backend ranges**: Individual integrations can add configuration options (e.g., `brightness_min` and `brightness_max`) to describe how their backend values map to the canonical range.\n3. **Use a scaling factor for bidirectional mapping**: A simple linear transformation can convert values in the canonical range to the backend range and vice versa: \n   - backend_value ≈ backend_min + (frontend_value / 255) * (backend_max−backend_min)\n   - frontend_value ≈ (backend_value−backend_min) * 255 / (backend_max−backend_min)\n4. **Support non‑standard and negative ranges**: The mapping logic should not assume that the backend minimum is zero or that values are non‑negative. Validating only that values are integers (and ideally that max >= min) allows support for sentinel values and domain‑specific conventions.\n5. **Keep scripts and templates in backend units**: When a platform calls user‑defined scripts or evaluates templates, it should pass values in the units/ranges that those scripts expect (e.g., pass the scaled backend brightness, not the UI 0–255 value), while still allowing the rest of the system to see a normalized representation.\n6. **Extend configuration schemas carefully**: Adding new config keys requires updating voluptuous schemas and providing sensible defaults so existing configurations continue to behave the same way.\n7. **Add targeted tests for configuration‑driven behaviour**: Whenever behaviour depends on user‑supplied configuration (like min/max brightness), tests should cover edge cases: only max set, only min set, both set, and negative values.\n\nThese ideas apply broadly to any integration where an internal device scale (e.g., 0–1000, -10–+10, or a sentinel off value) needs to be adapted to a standardized external API or UI scale.",
        "procedural_memory": [
            "When you need to support custom numeric ranges in an integration while presenting a standardized range to the rest of the system, use a configurable, bidirectional mapping and test it thoroughly.",
            "Step 1: Identify the canonical range and the backend range",
            "Determine the canonical range your platform expects (e.g., 0–255 for brightness, 0–100 for percentages) and the range used by the underlying device or abstraction (e.g., -257 to 255, 0–1000). Clarify whether bounds are inclusive and whether negative values or sentinel values (like a special 'off' code) are required.",
            "Step 2: Extend the configuration schema",
            "Add configuration keys to describe the backend range (e.g., `brightness_min` and `brightness_max`). Use a schema validation library (like voluptuous) to coerce values to integers and set reasonable bounds. Where appropriate, add a validation rule that max >= min to prevent invalid configurations.",
            "Step 3: Store the configured bounds in the entity",
            "Update the entity’s constructor to accept and store the new min/max parameters. Compute the number of discrete backend steps (the interval) and a scaling factor that maps the canonical range to the backend range. For a linear mapping, use something like `scale = CANONICAL_MAX / interval`.",
            "Step 4: Map from canonical values to backend values on commands",
            "In methods that handle incoming commands (e.g., `async_turn_on` with `ATTR_BRIGHTNESS`):\n- Read the canonical value (0–255).\n- Convert it to the backend range using the scaling factor and min offset.\n- Use the converted value when invoking user scripts (`set_level`) or device APIs, so that those consumers receive the values they expect.",
            "Step 5: Map from backend values to canonical values on state updates",
            "In update methods (e.g., `async_update`), where you read brightness from a template or device:\n- Interpret the value as being in the backend range.\n- Validate that it falls within `[brightness_min, brightness_max]`; if not, log an error and handle it defensively (e.g., set brightness to None).\n- Convert the valid backend value to the canonical 0–255 range for the entity’s internal brightness field so the UI and automations see normalized values.",
            "Step 6: Decide what the entity attributes should expose",
            "Decide whether the entity’s `brightness` attribute should reflect the canonical value or the backend value. Be consistent between the conversion logic and tests. If using the canonical 0–255 value, ensure that all paths (optimistic updates and template‑driven updates) apply the same mapping.",
            "Step 7: Add tests for the new configuration options",
            "Create tests that configure the entity with different combinations of min and max values:\n- Default (no custom min/max) to ensure backward compatibility.\n- Custom max only.\n- Custom min only.\n- Both min and max set.\n- Negative min values and ranges designed to include sentinel values.\nFor each case, simulate a `turn_on` with specific brightness values and assert both the outgoing script/device brightness and the resulting entity state.",
            "Step 8: Validate behaviour with real configurations",
            "Create small example configurations mirroring user scenarios (e.g., using an `input_number` that spans -257 to 255). Ensure that the UI slider behaves as expected, that the correct backend brightness is sent to scripts, and that the state templates correctly reflect the device’s brightness.",
            "Step 9: Log and handle out-of-range values robustly",
            "Whenever an incoming brightness (from a template or device) falls outside the configured bounds, log a clear error message including the expected range. Set the brightness attribute to a safe value (often None) to avoid propagating invalid state."
        ]
    }
}
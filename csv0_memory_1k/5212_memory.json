{
    "search_index": {
        "description_for_embedding": "Home Assistant imap_email_content sensor failed to correctly handle HTML emails that used base64 Content-Transfer-Encoding (e.g., SMS-to-email from Sprint). The fix adds base64 decoding for HTML parts, skips empty MIME parts, and safely handles missing Subject headers.",
        "keywords": [
            "home-assistant",
            "sensor.imap_email_content",
            "IMAP email sensor",
            "base64 encoded email",
            "Content-Transfer-Encoding base64",
            "HTML email body decoding",
            "email parsing",
            "MIME multipart",
            "missing Subject header",
            "NoneType header decode error"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant `sensor.imap_email_content` component had trouble parsing certain emails, specifically HTML-type emails whose body was base64 encoded. A concrete case was SMS-to-email messages from Sprint, which arrived as HTML parts encoded with `Content-Transfer-Encoding: base64`. The sensor was simply calling `part.get_payload()` and treating it as decoded text, so it would expose the raw base64-encoded string instead of the decoded HTML/text. Additionally, there were edge cases around empty MIME parts and messages without a `Subject` header that could cause errors or unexpected behavior.\n\nThe fix involved three key changes in `homeassistant/components/sensor/imap_email_content.py`:\n1. Importing the `base64` module.\n2. In `get_msg_subject`, adding a guard for missing `Subject` headers: if `email_message['Subject']` is falsy, return an empty string instead of passing `None` into `email.header.decode_header`, which could cause exceptions.\n3. In `get_msg_text`, improving robustness of the MIME traversal:\n   - Skip parts that have no payload (`if not part.get_payload(): continue`) to avoid operating on empty parts.\n   - For `text/html` parts, detect if `Content-Transfer-Encoding` is `base64`; if so, call `base64.decodestring(part.get_payload().encode('utf-8'))` to obtain the decoded HTML content, otherwise fall back to the raw `get_payload()` behavior as before.\n\nThese changes allowed the IMAP email content sensor to correctly display the decoded body of base64-encoded HTML emails and to handle missing subjects and empty MIME parts without errors. The PR ultimately went stale and was closed procedurally, but the technical approach illustrates how to add base64 support and harden email parsing logic.",
        "semantic_memory": "When parsing emails programmatically—especially MIME multipart emails—you cannot assume that payloads are already decoded or that all headers are present.\n\nGeneral lessons from this fix:\n1. **Respect Content-Transfer-Encoding**: Email parts may be encoded using base64, quoted-printable, or other transfer encodings. If you just call `get_payload()` without decoding based on the `Content-Transfer-Encoding` header, you may get encoded text instead of plain text. For HTML parts (`text/html`), this commonly manifests as unreadable base64 blocks in the UI. The correct approach is to inspect `part['Content-Transfer-Encoding']` and decode accordingly.\n2. **Guard against missing headers**: Not all email messages will have a `Subject` or other headers. Passing `None` into header-decoding utilities (like `email.header.decode_header`) can raise errors. Check for the presence of headers and define sensible defaults (e.g., empty string) when they are missing.\n3. **Skip empty MIME parts**: Multipart messages often contain container or boundary parts that have no meaningful payload. Iterating over `email_message.walk()` and blindly operating on every part can lead to `None` values or misleading content. Filtering out parts where `get_payload()` is falsy avoids unnecessary edge cases.\n4. **Prioritization of text types**: When extracting message text, it is common to prioritize `text/plain` over `text/html`, and have a fallback `text/*` handler. Only set each variant once (e.g., keep first occurrence) to avoid inconsistent content.\n5. **Robustness in integrations**: Integrations that ingest third-party data (IMAP, webhooks, etc.) must be defensive: validate headers, handle missing/empty fields, and correctly interpret encoding/transfer details, because upstream sources vary widely (telcos, email gateways, etc.).\n\nThese patterns apply broadly to any email-processing or MIME-parsing code: always inspect encoding metadata, handle absent metadata gracefully, and skip non-content parts.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the issue\n- Capture a raw email (including full headers) that the integration or parser is failing on. For IMAP-based systems, fetch the raw RFC822 message from the mailbox.\n- Observe how your application surfaces the content: is it showing base64 gibberish, failing with exceptions, or producing empty text?",
            "Step 2: Inspect the email structure and headers\n- Use Python's `email` module or an email client to inspect the message structure: print `email_message.as_string()` or iterate `email_message.walk()`.\n- For each part, note `Content-Type`, `Content-Transfer-Encoding`, and the result of `part.get_payload()`.\n- Check if the problem part is `text/plain`, `text/html`, or another `text/*` type.\n- Verify whether headers like `Subject` are present or missing.",
            "Step 3: Identify encoding and missing-field issues\n- If you see a long base64-like string in a text or HTML part, check if `Content-Transfer-Encoding` is `base64` or something else.\n- Confirm whether the parsing code is decoding the payload based on this header or just returning `get_payload()` directly.\n- Note any exceptions in logs, such as errors from `email.header.decode_header` when headers (e.g., `Subject`) are missing or `None`.",
            "Step 4: Harden header handling\n- Before decoding headers (e.g., `Subject`), add guards:\n  - Example: `if not email_message['Subject']: return ''`.\n  - Only pass non-empty header values into functions like `email.header.decode_header`.\n- Provide sensible defaults when headers are absent (empty string or `None`), and ensure the rest of the pipeline can handle that.",
            "Step 5: Properly decode MIME part payloads\n- In the part iteration loop, skip empty payloads:\n  - `payload = part.get_payload(); if not payload: continue`.\n- Inspect `Content-Type` to decide how to treat the content:\n  - For `text/plain`, store as the primary text if not already set.\n  - For `text/html`, before assigning, inspect `Content-Transfer-Encoding`:\n    - If `base64`, decode using `base64.b64decode` or `base64.decodestring` (for legacy code) after encoding to bytes if necessary.\n    - If encoded with a different scheme (e.g., quoted-printable), use the appropriate decoder (or let `email` module handle decoding via `get_payload(decode=True)`).\n  - For other `text/*` types, treat them as fallback text if neither plain nor HTML is available.",
            "Step 6: Integrate the fix into the codebase\n- Import any required modules (e.g., `import base64`).\n- Modify the email parsing function (e.g., `get_msg_text`) to:\n  - Skip parts with no payload.\n  - Handle `text/plain` and `text/html` as described, decoding when `Content-Transfer-Encoding` indicates base64.\n  - Preserve existing behavior for non-base64 parts.\n- Modify header parsing (e.g., `get_msg_subject`) to handle missing headers safely.",
            "Step 7: Add regression tests\n- Create test emails within the test suite that simulate the problematic cases:\n  - An HTML email whose body is base64 encoded (`Content-Type: text/html`, `Content-Transfer-Encoding: base64`).\n  - An email without a `Subject` header.\n  - An email with empty MIME parts.\n- Use the component’s parsing functions to process these test messages and assert that:\n  - The returned text/HTML is properly decoded (no raw base64).\n  - Missing subjects are handled without raising exceptions and give the expected default.\n  - Empty parts do not break the parsing logic.",
            "Step 8: Validate in real environment\n- Deploy the updated code to a test environment.\n- Send or fetch real messages from the problematic source (e.g., SMS-to-email gateway).\n- Confirm that the integration now displays the correct decoded content and does not error on missing headers or empty parts.",
            "Step 9: Generalize for future robustness\n- Consider centralizing MIME decoding logic (e.g., a helper that inspects `Content-Transfer-Encoding` and decodes accordingly).\n- When adding new email-related features, always treat headers and encodings as optional and variable, not guaranteed, and design parsing code defensively."
        ]
    }
}
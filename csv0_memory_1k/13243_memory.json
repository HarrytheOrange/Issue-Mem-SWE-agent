{
    "search_index": {
        "description_for_embedding": "Added support in Home Assistant for controlling Yeelight bulb power modes (including moonlight mode on Yeelight ceiling lamps) via a new 'mode' parameter on the generic light.turn_on service. The change wires a validated 'mode' attribute through the core light component into the Yeelight platform, which passes it as power_mode to the underlying yeelight library.",
        "keywords": [
            "Yeelight",
            "Home Assistant",
            "light.turn_on",
            "moonlight mode",
            "power mode",
            "PowerMode",
            "yeelight ceiling lamp",
            "component integration",
            "service schema",
            "voluptuous validation",
            "services.yaml",
            "platform-specific option"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, users wanted to control the Yeelight Ceiling Lamp's moonlight mode from Home Assistant. Initially, the only way to control Yeelight lights was via the generic light.turn_on service without any explicit control over the device's power mode. The Yeelight hardware and API support multiple power modes (Last, Normal, RGB, HSV, Color flow, Moonlight), but Home Assistant was not exposing this capability.\n\nThe discussion raised whether this should be modeled as a light \"effect\" or as a separate parameter. After reviewing the Yeelight inter-operation spec, it became clear that \"mode\" and \"effect\" are orthogonal concepts and can be combined. Instead of overloading effects, the developer implemented explicit mode support.\n\nThe fix introduced a new attribute ATTR_MODE in the core light component and in the light.turn_on schema. The schema validates 'mode' as an integer between 0 and 5. The turn_on/async_turn_on helper functions were extended to accept an optional 'mode' argument and include it in the service data if provided. In services.yaml, the light.turn_on service gained a documented 'mode' field describing valid values: 0 (Last), 1 (Normal), 2 (RGB), 3 (HSV), 4 (Color flow), 5 (Moonlight).\n\nOn the Yeelight side, the integration defined its own ATTR_MODE constant, read mode from kwargs in YeelightLight.turn_on, and converted it to yeelight.enums.PowerMode(mode), defaulting to 0 when not provided. The call to self._bulb.turn_on was updated from turn_on(duration=duration) to turn_on(duration=duration, power_mode=mode). Errors from the Yeelight library are still reported via the existing BulbException handling.\n\nAs a result, users can now call light.turn_on with {'mode': 5} on a Yeelight ceiling lamp entity to enable moonlight mode without additional frontend work. This change cleanly threads a platform-specific capability through the generic light interface while keeping it optional and validated.",
        "semantic_memory": "This case illustrates several general patterns for extending a generic service interface to support platform-specific features:\n\n1. **Propagating new parameters through a layered architecture**: When a platform (Yeelight) supports a capability not exposed by the generic interface (Home Assistant light platform), the correct approach is to:\n   - Introduce a new attribute/field at the generic layer (e.g., ATTR_MODE for light.turn_on).\n   - Define and validate it in the shared service schema (using voluptuous ranges, types, etc.).\n   - Update helper functions/wrappers (turn_on/async_turn_on) to accept and pass the parameter.\n   - Consume the parameter inside the specific integration and pass it to the underlying library or device API.\n\n2. **Separation of concerns between 'effects' and 'modes'**: It is tempting to overload an existing concept (like \"effect\") for new functionality (like power modes). However, effects and modes may be orthogonal – a device might support multiple power modes and visual effects simultaneously. The better design is to expose modes explicitly, preserving the semantic meaning of 'effect' for transient visual behaviors while using 'mode' for fundamental operating states.\n\n3. **Schema-driven API evolution**: In systems using declarative schemas (voluptuous in Home Assistant), adding new capabilities should be accompanied by:\n   - A well-defined schema entry with type coercion and bounds checking (e.g., mode as an int 0–5).\n   - Documentation in a services manifest (services.yaml) to make the new parameter discoverable and self-describing.\n   - Sensible defaults at the integration level when the parameter is omitted.\n\n4. **Mapping generic attributes to vendor-specific enums**: Vendor libraries often expose enums (yeelight.enums.PowerMode) instead of primitive types. A robust integration converts the generic parameter to the vendor enum at the boundary, allowing internal code to stay simple and avoiding propagation of vendor-specific types into the generic layers.\n\n5. **Backward compatibility and optional features**: Adding an optional parameter that defaults to prior behavior (mode=0, \"Last\" state) preserves existing automations and scripts. New behavior is only triggered when users explicitly supply the new field.\n\nOverall, this fix demonstrates a clean pattern for layering vendor-specific configurations onto a generic automation API without breaking existing behavior or muddling concepts like effects vs. modes.",
        "procedural_memory": [
            "When adding a new platform-specific capability (e.g., Yeelight power modes) to a generic service (e.g., light.turn_on), follow these steps:",
            "Step 1: Understand the device API and semantics",
            "- Review the vendor’s API/specification (e.g., Yeelight Inter-Operation Spec) to identify supported modes/options and how they interact with existing concepts like effects or color.",
            "- Determine whether the new capability is orthogonal to existing parameters (e.g., mode vs. effect). If so, treat it as a separate attribute rather than overloading an existing one.",
            "Step 2: Design the generic attribute and value domain",
            "- Choose an attribute name that is generic but meaningful (e.g., 'mode' for power mode).",
            "- Decide on the data type (int, string, enum) and valid range or set of values (e.g., integers 0–5, each mapped to a documented behavior).",
            "- Ensure that the default value corresponds to current behavior to maintain backward compatibility.",
            "Step 3: Extend the core service schema",
            "- In the core component (e.g., homeassistant/components/light/__init__.py), define a new constant (ATTR_MODE) if needed.",
            "- Add the attribute to the service schema (LIGHT_TURN_ON_SCHEMA) with appropriate validation, e.g.:",
            "  - Use vol.Coerce(int) to accept numeric-like inputs.",
            "  - Use vol.Range or vol.Clamp to restrict values (here, 0–5).",
            "- Update any helper or wrapper APIs (turn_on/async_turn_on functions) to accept the new parameter and include it in the service data dict only when non-None.",
            "Step 4: Document the service parameter",
            "- Update the services manifest (e.g., homeassistant/components/light/services.yaml) for the affected service.",
            "- Add a descriptive entry for the new field, listing valid values and their meaning (e.g., 0=Last, 1=Normal, 2=RGB, 3=HSV, 4=Color flow, 5=Moonlight).",
            "- Provide a concrete example that users can copy, such as 'mode: 5' for moonlight mode.",
            "Step 5: Consume the parameter in the platform integration",
            "- In the platform-specific module (e.g., light/yeelight.py), define a local ATTR_MODE constant if the platform uses its own kwargs parsing.",
            "- In the turn_on (or equivalent) method of the entity class, read mode from kwargs with a safe default (e.g., kwargs.get(ATTR_MODE, 0)).",
            "- Convert the generic value to the vendor-specific type, such as an enum (e.g., yeelight.enums.PowerMode(mode)).",
            "- Pass the converted value to the device API call (e.g., self._bulb.turn_on(duration=duration, power_mode=mode)).",
            "- Leave the rest of the parameters (brightness, color temperature, etc.) unchanged to preserve behavior.",
            "Step 6: Maintain error handling and logs",
            "- Ensure existing try/except blocks around device calls remain intact.",
            "- If necessary, enhance logging to include the new parameter when errors occur to assist debugging.",
            "Step 7: Test end-to-end behavior",
            "- Verify that existing automations calling light.turn_on without 'mode' still behave as before (using the default mode).",
            "- Test new behavior by calling light.turn_on with different 'mode' values (especially special modes like moonlight) on actual devices or in a simulated environment.",
            "- Confirm that the frontend or automations can pass through the new field correctly and that no validation errors are raised.",
            "Step 8: Consider conceptual alignment",
            "- Re-evaluate whether the new parameter overlaps semantically with existing ones (e.g., effect).",
            "- If users originally requested this as an effect, document or explain why it is provided as a separate 'mode' to avoid confusion and preserve clean API design."
        ]
    }
}
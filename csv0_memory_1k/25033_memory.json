{
    "search_index": {
        "description_for_embedding": "Home Assistant jewish_calendar sensor was recalculating all values every 30 seconds using the default SCAN_INTERVAL, even though its values (zmanim, candle lighting, havdalah, omer count, etc.) change only at predictable times. The fix disables frequent polling by setting a huge SCAN_INTERVAL and instead uses event-driven scheduling (async_track_sunset, async_call_later, async_track_time_change) to recalculate exactly at sunset, havdalah, and midnight, ensuring accurate updates without wasted computation.",
        "keywords": [
            "homeassistant",
            "Home Assistant",
            "jewish_calendar",
            "sensor",
            "SCAN_INTERVAL",
            "polling interval",
            "event-driven updates",
            "async_track_sunset",
            "async_call_later",
            "async_track_time_change",
            "zmanim",
            "calendar-based sensor",
            "performance optimization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant integration for the Jewish calendar (homeassistant/components/jewish_calendar/sensor.py), the sensors were using the platform default polling interval of 30 seconds. This meant that the component recalculated all calendar-based times (date, weekly portion, candle lighting, havdalah, issur melacha, omer count, etc.) every 30 seconds, even though those values only change a few times per day at well-defined halachic times. This was wasteful and unnecessary. One reviewer suggested just setting SCAN_INTERVAL to 30 minutes, but the code owner pointed out that a coarse fixed interval risks missing critical update moments (e.g., the exact time of candle lighting or havdalah). The PR introduced an event-driven update strategy. First, SCAN_INTERVAL was set to an extremely large value (dt.timedelta(days=9999)) to effectively disable the default periodic polling. The sensor entity was updated to receive a reference to hass and the hdate library was imported at module level instead of inside async_update. Inside the JewishCalSensor __init__, several nested callbacks were defined: `recalculate`, which schedules an async_update; `recalculate_and_schedule`, which calls async_update and then schedules the next havdalah recalculation; and `schedule_havdalah_recalculate`, which determines the next halachic 'three_stars' time via hdate.Zmanim or, if a havdalah offset is configured, computes sunset plus the offset using get_astral_event_date. That function calculates the delay until the next relevant time and uses async_call_later to schedule `recalculate` one second after the target time. The sensor then registers three time-based triggers: async_track_sunset with a negative offset based on `candle_lighting_offset` (to recalculate around candle lighting), async_track_sunset with a +1 second offset (to recalculate right after sunset and set up havdalah), and async_track_time_change at 00:00:01 (to perform daily updates). It also calls `schedule_havdalah_recalculate` once at initialization in case Home Assistant starts between sunset and havdalah. With this setup, the sensor updates only when its values are expected to change and at the precise times, eliminating unnecessary recalculation and ensuring timely state updates.",
        "semantic_memory": "Calendar- and schedule-driven sensors should not use high-frequency polling when their data only changes at known times. For systems like Home Assistant, where entities can register callbacks on time or astronomical events, it is often much more efficient and accurate to adopt an event-driven update model rather than a fixed SCAN_INTERVAL. The general pattern is: (1) compute the next relevant change time using domain logic (e.g., sunrise/sunset, three stars, offsets), (2) register a callback that triggers an update at that exact time using scheduling helpers, and (3) re-schedule the next update after each trigger. This avoids constant recalculation, reduces load, and ensures that time-sensitive values (like religious observance times, cron-like events, or timed automations) are updated precisely when they change. In Home Assistant specifically, helpers like async_track_sunset, async_track_time_change, and async_call_later are designed for this purpose; SCAN_INTERVAL should be used for simple polling needs, not when you can compute an exact schedule. Another generalizable point is to move heavy imports (like a calendar library) to module scope when they will be used in many updates rather than importing them in each async_update call. Finally, when you essentially disable polling by setting an enormous SCAN_INTERVAL, you must ensure that all state-changing logic is reachable via event callbacks so the entity does not become stale.",
        "procedural_memory": [
            "When a sensor is updating too frequently despite its values changing only at predictable times, consider replacing fixed-interval polling with event-driven scheduling based on the domain's time logic.",
            "Step 1: Identify the update pattern and waste.",
            "Inspect the integration: check for default or overly aggressive SCAN_INTERVAL values (e.g., 30 seconds). Determine how often the underlying data truly changes (e.g., specific times of day, sunset, date boundaries). If updates only matter at specific known times, high-frequency polling is wasteful and may still be imprecise around those times.",
            "Step 2: Enumerate the exact change events.",
            "List the domain events or times when the sensor's state can change: for a calendar sensor, these might include midnight, sunset, a calculated 'three stars' time, or an offset time like sunset + X minutes. Map each sensor type to the events that change its value (e.g., some values change daily at midnight, others at candle lighting, others at havdalah).",
            "Step 3: Compute the next change time programmatically.",
            "Using domain-specific code (e.g., an astronomy or halachic-time library like hdate), calculate the exact datetime of the next change: for example, use a Zmanim API to get 'three_stars', or use get_astral_event_date to get sunset and then add a configured offset. Convert all times to local time and ensure timezone correctness.",
            "Step 4: Disable unnecessary polling.",
            "Set SCAN_INTERVAL to a very large value (or otherwise disable periodic polling, depending on the framework) so that the framework does not call async_update frequently. In Home Assistant, something like SCAN_INTERVAL = dt.timedelta(days=9999) is one way to effectively stop regular polling when you fully rely on event scheduling. Ensure this is acceptable for the integration and that no other code relies on periodic updates.",
            "Step 5: Register event-based callbacks for updates.",
            "Use the framework's scheduling helpers to execute updates at the right times. In Home Assistant: use async_track_sunset to trigger around sunset with optional offsets; use async_track_time_change to trigger at specific wall-clock times (e.g., midnight); and use async_call_later to schedule a one-off callback a certain number of seconds in the future. Inside these callbacks, schedule or call async_update (or equivalent) to recompute sensor state.",
            "Step 6: Chain scheduling after each update.",
            "When an event occurs and you update the sensor, compute the next relevant event and schedule it. For example, after running a callback at sunset, schedule a havdalah recalculation at 'three_stars' or sunset + offset. This creates a chain where each update schedules the next one, ensuring the sensor remains in sync with real-world changes.",
            "Step 7: Handle startup and edge cases.",
            "On initialization, immediately compute whether the current time is between significant events (e.g., between sunset and havdalah) and schedule an update accordingly. This prevents the sensor from remaining stale if Home Assistant restarts during such a window. Also consider off-by-one issues: sometimes add a small buffer (e.g., +1 second) to ensure the time comparison behaves as expected and avoids missing events by microseconds.",
            "Step 8: Move heavy imports and shared logic out of hot paths.",
            "If async_update was importing a heavy library on each call, move that import to module scope so that it only occurs once. Keep async_update lean; the heavy lifting should be in initialization and in the scheduled callbacks.",
            "Step 9: Test timing behavior.",
            "Simulate or log for several days' worth of events (or adjust clock/test harness if possible) to ensure that callbacks fire at the right times and that sensor values change when expected. Log the computed 'next_schedule' times and verify they are increasing as days pass and handle configuration changes (offsets, timezone).",
            "Step 10: Document the scheduling behavior.",
            "Document in code comments and/or external docs that the sensor uses event-driven scheduling and does not rely on regular polling. Explain which events trigger recalculations (e.g., sunset, midnight, havdalah) so that future maintainers understand why SCAN_INTERVAL is unusually large and where to adjust behavior if needed."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor Home Assistant irish_rail_transport sensor to move a third-party library import (IrishRailRTPI from pyirishrail) from inside the setup_platform function to the module top-level, aligning with Home Assistant and Python style guidelines for import placement.",
        "keywords": [
            "irish_rail_transport",
            "Home Assistant",
            "sensor.py",
            "import order",
            "local import",
            "top-level imports",
            "pyirishrail",
            "IrishRailRTPI",
            "code style",
            "refactor",
            "performance",
            "linting"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant integration for Irish Rail (irish_rail_transport), the sensor platform had a non-standard import pattern. The IrishRailRTPI class from the pyirishrail library was imported inside the setup_platform function rather than at the top of the module. This can conflict with code-style guidelines, static analysis tools, and Home Assistant conventions that require imports to be at module top-level. The pull request refactored sensor.py by moving `from pyirishrail.pyirishrail import IrishRailRTPI` to the top of the file alongside other imports, and removed the now-redundant local import inside setup_platform. Additionally, the imports were slightly reordered for consistency (standard library, third-party, then Home Assistant modules; and minor reordering of ATTR_ATTRIBUTION and CONF_NAME, plus moving the config_validation import with other Home Assistant imports). No functional behavior of the integration was changed; this was a style and maintainability improvement that may also marginally improve performance by avoiding re-import attempts on every platform setup call.",
        "semantic_memory": "This change illustrates a common best practice in Python and especially in large frameworks like Home Assistant: imports should generally be placed at the top of the module, not inside functions. Top-level imports improve clarity, enable static analysis and type checking, avoid repeated import overhead, and follow style guides (PEP 8). Local imports should be used only when there is a clear justification (e.g., avoiding heavy dependencies at import time, breaking circular imports, or deferring optional imports). For Home Assistant integrations, code style and import structure are important because they affect dependency analysis (e.g., hassfest), linting, test tooling, and overall maintainability. Consistent import ordering (standard library, third-party, local application) and grouping related Home Assistant imports together reduces friction for other contributors and automated tools.",
        "procedural_memory": [
            "When you find imports inside functions in a Home Assistant integration (or any Python project) that do not have a compelling reason to be lazy-loaded, refactor them to the top-level of the module.",
            "Step 1: Inspect the module for any `import` or `from ... import ...` statements inside functions or methods, such as inside setup_platform, async_setup_entry, or other handlers.",
            "Step 2: Determine whether the local import is required to solve a specific problem (e.g., circular dependencies, optional heavy dependency, or conditional runtime import). If not, it is likely safe to move.",
            "Step 3: Move the import statement to the top of the file, grouping it appropriately: first standard library imports (e.g., datetime, logging), then third-party/library imports (e.g., voluptuous, pyirishrail), then project-specific imports (e.g., homeassistant.components, homeassistant.const).",
            "Step 4: After moving, remove the original import line from inside the function to avoid duplication and potential confusion.",
            "Step 5: Ensure any reordering of imports still preserves correct names and does not shadow other imports. Follow the project's style rules for ordering within groups (e.g., alphabetical, or per established patterns like ATTR_ATTRIBUTION before CONF_NAME if that is the norm).",
            "Step 6: Run linting and tests (`tox`, `pytest`, or project-specific tooling) to confirm there are no circular import issues or runtime errors introduced by the refactor.",
            "Step 7: If a local import was originally used to avoid a circular dependency and moving it to the top causes a failure, revert or adjust by refactoring the dependency graph or keeping that specific import local with a code comment explaining why.",
            "Step 8: For Home Assistant specifically, ensure that all integration dependencies remain properly declared in the manifest and that moving imports has not introduced any unintended import-time side effects (e.g., network calls on import, which should be avoided)."
        ]
    }
}
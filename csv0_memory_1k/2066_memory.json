{
    "search_index": {
        "description_for_embedding": "Refactor napari's ViewerModel and related components (camera, axes, cursor, dims, scale bar, colormaps) to use a custom Pydantic-based EventedModel instead of the old evented dataclass system. Fixes a recursion error when importing napari due to Pydantic deep-copying event emitters with deprecated attribute machinery, and ensures dict/json serialization excludes non‑serializable fields such as layers, active_layer, and input/mouse/key binding state.",
        "keywords": [
            "napari",
            "ViewerModel",
            "Pydantic",
            "EventedModel",
            "event system",
            "EmitterGroup",
            "recursion error",
            "deepcopy",
            "json serialization",
            "dict serialization",
            "layers",
            "active_layer",
            "KeymapProvider",
            "MousemapProvider",
            "numpy in pydantic",
            "custom types",
            "Array",
            "colormap",
            "axes",
            "camera",
            "dims"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident napari was being migrated to a Pydantic-based viewer model. When importing napari and constructing ViewerModel as a Pydantic model mixing in event emitters, the import crashed with a RecursionError. The stack trace showed Pydantic deep-copying default values while building model fields. That deep copy traversed napari's event system and hit a custom __getattr__‑based deprecation layer that recursively accessed self._deprecated, leading to unbounded recursion.\n\nTo make Pydantic and the event system coexist, the old ad-hoc 'event deprecation' machinery was removed and the event infrastructure was refactored. A dedicated napari.utils._pydantic.EventedModel base class was introduced. It subclasses pydantic.BaseModel, adds a private EmitterGroup, computes per-field equality functions (handling numpy arrays), and overrides __setattr__ to emit events when annotated fields change. A custom Array type was also introduced so Pydantic can validate and serialize numpy arrays (e.g. color arrays) while encoding them to JSON via json_encoders.\n\nViewerModel was rewritten to subclass EventedModel plus KeymapProvider and MousemapProvider. Internal subcomponents (Camera, Axes, Cursor, Dims, GridCanvas, ScaleBar, Colormap) were refactored to Pydantic models based on EventedModel (or using Array) with validators for things like tuple length and color normalization. Because Pydantic will try to validate everything by default, configuration was carefully set (arbitrary_types_allowed, validate_assignment, use_enum_values, etc.), and in ViewerModel.Config extra was temporarily allowed during initialization for mixins.\n\nThe viewer's dict() and json() methods were overridden to exclude fields that cannot or should not be serialized, such as the layers list, active_layer reference, and mouse/key binding state (_mouse_wheel_gen, _mouse_drag_gen, _persisted_mouse_event, and callback lists). This prevents Pydantic from walking complex live objects during serialization. EmitterGroup's mypy-only __getattr__ helper was also dropped to reduce the risk of magic attribute lookups causing unexpected interactions.\n\nAdditionally, mixins (KeymapProvider, MousemapProvider) were updated to call super().__init__ properly and ViewerModel.__init__ explicitly calls their initializers after EventedModel.__init__. Mouse wheel handling was extracted into MousemapProvider, and dims_scroll was registered via ViewerModel.mouse_wheel_callbacks. Various tests (Qt dims, Qt viewer, camera/axes/scale bar visuals, colormap handling, multichannel image tests) were updated for the new Pydantic-based behavior and type signatures.",
        "semantic_memory": "This work illustrates how to integrate Pydantic models with an existing custom event system and rich object graph in a GUI application:\n\n- **Separate event logic from data modeling via a dedicated EventedModel base.** Rather than making every model manually manage emitters, add a standard EventedModel that creates an EmitterGroup based on annotated fields and emits events from __setattr__ when values actually change. This centralizes patterns like equality checks (especially for numpy arrays) and event attachment.\n\n- **Avoid letting Pydantic deep-copy or validate non-model objects.** Pydantic will deepcopy default field values, run validators, and traverse data during dict/json export. If those objects include complex state (event emitters, QObject-like signals, generators, GUI callbacks, or deprecation proxies), you can hit recursion or serialization errors. The remedy is to either (a) mark such attributes as private (PrivateAttr) so Pydantic ignores them, or (b) override dict/json to explicitly exclude them. Structuring long-lived infrastructure (layers, active_layer, key/mouse bindings) outside of the Pydantic model and referencing them in a controlled way is safer than trying to model them as fields.\n\n- **Use custom types for numpy and similar structures.** Pydantic's standard types don't know about numpy semantics like shape and dtype. By defining a custom Array type with __class_getitem__ and __get_validators__, you can enforce (dtype, shape) and still have nice JSON serialization via json_encoders. This pattern is reusable for any non-standard data structure that must be validated but also serialized.\n\n- **Configure Pydantic carefully in a GUI/event-driven context.** Options like arbitrary_types_allowed, validate_assignment, use_enum_values, and underscore_attrs_are_private are often necessary when modeling Qt-like objects or enums. Using Extra.ignore or Extra.allow selectively (e.g., only on ViewerModel) lets you mix in behaviors without Pydantic rejecting or trying to validate the mixin state.\n\n- **Be wary of magic __getattr__ in objects that Pydantic touches.** Attr-based deprecation layers or dynamic attribute resolution can be dangerous when used on objects that will be traversed, deep-copied, or introspected. It’s better to implement deprecation via explicit properties or warning emitters that don’t depend on recursive __getattr__ checks.\n\n- **For complex serialization, explicitly control what is included.** Overriding dict() and json() to add an 'exclude' parameter (built from sets like EXCLUDE_DICT/EXCLUDE_JSON) is a clean way to ensure only pure model data is exported, leaving out live connections, callbacks, or heavy objects. This pattern generalizes to any Pydantic model used as part of a running application rather than a simple DTO.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues integrating Pydantic with an evented GUI model:",
            "Step 1: Reproduce and inspect the error.\n- Run a minimal entry point (e.g., importing the app or opening a simple viewer) to reproduce the traceback.\n- Identify where Pydantic is involved in the stack trace. Look for calls like pydantic.main.ModelMetaclass.__new__, pydantic.fields.ModelField.infer, get_default, and smart_deepcopy.\n- Note any recursion or infinite loops, especially around __getattr__, __getstate__/__setstate__, or custom proxies.",
            "Step 2: Identify problematic fields and behaviors.\n- Examine the model class being created by Pydantic. Check default values and annotated types for fields pointing to event emitters, GUI objects, generators, mixins, or deprecated proxies.\n- Look for magic __getattr__ or __getattribute__ implementations on any class that Pydantic might deepcopy or inspect. Verify whether those implementations might re-enter themselves or rely on attributes that are not yet initialized.",
            "Step 3: Introduce an EventedModel abstraction.\n- Create a base class (e.g., EventedModel) that subclasses pydantic.BaseModel.\n- In __init__, construct an EmitterGroup and add one emitter per field name from self.__fields__.\n- Build a __equality_checks__ dict mapping field names to appropriate equality functions (e.g., custom numpy array comparison) using a helper like _type_to_compare.\n- Override __setattr__ to: (a) fall back to normal behavior for non-event fields, (b) capture old value, (c) set the new value, (d) if changed according to __equality_checks__, emit events.<field>(value=new_value).\n- Configure the Pydantic Config for EventedModel: set arbitrary_types_allowed, validate_assignment, underscore_attrs_are_private, use_enum_values, validate_all, and json_encoders for any custom types (e.g. numpy arrays).",
            "Step 4: Introduce custom validated types for arrays or other complex data.\n- Implement a custom class (e.g., Array) that subclasses numpy.ndarray and defines __class_getitem__ to support generics like Array[float, (-1, 4)].\n- Implement __get_validators__ and validate_type to enforce dtype and shape and coerce input values via np.array.\n- Add JSON encoders that convert Array/numpy.ndarray to lists when serializing.\n- Use Array in your Pydantic models for any fields holding numpy data (colors, coordinates, etc.).",
            "Step 5: Migrate existing models to EventedModel.\n- For each model that previously used a custom evented dataclass or manual emitter setup (e.g., Camera, Axes, Cursor, Dims, GridCanvas, ScaleBar, Colormap), replace the base class with EventedModel.\n- Move any __post_init__-style logic into validators or root_validators.\n- Use Pydantic validators to enforce invariants (e.g., ensure center and angles are 3-tuples; dims.range and dims.axis_labels lengths match ndim; colormap.controls size is consistent with colors and interpolation).",
            "Step 6: Handle mixins (key/mouse providers) and extra attributes.\n- For mixins like KeymapProvider and MousemapProvider that define their own __init__, make sure to call super().__init__(*args, **kwargs) so they are compatible with BaseModel initialization.\n- In a model that combines EventedModel with such mixins (like ViewerModel), call the mixin initializers after EventedModel.__init__.\n- If mixins add attributes that are not present in the Pydantic field definitions, temporarily allow extra attributes on that model (e.g., by setting the model's Config.extra to 'allow' during init or override Config in a subclass). Reset to a stricter mode if desired after init.",
            "Step 7: Prevent Pydantic from touching non-serializable or live data.\n- Identify fields that represent live application state (e.g., layers list, active_layer, callback lists, generator objects, event handler maps).\n- Decide whether those should be Pydantic fields at all. For long-lived runtime-only state, prefer PrivateAttr or standard Python attributes not included in the model fields.\n- When you do need such fields on the model object, override dict() and json() in the model (e.g., ViewerModel) to union any passed 'exclude' set with a constant set of exclusions (EXCLUDE_DICT, EXCLUDE_JSON) that includes those fields.\n- Use json_encoders for types that you do want to serialize but which are not JSON-serializable by default.",
            "Step 8: Remove dangerous dynamic attribute machinery.\n- Audit your event and model classes for magic __getattr__ or __getattribute__ that depend on internal state like self._deprecated.\n- If such methods can be triggered during deepcopy or introspection, replace them with safer mechanisms (e.g., explicit properties with warnings, or standalone deprecation utilities) to avoid recursive lookups.\n- In this case, remove or refactor any __getattr__ used solely for deprecation warnings in the event system.",
            "Step 9: Update tests and usage code.\n- Update all tests that construct models directly (e.g., Axes, Camera, Dims) to use the new constructor signature and validate new behaviors (e.g., event emission, default values, shape/dtype handling, enum value handling).\n- Adjust GUI tests that rely on viewer.dims, camera, axes, scale bar, and colormaps to reflect new defaults (e.g., center shape, background color defaults).\n- Ensure that Qt and VisPy integration paths still work: connect event signals to slots, and verify that they are triggered when model fields change.",
            "Step 10: Re-run the full test suite and check serialization paths.\n- Run unit, integration, and GUI tests to ensure no RecursionError or type errors remain.\n- Specifically test dict() and json() on your primary models to confirm they exclude non-serializable fields and correctly encode Array/numpy types.\n- If new errors appear, refine validators or Config settings (e.g. Extra.ignore vs Extra.forbid vs Extra.allow) and add targeted tests to prevent regressions."
        ]
    }
}
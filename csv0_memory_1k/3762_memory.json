{
    "search_index": {
        "description_for_embedding": "Added TTL-based garbage collection for StackStorm Inquiries (inquirer runner). Pending inquiries now have per-inquiry TTLs; when exceeded, the corresponding liveaction is marked as timed out, the inquirer runner's post_run is invoked, and parent workflows are instructed to resume. A new purge_inquiries boolean option on the garbage collector enables this behavior, and TTL<=0 disables GC for that inquiry.",
        "keywords": [
            "StackStorm",
            "Inquiry",
            "inquirer runner",
            "garbage collector",
            "TTL-based cleanup",
            "purge_inquiries",
            "ActionExecution",
            "LIVEACTION_STATUS_TIMED_OUT",
            "workflow resume on timeout",
            "pending inquiries leak",
            "workflow paused indefinitely"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the team addressed the problem that StackStorm 'Inquiries' (actions using the 'inquirer' runner that pause workflows waiting for human input) were never being cleaned up or automatically resolved if a user never responded. Previously, an Inquiry is just an ActionExecution with runner='inquirer' and status PENDING, and there was no garbage collection logic specific to them. This could leave workflows paused indefinitely and accumulate stale inquiry executions.\n\nTo fix this, a new garbage collection path for inquiries was implemented in st2common/st2common/garbage_collection/inquiries.py and wired into the existing st2garbagecollector service (st2reactor/st2reactor/garbage_collector/base.py). The GC logic queries ActionExecution records with runner__name='inquirer' and status=PENDING. For each such inquiry, it reads a per-inquiry TTL from inquiry.result['ttl'], coerces it to an integer, and skips any inquiries whose TTL is <= 0 (treating these as disabled/infinite TTL). For the rest, it computes how many minutes have elapsed since start_timestamp. If the elapsed minutes exceed the TTL, the inquiry is considered expired.\n\nWhen an inquiry expires, GC now:\n- Updates the associated liveaction status to LIVEACTION_STATUS_TIMED_OUT with the current inquiry.result via action_utils.update_liveaction_status, and calls executions.update_execution to sync the ActionExecution.\n- Obtains a runner instance from the runner container (using get_action_by_ref and get_runnertype_by_name) and calls runner.post_run(status=TIMED_OUT, result=inquiry.result). This is important because the inquirer runner's post_run is responsible for sending callbacks back into the workflow engine.\n- If the liveaction has a parent context (i.e., it is part of a workflow), it locates the root liveaction using action_service.get_root_liveaction and calls action_service.request_resume(root_liveaction, system_user). This requests that the parent workflow engine resume the workflow, now seeing the inquiry as having timed out and allowing the workflow definition to handle this failure path.\n\nA new boolean configuration option [garbagecollector] purge_inquiries (default False) was added in st2reactor/st2reactor/garbage_collector/config.py and surfaced in conf/st2.conf.sample. The GC base class reads this into self._purge_inquiries; when enabled, _perform_garbage_collection calls a new _timeout_inquiries method, which delegates to purge_inquiries and logs results. If purge_inquiries is False, inquiry GC is skipped entirely.\n\nIntegration tests were added in st2reactor/tests/integration/test_garbage_collector.py. These tests:\n- Use fixtures for an inquirer runner and ask action.\n- Create multiple mock inquiries via LiveActionDB and executions.create_execution_object, with different TTLs and backdated start_timestamp values.\n  - 'Old' inquiries with start_timestamp older than their TTL (should be timed out and removed from the PENDING set).\n  - 'New' inquiries whose TTL is not yet exceeded (should remain PENDING).\n  - Inquiries with TTL=0 (disabled; should remain PENDING even though they are old).\n- Start the garbage collector binary with a special test config conf/st2.tests2.conf where purge_inquiries=True and system.base_path points at test packs so the GC can resolve and instantiate the real inquirer runner (needed for runner.post_run).\n- After a brief sleep, kill the GC process and assert that only the non-expired and TTL-disabled inquiries remain in PENDING status.\n\nMiscellaneous cleanups were also made: unnecessary return statements after abort() calls were removed from the experimental inquiries controller, log messages and comments were clarified (e.g., using 'timed out' instead of 'failed'), and the Makefile's circular dependency check was updated to exclude garbage_collection/inquiries.py since it legitimately imports st2actions. This PR thus introduces robust, opt-in TTL-based garbage collection for Inquiries, ensuring that stale inquiries don't leave workflows paused forever and that timeouts propagate in a workflow-friendly way.",
        "semantic_memory": "Generalizable lessons and patterns from this change:\n\n1. **TTL-based lifecycle management for long-lived tasks**\n   - Any system component that represents 'waiting for external input' (like human approvals, interactive prompts, or external callbacks) should have a clear time-to-live (TTL) policy. Without this, such tasks can accumulate and cause logical leaks where workflows or workers remain blocked indefinitely.\n   - It can be useful to support a **per-instance TTL** rather than only a global TTL, giving workflow authors fine-grained control over how long each interaction may wait. In this implementation, each inquiry carries its own TTL in its result payload.\n   - A TTL of 0 or negative can be treated as 'no auto-expiration' or 'GC disabled' for that instance, giving an opt-out escape hatch.\n\n2. **Garbage collection should integrate with workflow semantics, not just delete data**\n   - When cleaning up pending tasks that are part of workflows, simply deleting database records is not enough. The workflow engine needs to be notified so it can handle the timeout according to the workflow definition (e.g., fallback path, error handling, or escalation).\n   - This PR exemplifies a pattern:\n     - Mark the task with an appropriate terminal status (TIMED_OUT rather than FAILED) to distinguish timeouts from other failures.\n     - Invoke any runner-level hooks (like post_run) that are responsible for dispatching events or callbacks to the workflow engine or other subsystems.\n     - Explicitly request that the parent workflow resume, so the timeout is processed as part of normal workflow execution.\n   - This is a generalized best practice: when implementing GC for workflow-related resources, **propagate state changes through the same channels used by normal execution**, rather than bypassing them or silently deleting records.\n\n3. **Configuration flags for behavioral GC features**\n   - Featureful GC logic that alters the behavior of running workflows (e.g., auto-timeouts) should be guarded by explicit configuration options. Using a straightforward boolean (purge_inquiries) makes the behavior opt-in and easy to reason about.\n   - Configuration should be clearly documented and surfaced in sample configs, including the operational consequences of enabling it.\n\n4. **Testing GC that interacts with runtime components**\n   - GC logic can depend on more than just database state; here, it needs access to the runner container to instantiate the inquirer runner and call post_run. Integration tests must therefore ensure that:\n     - The configuration used for tests points to valid pack/runners paths (base_path) so runner code can be loaded.\n     - The messaging/bus and database backends used in GC are wired to the test environment.\n   - When the usual test configuration is not suitable, creating a dedicated test config (st2.tests2.conf) with explicit comments explaining its purpose can make such tests reliable while minimizing the risk that the config is reused in production environments.\n\n5. **Status design and observability**\n   - Introducing or using a specific status like TIMED_OUT instead of overloading FAILED improves observability and makes it easier for workflows and operators to distinguish between different failure causes.\n   - Clear log messages (e.g., 'Marked N ttl-expired Inquiries as \"timed out\"') and debug logs explaining why particular items are skipped (TTL <= 0) improve debuggability of GC behavior.\n\n6. **Avoiding circular dependencies when adding cross-layer logic**\n   - Adding GC logic in a common module that depends on action services and runners can introduce circular dependency concerns. Here, the team addressed it by:\n     - Localizing the cross-layer imports in a dedicated module (garbage_collection/inquiries.py).\n     - Explicitly excluding this file from an automated circular-dependency check in the Makefile.\n   - In general, when infrastructure code must cross service boundaries, isolate those imports and document the rationale to keep dependency analysis manageable.",
        "procedural_memory": [
            "Step-by-step guide to diagnosing and implementing TTL-based garbage collection for long-lived, workflow-related tasks like Inquiries:",
            "Step 1: Identify the leak condition",
            "• Observe that certain workflow-related tasks (e.g., human approval steps, inquiries) remain in a non-terminal state (PENDING, WAITING, etc.) indefinitely if external input never arrives.\n• Verify via database or API that these tasks accumulate over time and that parent workflows remain paused or blocked.\n• Confirm that there is no existing GC or timeout mechanism for these tasks.",
            "Step 2: Define the desired lifecycle semantics",
            "• Decide what should happen when such a task exceeds its allowed waiting time:\n  – Should it be treated as FAILED, TIMED_OUT, or a custom terminal status?\n  – Should parent workflows resume on a dedicated timeout path?\n• For this case, use a distinct TIMED_OUT status to differentiate from other failures and allow workflows to branch accordingly.",
            "Step 3: Choose where to implement the GC logic",
            "• Prefer integrating with an existing GC or scheduler service rather than introducing a new microservice, unless there is a strong reason otherwise.\n• Ensure that the chosen service already deals with TTL concepts and periodic sweeps (e.g., st2garbagecollector in StackStorm).",
            "Step 4: Model the tasks for GC queries",
            "• Determine how to uniquely identify the tasks to be GC'd. For inquiries in StackStorm:\n  – They are ActionExecution rows with runner__name='inquirer' and status=PENDING.\n• Implement a query that fetches all such tasks from the persistence layer.",
            "Step 5: Implement per-item TTL evaluation",
            "• Store TTL per task instance (e.g., in a field like result['ttl'] or an equivalent attribute).\n• In GC logic, for each candidate item:\n  – Read and coerce TTL to an integer, with proper defaulting or validation.\n  – If TTL <= 0, treat as 'no auto-expiry' and skip, logging a debug message.\n  – Compute elapsed time since creation (e.g., minutes from start_timestamp to now).\n  – If elapsed > TTL, mark the task as expired and proceed to cleanup; otherwise, leave it untouched.",
            "Step 6: Update task status and propagate to workflows",
            "• For expired tasks:\n  – Update the underlying live action or task object to TIMED_OUT (or your chosen status) using existing status update helpers to ensure consistency.\n  – Update any derived or related execution records so that the system reflects the new terminal state.\n  – Obtain the appropriate runner or executor instance and call its post_run (or equivalent callback) with the new status and result, ensuring that any side effects (notifications, callbacks, etc.) are triggered.\n  – If the task belongs to a workflow (check parent context or similar metadata), locate the root workflow action and request a resume operation, so the workflow engine can handle the timeout according to the workflow definition.",
            "Step 7: Wire GC into the periodic collector with configuration",
            "• Add a configuration flag (e.g., purge_inquiries) under the garbage collector section to control whether this GC behavior is active.\n• In the GC service main loop, read this flag and conditionally invoke the new logic.\n• Insert appropriate sleep delays between processing different resource types to avoid overloading the system.\n• Update sample configuration files (e.g., st2.conf.sample) with the new option and a clear explanation of its behavior.",
            "Step 8: Implement integration tests",
            "• Create fixtures for any specialized runners or actions needed by the tasks (e.g., inquirer runner, ask action).\n• In a test case:\n  – Create multiple mock tasks with various TTL and timestamp combinations: expired, non-expired, and TTL-disabled (<=0).\n  – Ensure their status and metadata match how the GC logic identifies them (e.g., status=PENDING, runner name).\n  – Start the garbage collector in a subprocess using a test-specific config where the new GC option is enabled and base paths point to test packs so custom runners can be loaded.\n  – Wait long enough for at least one GC cycle, then kill the process.\n  – Assert that only expected tasks have transitioned from PENDING, and that non-expired and TTL-disabled tasks remain.\n• If necessary, create a dedicated test config with comments explaining its purpose and why it should not be used outside tests.",
            "Step 9: Address dependency and maintainability concerns",
            "• If the new GC module must import higher-level services or runners, isolate that logic in a dedicated file and, if you have automated circular dependency checks, explicitly exclude that file with a justification.\n• Ensure log messages clearly state what GC is doing (e.g., 'Marked N ttl-expired X as timed out').\n• Clean up any redundant code (e.g., unnecessary returns after abort() calls) that you touch during this work to keep related modules tidy.",
            "Step 10: Deploy and monitor",
            "• Enable the new GC behavior in the appropriate environment by setting purge_inquiries (or equivalent) to True.\n• Monitor logs to verify that expired tasks are being marked as timed out and that workflows are resuming and handling the timeout paths as intended.\n• Observe system behavior under normal and edge conditions (e.g., TTL=0, invalid TTL values) and adjust logging or validation as needed."
        ]
    }
}
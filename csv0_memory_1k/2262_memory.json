{
    "search_index": {
        "description_for_embedding": "Fix for a subtle startup hang in napari caused by the main viewer being garbage-collected before the GUI event loop starts. The CLI entrypoint called view_path() without retaining the returned Viewer, so under certain GC timings the viewer was collected, causing napari to hang at startup. The fix stores the returned viewer in a local variable to keep a strong reference alive until the global window takes ownership, and a regression test forces GC and checks that the viewer reference count has increased when run() is called.",
        "keywords": [
            "napari",
            "startup hang",
            "garbage collection",
            "GC timing bug",
            "viewer reference lost",
            "CLI entrypoint",
            "__main__._run",
            "view_path",
            "Qt event loop",
            "GUI initialization",
            "sys.getrefcount",
            "reference lifecycle",
            "Python GC",
            "UI freezing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari would intermittently hang at startup, depending on small code changes and whether garbage collection happened at a particular point in time. The hang occurred during the CLI startup path in napari.__main__._run(). The code created the main viewer by calling view_path(args.paths, ...) but did not assign the return value to any variable. The viewer object was only implicitly referenced later through the global window, but there was a time window between creation and event loop startup where no strong reference was held. If Python's garbage collector ran during this window, it would collect the viewer instance, leaving the application in a broken state and causing an apparent startup freeze or hang.\n\nThe fix was to explicitly retain the viewer reference in the CLI entrypoint by assigning the result of view_path(...) to a local variable `_viewer` (marked with `# noqa: F841` to silence the unused-variable lint warning). This ensures that the viewer remains strongly referenced until after the event loop is started and the global window has safely taken ownership. An initial patch also forced gc.collect() immediately after creating the viewer to aggressively surface any remaining leaks, but that explicit collection was later removed from the production code and replaced by a targeted test.\n\nA regression test was added in napari/_tests/test_cli.py. The test constructs a Viewer instance `v` and mocks napari.__main__.view_path to return that object. It also patches the run function (mock_run) so that when __main__._run() calls run(gui_exceptions=True), the side-effect function `_check_refs` is executed. `_check_refs` first triggers gc.collect() and then asserts that `sys.getrefcount(v)` is greater than the baseline reference count measured just before calling __main__._run(). This verifies that the CLI startup code retains at least one additional reference to the viewer by the time the event loop starts. If the reference were lost (e.g., if `_viewer` were removed), this test would fail, catching the regression. The test also verifies that view_path is called once with the expected arguments.",
        "semantic_memory": "This bug illustrates a subtle but important pattern in GUI and long-lived application initialization: objects that are critical to the application's operation (such as main windows or viewer objects) must have a clear, explicit ownership model, especially during startup and shutdown phases. Relying on implicit references or delayed attachment to a global manager creates a time window where garbage collection can remove an object that is still logically 'in use', leading to intermittent, timing-dependent hangs or crashes.\n\nIn Python, especially with GUI frameworks and event loops, GC timing bugs are often non-deterministic: small code changes, print statements, or different machines and OS versions can affect when the garbage collector runs. If an object is created and not stored in any variable or container, it becomes eligible for collection as soon as the creating frame is unwound, even if some external system (like a C-extension GUI loop) is expected to hold it later. This can cause 'heisenbugs' that only show up when GC happens in just the wrong moment.\n\nA robust pattern is to explicitly store critical objects (viewers, windows, controllers) in a scope that lives as long as they are neededâ€”either in a local variable that spans until event loop startup, in an application object, or in another clearly owned container. Lint tools that flag unused variables can conflict with this, so it may be necessary to intentionally keep an 'unused' variable with an inline comment or suppression directive.\n\nTesting for GC-related lifecycle issues can be done by forcing garbage collection at known critical points and by measuring reference counts (e.g., using sys.getrefcount) or using weakrefs to detect premature collection. Regression tests that approximate worst-case GC behavior help ensure that refactoring or cleanup does not re-introduce subtle lifecycle bugs.\n\nMore generally, for long-lived systems with asynchronous initialization, it is best practice to:\n- Define explicit ownership and lifetime contracts for key objects.\n- Avoid assuming that an object 'will be held somewhere else soon' without actually storing a reference.\n- Incorporate lifecycle-aware tests that simulate aggressive GC or teardown scenarios.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Observe and characterize the symptom.\n- Note when the hang or crash occurs (e.g., during application startup, right after launching the CLI).\n- Observe whether the issue is intermittent or sensitive to minor code changes (e.g., adding/removing print statements).\n- If behavior is timing- or environment-dependent, suspect GC or race-condition issues.",
            "Step 2: Suspect garbage collection or lifecycle problems.\n- Add logging around object construction and destruction, including __init__, __del__, and any cleanup callbacks.\n- Temporarily enable aggressive garbage collection (e.g., call gc.collect() at key points) to see if the hang/crash becomes more reproducible.\n- If forcing gc.collect() makes the problem more consistent, it's likely a GC/lifecycle bug.",
            "Step 3: Identify critical objects created during startup.\n- Inspect the startup / CLI entrypoint code to see what key objects are instantiated (e.g., main window, viewer, controller) before the event loop starts.\n- Check whether the return values of these constructors or factory functions are stored anywhere (locals, globals, attributes, or containers) or simply created and discarded.",
            "Step 4: Verify reference ownership and lifetime.\n- For each critical object, confirm that there is at least one strong Python reference that persists until the object is fully integrated into the application's ownership graph (e.g., attached to a global window or app instance).\n- Pay attention to windows where an object exists but is not yet stored in a long-lived structure, especially between creation and event loop startup.",
            "Step 5: Reproduce and inspect with reference counting.\n- Create a test scenario where you manually construct the object (e.g., Viewer) and record its reference count using sys.getrefcount(obj).\n- Mock or wrap the part of the code that starts the event loop (e.g., run()) so that you can execute custom code right when the event loop would begin.\n- In that hook, call gc.collect(), then re-check sys.getrefcount(obj) to ensure it has increased (indicating additional references) or at least has not decreased below the expected baseline.",
            "Step 6: Implement the fix by explicitly retaining references.\n- If a critical object is created but not stored, assign it to a variable in the appropriate scope (e.g., `_viewer = view_path(...)`).\n- If lints complain about an unused variable, add a comment (and if needed, a lint suppression such as `# noqa: F841`) explaining that the reference is intentionally kept alive to prevent GC.\n- Ensure that the lifespan of this variable covers the entire period where the object must remain valid (e.g., until `run()` is called and the GUI owns it).",
            "Step 7: Add a regression test that stresses GC.\n- Write a test that constructs a known object, mocks the factory function to return that object, and mocks the event-loop start function to run a custom check.\n- In the custom check, call gc.collect() and assert that the reference count for the object is greater than or equal to a baseline measured before starting the sequence, indicating that additional references are held when they should be.\n- Ensure the test fails if the explicit reference-holding variable is removed or refactored away.",
            "Step 8: Remove overly aggressive GC from production (if used temporarily).\n- If you temporarily added gc.collect() calls to production paths purely for debugging, remove them once the root cause is fixed, as they can hurt performance and alter normal behavior.\n- Keep GC forcing only in tests or debug/diagnostic utilities.",
            "Step 9: Document ownership assumptions.\n- Add comments in the code near the explicit reference (e.g., `_viewer`) explaining why the variable must be kept and the consequences of its removal.\n- Optionally, add a brief note in developer documentation about lifecycle expectations for main objects (like viewers/windows) and the presence of tests that enforce those contracts.",
            "Step 10: Monitor future changes.\n- When refactoring startup or CLI code, re-run the GC-stress tests and ensure that new code maintains explicit ownership of critical objects.\n- Encourage reviewers to look for patterns where factory calls return important objects whose references are not stored, and to question such designs."
        ]
    }
}
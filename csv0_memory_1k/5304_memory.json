{
    "search_index": {
        "description_for_embedding": "StackStorm change to the action delete API so that deleting an action/workflow also removes its metadata and entrypoint files from disk, with CLI confirmation flags, centralized pack file deletion logic, robust error handling to avoid inconsistent DB/disk state, and tests. Includes discussion of backwards compatibility and read‑only pack filesystems.",
        "keywords": [
            "StackStorm",
            "st2",
            "action delete API",
            "workflow delete",
            "remove files on disk",
            "packs",
            "st2api.controllers.v1.actions",
            "st2common.services.packs.delete_action_files_from_pack",
            "st2client ActionDeleteCommand",
            "ResourceDiskFilesRemovalError",
            "PermissionError",
            "atomic delete",
            "DB and filesystem consistency",
            "CLI confirmation",
            "-f",
            "--force",
            "breaking change",
            "infrastructure as code",
            "read-only filesystem",
            "stackstorm-ha"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The issue was that StackStorm's action/workflow delete API only removed the database registration for an action, leaving the underlying pack files (action entrypoint and metadata YAML) intact. After a reload, those files would be re-scanned and the 'deleted' actions would reappear in the database, confusing users, especially those using the workflow composer/UI.\n\nTo address this, the PR modified the action delete flow in several places:\n\n1. **API layer (st2api/controllers/v1/actions.py)**\n   - The DELETE endpoint for actions was changed so that after successfully calling `Action.delete(action_db)` (removing the DB record), it calls a new helper `delete_action_files_from_pack(pack_name, entry_point, metadata_file)` from `st2common.services.packs`.\n   - DB deletion and file deletion are now separated into two try/except blocks: first the DB deletion, then the file deletion. Any exception during file deletion is logged and converted into an HTTP 500 via `abort(http_client.INTERNAL_SERVER_ERROR, six.text_type(e))`, preventing a silent success when files could not be removed.\n\n2. **Common service layer (st2common/services/packs.py)**\n   - A new function `delete_action_files_from_pack(pack_name, entry_point, metadata_file)` was introduced and exported.\n   - It uses `get_pack_base_path(pack_name=pack_name)` to locate the pack, then builds absolute paths:\n     - `action_entrypoint_file_path = os.path.join(pack_base_path, 'actions', entry_point)`\n     - `action_metadata_file_path = os.path.join(pack_base_path, metadata_file)`\n   - For each of these paths (only if `os.path.isfile(...)`):\n     - On success, the file is removed with `os.remove`.\n     - On `PermissionError`, it logs a clear error (\"No permission to delete the ... file\") and raises a `PermissionError` with a message like `No permission to delete \"<path>\" file from disk`.\n     - On any other exception, it logs the full exception and raises a custom `ResourceDiskFilesRemovalError` (moved to `st2common.exceptions.content`) with a user-facing message: `The action file \"<path>\" could not be removed from disk, please check the logs or ask your StackStorm administrator to check and delete the actions files manually`.\n   - If a file is not present, it logs a warning saying the action entrypoint/metadata file does not exist on disk, but does not fail the delete.\n\n3. **CLI behavior (st2client)**\n   - Initially, a generic confirmation prompt was added in `ResourceDeleteCommand`, but this was later refactored so that only the action delete command behaves specially.\n   - `ActionDeleteCommand` now subclasses `ContentPackResourceDeleteCommand` and adds combined `-f`/`--force` CLI arguments (with shared `dest='force'`). This flag is interpreted as an automatic \"yes\" to deleting the action's files from disk.\n   - The `run()` method of `ActionDeleteCommand`:\n     - Looks up the action by `ref_or_id`.\n     - If `--force/-f` is set, it directly calls `self.manager.delete(...)` and prints a message that the resource was deleted from DB and disk.\n     - Otherwise, it prompts: `The resource files on disk will be deleted. Do you want to continue? (y/n): ` and only proceeds with deletion if the user answers `y` or `yes`. Otherwise it prints \"Action is not deleted.\" and exits.\n   - `run_and_print()` delegates to `run()` and uses common error handling; on `ResourceNotFoundError` it prints 'not found' and raises an `OperationFailureException` in the generic path, but the action-specific override now just prints the not-found and does not re-raise.\n\n4. **Exceptions and tests**\n   - A new exception `ResourceDiskFilesRemovalError` was defined in `st2common.exceptions.content` for signaling non-permission-related failures during file deletion.\n   - Extensive unit tests were added in `st2common/tests/unit/services/test_packs.py` to cover normal deletions, missing files, permission errors, and generic errors for both entrypoint and metadata files.\n     - The tests create dummy files under `dummy_pack_1/actions/` in the fixtures packs, then assert that `delete_action_files_from_pack` removes them.\n     - Additional tests use `mock.patch.object(os, 'remove')` to force `PermissionError` or generic `Exception` and assert that the appropriate exception (with correct message) is propagated.\n     - Tests also verify logging behavior for missing files (indirectly) and ensure no exceptions are raised when only one of the two files exists.\n\n5. **CHANGELOG and discussions**\n   - The change was documented as a breaking behavior change in `CHANGELOG.rst` under the \"in development\" section, noting that action delete now also deletes files from disk and that `-f`/`--force` were added to the CLI.\n   - There was substantial discussion around conceptual impact: historically, StackStorm did not mutate pack files because Git / IaC was treated as the source of truth. Reviewers debated whether to keep the endpoint backward compatible by adding a `delete_on_disk` boolean parameter, but the final decision for this PR was to change the behavior directly and rely on documentation and user feedback.\n   - Later comments from users (e.g. `nzlosh` and `cognifloyd`) pointed out that the new behavior made it impossible to remove just the DB entry in non-interactive contexts, and that read-only pack filesystems (e.g., in Kubernetes-based `stackstorm-ha`) would cause consistent 500 errors on delete. They requested a follow-up PR, possibly introducing configuration or an API option, since the current behavior is problematic for those deployments and for scripts expecting DB-only deletion.\n\nIn summary, this PR made the action deletion API delete both the database registration and the corresponding pack files on disk, added interactive confirmation and `--force` flags in the CLI, centralized and hardened the file deletion logic, and documented the behavior as a breaking change. It also exposed new edge cases: read-only filesystems and users wanting DB-only deletion, which are to be addressed in future work.",
        "semantic_memory": "This case illustrates several generalizable patterns about designing APIs and CLI tools that manage both database records and filesystem resources:\n\n1. **DB + filesystem operations should be coordinated and treated as a single logical transaction**\n   - When an operation conceptually means \"delete a resource\", and that resource exists in both the database and the filesystem, the system must avoid leaving them in a conflicting state. A naive implementation that deletes only from the DB or that treats file deletion as best-effort can lead to confusing behavior (e.g., resources resurrecting themselves on reload).\n   - While full ACID-like atomicity across DB and filesystem may not be feasible, the API should: (a) define a clear order of operations, and (b) treat failure in either part as a failure of the entire operation, surfacing clear errors.\n\n2. **Centralize common filesystem logic in a service layer**\n   - Code that computes paths and manipulates files (like action entrypoints and metadata) should live in a shared service module (e.g., `st2common.services.packs`) and reuse existing helpers (`get_pack_base_path`). This avoids duplication, ensures consistent behavior across features, and makes testing easier.\n\n3. **Surface precise, user-appropriate error messages while logging full context**\n   - For operational errors like file deletion failures, it's useful to:\n     - Log detailed error context and stack traces for operators and debugging.\n     - Raise specific exception types (`PermissionError`, `ResourceDiskFilesRemovalError`) with concise, user-facing messages that explain what happened and what to do next.\n   - The API converts these exceptions into HTTP 500 responses, ensuring clients see the failure instead of assuming success.\n\n4. **Design CLI UX for both interactive and automated use**\n   - Destructive operations that modify the filesystem should prompt for confirmation in interactive usage to prevent accidental data loss.\n   - The same commands should offer an explicit non-interactive override flag (e.g. `-f`/`--force`) so scripts and automation can run without blocking.\n   - Flags must be designed carefully to avoid breaking existing scripts, particularly around default behaviors vs new optional behaviors.\n\n5. **Breaking changes require explicit documentation and early design consideration**\n   - Changing an API from \"DB-only delete\" to \"DB + filesystem delete\" is a breaking change for any clients that relied on the previous behavior, including tools that expect to manage the filesystem via Git or deployment pipelines.\n   - These changes should be documented in changelogs and upgrade notes, and ideally considered for feature flags or backward-compatible new parameters (`delete_on_disk`), especially for widely used APIs.\n   - Community feedback may reveal deployment models (e.g., read-only pack volumes in HA environments) that make certain behavior untenable. Configuration toggles or mode-specific behavior may be necessary.\n\n6. **Testing filesystem interactions robustly**\n   - For production code that mutates files, tests should cover:\n     - Normal cases (files exist and are removed).\n     - Missing files (no-op with warnings).\n     - Permission errors and unexpected exceptions via mock-based fault injection.\n   - Tests should use fixture directories and paths built with `os.path.join` (not hard-coded absolute strings) for portability.\n\n7. **Ordering and granularity of error handling matters**\n   - Splitting DB and filesystem operations into separate try/except blocks clarifies which part failed and ensures that an error in one does not accidentally swallow or mask the other.\n   - It is usually better to fail loudly than to silently log and continue when the user’s mental model of the operation (\"delete this action\") has not actually been satisfied.\n\nThese patterns apply to many systems that have configuration defined both in the database and on disk (or in any secondary store) and to any CLI/API that must serve both interactive users and automated scripts.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the resource lifecycle scope\n- Determine whether a 'resource delete' should affect only the database, only the filesystem, or both.\n- Inspect current behavior: does deleting via the API/CLI remove files, DB entries, or some combination? Look for symptoms like resources reappearing after reload if only DB entries are removed.",
            "Step 2: Decide and document the intended behavior\n- Gather stakeholder input (users, operators, infra-as-code maintainers) about expectations.\n- If you change behavior (e.g., from DB-only to DB+filesystem deletion), treat it as a breaking change.\n- Update changelogs and upgrade notes early, stating what changed and how users can adapt.",
            "Step 3: Centralize resource deletion logic\n- Create or extend a service-level function (e.g., `delete_action_files_from_pack`) that encapsulates path calculation and file deletion for the resource.\n- Use existing helpers to determine base paths (e.g., `get_pack_base_path(pack_name)`), then build file paths with `os.path.join`.\n- Export this helper so API controllers and other layers can call it rather than duplicating logic.",
            "Step 4: Implement robust filesystem deletion with clear error handling\n- For each file:\n  - Check `os.path.isfile(path)` to decide if it should be removed.\n  - Call `os.remove(path)` in a try/except block.\n  - On `PermissionError`, log a clear error and re-raise `PermissionError` with a human-readable message like `No permission to delete \"<path>\" file from disk`.\n  - On other exceptions, log the full exception (path + error) and raise a custom exception (e.g., `ResourceDiskFilesRemovalError`) saying the file could not be removed and advising admins to check logs/delete manually.\n  - If the file does not exist, log a warning and do not treat this as a failure.",
            "Step 5: Integrate filesystem deletion into the API endpoint\n- In the API controller for DELETE operations:\n  - First, perform the DB deletion (`Action.delete(action_db)` etc.) in its own try/except. On failure, log and return an HTTP 500.\n  - Then call the centralized filesystem deletion function in a second try/except block.\n  - Catch `PermissionError` and custom exceptions, log them, and use the HTTP router's `abort()` (or similar) to return a 5xx error with the exception message.\n  - Ensure that a failure in filesystem deletion produces a non-2xx HTTP response so clients know the operation was not fully completed.",
            "Step 6: Adjust CLI behavior for interactive and non-interactive usage\n- Identify which CLI commands should be aware of filesystem deletion (e.g., `st2 action delete`).\n- Add a confirmation prompt for interactive users explaining that files on disk will be removed.\n- Introduce a `--force` (and possibly `-f`) option that skips the prompt and assumes 'yes', suitable for scripts.\n- Wire the CLI flags so they only affect relevant commands (e.g., ActionDeleteCommand), not all resource deletion commands.\n- Ensure success and failure messages accurately describe what was deleted (DB and disk).",
            "Step 7: Write comprehensive tests\n- Create unit tests for the service function:\n  - Normal deletion where both entrypoint and metadata files exist and are removed.\n  - Only one of the files exists (should still succeed, logging warnings for the missing file).\n  - Missing files (no exceptions, only warnings).\n  - Mock `os.remove` to raise `PermissionError` and assert that `PermissionError` with the right message is raised.\n  - Mock `os.remove` to raise a generic `Exception` and assert that your custom error (`ResourceDiskFilesRemovalError`) and message are raised.\n- Write tests for API behavior if possible (e.g., integration tests) to verify that delete endpoints return 500 when filesystem deletion fails.\n- For CLI, test that `--force` bypasses prompts and that the prompt appears when `--force` is not provided.",
            "Step 8: Consider deployment models and backward compatibility\n- Evaluate environments where the filesystem might be read-only (e.g., Kubernetes pods with read-only volumes) and how your delete logic behaves there (likely consistent `PermissionError`).\n- If necessary, introduce a configuration setting (in a config file) or an API parameter (e.g., `delete_on_disk=false`) to allow DB-only deletion, especially for existing scripts and HA deployments.\n- Document these behaviors and configuration options so operators can choose appropriate modes.",
            "Step 9: Monitor and iterate\n- After deploying the change, monitor logs and user reports for unexpected 500 errors on delete or complaints about behavior changes.\n- Be prepared to add feature flags, config options, or additional parameters if the new behavior proves too disruptive in some environments."
        ]
    }
}
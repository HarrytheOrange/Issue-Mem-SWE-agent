{
    "search_index": {
        "description_for_embedding": "Home Assistant integration for Melissa Climate A/C and sensors: add a core melissa component plus climate and sensor platforms, wire them to the py-melissa-climate API, handle API changes (status(cached=True), constants on the client), robustly map external modes/fan states to Home Assistant states with fallbacks and logging, and add full unit test coverage.",
        "keywords": [
            "homeassistant",
            "melissa",
            "climate",
            "sensor",
            "py-melissa-climate",
            "integration",
            "third-party API",
            "entity state mapping",
            "KeyError handling",
            "status(cached=True)",
            "DATA_MELISSA",
            "load_platform",
            "PRECISION_WHOLE",
            "unit tests",
            "fixtures",
            "MockDependency"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced and then iteratively refined a new Home Assistant integration for Melissa Climate devices. Initially, a basic `melissa` component was added along with support for climate entities, but the implementation had several rough edges: an incorrect docstring, direct usage of the melissa module constants inside entity methods, and no robust error handling or tests. Over subsequent commits the author:\n\n1. **Core component (`homeassistant/components/melissa.py`)**:\n   - Defined a `melissa` domain with `CONFIG_SCHEMA` accepting `username` and `password`.\n   - Instantiated the `melissa.Melissa` API client with keyword arguments and stored it in `hass.data[DATA_MELISSA]` for use by dependent platforms.\n   - Used `load_platform` to load both `sensor` and `climate` platforms, passing an empty discovery payload.\n   - Updated the dependency to `py-melissa-climate==1.0.1` to match a newer API version.\n\n2. **Sensor platform (`homeassistant/components/sensor/melissa.py`)**:\n   - Added `MelissaTemperatureSensor` and `MelissaHumiditySensor` entities, each tied to a Melissa device. Sensors share an API instance via `hass.data[DATA_MELISSA]` and use `api.fetch_devices()` to discover devices.\n   - Removed an initial `MelissaConnection` helper and change-threshold smoothing, simplifying updates to direct calls to `api.status(cached=True)`.\n   - Entity naming was adjusted from 'Melissa {serial} {type}' to '{device[\"name\"]} {type}', making names more human-friendly.\n   - Added robust update behavior: `update()` wraps status access in `try/except KeyError`. If the API response is missing the device or field, it logs a warning and leaves `state` as `STATE_UNKNOWN` instead of throwing.\n   - Tests (`tests/components/sensor/test_melissa.py`) mock the Melissa API, load JSON fixtures (`melissa_fetch_devices.json`, `melissa_status.json`), assert name, state, and unit_of_measurement, and verify that KeyError scenarios result in `STATE_UNKNOWN` without crashing.\n\n3. **Climate platform (`homeassistant/components/climate/melissa.py`)**:\n   - Implemented `MelissaClimate(ClimateDevice)` to represent an A/C unit per Melissa controller.\n   - The setup function obtains `api = hass.data[DATA_MELISSA]`, calls `api.fetch_devices().values()`, and constructs a `MelissaClimate` instance per device.\n   - The entity stores a reference to the API and serial number; on `update()` it calls `api.status(cached=True)[serial]` and `api.cur_settings(serial)['controller']['_relation']['command_log']` to refresh telemetry and settings. This is wrapped in `try/except KeyError` with a logged warning if fetch fails.\n   - All external constants (STATE, MODE, FAN, TEMP, and the numeric values for modes/fans/states) are accessed via attributes on the API object (`self._api.STATE_ON`, `self._api.MODE_HEAT`, etc.) instead of importing from the melissa module in each method, making the code more robust to library changes and easier to test.\n   - Mappings from Melissa-specific values to Home Assistant's concepts are encapsulated in methods:\n     - `melissa_state_to_hass()`: maps Melissa state values to `STATE_ON`, `STATE_OFF`, `STATE_IDLE`, or `STATE_UNKNOWN`.\n     - `melissa_op_to_hass()`: maps operation modes to `STATE_AUTO`, `STATE_HEAT`, `STATE_COOL`, `STATE_DRY`, `STATE_FAN_ONLY`, or `STATE_UNKNOWN` and logs a warning for unknown modes.\n     - `melissa_fan_to_hass()`: maps fan speeds to `STATE_AUTO`, `SPEED_LOW`, `SPEED_MEDIUM`, `SPEED_HIGH`, or `STATE_UNKNOWN` and logs a warning when mapping fails.\n     - `hass_mode_to_melissa()` and `hass_fan_to_melissa()` provide reverse mappings, with warnings when Home Assistant provides a mode/fan that Melissa does not support.\n   - `current_temperature`, `current_operation`, `current_fan_mode`, `is_on`, `target_temperature`, and `state` all rely on `_data` and `_cur_settings`, but gracefully handle missing data by logging and returning `STATE_UNKNOWN` or `None` rather than raising exceptions.\n   - The class declares capabilities correctly: `supported_features` returns the bitmask of `SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE | SUPPORT_ON_OFF | SUPPORT_FAN_MODE`; `temperature_unit` returns `TEMP_CELSIUS`; `target_temperature_step` uses `PRECISION_WHOLE`; and fixed `min_temp`/`max_temp` return 16 and 30 degrees.\n   - Outgoing commands (`set_temperature`, `set_fan_mode`, `set_operation_mode`, `turn_on`, `turn_off`) are funneled through a `send()` helper that updates `_cur_settings` locally and calls `api.send(serial, _cur_settings)`. If the send fails, `_cur_settings` is rolled back to its previous value and `False` is returned.\n   - Unit tests (`tests/components/climate/test_melissa.py`) are extensive. They:\n     - Use `Mock` to create a fake API object with the same interface as the real melissa API, assigning constants (STATE_*, MODE_*, FAN_*, and string keys like 'state', 'mode', 'fan', 'temp').\n     - Load fixture files for devices, current settings, and status.\n     - Patch `melissa.MelissaClimate` in `test_setup_platform` to verify that setup uses `DATA_MELISSA` and calls `add_devices` with the created entities.\n     - Validate all properties (name, on/off, current fan mode, current temperature, target temperature, operation/fan lists, state, temperature unit, min/max temperature, supported_features).\n     - Test mutation methods (set_temperature, set_fan_mode, set_operation_mode, turn_on, turn_off) and ensure that the API is invoked, local state is adjusted, and return values reflect API success.\n     - Simulate send failures and confirm that `_cur_settings` is rolled back and that entity behavior degrades gracefully.\n     - Use `asynctest.mock.patch` and `_LOGGER.warning` to assert that incorrect or unmappable values produce appropriate log warnings, and that KeyError in `update()` produces a warning without crashing.\n\n4. **Testing & coverage**:\n   - The `.coveragerc` entries that previously omitted the melissa component and platforms were removed, enforcing coverage for new code.\n   - The tests ensure near-100% coverage of control flow, including edge cases like missing data and unknown mapping values.\n\nOverall, this PR is less about a single crash bug and more about evolving a new integration from a naive first draft to a robust, tested implementation that correctly consumes a third-party API, exposes entities to Home Assistant, and handles error conditions politely.",
        "semantic_memory": "This PR embodies several general patterns and best practices for integrating third‑party device APIs into a Home Assistant-like framework:\n\n1. **Central API client and platform separation**:\n   - Use a top-level component (here `homeassistant/components/melissa.py`) to create and configure the external API client once, then share it across platforms via a central registry (e.g., `hass.data[DATA_FOO]`).\n   - Dependent platforms (e.g., `climate.foo`, `sensor.foo`) declare `DEPENDENCIES = [DOMAIN]` and retrieve the shared client from `hass.data`, avoiding repeated logins and configuration parsing.\n\n2. **Explicit mapping layer between external API and internal states**:\n   - External APIs often expose domain-specific constants (e.g., numeric codes for modes and fans). Wrap these mappings in well-named helper methods (`vendor_mode_to_hass`, `hass_mode_to_vendor`, etc.) instead of sprinkling `if`/`elif` checks throughout the code.\n   - Import or inject constants from the API client instead of the raw module to decouple the integration from the library’s module-level namespace and to simplify testing.\n   - Always include a default branch that returns a safe fallback (e.g., `STATE_UNKNOWN`) and logs a warning when the mapping fails. This gracefully handles firmware/API changes and unexpected values.\n\n3. **Robust error handling in update loops**:\n   - Device status and settings often arrive as nested JSON structures accessed by IDs. Use `try/except (KeyError, AttributeError)` in `update()` methods to catch missing keys or malformed data rather than letting exceptions propagate into the core.\n   - When status cannot be retrieved, keep entity `state` as `STATE_UNKNOWN` or leave it unchanged, and log a warning that includes the entity ID. This makes integrations resilient to transient backend issues.\n   - Where the API exposes caching options (e.g., `status(cached=True)`), prefer them in periodic update methods to reduce backend load and latency.\n\n4. **Predictable behavior for write operations**:\n   - Aggregate outgoing state into a single settings dict that mirrors the remote device’s expected command payload; have a single `send()` function that updates the local copy and dispatches it to the API.\n   - On failure, roll back local state to the last known-good configuration to avoid discrepancies between what the integration thinks is set and what the device actually uses.\n   - Return booleans from command methods to indicate success/failure; tests can then assert correct behavior in both cases.\n\n5. **Entity and configuration design**:\n   - Name entities based on user-visible device names plus an indicator (e.g., `\"{name} temperature\"` instead of serial numbers) for better UX.\n   - Use framework-provided constants for units and capabilities (`TEMP_CELSIUS`, `PRECISION_WHOLE`, `SUPPORT_*`), ensuring consistency and avoiding magic numbers.\n\n6. **Testing practice for device integrations**:\n   - Mock the external API client instead of performing real network I/O. Provide JSON fixtures that reflect actual API responses (`fetch_devices`, `status`, `cur_settings`) to keep tests representative and stable.\n   - Set up the mocked client to expose the same constants and methods as the real library (e.g., `.STATE_ON`, `.MODE_COOL`, `.FAN_HIGH`, `.TEMP` string keys) so the integration is tested against realistic contracts.\n   - Validate both the happy path and failure modes: unknown mode mapping, unsuccessful sends, missing keys, and unexpected responses should all be covered.\n   - Remove the component from coverage ignore lists once tests exist; this encourages thorough test coverage and guards against regressions.\n\nThese patterns generalize to any integration layer that sits between a home automation platform and a third-party cloud or device SDK: centralize client instantiation, abstract mapping of states, handle missing/bad data defensively, and treat tests and fixtures as first‑class citizens when evolving functionality or upgrading underlying dependencies.",
        "procedural_memory": [
            "How to build and harden a new Home Assistant integration for a third-party climate/sensor API:",
            "Step 1: Create a core component to own the API client.",
            " - Define a new domain module (e.g., `components/foo.py`) with a `CONFIG_SCHEMA` that validates credentials and configuration via voluptuous.",
            " - In `setup(hass, config)`, read config values, instantiate the third-party client, and store it in `hass.data[DATA_FOO]` or similar. Use keyword arguments and the library’s documented constructor signature.",
            " - Call `load_platform(hass, 'climate', DOMAIN, {})`, `load_platform(hass, 'sensor', DOMAIN, {})`, etc. to bootstrap dependent platforms, keeping discovery_info simple unless more context is needed.",
            " - Add the external library to `REQUIREMENTS` and to `requirements_all.txt`, pinning a tested version.",
            "",
            "Step 2: Implement climate/sensor platforms that consume the shared client.",
            " - In each platform module (e.g., `components/climate/foo.py`, `components/sensor/foo.py`), declare `DEPENDENCIES = [DOMAIN]` and import `DATA_FOO` from the core component.",
            " - In `setup_platform(...)`, retrieve the client via `api = hass.data[DATA_FOO]` and call `api.fetch_devices()` (or equivalent) to enumerate devices.",
            " - Create one entity instance per relevant device and call `add_devices(entities)` unconditionally (the list may be empty).",
            " - Store the API client and device identifiers on each entity so they can call `status`, `cur_settings`, and `send` as needed.",
            "",
            "Step 3: Map external states and modes to internal semantics.",
            " - Identify all state and mode constants provided by the API client (e.g., `api.STATE_ON`, `api.MODE_HEAT`, `api.FAN_HIGH`) and expose them via attributes on the mocked API in tests.",
            " - Implement helper methods like `vendor_state_to_hass(value)`, `vendor_mode_to_hass(value)`, `vendor_fan_to_hass(value)`, and their inverses. Use the framework’s constants (`STATE_ON`, `STATE_COOL`, `SPEED_LOW`, etc.).",
            " - Always handle unexpected values: return `STATE_UNKNOWN` (or a safe default) and log a warning, including the raw value and sometimes the entity ID.",
            "",
            "Step 4: Implement robust update logic.",
            " - In each entity’s `update()` method, call the API’s status methods (preferably with caching flags like `status(cached=True)` if supported) to read the latest data, using the device’s ID or serial as a key.",
            " - Use `try/except KeyError` around nested dict lookups. If a device ID is missing or the API response shape changed, log a warning and keep local state as `STATE_UNKNOWN` or unchanged.",
            " - Similarly, retrieve current settings (e.g., `cur_settings(serial)['controller']['_relation']['command_log']`) inside a try/except block, and log if this fails.",
            "",
            "Step 5: Implement write operations with rollback.",
            " - Maintain a `_cur_settings` dict representing the device’s command payload. When higher-level methods like `set_temperature`, `set_fan_mode`, or `set_operation_mode` are invoked, build a delta dict `{api.TEMP: temp}` etc.",
            " - Implement a `send(delta)` helper that: (1) copies `_cur_settings`, (2) updates it with the delta, (3) calls `api.send(serial, _cur_settings)`, (4) on failure, restores the old settings and returns `False`, and (5) on success, returns `True`.",
            " - Call this helper from `turn_on`/`turn_off` by setting the relevant state constant.",
            "",
            "Step 6: Handle missing data and edge conditions gracefully.",
            " - For properties like `current_temperature`, `current_operation`, `current_fan_mode`, `is_on`, and `target_temperature`, always consider that their backing data (`_data`, `_cur_settings`) might be `None` or partial.",
            " - When data is missing, log an informative message (including `self.entity_id` where possible) and return `STATE_UNKNOWN` or `None` instead of raising.",
            " - Use the framework’s constants like `PRECISION_WHOLE`, `TEMP_CELSIUS`, `SUPPORT_*` to properly describe capabilities.",
            "",
            "Step 7: Write unit tests with fixtures and mocks.",
            " - Build JSON fixtures mirroring real API responses for device lists, status, and settings, and store them under `tests/fixtures/`.",
            " - In tests, create a mocked API object with attributes and methods matching the real client: constants (STATE_*, MODE_*, FAN_*), string keys (e.g., `TEMP = 'temp'`), and methods (`fetch_devices`, `status`, `cur_settings`, `send`). Have those methods return the fixtures.",
            " - For setup tests, patch the entity class (e.g., `@patch('homeassistant.components.climate.foo.FooClimate')`) and verify that `setup_platform` reads `hass.data[DATA_FOO]` and calls `add_devices` with the resulting entities.",
            " - For entity tests, instantiate the entity directly with the mock API and a device fixture, call `update()`, and assert that properties (name, state, temperature, fan mode, operation, supported_features) match expectations.",
            " - Test write operations by setting `api.send.return_value` to True/False and verifying both success behavior and rollback behavior.",
            " - Use `patch('module._LOGGER.warning')` to assert that unknown modes, mapping failures, or KeyError conditions produce appropriate warnings, improving observability.",
            " - Remove the component/platform from `.coveragerc`'s omit list so coverage tools track it; use tests to drive coverage up.",
            "",
            "Step 8: Update dependencies carefully.",
            " - When the third-party library changes (e.g., adding a `cached` parameter to `status()` or moving constants from module-level to instance attributes), bump the pinned version, adapt your code to the new API surface, and adjust mocks and tests accordingly.",
            " - Re-run tests and confirm both functional correctness and that error handling paths still behave as expected."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Adds interactive pack configuration to StackStorm: a new CLI command `st2 pack config` that reads a pack's config schema, walks the user through an interactive prompt (supporting strings, booleans, numbers, integers, enums, arrays, nested objects, and secret fields), validates input with jsonschema, optionally opens the generated YAML in a text editor for review, and then saves it via a new API endpoint to /opt/stackstorm/configs/<pack>.yaml. Includes graceful interruption handling, tests for the interactive readers, and ensures the configs directory exists in the dev launcher.",
        "keywords": [
            "StackStorm",
            "interactive configuration",
            "pack config",
            "st2 pack config",
            "prompt_toolkit",
            "jsonschema",
            "python-editor",
            "YAML config",
            "ConfigAPI",
            "ConfigSchema",
            "ConfigManager",
            "DialogInterrupted",
            "ReaderNotImplemented",
            "boolean input",
            "array enum",
            "secret fields",
            "/opt/stackstorm/configs",
            "launchdev.sh"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set implements interactive pack configuration for StackStorm.\n\nPreviously, users configured packs only by manually editing YAML files under /opt/stackstorm/configs or similar locations. There was no guided or interactive CLI flow, no easy validation against the pack's config schema, and the configs directory might not even exist in a fresh dev environment. The team also wanted basic type support (booleans, arrays, etc.) and better UX around interruptions and defaults.\n\nTo address this, the PR introduces multiple coordinated components:\n\n1. **New API endpoint for configs**\n- In `st2api/st2api/controllers/v1/pack_configs.py`, a `put` method is added to `PackConfigsController` using `ConfigUpdateRequestAPI`. It:\n  - Requires `PACK_CREATE` permission.\n  - Accepts a JSON body, wraps it into `ConfigAPI(pack=pack_ref, values=...)` and calls `config_api.validate(validate_against_schema=True)` which uses jsonschema to validate against the pack's config schema.\n  - On jsonschema `ValidationError`, it raises `ValueValidationException` to return a clean API error.\n  - Serializes the validated values with `yaml.safe_dump` and writes to `{cfg.CONF.system.base_path}/configs/<pack>.yaml`.\n  - Returns the `ConfigAPI` object on success.\n\n2. **Client-side models and managers**\n- New `Config` and `ConfigSchema` resources are added in `st2client/st2client/models/config.py` and exported in `st2client/st2client/models/__init__.py`.\n- A `ConfigManager` is implemented in `st2client/st2client/models/core.py`, with a custom `update` method that issues `PUT /configs/<pack>` with `instance.values` and deserializes the response.\n- In `st2client/st2client/client.py`, new managers are registered: `'Config'` using `ConfigManager` and `'ConfigSchema'` using a generic `ResourceManager` pointing to the `config_schemas` API.\n\n3. **Interactive CLI command**\n- In `st2client/st2client/commands/pack.py`, a new subcommand `pack config` is introduced as `PackConfigCommand`.\n- Flow:\n  - Fetch config schema via `self.app.client.managers['ConfigSchema'].get_by_ref_or_id(args.name, **kwargs)`.\n  - If no schema, raise `ResourceNotFoundError` indicating the pack lacks a config schema.\n  - Use `interactive.InteractiveForm(schema.attributes).initiate_dialog()` to drive an interactive session collecting config values according to the JSON schema.\n  - Ask: `Do you want to preview the config in an editor before saving?` via `interactive.Question`, with description warning: `Secrets would be shown in plain text.`\n    - If yes, dump the config to YAML, open it with `editor.edit(..)` (python-editor), then re-load the edited YAML with `yaml.safe_load`.\n  - Ask: `Do you want me to save it?` via another `Question`; if user answers `n`, raise `OperationFailureException('Interrupted')`.\n  - If confirmed, call `self.app.client.managers['Config'].update(Config(pack=args.name, values=config))` to push and persist the config.\n  - `run_and_print` wraps `run`, printing the resulting config using `PropertyValueTable`, and handles `KeyboardInterrupt` / general exceptions by turning them into `OperationFailureException` with user-friendly messages.\n\n4. **Interactive schema-driven input system**\n- `st2client/st2client/utils/interactive.py` introduces a generic interactive form engine based on `prompt_toolkit` and `jsonschema`:\n\n  - **Infrastructure:**\n    - `MuxValidator`: a custom `prompt_toolkit.validation.Validator` that multiplexes multiple validator callables on each input.\n    - `ReaderNotImplemented`: exception signaling an unsupported type or structure.\n    - `DialogInterrupted`: exception signaling a user-initiated interruption (Ctrl+C) that should abort the form.\n\n  - **Base reader:**\n    - `StringReader` implements fundamental behavior for scalar prompts:\n      - Accepts `name`, `spec` (schema fragment), `prefix`, and `secret` flag.\n      - Configures `prompt` call with `is_password` when `secret=True` to hide input.\n      - `description` from schema is rendered in a bottom toolbar via `get_bottom_toolbar_tokens`.\n      - Outputs templates like `name: ` or `name [default]: `.\n      - Uses `jsonschema.validate` (Draft3) on the raw input (or typed variant in subclasses) and raises `prompt_toolkit.validation.ValidationError` on failure.\n      - Returns default if user presses Enter without input.\n\n  - **Typed readers:**\n    - `BooleanReader` for `type: boolean`:\n      - Accepts flexible inputs: `1, y, yes, true` vs `0, n, no, nope, nah, false` (case-insensitive), defined as `POSITIVE_BOOLEAN` / `NEGATIVE_BOOLEAN` sets.\n      - Template: `name (boolean) [y|n]: ` with default shown as `y` when default is true, `n` when false.\n      - Validates membership in allowed boolean words and converts to actual Python `True` / `False`.\n\n    - `NumberReader` for `type: number`:\n      - Template: `name (float) [default]: `.\n      - Converts input to `float`; errors become validation errors.\n      - After conversion, still passes the value through jsonschema validation.\n\n    - `IntegerReader` for `type: integer`:\n      - Template: `name (integer) [default]: `.\n      - Converts input to `int`; errors become validation errors.\n      - Also applies jsonschema constraints afterward.\n\n    - `SecretStringReader` for fields with `secret: true`:\n      - Template: `name (secret) [default]: `.\n      - Uses `is_password=True` to hide user input.\n      - Otherwise behaves like `StringReader`.\n\n    - `EnumReader` for scalar enums:\n      - Condition: schema has `enum` and not an array.\n      - Renders choices as numbered list:\n        - Example: `name: \\n 0 - some\\n 1 - thing\\n 2 - else\\nChoose from 0, 1, 2 [1]: `.\n      - Validates that user inputs an integer index in range.\n      - Translates index to enum value.\n\n    - `ObjectReader` for `type: object`:\n      - For nested objects, recursively instantiates `InteractiveForm` on `properties`, prefixing field names with `parent.` (e.g., `db.host`).\n      - Uses `reraise=True` so interruptions bubble up cleanly.\n\n    - `ArrayReader` for `type: array` with primitive `items` (`string`, `integer`, `number`, `boolean`):\n      - Template: `name (comma-separated list) [a,b]: ` for default `['a', 'b']`.\n      - Validates each comma-separated element using `StringReader.validate` against the `items` schema.\n      - Returns a list of trimmed strings (or, conceptually, could be extended to typed values).\n      - For non-primitive array item types (e.g., arrays of objects), raises `ReaderNotImplemented` with a clear message: interactive mode does not yet support such arrays.\n\n    - `ArrayEnumReader` for `type: array` where `items.enum` is defined:\n      - Works like `EnumReader`, but supports multiple comma-separated indices.\n      - Template enumerates the enum values similarly, and default is shown as indices of defaults.\n      - Validates each index is numeric and within bounds.\n      - Returns list of enum values based on indices.\n\n  - **InteractiveForm orchestration:**\n    - `InteractiveForm.readers` defines precedence: `EnumReader`, `BooleanReader`, `NumberReader`, `IntegerReader`, `ObjectReader`, `ArrayEnumReader`, `ArrayReader`, `SecretStringReader`, `StringReader`.\n    - For each field in the schema:\n      - Finds the first reader whose `condition` returns `True`.\n      - If none is found, raises `ReaderNotImplemented('No reader for the field spec')`.\n      - Calls `reader.read()` to get the value.\n      - Catches `ReaderNotImplemented` inside the loop, prints a skip message, and continues.\n    - Global try/except wraps the loop to catch `DialogInterrupted` (which is raised when a reader sees a `KeyboardInterrupt`):\n      - If `reraise=False` (default), print `Dialog interrupted.` and return whatever partial results were collected.\n      - If `reraise=True`, propagate `DialogInterrupted` to callers (used by `ObjectReader` to bubble interruptions out of nested forms).\n\n  - **Question helper:**\n    - `Question` is a thin wrapper around `StringReader` used for yes/no prompts at the end of config flow (preview/edit and save decisions).\n\n5. **Tests for interactive behavior**\n- `st2client/tests/unit/test_interactive.py` thoroughly covers the interactive components:\n  - `InteractiveForm` reader selection and behavior when no reader matches.\n  - Handling of `KeyboardInterrupt`:\n    - Verifies `Dialog interrupted.` is printed with default behavior.\n    - Verifies `DialogInterrupted` is raised when `reraise=True`.\n  - Individual reader behavior using a patched `interactive.prompt` mock:\n    - For each reader (`StringReader`, `BooleanReader`, `NumberReader`, `IntegerReader`, `SecretStringReader`, `EnumReader`, `ArrayReader`, `ArrayEnumReader`), tests:\n      - Prompt message string.\n      - Description toolbar content.\n      - Validation behavior (including invalid inputs raising `prompt_toolkit.validation.ValidationError`).\n      - Default value handling when user input is empty.\n      - Password masking for secret fields via `is_password=True`.\n\n6. **Environment / requirement updates and directory management**\n- Dependencies:\n  - `python-editor` is added and pinned to `1.0.1` in both `requirements.txt`, `fixed-requirements.txt`, and `st2client` requirements.\n  - Client requirements change from plain `requests` to `requests[security]<2.12,>=2.11.1` and add `sseclient==0.0.12`.\n  - Some dependencies (e.g., `prompt_toolkit`, `jsonschema`) were managed via input requirements and/or removed from the generated `st2client/requirements.txt` to rely on central `in-requirements`/`fixed-requirements` generation.\n- `tools/launchdev.sh` is updated to ensure the configs directory exists when starting dev services:\n  - Reads `base_path` from `st2.conf`, defaults to `/opt/stackstorm` when absent.\n  - Derives `CONFIG_BASE_DIR=\"$BASE_DIR/configs\"`.\n  - If the directory does not exist, creates it with `sudo mkdir -p` and prints what it is doing.\n\nOverall, this PR implements an end-to-end path for interactive pack configuration: from schema discovery, through CLI-driven, schema-aware prompting with type support and interruption handling, to validated persistence of YAML configs on the server, while adding necessary tests and environment setup.",
        "semantic_memory": "This work illustrates a robust pattern for building schema-driven interactive configuration flows in CLI tools.\n\nKey generalizable concepts:\n\n1. **Schema-driven interactive forms**\n- Instead of hardcoding prompts, derive the UI from a formal schema (e.g., JSON Schema). This decouples the configuration UX from specific packs or modules: new fields or types can be added by changing the schema rather than modifying code.\n- A registry of type-specific readers (e.g., BooleanReader, NumberReader, EnumReader, ObjectReader) allows you to map schema fragments to interactive prompts dynamically.\n- Type readers can use the schema not just for prompt text and defaults, but also to enforce constraints (via jsonschema or custom validation logic) at input time.\n\n2. **Composable, extensible reader architecture**\n- Define a base reader with standard behaviors (default value handling, prompt construction, description/tooltips, validation integration) and subclass it for specific types.\n- Have a prioritized list of readers with a `condition(spec)` function that determines applicability. This allows flexible extension (add readers for new types such as `array of objects` or `date/time` without disrupting existing code).\n- For nested objects, recurse into the form logic rather than treating them as a special case in the top-level flow.\n\n3. **Integrating validation into UX**\n- Use the same schemas and validation logic on both client and server:\n  - Client-side: use `jsonschema` + interactive validation to prevent invalid config entries before they are sent.\n  - Server-side: revalidate with jsonschema and surface semantic errors via typed API exceptions (e.g., `ValueValidationException`).\n- Convert validation failures into UI-native errors (e.g., prompt_toolkit `ValidationError`) so users can correct mistakes immediately.\n\n4. **Handling interruptions and partial input gracefully**\n- Interactive CLIs must handle `KeyboardInterrupt` (Ctrl+C) as a first-class flow:\n  - Catch it per-field and raise a domain-specific `DialogInterrupted` exception.\n  - Decide at the form level whether to swallow the interruption (printing a message and returning partial data) or re-raise for higher-level logic to handle.\n- This pattern lets you implement features such as \"restart from scratch\", \"switch to file-based editing\", or \"abort and roll back\" consistently.\n\n5. **Security and secrets in interactive UIs**\n- Fields that are sensitive (e.g., passwords, API keys) should be annotated in the schema (e.g., `secret: true`) and routed to a `SecretStringReader` that uses hidden input (`is_password=True`).\n- When offering a preview/edit step (e.g., opening YAML in a text editor), clearly warn users that secrets will be visible in plain text.\n- Avoid echoing secrets to stdout or logs. Let the user choose whether to reveal them via editor or other tools.\n\n6. **Enum and list UX improvements**\n- Present enums as numbered options, not as raw string lists. This reduces typos and makes validation trivial and user-friendly.\n- For array-of-enum cases, allow comma-separated indices; validate each independently to provide precise error feedback.\n- For array fields in general, treat inputs as comma-separated lists and re-use the item-type validator to validate each element.\n\n7. **File persistence and config directories**\n- When saving configuration, serialize structured data to a well-defined path using a stable format (e.g., YAML) with safe loaders/dumpers (`safe_dump`, `safe_load`).\n- Ensure required directories (like `/opt/stackstorm/configs`) exist at service startup or before writing. This prevents runtime IO errors and improves the developer experience in fresh environments.\n\n8. **Editor integration in CLI flows**\n- Offering an optional \"open in editor\" step (via a library like `python-editor`) is a powerful safety net: users can fine-tune or review generated configs outside of the constraints of an interactive wizard.\n- After editing, re-parse the content and reapply schema validation if necessary to catch manual mistakes.\n\n9. **Robust testing of interactive code**\n- Interactive code can be unit-tested by mocking the prompt function (e.g., `prompt_toolkit.prompt`) and asserting:\n  - Correct prompt messages and help text.\n  - Correct handling of defaults and various input values.\n  - Validation behavior on good and bad input.\n  - Secret fields toggling password mode.\n- Ensure that interruption paths (`KeyboardInterrupt`) are covered and produce expected messages or exceptions.\n\nThese patterns apply to any application that needs to guide users through building structured configuration files or objects, especially when you have a schema and need both validation and a good CLI UX.",
        "procedural_memory": [
            "Design and implement a schema-driven interactive configuration CLI similar to this PR.",
            "Step 1: Define or reuse a formal configuration schema format (e.g., JSON Schema) for the resource you want to configure. Ensure the schema declares field types (string, integer, number, boolean, object, array, enum) and, if needed, custom hints such as `secret: true`.",
            "Step 2: On the server side, implement or extend an API endpoint that accepts a configuration object, wraps it in a model, and validates it against the schema using a library like `jsonschema`. On validation failure, translate errors into domain-specific exceptions (e.g., `ValueValidationException`) that produce clear API responses.",
            "Step 3: Decide on a persistence mechanism for the configuration (e.g., YAML files, JSON files, database). Implement serialization logic that takes the validated configuration and writes it to a deterministic location (like `/base_path/configs/<name>.yaml`) using safe serializers (`yaml.safe_dump`, `yaml.safe_load`). Ensure parent directories exist before writing.",
            "Step 4: On the client side, introduce resource models (e.g., `Config`, `ConfigSchema`) and managers. Implement a `ConfigManager.update` (or equivalent) that sends a `PUT` or `POST` request to the server with the configuration payload and handles error responses. Register these managers with your client so CLI commands can access them easily.",
            "Step 5: Build a generic interactive form engine. Create a base reader class that:\n- Accepts a field name and a schema fragment.\n- Constructs human-friendly prompts using the field name and any default values.\n- Displays descriptions or help text via toolbars or help messages.\n- Validates user input using jsonschema or custom logic and reports errors through your interactive library’s validation mechanism.",
            "Step 6: Implement type-specific readers by subclassing the base reader:\n- BooleanReader: parse flexible boolean expressions (e.g., y/yes/true, n/no/false) and map them to True/False.\n- NumberReader and IntegerReader: cast input to float/int, handle conversion errors, and apply schema constraints.\n- EnumReader: present enumerated options with indices, accept numbers, and map back to the enum values.\n- SecretStringReader: hide user input and mark prompts appropriately for secret values.\n- ObjectReader: recursively instantiate your InteractiveForm on nested `properties`.\n- ArrayReader and ArrayEnumReader: accept comma-separated values or indices, validate each element using the appropriate scalar reader, and build lists.",
            "Step 7: Implement an `InteractiveForm` orchestrator:\n- Maintain a prioritized list of reader classes, each with a `condition(spec)` function that determines applicability.\n- For each field in the schema, find the first reader whose condition is true.\n- Call `reader.read()` to collect a value, catching any `ReaderNotImplemented` exceptions to skip unsupported fields with a clear message.",
            "Step 8: Handle interruptions gracefully:\n- Wrap each `read()` call in a try/except for `KeyboardInterrupt`. On interrupt, raise a domain-specific `DialogInterrupted` exception.\n- In `InteractiveForm.initiate_dialog`, catch `DialogInterrupted`. Decide whether to print a message (e.g. `Dialog interrupted.`) and return partial results, or re-raise for callers to handle (e.g., to abort the whole configuration flow).",
            "Step 9: Optionally integrate an editor step:\n- After collecting config via your interactive form, serialize it to YAML or JSON and open it in the user’s preferred editor using a library like `python-editor`.\n- Warn the user if secrets will appear in plain text.\n- After the editor is closed, reload the content and, if appropriate, re-run validation to catch errors introduced during manual editing.",
            "Step 10: Add CLI commands that tie everything together:\n- Implement a `config` subcommand (e.g., `mytool pack config <name>`) that:\n  - Fetches the schema from the server.\n  - Runs `InteractiveForm(schema).initiate_dialog()` to collect configuration.\n  - Optionally opens the preview in an editor.\n  - Asks for confirmation to save.\n  - Calls the client `ConfigManager.update()` to persist the configuration.\n- Handle high-level exceptions (validation failures, interruptions) and print user-friendly errors.",
            "Step 11: Ensure environment readiness:\n- At service startup or in dev scripts, read `base_path` or equivalent setting and ensure the configuration directory exists (e.g., `/opt/stackstorm/configs`). Create it with appropriate permissions if missing, to avoid runtime errors when saving configs.",
            "Step 12: Write tests for interactive logic:\n- Mock your interactive prompt function to simulate user input.\n- Assert that prompts, default handling, and descriptions match expectations.\n- Validate that invalid inputs raise appropriate validation errors.\n- Verify that secret fields use password input mode.\n- Test interruption handling by making mocked readers raise `KeyboardInterrupt` and assert that the form prints the correct messages or raises your `DialogInterrupted` exception as intended."
        ]
    }
}
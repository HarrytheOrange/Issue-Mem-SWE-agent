{
    "search_index": {
        "description_for_embedding": "Home Assistant homekit_controller integration was extended to support Aqara (HomeKit 'contact') door/window sensors by mapping the HomeKit 'contact' service type to a binary_sensor platform and implementing a HomeKitContactSensor entity that tracks the CONTACT_STATE characteristic with an appropriate door device_class.",
        "keywords": [
            "homekit_controller",
            "Home Assistant",
            "Aqara door sensor",
            "window door sensor",
            "contact sensor",
            "CONTACT_STATE",
            "binary_sensor",
            "DEVICE_CLASS_DOOR",
            "DEVICE_CLASS_MOTION",
            "HomeKit service type mapping",
            "const.py",
            "async_setup_entry"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant homekit_controller integration lacked support for an Aqara door/window sensor exposed via HomeKit as a 'contact' service. Only motion sensors were supported as binary sensors. The contributor added support by updating the binary_sensor platform and the service-type-to-platform mapping. In homeassistant/components/homekit_controller/const.py, the mapping dict was extended so that the HomeKit service type 'contact' is recognized and routed to the 'binary_sensor' platform. In homeassistant/components/homekit_controller/binary_sensor.py, async_setup_entry was modified so that when it encounters a service with stype == 'contact', it instantiates a new HomeKitContactSensor entity (wired similarly to the existing motion sensor). A new HomeKitContactSensor class was introduced, inheriting from HomeKitEntity and BinarySensorDevice. It tracks the HomeKit CONTACT_STATE characteristic (from homekit.model.characteristics.CharacteristicsTypes) and stores the state in a boolean _on member. The device_class property was set to DEVICE_CLASS_DOOR so that Home Assistant treats it as a door sensor, and is_on returns the _on value. At the same time, the existing motion sensor entity was updated to use the symbolic DEVICE_CLASS_MOTION constant instead of the raw string 'motion'. This made Aqara door/window sensors show up correctly as binary sensors in Home Assistant via homekit_controller. Although this specific PR was later closed in favor of a similar, merged PR, it demonstrates the pattern for adding support for new HomeKit accessory types.",
        "semantic_memory": "To add support for a new HomeKit accessory type in Home Assistant's homekit_controller integration, you must (1) map the HomeKit service type to a Home Assistant platform and (2) implement an entity class that binds specific HomeKit characteristics to Home Assistant state and metadata (like device_class). The mapping lives in a central const.py, where service-type strings such as 'contact', 'motion', 'light', etc., are associated with platforms like 'binary_sensor' or 'sensor'. The platform module (e.g., binary_sensor.py) is responsible for listening to HomeKit services, recognizing those with specific service types (stype), and creating the appropriate entity types. Each entity subclass of HomeKitEntity is responsible for declaring which characteristic types it cares about, updating its internal state when those characteristics change, and exposing Home Assistant properties like is_on and device_class. Using standardized device_class constants (e.g., DEVICE_CLASS_DOOR, DEVICE_CLASS_MOTION) rather than raw strings ensures consistent behavior and UI representation across the system. This pattern generalizes to any new HomeKit device: define how its service type maps to a platform, implement characteristic handling, and assign the correct device_class.",
        "procedural_memory": [
            "To add or fix support for a new HomeKit accessory in Home Assistant's homekit_controller integration:",
            "Step 1: Identify the HomeKit service type and characteristics for the accessory.\n- Inspect the accessory via HomeKit to find its service type string (e.g., 'contact', 'motion', 'light-sensor').\n- Determine which characteristic(s) represent its main state (e.g., CONTACT_STATE, MOTION_DETECTED).",
            "Step 2: Map the HomeKit service type to a Home Assistant platform.\n- Open homeassistant/components/homekit_controller/const.py.\n- In the service-type-to-platform mapping dict, add an entry mapping the service type to the correct platform (e.g., 'contact': 'binary_sensor').\n- This ensures the correct platform module (binary_sensor, sensor, cover, etc.) is invoked when that service type is discovered.",
            "Step 3: Extend the platform's async_setup_entry to handle the new service type.\n- Open the relevant platform module, e.g., homeassistant/components/homekit_controller/binary_sensor.py.\n- In async_setup_entry, adjust the async_add_service callback to detect services with the new stype (e.g., if service['stype'] == 'contact').\n- For that service type, construct an info dict with the aid and iid, and call async_add_entities with an instance of your new entity class (e.g., HomeKitContactSensor(conn, info)) and True for initial update.",
            "Step 4: Implement a HomeKitEntity subclass for the new accessory type.\n- Create a new class, e.g., HomeKitContactSensor(HomeKitEntity, BinarySensorDevice).\n- Initialize any internal state (e.g., self._on = False in __init__).\n- Implement get_characteristic_types to return a list of characteristic types to track. Import homekit.model.characteristics.CharacteristicsTypes and return the relevant constant(s), e.g., [CharacteristicsTypes.CONTACT_STATE].\n- Implement update methods following the naming convention _update_<characteristic_name> (e.g., _update_contact_state(self, value)) that store the incoming characteristic values into internal state variables.\n- Implement the is_on property to translate the internal state to a Home Assistant boolean state.\n- Implement device_class and return the appropriate DEVICE_CLASS_* constant (e.g., DEVICE_CLASS_DOOR for door sensors, DEVICE_CLASS_MOTION for motion sensors). Avoid raw strings; use the constants from homeassistant.components.binary_sensor.",
            "Step 5: Use symbolic device_class constants instead of magic strings.\n- Import from homeassistant.components.binary_sensor: BinarySensorDevice and the relevant DEVICE_CLASS_* constants.\n- Update existing entities to return DEVICE_CLASS_* (e.g., DEVICE_CLASS_MOTION) instead of hard-coded strings like 'motion'. This improves consistency and reduces risk of typos.",
            "Step 6: Add tests mirroring existing entity tests.\n- Open the corresponding tests, e.g., tests/components/homekit_controller/test_binary_sensor.py.\n- Copy and adapt an existing test for a similar entity (e.g., motion sensor) to create one for the new contact sensor.\n- Ensure the test covers: discovery of the service, creation of the entity, update of state when the characteristic changes, and the correct device_class.",
            "Step 7: Run the test suite and static checks.\n- Run `tox` or the project's test runner to ensure all tests pass.\n- Fix any linting or import issues (e.g., long lines, unused imports) flagged by the tooling.",
            "Step 8: Verify behavior in a real or simulated environment.\n- Pair a device of the new type (e.g., Aqara door/window sensor) with HomeKit and then with homekit_controller.\n- Confirm that it is discovered as the expected Home Assistant entity type (binary_sensor) and that the device_class (door) and state changes reflect correctly in the UI."
        ]
    }
}
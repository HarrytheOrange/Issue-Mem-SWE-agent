{
    "search_index": {
        "description_for_embedding": "Home Assistant SmartThings integration enhanced to use SmartApp OAuth tokens, automatically synchronize capability subscriptions based on actual devices, and periodically refresh tokens. Includes a breaking migration that removes v1 config entries and re-triggers config flow, a refactored DeviceBroker to manage event handlers and token refresh, and smarter subscription diffing instead of wholesale delete/recreate.",
        "keywords": [
            "Home Assistant",
            "SmartThings",
            "SmartApp",
            "pysmartthings",
            "OAuth",
            "refresh_token",
            "access_token",
            "subscription synchronization",
            "config entry migration",
            "breaking change",
            "async_migrate_entry",
            "async_track_time_interval",
            "cloud_push",
            "webhook"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant SmartThings integration was reworked to eliminate the need for users to manually re-authorize the SmartThings SmartApp whenever devices changed or new platforms were added. Previously, subscriptions for device capabilities were tied to a personal access token and required manual steps when the device set changed. The new implementation switches to using SmartApp-level OAuth tokens, which are short-lived access tokens backed by longer-lived refresh tokens.\n\nTo support this, the config entry schema was bumped from version 1 to 2 to store three new fields: `client_id`, `client_secret`, and `refresh_token`. Because v1 entries did not have the necessary data, the migration path could not be an in-place transformation. Instead, `async_migrate_entry` was implemented to delete the existing SmartThings installed app via the SmartThings API, remove the old config entry, and automatically start a new config flow (source `import`) so users can reconfigure once. This is a breaking change but only requires a one-time re-setup; entities keep their names.\n\nOn setup, `async_setup_entry` now uses the stored OAuth client ID/secret and refresh token to call `SmartThings.generate_tokens`, obtaining a fresh short-lived access token and a new refresh token. It updates the config entry with the new refresh token, fetches devices and their status, then calls `smartapp_sync_subscriptions` with the current device list. Subscriptions are now synchronized using a diff-based approach: the integration fetches existing subscriptions, computes the set of capabilities actually present on devices, removes any subscriptions for capabilities not present, and creates subscriptions for any new capabilities. This avoids unnecessary API calls and ensures subscriptions track the actual device set.\n\nThe `DeviceBroker` was refactored from a thin capability mapper into a richer manager that holds the config entry, the SmartApp token, and the SmartApp instance. It now exposes `connect()`/`disconnect()` methods. `connect()` registers the event handler with the SmartApp and uses `async_track_time_interval` with a 14-day interval to periodically refresh the SmartApp token's refresh token before its 30-day expiry. The periodic callback calls `token.refresh(client_id, client_secret)`, updates `CONF_REFRESH_TOKEN` in the config entry, and logs the update. `disconnect()` cancels the interval callback and disconnects the event handler. `async_unload_entry` was updated to call `broker.disconnect()` instead of manually handling event handler disconnection.\n\nOn the SmartApp side, installation and update events now correctly manage OAuth-related data. `smartapp_install` no longer immediately creates subscriptions. Instead, it packages `installed_app_id`, `location_id`, and the SmartApp `refresh_token` into an `install_data` dict. If there is an existing config entry for the same parent `app_id`, it copies over the app-level OAuth parameters and spawns a new config flow (`source: install`) with the combined data. If not, it stores the `install_data` in `hass.data[DOMAIN][CONF_INSTALLED_APPS]` for the config flow to pick up during the `wait_install` step. `smartapp_update` now only updates the stored `refresh_token` in the corresponding config entry rather than reloading the entry, avoiding unnecessary unload/load cycles.\n\nThe config flow was updated to manage the new OAuth flow: in `async_step_user`, the integration either finds an existing SmartApp or creates a new one, then regenerates the OAuth client settings using `generate_app_oauth` or `update_app_oauth`, storing `oauth_client_id` and `oauth_client_secret` in the flow instance. The `wait_install` step now pulls installation data from `hass.data[DOMAIN][CONF_INSTALLED_APPS]`, enriches each with app ID, the personal access token used during setup, and the OAuth client credentials, and creates separate config flows if the SmartApp was installed in multiple SmartThings locations. Tests were updated or added to cover config entry migration, correct use of `generate_tokens`, periodic refresh handling, subscription diffing, and the new install/update behavior, ensuring backwards compatibility for entities while enforcing a one-time reconfiguration.",
        "semantic_memory": "This PR encapsulates several generalizable patterns in managing cloud integrations and OAuth-based device subscriptions.\n\n1. **Safe schema evolution for integrations**: When a config entry schema must change to store new security-critical fields (like OAuth client ID/secret and refresh token) and no safe in-place migration is possible, it's better to explicitly decommission the old integration state. This can be done by implementing `async_migrate_entry` to clean up any cloud-side resources (delete installed apps or webhooks) and remove the local entries, then automatically trigger a new configuration flow. Communicating this as a one-time breaking change avoids subtle, hard-to-debug failures later.\n\n2. **Using SmartApp OAuth instead of user tokens**: For SmartThings (and similar platforms), personal access tokens are not ideal for subscription management and event callbacks. Instead, using SmartApp-level OAuth tokens (short-lived access tokens with refresh tokens) aligns with platform expectations and supports server-side subscription management from the integration. Storing `client_id`, `client_secret`, and `refresh_token` in the config entry enables the integration to generate short-lived tokens on demand, without re-prompting the user.\n\n3. **Periodic refresh of long-lived tokens**: Even refresh tokens have expiration. A robust integration proactively refreshes tokens before expiry using a scheduler (`async_track_time_interval` in Home Assistant) rather than waiting for failures. The callback should be idempotent and update persisted configuration (`CONF_REFRESH_TOKEN`) after each successful refresh, so the latest token is always stored.\n\n4. **Diff-based subscription synchronization**: Rather than deleting and recreating all subscriptions on each setup or configuration change, it's more efficient and safer to perform a diff between desired and actual state. The integration should compute the set of capabilities (or resources) needed based on the current devices, fetch existing subscriptions, remove only obsolete ones, and create only missing ones. This pattern minimizes API calls, reduces the risk of transient errors breaking all subscriptions, and keeps subscriptions in sync with reality.\n\n5. **Decoupling install/update events from setup logic**: SmartApp install and update callbacks may arrive in different orders relative to the config flow. A resilient design stores raw install/update data in a shared place (`hass.data[DOMAIN][CONF_INSTALLED_APPS]`) and lets the config flow pick it up during the appropriate step. This avoids tightly coupling lifecycle events to configuration UI flow state and handles multi-location installs more cleanly.\n\n6. **Explicit connection lifecycle for brokers**: When a component manages long-lived callbacks and periodic tasks, it's useful to encapsulate registration and cleanup in `connect()`/`disconnect()` methods rather than work in the constructor/destructor. This makes lifecycle explicit, eases testing, and ensures cleanup is performed during integration unload.\n\n7. **Error-tolerant subscription management**: When creating or deleting subscriptions via an external API, individual operations should be wrapped in `try/except Exception` blocks with logging. This ensures that one failing API call does not prevent the integration from making progress on other subscriptions, while still surfacing useful diagnostic information.",
        "procedural_memory": [
            "Step-by-step pattern for migrating a cloud integration to use SmartApp/refresh-token-based OAuth with automatic subscription synchronization:\n",
            "Step 1: Identify the new data needed and bump the config entry version.",
            "- Determine what additional fields are required (e.g., OAuth client ID, client secret, refresh token).",
            "- Update the integration's config entry `VERSION` constant.",
            "- Extend the config entry schema (e.g., via constants like `CONF_OAUTH_CLIENT_ID`, `CONF_OAUTH_CLIENT_SECRET`, `CONF_REFRESH_TOKEN`).",
            "- Plan whether an in-place migration is possible; if not, design a strategy to delete and recreate entries.",
            "",
            "Step 2: Implement `async_migrate_entry` for non-trivial migrations.",
            "- Add an `async_migrate_entry(hass, entry)` function in the integration's `__init__.py`.",
            "- If the old entry lacks required OAuth details, use the existing credentials (e.g., personal access token) to clean up any cloud resources (e.g., `api.delete_installed_app(entry.data[CONF_INSTALLED_APP_ID])`).",
            "- Remove the config entry via `hass.config_entries.async_remove(entry.entry_id)`. Use tasks (`hass.async_create_task`) to avoid blocking.",
            "- Check for any ongoing flows for this domain; if none exist, start a new configuration flow with `context={'source': 'import'}` to prompt the user for re-configuration.",
            "- Return `False` to indicate that the entry could not be migrated in-place.",
            "",
            "Step 3: Update the config flow to obtain and persist SmartApp OAuth details.",
            "- In the user step (`async_step_user`), after validating the personal access token, check if the SmartApp exists; either refresh and update it or create it.",
            "- Use the underlying API (e.g., `pysmartthings.AppOAuth` and `generate_app_oauth`) to regenerate or create OAuth credentials and obtain `client_id` and `client_secret`.",
            "- Store `client_id` and `client_secret` on the flow instance and include them in the installation data.",
            "- In the wait-for-installation step (`async_step_wait_install`), load installation data from a shared store (e.g., `hass.data[DOMAIN][CONF_INSTALLED_APPS]`). Enrich each install record with `app_id`, the personal access token, and the OAuth client credentials.",
            "- For multiple installations (different locations), spawn separate flows with `context={'source': 'install'}` and correct data for each installation.",
            "",
            "Step 4: Wire SmartApp install and update callbacks to config flow and token storage.",
            "- In the SmartApp `install` handler, collect `installed_app_id`, `location_id`, and `refresh_token` into an `install_data` dict.",
            "- If an existing config entry for the same `app_id` exists, merge its app-level data (including OAuth client info and access token) with `install_data` and kick off a flow via `config_entries.flow.async_init(DOMAIN, context={'source': 'install'}, data=data)`. This handles additional locations.",
            "- If no entry exists yet, append `install_data` to `hass.data[DOMAIN][CONF_INSTALLED_APPS]` so the config flow can consume it during `wait_install`.",
            "- In the SmartApp `update` handler, find the config entry by `installed_app_id`, update `entry.data[CONF_REFRESH_TOKEN]` with the new refresh token, and call `config_entries.async_update_entry(entry)`. Avoid unnecessary reloads unless configuration itself has changed.",
            "",
            "Step 5: Generate and refresh access tokens during normal setup.",
            "- In `async_setup_entry`, construct a SmartThings API client using the stored personal access token for initial app validation, if needed.",
            "- Use the stored `client_id`, `client_secret`, and `refresh_token` to generate new tokens: `token = api.generate_tokens(client_id, client_secret, refresh_token)`.",
            "- Update `entry.data[CONF_REFRESH_TOKEN]` with `token.refresh_token` and persist via `async_update_entry`.",
            "- Use `token.access_token` for subsequent API calls (e.g., device retrieval, subscription management).",
            "",
            "Step 6: Synchronize subscriptions using a diff-based method.",
            "- Collect the set of capabilities actually used by current devices. Remove unsupported capabilities using a known capability set (`CAPABILITIES`).",
            "- Fetch current subscriptions via `api.subscriptions(installed_app_id)`.",
            "- For each existing subscription: if its capability is still needed, remove it from the desired-capability set; otherwise, schedule a deletion operation for that subscription.",
            "- For any capabilities remaining in the desired set, schedule creation of new subscriptions using a helper that constructs a `Subscription` object (with installed app ID, location ID, `SourceType` etc.) and calls `api.create_subscription`.",
            "- Wrap each create/delete operation in a try/except block to log and ignore individual failures, then execute them concurrently with `asyncio.gather`.",
            "- Log when subscriptions are already up to date to aid debugging.",
            "",
            "Step 7: Manage event handlers and token refresh in a broker class.",
            "- Encapsulate integration-specific state (config entry, SmartApp token, SmartApp instance, devices) in a broker class (e.g., `DeviceBroker`).",
            "- Provide a `connect()` method that:\n  - Schedules a periodic task with `async_track_time_interval(hass, callback, TOKEN_REFRESH_INTERVAL)` to refresh the token before expiry. The callback should call `token.refresh(client_id, client_secret)` and update `CONF_REFRESH_TOKEN` in the config entry.\n  - Registers an event handler with the SmartApp (`smart_app.connect_event(self._event_handler)`) and stores the disconnect callback.\n",
            "- Provide a `disconnect()` method that cancels the periodic refresh and disconnects the event handler. Call this from `async_unload_entry`.",
            "- Implement the event handler to verify the `installed_app_id`, collect affected device IDs, and dispatch a signal (e.g., via `async_dispatcher_send`) so entity platforms can update state. Optionally emit custom events (like button presses) to the event bus.",
            "",
            "Step 8: Update tests to reflect new behavior.",
            "- Add tests for `async_migrate_entry` to verify that old entries are removed, the installed app is deleted, and a new flow is initiated.",
            "- Mock token generation and refresh (`generate_tokens`, `token.refresh`) and assert that the config entry refresh token is updated.",
            "- Test that `DeviceBroker.connect()` registers refresh callbacks and event handlers, and that `disconnect()` cleans them up.",
            "- Add tests for `smartapp_sync_subscriptions` verifying that it:\n  - Adds missing subscriptions,\n  - Removes obsolete subscriptions,\n  - No-ops when subscriptions are already correct,\n  - Logs and continues when individual create/delete operations fail.",
            "- Test SmartApp `install` and `update` behavior, ensuring installation data is stored or used to spawn additional flows, and that refresh tokens are correctly persisted.",
            "",
            "Step 9: Communicate the breaking change to users.",
            "- Mark the PR or release notes with a clear notice that existing SmartThings integrations will be removed and must be reconfigured once.",
            "- Clarify that entity names and IDs will be preserved to minimize impact.",
            "- Optionally coordinate with release notes / podcast or other communication channels to highlight the change."
        ]
    }
}
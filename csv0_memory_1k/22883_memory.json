{
    "search_index": {
        "description_for_embedding": "Home Assistant 0.91.2 is a patch release with many small but important fixes: Mopar config loading now reads from the domain section; Konnected switch unique_id is made deterministic (breaking change); ZHA lights now actually poll uncached state and add detailed debug logging; Tado climate uses new pyTado turn-off API; the mobile_app integration adds get_zones and get_config webhook commands, improves JSON encoding and validation, makes update_location optional fields robust, and makes push notification rate-limit info optional and logged safely; Foscam camera gains an optional rtsp_port config override while still auto-detecting ports; camera recording service coercively casts duration and lookback to int so templates work; Yeelight integration improves imports, uses relative imports, and avoids mutating collections during iteration; Hass.io ingress fixes content_type handling when proxying responses; mobile_app sensor schemas make unit_of_measurement optional and return clearer success flags.",
        "keywords": [
            "Home Assistant 0.91.2",
            "Mopar config load bug",
            "Konnected switch unique_id breaking change",
            "ZHA light polling cache bypass",
            "ZHA debug logging",
            "Tado climate turn off pyTado",
            "mobile_app webhook get_zones",
            "mobile_app webhook get_config",
            "mobile_app update_location optional fields",
            "mobile_app push notification rate limits optional",
            "mobile_app sensor registration success flag",
            "Foscam camera rtsp_port override",
            "RTSP port 88",
            "camera service record duration lookback template int coercion",
            "Yeelight BulbException imports",
            "Yeelight relative imports",
            "Yeelight iteration over changing dict",
            "Hass.io ingress content_type passthrough",
            "content_type header proxy bug",
            "webhook schema validation optional",
            "JSONEncoder for webhook_response"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set is the Home Assistant 0.91.2 patch release, composed of multiple focused fixes across several integrations.\n\nMopar: The Mopar integration was incorrectly reading credentials and scan_interval directly from the root config dict instead of the domain-specific section. In __init__.py, the setup() function now first extracts conf = config[DOMAIN] and uses that to read CONF_USERNAME, CONF_PASSWORD, CONF_PIN, and CONF_SCAN_INTERVAL. This fixes failures where Mopar could not log in or schedule updates when configured under its proper domain key.\n\nKonnected: Konnected switches previously computed unique_id using hash(frozenset({...})), which is not stable across restarts and could change between processes. This broke entity identity and caused duplicate entities or lost associations. The code now uses a deterministic string: f\"{device_id}-{pin}-{momentary}-{pause}-{repeat}\", ensuring consistent unique IDs (a breaking change because existing entity IDs may shift).\n\nZHA lights: Custom polling for ZHA lights was not actually triggering fresh state reads; async_update called the parent but never forced a read from the light. The patch adds async_get_state(from_cache=True) and makes refresh() call async_get_state(from_cache=False), passing from_cache flags into get_attribute_value. This ensures periodic polling bypasses cache and updates on/off and brightness. Additionally, a debug() helper is added and the on/off and color/level flows use detailed structured logging (t_log) to record which Zigbee commands succeeded or failed.\n\nTado: After an upstream pyTado change, turning heating off no longer worked. The integration previously used set_zone_overlay even for OFF. A new method set_zone_off() was added to the shared Tado store wrapper to call tado.setZoneOverlay with explicit mode, temperature=None, duration=None, plus 'HEATING', 'OFF' arguments as required by the new API. Climate._control_heating() now calls set_zone_off instead of set_zone_overlay when switching to OFF, restoring correct off behavior.\n\nmobile_app – new webhooks & robustness:\n- get_zones: A new webhook type WEBHOOK_TYPE_GET_ZONES returns all zone.* entities. The webhook handler verifies the type against WEBHOOK_TYPES (now separate from WEBHOOK_SCHEMAS), collects hass.states for all entities in the zone domain, and returns them via webhook_response with proper JSON encoding and optional encryption.\n- get_config: A new WEBHOOK_TYPE_GET_CONFIG returns key config attributes (latitude, longitude, elevation, unit_system, location_name, time_zone, components, version, and frontend theme_color). It uses hass.config.as_dict() and frontend.MANIFEST_JSON.\n- webhook_response: Now uses homeassistant.helpers.json.JSONEncoder when dumping JSON to ensure complex types (e.g., sets) are serialized correctly and uses the registration[ATTR_SUPPORTS_ENCRYPTION] flag instead of testing CONF_SECRET presence directly.\n- Webhook type handling: Incoming webhook types are first checked against WEBHOOK_TYPES. For types with defined schemas, payloads are validated; for others like get_config/zones, the raw webhook_payload is used, preventing schema errors for type-only payloads.\n- update_location: Some fields are optional and were previously passed as None within nested ATTR_ATTRIBUTES, causing issues. The handler now requires ATTR_GPS and ATTR_GPS_ACCURACY but only includes location_name, battery, and extended attributes (altitude, course, speed, vertical_accuracy) if they are present. ATTR_ATTRIBUTES is only created when needed.\n- Notify rate limits: The push notification response sometimes lacks rateLimits. log_rate_limits() now checks for ATTR_PUSH_RATE_LIMITS in the response before logging, and uses explicit attribute constants for keys. It parses resetsAt with dt_util.parse_datetime and logs a concise summary only when rate limit info exists.\n- Sensors: The mobile_app sensor registration schema now makes ATTR_SENSOR_UOM optional (previously required). The MobileAppSensor entity’s unit_of_measurement property now uses config.get(ATTR_SENSOR_UOM) and sensors without a UOM return None. Webhook responses for sensor register/update now use {'success': True} instead of custom status strings, and tests are updated accordingly.\n\nFoscam: Users had issues streaming from certain Foscam cameras (e.g., C1) because the RTSP port auto-detection via get_port_info was unreliable or mismatched their setup. The camera platform config now supports an optional rtsp_port parameter (validated as a port). In the FoscamCamera entity’s __init__, _rtsp_port is first taken from device_info[CONF_RTSP_PORT]; if not provided, it falls back to calling get_port_info() and using rtspPort or mediaPort from the camera. This allows users to explicitly set the RTSP port (e.g., 88) when auto-detection fails, while retaining backwards compatibility when they do not specify it.\n\nCamera service: The camera.record service schema declared CONF_DURATION and CONF_LOOKBACK as int, which breaks when those values are provided as templated strings. The schema now uses vol.Coerce(int) for both, allowing template outputs (strings) to be coerced to integers while still enforcing type correctness.\n\nYeelight: Several quality fixes were applied. Imports were adjusted so that the heavyweight yeelight module and BulbException are imported lazily inside methods, minimizing startup overhead and circular import risks. The light integration introduces a cached _light_type attribute set in the constructors (LightType.Main or LightType.Ambient), used by the light_type property instead of reimporting enums each call. Relative imports are used for internal modules (binary_sensor/light importing from . instead of homeassistant.components.yeelight). Additionally, a potential runtime error from mutating yeelight_data during iteration was fixed by iterating over list(yeelight_data.values()) in the periodic update.\n\nHass.io ingress: The ingress reverse proxy mishandled Content-Type; it previously dropped the upstream content_type when forwarding responses and also filtered out the CONTENT_TYPE header from requests. The handler now explicitly sets content_type=result.content_type on the Response and no longer excludes CONTENT_TYPE in the header filter (only CONTENT_LENGTH and CONTENT_ENCODING are filtered), fixing issues where UIs behind ingress rendered incorrectly due to missing or wrong MIME type.\n\nFinally, the Home Assistant version constants were bumped from 0.91.1 to 0.91.2.",
        "semantic_memory": "Several cross-cutting engineering lessons emerge from this 0.91.2 patch set:\n\n1. **Always read config from the correct scope**: Components should read options from their domain-specific config entry (e.g., config[DOMAIN]) instead of the root config dict. Mis-scoped reads can silently fail or work only under limited setups. This pattern is broadly applicable to any framework that organizes configuration hierarchically.\n\n2. **Unique IDs must be deterministic and stable**: Using Python's hash() or frozenset-based hashes for entity identifiers is dangerous because hash values can vary across processes and runs (and are salted by default). Unique IDs persisted by clients (like Home Assistant) must be deterministic strings derived from stable attributes (e.g., device_id + pin + configuration flags). This is relevant to any system that stores \"entity IDs\" or similar keys across restarts or between machines.\n\n3. **Polling must bypass caches when fresh state is required**: Having a periodic refresh that only hits a cached layer does *not* guarantee up-to-date state. Separating 'update from cache' and 'force fetch from device' (e.g., via a from_cache flag) clarifies intent and avoids expensive queries when not necessary, while still allowing a refresh path that guarantees fresh device state.\n\n4. **Log structured data and reuse helpers**: Instead of ad-hoc logging strings, gathering results into dicts (like t_log) and logging via a dedicated debug() helper leads to more consistent and searchable logs. Including entity_id in log messages via a helper reduces repetition and mistakes.\n\n5. **Wrapping upstream API changes in thin adapters**: When an upstream library changes its method signature (such as pyTado's zone overlay/off API), the main integration should introduce a small wrapper (e.g., set_zone_off) rather than scattering new call patterns across multiple places. This centralizes adaptation logic and keeps the component's internal call sites simpler.\n\n6. **Webhook / API robustness**:\n   - Maintain a separation between the list of allowed types (WEBHOOK_TYPES) and the subset with strict schemas (WEBHOOK_SCHEMAS). This enables simple types that require no body validation (e.g., 'get_config', 'get_zones').\n   - Use a custom JSON encoder when returning data that may include sets or other non-primitive types.\n   - Treat optional fields as truly optional: only include them in payloads when present, and avoid passing None for fields that third-party consumers might not accept (e.g., nested ATTR_ATTRIBUTES for location updates).\n   - For responses, use a uniform, simple success indicator (e.g., {'success': True}) rather than bespoke 'status' strings.\n\n7. **Optional data in responses should be guarded**: When a backend API or service can optionally return extra diagnostic information (like push notification rate limits), code must guard accesses with 'in' checks or .get(). Assuming presence leads to KeyError and brittle integrations.\n\n8. **Exposing override hooks while preserving auto-detection**: The Foscam RTSP port fix illustrates a good pattern: keep the auto-discovery behavior for existing users but add an explicit configuration override. This benefits advanced or edge-case setups without regressing defaults. The same pattern applies to many integrations with auto-detected addresses/ports.\n\n9. **Schema coercion for template-driven configs**: When user-facing configuration values can be templated (common in automation systems), they will often arrive as strings even if logically numeric. Using vol.Coerce(int) (or analogous coercions in other validation libraries) instead of raw int makes the system more tolerant while preserving type safety.\n\n10. **Avoid modifying collections while iterating**: When iterating over shared data structures that may be mutated (such as a dict tracking devices), copy their values first (e.g., list(dict.values())) to avoid runtime errors or skipped entries. This is a general collection-safety practice.\n\n11. **Lazy imports and relative imports**: Deferring imports of heavy or optional modules to inside methods reduces startup time and avoids circular import issues. Using relative imports within a package clarifies ownership and reduces coupling to the broader package path.\n\n12. **Reverse-proxying and content-type handling**: A proxy (like Hass.io ingress) must preserve the upstream Content-Type when returning responses or clients may misinterpret the body. Similarly, filtering headers on the inbound request should be minimal and deliberate (e.g., ignoring only length/encoding when rebuilding headers). This lesson generalizes to any HTTP reverse proxy or gateway layer.\n\n13. **Tests as behavioral specification**: The updated tests around mobile_app webhooks and sensors show how tests codify expected JSON structures (e.g., success flags, theme_color, type-only payloads) and catch regressions when internal logic changes. When adding new webhook types, it's important to cover them end-to-end via realistic HTTP requests in tests.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: For configuration-loading bugs (e.g., an integration not seeing user credentials or options), verify how the component accesses the config. Ensure it uses the correct domain-scoped section (config[DOMAIN] or the framework’s equivalent) rather than the global config object. Adjust calls accordingly and add tests that cover typical configuration layouts.",
            "Step 2: For unstable or changing entity identifiers (e.g., devices reappearing as new entities after restart), inspect how unique_id or identifiers are computed. Avoid any use of non-deterministic operations like hash() or unordered collections. Replace them with a stable, human-readable string built from deterministic attributes (device_id, port, mode flags) and note that this may be a breaking change requiring migration.",
            "Step 3: When periodic polling appears to have no effect on device state, review the code path to see if it actually performs I/O or only reads from a cached state. Introduce a clear separation between cached lookups and real device reads (e.g., a from_cache parameter), call the uncached path from polling functions, and ensure state variables (like _state or _brightness) are updated from the fresh values.",
            "Step 4: If an integration breaks after an upstream library update (e.g., Tado, Foscam), read the upstream changelog or inspect the failing call signatures. Implement adapter methods in your integration that conform to the new signature, then refactor existing usages to call the adapter. Add tests that simulate the new expected behavior (e.g., off actually turning off).",
            "Step 5: For webhooks or HTTP APIs that need new commands (like get_zones or get_config), extend a central list of allowed types and conditionally validate payloads. Use schema validation (via voluptuous or equivalent) only where bodies are expected and allow body-less or minimal-body commands to bypass schema validation. Always ensure unknown types are logged and return safe default responses.",
            "Step 6: Make webhook handlers robust to optional fields. In request parsing, treat required keys (like GPS coordinates) separately from optional ones (like speed, battery). Use data[key] for required fields and data.get(key) for optional fields, and only add sub-dictionaries (like attributes) when at least one optional field is present. This avoids passing None values to downstream services.",
            "Step 7: When returning JSON from APIs that may include complex objects (sets, datetime, framework-specific objects), use a custom JSON encoder provided by the framework (e.g., Home Assistant’s JSONEncoder) instead of the standard library’s default serializer. This prevents serialization errors and keeps responses consistent.",
            "Step 8: For optional diagnostic data returned by third-party services (e.g., push notification rate limits), always guard dictionary access with 'if key in dict' checks or .get() to avoid KeyError. Wrap logging in a helper that no-ops when the data is absent, and use well-named constants for nested keys to keep code self-documenting.",
            "Step 9: To support both auto-detection and manual overrides (as with Foscam rtsp_port), first read an explicit config option. If present, honor it and skip discovery. If absent, fall back to querying the device or environment. Document the override in user-facing docs so users can work around discovery issues.",
            "Step 10: When users can provide values via templates or other indirect means, assume they might arrive as strings even when numeric. Change your validation schema to use coercion (e.g., vol.Coerce(int)) to convert string numerals into proper ints. Verify via tests that both literal numbers and string numbers are accepted while invalid strings are rejected.",
            "Step 11: If you need to iterate over a collection that may be modified (e.g., device registry updated during callbacks), copy it first: for item in list(collection.values()): .... This protects against runtime errors and ensures you cover all elements present at the time iteration started.",
            "Step 12: For HTTP proxy/ingress issues where frontends display incorrectly (blank pages, wrong charset, missing styles), inspect how you forward headers and status from the upstream response. Ensure you propagate the upstream content_type/content-type and avoid over-filtering request headers. For server responses, explicitly pass content_type from the upstream client response when building the proxy response object.",
            "Step 13: After making API or schema changes (e.g., new webhook types or response formats), update or add tests that exercise the full path: sending HTTP requests, validating responses (status code and body), and checking side effects (like entity creation or service calls). Run the test suite to confirm no regressions are introduced elsewhere."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor proposal in napari introducing a generic event-bus style ImageEventHandler and interface-based contracts to synchronize model (Image layer), Qt controls, and Vispy views. Moves away from hard-wired Qt/Vispy event wiring toward a decoupled, headless-friendly design that prevents infinite update loops by centralizing interpolation and contrast_limits updates through an EventHandlerBase and ImageInterface.",
        "keywords": [
            "napari",
            "ImageEventHandler",
            "EventHandlerBase",
            "event bus",
            "controller",
            "synchronizer",
            "MVC",
            "QtImageControls",
            "VispyImageLayer",
            "Image layer",
            "interpolation",
            "contrast_limits",
            "UpdateContract",
            "BaseInterface",
            "ImageInterface",
            "headless mode",
            "infinite update loop",
            "decoupling model and view",
            "Qt",
            "Vispy",
            "Protocols",
            "ABCs",
            "typing-extensions"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request was an experimental refactor in napari aiming to cleanly synchronize the image model, Qt controls, and Vispy rendering while decoupling them from each other and making behavior clearer in headless mode.\n\nInitially, the PR introduced a `_controllers` package with a `ControllerBase` and an `ImageController`. The controller took explicit references to the model (`Image`), Qt controls (`QtImageControls`), and Vispy layer (`VispyImageLayer`). It listened to interpolation changes from both the model and the Qt widgets, and on any change, it updated all three components (model, Qt, Vispy) in a single place. This eliminated duplicated wiring and reduced risk of infinite update loops between model and views, but it tightly coupled the controller to specific Qt/Vispy classes.\n\nBased on discussion, the author pivoted to a more generic, interface-based event bus design and removed the `_controllers` package entirely. They added:\n\n- `BaseInterface` and `ImageInterface`: abstract interfaces that declare the update methods shared across model, Qt, and Vispy for image layers, e.g. `_set_interpolation` and `_set_contrast_limits`.\n- `EventHandlerBase`: an event-bus-like class that accepts a list of `editable_components` implementing `BaseInterface`. On initialization it iterates over these components, finds their `.events`, and connects specific events (currently `interpolation` and `contrast_limits`) to a single `on_change` handler. That handler reads `event.name` and `event.value`, and calls `_set_<name>(value)` on all components, keeping them in sync.\n- `ImageEventHandler`: a thin subclass of `EventHandlerBase` for image layers, with a type-narrowed list of `ImageInterface` components.\n\nThe model and views were modified to conform to this pattern:\n\n- `Image` (the model) now inherits from `ImageInterface` and splits its public setters into two parts: the public property setter just emits an event with `name` and `value` (e.g. `self.events.interpolation(name=\"interpolation\", value=interpolation)`), while a private `_set_interpolation` method actually mutates internal state without firing another event. A similar pattern was applied to `contrast_limits` via `IntensityVisualizationMixin`'s `_set_contrast_limits`.\n- `QtImageControls` now inherits from `ImageInterface`. Instead of directly mutating the model on user interaction, it emits its own interpolation event via `self.events.interpolation(name=\"interpolation\", value=text)`. It implements `_set_interpolation` to update the combo box selection when a change comes from elsewhere in the system.\n- `QtBaseImageControls` stopped listening directly to `layer.events.contrast_limits` and instead exposes `_set_contrast_limits(contrast_limits)` to set the slider and optional popup from a given value, which is called by the event handler.\n- `VispyImageLayer` also implements `ImageInterface`. It no longer connects directly to `layer.events.contrast_limits`, and exposes `_set_contrast_limits(contrast_limits)` to update the Vispy texture clim. Its interpolation update method was renamed from `set_interpolation` to `_set_interpolation`, and it uses the incoming value instead of always reading from the layer.\n\nAt the viewer level, `QtViewer` now uses a generic mapping in `layers.base.__init__` (`layer_to_controller = {Image: ImageEventHandler}`) instead of `_controllers`. In `_add_layer`, after creating the Vispy and Qt controls for each layer, it builds an `editable_components` list `[layer, vispy_layer, controls]` and instantiates `ImageEventHandler` with it. A `layer_controllers` dict stores the handler per layer. On removal, it cleans up both the Vispy mapping and controller mapping.\n\nTests were updated to show how the controller could be used in a headless context: `test_random_image` instantiates an `Image` and then an `ImageEventHandler(editable_components=[layer])`, showing that in headless mode the 'controller' can still operate purely on the model.\n\nOverall, this PR didn't land as-is (it was closed in favor of another PR), but it captures a specific attempt to refactor napari's synchronization logic into a decoupled event-bus pattern with explicit interfaces and shared update methods, targeting improved maintainability, prevention of recursive update loops, and headless compatibility.",
        "semantic_memory": "This change exemplifies a general design pattern for GUI/model synchronization in complex applications: use an event-bus-like mediator plus explicit interfaces to synchronize multiple representations of the same logical state while avoiding tight coupling and feedback loops.\n\nKey ideas:\n\n1. **Central event handler as an event bus / synchronizer**: Instead of wiring every component directly to every other component (model ↔ Qt ↔ Vispy), define a single mediator (here `EventHandlerBase` / `ImageEventHandler`) that listens to events from any component and propagates updates to all others. This reduces complexity from O(n^2) connections to O(n) and makes reasoning about data flow easier.\n\n2. **Interfaces / contracts to decouple implementations**: By giving each participating component an interface (e.g. `ImageInterface` extending `BaseInterface`) specifying the methods the event handler may call (`_set_interpolation`, `_set_contrast_limits`), the handler doesn't need to know about the concrete classes, libraries, or frameworks involved (Qt, Vispy, headless). Any new front-end (keyboard, mouse, network, alternative GUI toolkit) can join the synchronization scheme by implementing the interface and registering with the handler.\n\n3. **Separate event emission from state mutation**: The pattern of splitting a property setter into:\n   - A public setter that **only emits an event** (with a neutral schema like `name`, `value`), and\n   - A private `_set_<prop>` method that **only mutates internal state without emitting**,\n   allows the event handler to avoid infinite loops. The event handler always calls `_set_<prop>`, which does not re-emit events, while user-facing entry points (Qt widget changes, direct attribute assignment) emit events once and let the mediator handle propagation.\n\n4. **Event payloads with standardized metadata**: Rather than each event having bespoke attributes, this design uses generic fields `name` and `value` in the event payload. The handler infers the correct update method (`_set_<name>`) and propagates `value`. This makes the event handler generic and reusable: adding a new synchronized property is as simple as implementing `_set_property_name` on all components and emitting an event with `name=\"property_name\", value=<new_value>`.\n\n5. **Headless mode compatibility by design**: Because the mediator only requires that participants implement the interface, headless operation is natural: a handler can be instantiated with just the model as `editable_components=[model]`. No Qt or Vispy dependencies are required; the same event-driven logic applies even without a GUI.\n\n6. **Pythonic enforcement of contracts via ABCs and (optionally) Protocols**: While the concept comes from statically-typed languages (interfaces/contracts), Python's ABCs and typing.Protocol (with backports via `typing-extensions`) give similar benefits: IDEs and type checkers can warn when a component doesn't implement the required API before runtime. This supports safer refactoring in large codebases.\n\n7. **Avoid using string maps for wiring behavior**: The discussion emphasizes avoiding string-based 'maps of method names' for critical control paths, since they hinder automated refactoring and static analysis. Instead, the update method names are derived programmatically from event names, with the contract encoded in interfaces/ABCs.\n\nThese concepts generalize well to any application with multiple synchronized views of the same state (e.g., web clients with multiple widgets, desktop apps with multiple panes, or distributed systems with mixed front-ends). The pattern improves modularity, testability, and extensibility while reducing event-loop bugs.",
        "procedural_memory": [
            "Step-by-step guidance for diagnosing and refactoring similar synchronization issues using an event-bus pattern:",
            "Step 1: Identify duplicated or tangled synchronization logic",
            "Look for properties that are updated from multiple places (e.g., GUI widgets, model setters, rendering code) and where each component listens to each other's events. Symptoms often include complex wiring, difficulty tracing updates, and risk of infinite update loops.",
            "Step 2: Enumerate the shared state that must be synchronized",
            "List out the properties that all relevant components must keep in sync (e.g., `interpolation`, `contrast_limits`, `opacity`, etc.). These become candidates for your interface/API contract.",
            "Step 3: Define an interface/contract for editable components",
            "Create a base interface (e.g., `BaseInterface`) and per-domain interfaces (e.g., `ImageInterface`) that declare abstract `_set_<property>` methods for each synchronized property. Implement these interfaces in the model and in each view (GUI, renderer, etc.), ensuring that each component knows how to update itself given a new value.",
            "Step 4: Separate event emission from state mutation",
            "Refactor properties in the model and views to use a two-layer approach:\n- Public property setter: emits an event with a neutral payload (e.g., `events.property(name='property', value=new_value)`) and does not directly mutate state.\n- Private `_set_property` method: performs the actual state mutation and any internal side effects but does not emit events.\nApply a similar pattern to GUI widgets (e.g., Qt controls) and renderers where appropriate.",
            "Step 5: Implement a generic event handler (event bus / synchronizer)",
            "Create an `EventHandlerBase` that accepts a list of `editable_components` implementing your interface(s). In its initialization, iterate over each component, discover its `.events`, and connect events of interest (e.g., `interpolation`, `contrast_limits`) to a single `on_change` method.",
            "Step 6: Standardize the event payload format",
            "Ensure that events used for synchronization carry a consistent payload, such as `name` (the property name) and `value` (the new value). In the event handler’s `on_change`, read these fields and compute the appropriate update method name (e.g., `update_method_name = f'_set_{name}'`). Use `getattr` to fetch and call the method on each registered component, passing `value`.",
            "Step 7: Wire the event handler into your application lifecycle",
            "At the point where you create or add a new logical entity (e.g., an image layer), construct all its representations (model, GUI controls, renderer) and pass them as `editable_components` to the corresponding EventHandler (e.g., `ImageEventHandler([model, qt_controls, vispy_layer])`). Store these handlers in a mapping (`layer_controllers`) and clean them up when removing entities.",
            "Step 8: Ensure headless compatibility",
            "Design the event handler so that it can operate with any subset of components, including just the model. In headless mode or unit tests, instantiate the handler with `editable_components=[model]` to keep the API consistent while avoiding GUI dependencies.",
            "Step 9: Use ABCs and/or Protocols to enforce the contract",
            "Use abstract base classes (ABCs) or typing.Protocols to define the expected methods (e.g., `_set_interpolation`, `_set_contrast_limits`). This allows static type checkers and IDEs to help ensure all components are correctly implemented and aids future refactoring.",
            "Step 10: Remove legacy direct wiring and prevent loops",
            "Once the mediator and interfaces are in place, remove direct listeners between model and views for the synchronized properties. All cross-component updates should go through the event handler, which calls `_set_*` methods to avoid re-emitting events and thus prevent infinite loops.",
            "Step 11: Add tests and examples",
            "Write tests demonstrating how to instantiate the handler in both GUI and headless contexts. Include a simple example where changing a property in any one component (model or view) results in consistent updates across all registered components, verifying that no infinite loops or missed updates occur."
        ]
    }
}
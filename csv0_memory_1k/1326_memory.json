{
    "search_index": {
        "description_for_embedding": "Optuna's dashboard silently broke when used with bokeh>=2.0.0 due to incompatibilities. The fix adds an explicit bokeh version check inside the dashboard import logic (wrapped in try_import) and raises a clear ImportError if the installed bokeh version is 2.0.0 or newer, instructing the user to install bokeh<2.0.0.",
        "keywords": [
            "optuna",
            "dashboard",
            "bokeh",
            "bokeh>=2.0.0",
            "version check",
            "dependency incompatibility",
            "ImportError",
            "try_import",
            "StrictVersion",
            "runtime dependency validation",
            "breaking change in library update"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Optuna's web dashboard depended on the bokeh library, but the code was only compatible with bokeh versions older than 2.0.0. When users had bokeh>=2.0.0 installed, the dashboard did not work but also did not emit a clear error, leading to confusing failures. The fix implemented a version guard around the bokeh imports in optuna/dashboard.py.\n\nThe code already used a `try_import()` helper for optional imports. Inside this context manager, the developer imported `bokeh.__version__` and compared it against the minimum incompatible version using `StrictVersion` from `distutils.version`. If `StrictVersion(bokeh_version) >= StrictVersion(\"2.0.0\")`, the code now raises an ImportError with a detailed message explaining that the current bokeh version is unsupported, and instructs users to install `bokeh<2.0.0` via pip. The ImportError is raised with `name=\"bokeh\"` to integrate with the project’s import-handling conventions.\n\nInitially, the version check was implemented outside the `try_import()` block and then refactored, following review feedback, so that the version check and error raising are done inside the `with try_import() as _imports` context, consistent with other modules like `plotly_imports.py`. Finally, the import of `StrictVersion` was moved to the top of the module to clean up the import structure. This change makes the incompatibility explicit and user-facing instead of failing silently when an unsupported bokeh version is installed.",
        "semantic_memory": "This fix highlights several generalizable practices:\n\n1. **Explicit runtime dependency version checks**: When a component is only compatible with a subset of a dependency’s versions (e.g., due to breaking changes in a major release), it is safer to explicitly check the dependency’s version at import or initialization time. If an unsupported version is detected, fail fast with a descriptive error.\n\n2. **Fail fast with actionable error messages**: Instead of allowing subtle or silent failures when an incompatible library version is installed, raise a clear exception that explains:\n   - what went wrong (incompatible library version),\n   - which version is installed,\n   - which versions are supported/required,\n   - how to fix it (exact pip install command),\n   - and, if relevant, where to find more information.\n\n3. **Use centralized optional import helpers**: Wrapping optional or heavy imports in an abstraction like `try_import()` makes it easier to handle missing dependencies and version constraints consistently across a codebase. Putting version checks inside this context preserves a single, consistent path for handling import failures and reporting them.\n\n4. **Guarding against upstream breaking changes**: When upstream libraries introduce breaking changes (here, bokeh 2.x vs older APIs), downstream projects often cannot support the new API immediately. In such cases, temporary version pinning and version guards are a pragmatic way to protect users and avoid undefined behavior until full compatibility is implemented.\n\n5. **Locating version checks near imports**: Putting version-checking logic adjacent to the imports of the dependency (at the top of the module or immediately inside the import context) makes the code easier to understand and maintain, and ensures that incompatible versions are caught as early as possible.\n\nOverall, the pattern is: for optional but critical dependencies that may break across versions, use a unified import mechanism plus explicit version checks and high-quality error messages instead of letting errors cascade later in execution.",
        "procedural_memory": [
            "When a feature that depends on an external library starts failing after users upgrade that library, suspect version incompatibility and consider adding explicit version checks.",
            "Step 1: Reproduce the issue with different versions of the dependency.\n- Create a minimal environment where the feature (e.g., dashboard) is run with the older, known-good version of the library.\n- Then upgrade the library to the newer version (e.g., bokeh>=2.0.0) and confirm that the feature breaks, checking whether errors are clear or silent.",
            "Step 2: Identify the compatibility boundary.\n- Determine the exact library versions that are known to work vs those that are broken.\n- Use `library.__version__` and test across key versions (e.g., last known working minor release and the first major release).",
            "Step 3: Introduce a version check around imports or initialization.\n- If you have an optional import helper (like `try_import()`), add the version check inside that block, right after importing the dependency and its `__version__`.\n- Import a version comparison helper (e.g., `from distutils.version import StrictVersion` or `packaging.version.Version`) at the top of the module.\n- Compare versions, e.g. `if StrictVersion(lib_version) >= StrictVersion(\"2.0.0\"):`.",
            "Step 4: Raise a clear, actionable ImportError (or similar).\n- If an unsupported version is detected, raise `ImportError` (or your project’s custom import error) with a message that:\n  - states the detected version,\n  - states the allowed version range,\n  - instructs how to install a compatible version (e.g., `pip install 'bokeh<2.0.0'`),\n  - optionally includes the dependency name as a parameter if your project wraps ImportError (`name=\"bokeh\"`).",
            "Step 5: Keep the logic consistent with other modules.\n- Check other parts of the codebase that use similar dependencies or optional imports (e.g., `plotly_imports.py`) and mirror their patterns for imports, exception types, and messaging.\n- Move common imports (like StrictVersion) to the module top-level for cleanliness and reuse, unless there’s a strong reason to localize them.",
            "Step 6: Add or update tests.\n- Add tests that simulate environments with both supported and unsupported versions by mocking the dependency’s `__version__` or using dependency injection.\n- Assert that:\n  - For supported versions, imports succeed.\n  - For unsupported versions, the correct exception is raised with the expected message.",
            "Step 7: Communicate the change to users.\n- Label the change appropriately (e.g., as an enhancement or breaking change in behavior) since it introduces a new, explicit error where there previously was a silent failure.\n- Document the required dependency version range and installation instructions in the project’s docs or release notes.",
            "Step 8: Plan for eventual compatibility.\n- Treat the version guard as a temporary safety measure.\n- Create a follow-up task/issue to add support for the newer library version and remove or relax the version constraint once the integration is updated."
        ]
    }
}
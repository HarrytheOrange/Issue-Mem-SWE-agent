{
    "search_index": {
        "description_for_embedding": "Migration of Home Assistant's scene component and state reproduction helper to an async architecture: replacing sync setup and service handlers with async coroutines, introducing async_reproduce_state with a sync wrapper using run_coroutine_threadsafe, updating platform setup to async_setup_platform, and wiring everything into hass.services.async_* APIs while avoiding overloading devices with parallel commands.",
        "keywords": [
            "Home Assistant",
            "scene component",
            "scene.homeassistant",
            "async_setup",
            "async_setup_platform",
            "async_reproduce_state",
            "run_coroutine_threadsafe",
            "hass.services.async_call",
            "asyncio",
            "state reproduction",
            "entity activation",
            "async migration",
            "backwards compatible async API"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request migrated the Home Assistant scene functionality and the state reproduction helper to Home Assistant's async architecture.\n\nPreviously, the scene component and the `homeassistant` scene platform were implemented synchronously: `scene.setup`, `setup_platform`, and `reproduce_state` were all blocking functions that interacted with `hass.services.call` and synchronous service registries. As the rest of the framework moved toward async patterns, this created inconsistency and limited concurrency control.\n\nThe PR introduced `async_setup` for the scene component, which uses `EntityComponent.async_setup` and registers services with `hass.services.async_register`. Scene service handling is now done by an async handler (`async_handle_scene_service`) that calls `component.async_extract_from_service` and then awaits `scene.async_activate()` for each target scene, aggregating them with `asyncio.wait`. This preserves the ability to activate multiple scenes via a single service call while staying within the event loop.\n\nOn the entity side, the base `Scene` class gained `async_activate`, which by default offloads the existing synchronous `activate` method to the executor via `hass.loop.run_in_executor`. This gives each scene an async interface without forcing all existing scene implementations to be fully async immediately.\n\nThe `homeassistant` scene platform was also migrated: `setup_platform` became `async_setup_platform`, now yielding from `async_add_devices` and using `async_reproduce_state` instead of the old synchronous `reproduce_state`. The `HomeAssistantScene` entity now implements its own `async_activate` coroutine that delegates to `async_reproduce_state`.\n\nIn `homeassistant/helpers/state.py`, a new coroutine `async_reproduce_state` was added. It contains the core logic for determining what services to call to reproduce given entity states and then uses `hass.services.async_call` to perform those calls. To maintain a synchronous API for existing callers, `reproduce_state` was reimplemented as a thin wrapper around `async_reproduce_state` using `run_coroutine_threadsafe(..., hass.loop).result()`. The service registry lookup was also adapted to the async API via `hass.services.async_services()`.\n\nA key design choice noted in the issue description is that although `async_reproduce_state` is async, the actual device commands are not aggressively parallelized in order to avoid flooding devices (e.g., Hue lights) with too many commands at once. Instead, the async migration focuses on integrating with the event loop and async service APIs while preserving the existing, relatively serialized behavior of device interaction.\n\nFinally, test failures were addressed by fixing minor API usage details (calling `hass.services.async_services()` instead of indexing a property, using `hass.loop.run_in_executor` instead of `hass.run_in_executor`, and properly awaiting `async_add_devices`) and reorganizing tests into a `tests/components/scene` package.",
        "semantic_memory": "This change illustrates a general pattern for migrating a synchronous integration in an event-driven system (like Home Assistant) to an async architecture while preserving backward compatibility and preventing device overload.\n\nKey concepts and patterns:\n\n1. **Dual API (sync wrapper around async core)**\n   - Implement the core logic as an async coroutine (e.g., `async_reproduce_state`).\n   - Provide a synchronous wrapper (`reproduce_state`) that uses `run_coroutine_threadsafe(coro, loop).result()` to allow legacy synchronous callers to block until the async work completes.\n   - This allows the system to standardize on async internally while giving consumers time to migrate.\n\n2. **Async setup and service registration**\n   - Framework-level setup functions (`setup`, `setup_platform`) are replaced with `async_setup` and `async_setup_platform` coroutines.\n   - Service handlers are changed from sync functions registered via `register` to async coroutines registered via `async_register`.\n   - Service calls move from `hass.services.call` to `hass.services.async_call`, and service introspection uses `hass.services.async_services()`.\n\n3. **Async entity methods with executor fallback**\n   - Entities that historically exposed synchronous methods (like `Scene.activate`) can gain async counterparts (`async_activate`).\n   - The default async implementation can offload the sync method to a thread pool using `loop.run_in_executor`, allowing immediate async compatibility without rewriting all I/O logic.\n   - Entity implementations that can be fully async are free to override the async method directly.\n\n4. **Controlled concurrency for device safety**\n   - Making APIs async does not imply that all underlying operations must be highly parallel. Over-parallelization can overwhelm physical devices (e.g., smart lights, hubs).\n   - Even in async code, it can be better to batch operations or keep them serialized or coarsely grouped to protect devices and maintain reliability.\n\n5. **Gradual refactor and test adaptation**\n   - When migrating framework internals to async, tests need to be updated to import from new locations (e.g., test file restructuring) and to work with async APIs (e.g., awaiting async setup or entity additions).\n   - Minor API differences (`async_services` as a method vs. property, using `hass.loop.run_in_executor`) can be easy sources of breakage and must be adjusted carefully.\n\nOverall, this PR demonstrates how to transition a system from synchronous service calls to an async model without breaking callers, while keeping device interactions safe and predictable.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues (migrating synchronous integration code to async while keeping backward compatibility):",
            "Step 1: Identify synchronous entry points and core logic\n- Locate synchronous APIs that are central to the component's behavior: setup functions (`setup`, `setup_platform`), service handlers, and helper functions (e.g., `reproduce_state`).\n- Identify where they interact with framework services (e.g., `hass.services.call`, synchronous service registries) or block the event loop.",
            "Step 2: Design async counterparts for the core logic\n- For each core helper function, create an async version, e.g., `async_reproduce_state(hass, states, blocking=False)`.\n- Move the main operational logic into this coroutine (resolving service domains, building service data, performing calls via async APIs).\n- Ensure the async version uses the event loop aware methods: `hass.services.async_call`, `hass.services.async_services()`, and other async utilities.",
            "Step 3: Wrap async core logic with a synchronous API\n- Keep the original synchronous function name as a thin wrapper for backward compatibility (e.g., `reproduce_state`).\n- Implement it as:\n  - `return run_coroutine_threadsafe(async_reproduce_state(hass, states, blocking), hass.loop).result()`\n- This allows existing synchronous callers to continue working while the internals run in the async event loop.",
            "Step 4: Migrate component-level setup to async\n- Replace `def setup(hass, config):` with `@asyncio.coroutine` / `async def async_setup(hass, config):`.\n- Use async component helpers, e.g., `yield from component.async_setup(config)` instead of `component.setup(config)`.\n- Update service registration to async:\n  - Replace `hass.services.register(domain, service, handler, schema=...)` with `hass.services.async_register(domain, service, async_handler, schema=...)`.\n- Make the service handler itself a coroutine, and ensure all called entity methods are async.",
            "Step 5: Migrate platform setup to async\n- Replace `setup_platform(hass, config, add_devices, discovery_info=None)` with `async_setup_platform(hass, config, async_add_devices, discovery_info=None)`.\n- Use `yield from async_add_devices(...)` or `await async_add_devices(...)` to add entities.\n- Ensure any state manipulation or device interaction inside platform setup uses async helpers (e.g., `async_reproduce_state`).",
            "Step 6: Provide async methods on entities with executor fallback\n- For each entity type with a synchronous method (e.g., `Scene.activate`), add an async counterpart (`async_activate`).\n- Default implementation can be:\n  - `yield from hass.loop.run_in_executor(None, self.activate)`\n- This immediately makes the entity usable in async contexts without forcing an immediate rewrite of the device-specific logic.\n- Where possible, override the async method with a fully async version that avoids extra threads.",
            "Step 7: Manage concurrency to avoid overloading devices\n- Be cautious about spawning a separate task for every device operation. Group operations logically (e.g., by service call) or maintain some serialization if devices are sensitive.\n- In cases like state reproduction for many entities, consider batching by `(service_domain, service, service_data)` so that each distinct operation is done once per group of entity_ids rather than per entity.\n- Avoid running heavy I/O directly in async coroutines; either keep it in the service layer (which may already manage concurrency) or offload it via `run_in_executor`.",
            "Step 8: Update tests and fix framework API differences\n- Adjust tests to import from new locations if you restructure (e.g., moving `tests/components/test_scene.py` to `tests/components/scene/test_init.py`).\n- Ensure tests interact with async APIs correctly: they may need to run inside an event loop, await async setup, or use test helpers that drive async code.\n- Pay attention to subtle API changes, such as:\n  - `hass.services.async_services()` being a callable that returns a dictionary, rather than a property.\n  - Using `hass.loop.run_in_executor` instead of non-existent helpers like `hass.run_in_executor`.\n- Run the full test suite (e.g., via `tox`) and iterate to resolve remaining async-related issues.",
            "Step 9: Verify behavior and performance characteristics\n- Confirm that the async migration did not change functional behavior: scenes still activate correctly, states are properly reproduced, and services are available as before.\n- Monitor that devices are not being flooded with parallel commands; adjust batching or serialization if necessary.\n- Review logs for warnings or errors from async service calls, and ensure event loop is not blocked by leftover synchronous operations."
        ]
    }
}
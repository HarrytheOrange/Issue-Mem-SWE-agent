{
    "search_index": {
        "description_for_embedding": "Stopping StackStorm dev services with gunicorn left orphaned gunicorn worker processes (st2api and st2auth) running because the stop script only killed screen parent processes by PPID. These orphan processes kept ports 9100/9101 bound and caused subsequent restarts to silently fail. The fix adds explicit killing of gunicorn st2api/st2auth processes in st2stop() and corrects minor typos.",
        "keywords": [
            "StackStorm",
            "launchdev.sh",
            "st2start",
            "st2stop",
            "gunicorn",
            "screen",
            "orphan processes",
            "PPID kill",
            "port already in use",
            "dev server restart failure",
            "st2api",
            "st2auth",
            "bash scripting",
            "process cleanup"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the StackStorm development launcher script (tools/launchdev.sh) had a bug in the st2stop() function when running services under gunicorn. The script started st2-api and st2-auth inside screen sessions using gunicorn_pecan, controlled by a use_gunicorn flag. However, the stop logic only killed screen sessions by extracting their PIDs and using pkill -P to kill child processes by PPID.\n\nWith gunicorn, this approach left gunicorn worker processes (for st2api and st2auth) running even after the screen master processes exited. On macOS this consistently left four worker processes around, and on Linux it was intermittent (~1/10 runs). These leftover gunicorn workers kept ports 9100 and 9101 bound, so subsequent attempts to restart the dev services appeared to succeed but silently failed because the ports were already in use.\n\nThe fix modifies st2stop() so that when use_gunicorn is true, it explicitly finds and kills the gunicorn processes for st2auth and st2api after killing the screen sessions. It does this via:\n\n  ps -e | grep \"[s]t2auth/gunicorn_config.py\\|[s]t2api/gunicorn_config.py\" \\\n      | cut -d \" \" -f1 | awk '{print $1}' | xargs -L 1 kill\n\nThe grep pattern with [s] avoids matching the grep command itself. This ensures that all gunicorn master/worker processes for st2auth and st2api are terminated and the ports are freed, making restarts reliable. Additionally, the patch corrects typos in log messages ('guicorn' → 'gunicorn') for st2-api and st2-auth startup messages.\n\nDevelopers noted that on Linux, killing the gunicorn parent would usually clean up children, but not always; on macOS, the children consistently lingered. The explicit kill-by-command pattern makes the stop behavior deterministic across platforms.",
        "semantic_memory": "When wrapping application servers (like gunicorn) inside terminal multiplexers (like screen or tmux) and managing them via shell scripts, it's not sufficient to assume that killing the top-level parent process will reliably reap all child worker processes. Process re-parenting, signal handling, and platform differences (macOS vs Linux) can cause worker processes to remain alive and continue holding open ports.\n\nFor service management scripts, especially in development environments:\n\n1. Stop logic should be robust to process hierarchy quirks. In addition to killing parent/supervisor processes (screen, tmux, gunicorn master), scripts should have a fallback that matches and terminates processes by command pattern or port, to avoid leaving stragglers.\n\n2. Leaving orphaned worker processes is particularly dangerous when they bind to well-known ports. Subsequent restarts may fail silently if the script does not verify port availability or process exit, giving the illusion that services restarted when they did not.\n\n3. Using careful grep patterns such as \"[p]attern\" avoids accidentally matching the grep process itself while searching the process list.\n\n4. Cross-platform behavior of process cleanup can differ; what appears to work most of the time on Linux may fail systematically on macOS. Scripts should not rely on OS-dependent behavior of signal propagation and process reaping.\n\n5. Clear log messages and absence of typos increase the readability and debuggability of launcher scripts, though this is secondary to correctness.\n\nIn general, any homegrown service orchestration script should be treated like a minimal init system: implement explicit, deterministic start/stop actions that ensure all relevant processes are actually terminated and resources (especially ports) are freed.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Detect symptoms of orphaned processes\n- Observe that restarting a dev/server script appears to succeed (no obvious error), but the service is not behaving as expected (e.g., API not responding, port already in use).\n- Check for errors like \"Address already in use\" in logs or on the console. If the script doesn't show errors, manually inspect port usage.",
            "Step 2: Verify which processes are holding the port\n- Use tools like netstat, ss, or lsof to see what process is bound to the expected port. For example:\n  - macOS: lsof -nP -iTCP:9101 | grep LISTEN\n  - Linux: sudo netstat -tulpn | grep 9101 or ss -tulpn | grep 9101\n- Note the PID(s) and command(s) of processes still bound to those ports.",
            "Step 3: Inspect process tree and parent/child relationships\n- Use ps and tools like pstree (on Linux) or ps -fj to see parent-child relations:\n  - ps -el | grep your-service-name\n  - pstree -p <parent_pid>\n- Check whether the parent process (e.g., screen, tmux, gunicorn master) has exited while children (e.g., gunicorn workers) remain.",
            "Step 4: Evaluate the existing stop/cleanup logic\n- Open the start/stop script (bash, sh, etc.) and inspect how st2stop() or the equivalent function is implemented.\n- Look for logic relying solely on killing parents by PPID (e.g., pkill -P <pid>) or killing only one process name without ensuring children are gone.\n- Identify the flag or configuration controlling which process manager / WSGI server is used (e.g., use_gunicorn).",
            "Step 5: Add explicit cleanup for all relevant processes\n- Implement an additional cleanup block that, after killing parent processes (screen, tmux, gunicorn master), explicitly finds and kills the actual service processes (e.g., gunicorn workers) by command pattern.\n- Example pattern based on this fix:\n  - if [ \"${use_gunicorn}\" = true ]; then\n        ps -e | grep \"[s]t2auth/gunicorn_config.py\\|[s]t2api/gunicorn_config.py\" \\\n            | awk '{print $1}' | xargs -L 1 kill\n    fi\n- Use a '[c]md' style grep pattern to avoid matching the grep process itself.",
            "Step 6: Make the kill logic robust and safe\n- Pipe the output through awk or cut to extract the PID field reliably. Avoid brittle parsing of ps output based on spaces; consider using 'ps -eo pid,cmd' for more predictable formatting.\n- Consider using kill -TERM first, followed by kill -KILL if processes do not exit after a grace period.\n- Guard xargs calls with options that handle empty input gracefully (e.g., xargs -r kill in GNU xargs; or test that there is at least one PID before calling kill).",
            "Step 7: Test the updated stop/start cycle on all target platforms\n- Run the full start → stop → start cycle multiple times on each supported OS (e.g., macOS and Linux) to ensure no orphan processes are left.\n- After each stop, run:\n  - ps aux | grep your-service\n  - netstat/ss/lsof checks on the relevant ports\n- Confirm that no processes related to the service remain and ports are free.",
            "Step 8: Improve observability and messaging\n- Update echo/log messages in the script to clearly state when gunicorn (or other servers) are used, and when stop operations are performed.\n- Fix typos or misleading messages (like 'guicorn' vs 'gunicorn') to reduce confusion for future maintainers.",
            "Step 9: (Optional) Harden against silent failures\n- After stop, assert that no processes matching your service pattern remain; if they do, log a warning or error.\n- Before start, check that the ports are free; if not, fail with a clear message rather than silently continuing.\n- Consider adding simple tests or CI checks for the script if feasible (e.g., dry-run tests in containers)."
        ]
    }
}
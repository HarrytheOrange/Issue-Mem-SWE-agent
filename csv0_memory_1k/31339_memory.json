{
    "search_index": {
        "description_for_embedding": "Fixed Home Assistant service helper and camera entity methods to correctly handle callback-based and async service handlers. Camera async_turn_on/async_turn_off were incorrectly implemented as callbacks returning a coroutine via async_add_job, and the service helper assumed async_add_job always returned an awaitable. The fix converts the camera methods to proper async functions and adds a guard in the service helper to handle when async_add_job returns None for callbacks before awaiting the result.",
        "keywords": [
            "Home Assistant",
            "service helper",
            "camera component",
            "async_add_job",
            "callback vs coroutine",
            "_handle_service_platform_call",
            "async_turn_on",
            "async_turn_off",
            "Task return value",
            "event loop",
            "un-awaited coroutine",
            "service call handling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant had two related issues around async execution and callbacks. First, the camera platform defined async_turn_on and async_turn_off as callback-decorated methods that simply returned self.hass.async_add_job(self.turn_on/off). This meant they were not true async functions but instead returned a value from async_add_job, which could be a task or None, and did not match the expected async semantics of methods prefixed with async_. Second, the generic service helper in helpers/service.py, in _handle_service_platform_call, always awaited hass.async_add_job(...) directly, assuming it would always return an awaitable. However, when a plain callback function (non-coroutine) is passed to async_add_job, it may return None rather than a task, making the await invalid and causing runtime issues.\n\nThe fix for the camera component was to change async_turn_on and async_turn_off from @callback functions returning async_add_job to proper async def methods that await hass.async_add_job(self.turn_on/off). This aligns their signatures and behavior with the async_ prefix expectations and ensures scheduled work is correctly awaited. For the service helper, the code was changed to call hass.async_add_job(...) without immediately awaiting it, capturing the result. Then a guard was added: only if result is not None will it be awaited. This accommodates callback-style functions, for which async_add_job may return None, while still correctly awaiting tasks for coroutine-based handlers. After this, the existing check remains that logs an error if a coroutine is returned from a service call, reinforcing that service handlers should not themselves return coroutines. Together, these changes fixed bug #31332 by making the service helper robust to both callbacks and coroutines and correcting the camera entity's async methods.",
        "semantic_memory": "This fix illustrates a common pattern and pitfall in async frameworks: mixing synchronous callbacks and asynchronous coroutines with a helper API that schedules work on the event loop. Several general principles emerge:\n\n1. **Naming and semantics must match**: Methods named with an async_ prefix should generally be declared with async def and behave like coroutines. Having a callback-decorated function that returns a task or coroutine under an async_ name is confusing and easily causes misuse (e.g., callers expecting to await it).\n\n2. **Scheduler helpers may return None for callbacks**: Utility methods like async_add_job that accept both plain callables (callbacks) and coroutines often have different return behavior depending on the input. For coroutines, they typically return a Task or Future you can await; for callbacks, they may schedule the call and return None. Code that blindly awaits the return value can therefore break for callback inputs. A defensive pattern is to treat the scheduler's return as an optional awaitable: only await it if it's not None and is awaitable.\n\n3. **Guarding against coroutines returned from service handlers**: Service handlers should perform their work and optionally return a result, but not return a coroutine object to be awaited by the caller unless explicitly documented. Adding checks (like asyncio.iscoroutine) and logging errors when a coroutine is returned helps enforce the contract and detect mis-implemented handlers.\n\n4. **Centralized service-call helpers must handle both sync and async implementations**: A generic service dispatch function that operates on arbitrary platform entities cannot assume all service methods are coroutines. It needs to handle: a) a method name (string) to look up on the entity; b) a function that might be a callback or coroutine; and c) variability in what async_add_job returns. Writing this helper defensively helps avoid type errors and event-loop misuses across all integrations.\n\n5. **Async correctness is both about syntax and contracts**: It is not enough that code compiles or that functions can be awaited; the contract between components (e.g., what a service handler may return, how scheduling helpers behave) needs to be clear and enforced with guards and logging to prevent subtle runtime bugs.\n\nThese lessons apply in any Python async codebase (or similar event-loop frameworks) that supports both callbacks and coroutines and uses scheduling helpers or dispatch layers.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of incorrect async/callback handling. Look for runtime warnings or errors such as 'cannot await NoneType', 'coroutine was never awaited', or service handlers that behave inconsistently depending on whether they are callbacks or coroutines. Also inspect any central service dispatch helpers that interact with entity methods via an async scheduler like async_add_job.",
            "Step 2: Inspect scheduling/helper APIs. Examine the documentation and implementation of helpers like async_add_job. Determine how they behave for different types of targets (plain function, callback, coroutine function). Specifically, check whether they return a Task/Future for coroutines and None for callbacks.",
            "Step 3: Audit call sites that await scheduler results. Search for code that does result = await hass.async_add_job(...). For each call site, verify whether the target function can be a callback, a coroutine, or both. If callbacks are possible, awaiting async_add_job directly is unsafe because it might return None. Instead, treat its return as an optional awaitable.",
            "Step 4: Introduce a guard around the scheduler result. Refactor call sites so they call async_add_job without immediately awaiting it, e.g.: result = hass.async_add_job(...). Then only await the result if it is not None (and, optionally, if it is a Future/Task). For example:\n\n   - old: result = await hass.async_add_job(func, *args)\n   - new: result = hass.async_add_job(func, *args)\n            if result is not None:\n                result = await result",
            "Step 5: Enforce service handler contracts. After awaiting any scheduled work, inspect the final result. If the API contract states that a service handler must not return a coroutine, add a check using asyncio.iscoroutine(result) and log an error if you detect a coroutine. This helps catch mis-implemented handlers early.",
            "Step 6: Align async method names with implementations. In entity or service classes, check that methods named async_* are declared with async def and actually use await internally. If you find an async_* method implemented as a synchronous callback (@callback) that returns async_add_job(...), refactor it to async def and await async_add_job instead. This makes usage clear and consistent for callers.",
            "Step 7: Verify behavior with both callback and coroutine handlers. Write or run tests where the service helper is invoked with: (a) a string method name that maps to a synchronous entity method, (b) a string method name mapping to an async entity method, and (c) a direct function reference that is either a callback or coroutine. Confirm that in all cases the work is executed, no type errors occur, and no un-awaited coroutine warnings are emitted.",
            "Step 8: Review logging and error messages. Ensure that when developers misuse the async contracts (e.g., returning coroutines from service handlers), clear log messages are produced. This helps maintainers quickly diagnose similar issues in the future.",
            "Step 9: Document the expected patterns. Update developer documentation or code comments to clarify: how async_add_job behaves; when to use async_ methods vs callbacks; and what a service handler is allowed to return. This reduces the chance of similar regressions.",
            "Step 10: Monitor for regressions. After deployment, keep an eye on logs for async-related warnings or errors. If new integrations or changes introduce callback/coroutine mismatches, apply the same guarded patterns around scheduler helpers and method implementations."
        ]
    }
}
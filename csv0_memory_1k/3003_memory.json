{
    "search_index": {
        "description_for_embedding": "Optuna updated its scikit-learn integration to support scikit-learn v1.0.0 by removing an artificial upper version bound in setup.py and relaxing a brittle test that expected a specific ValueError message from SGDClassifier when y is None. CI workflow was also cleaned up by removing an obsolete Python 3.9 TODO.",
        "keywords": [
            "Optuna",
            "scikit-learn 1.0.0 support",
            "sklearn integration",
            "dependency version constraint",
            "setup.py extras_require",
            "pytest.raises",
            "error message changed",
            "SGDClassifier y None",
            "Python 3.6",
            "CI workflow matrix",
            "tests-integration.yml",
            "scikit-optimize 0.9.0"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Optuna needed to support scikit-learn v1.0.0. Previously, due to scikit-optimize not yet supporting sklearn >= 1.0, various extras in setup.py had a constraint like `scikit-learn>=0.24.2,<1.0.0` or `scikit-learn<1.0.0`. Once scikit-optimize 0.9.0 added support, these upper bounds became unnecessary and prevented users from installing Optuna alongside scikit-learn 1.0.0.\n\nThe PR removed the `<1.0.0` upper bound from all affected extras in setup.py, keeping only the lower bound where needed (e.g., `scikit-learn>=0.24.2`). As a result, Optuna could be installed with scikit-learn 1.0 and newer (subject to their own Python version constraints).\n\nUpdating to a newer scikit-learn changed the error message raised by `SGDClassifier` when fitting with `y=None`. The existing integration test `test_objective_y_None` in `tests/integration_tests/test_sklearn.py` originally asserted a specific message (`\"y cannot be None\"`), and was then briefly updated to assert the new, more verbose message. However, to keep compatibility across Python versions and sklearn versions (including 3.6 environments where sklearn 1.0 is not available and messages may differ), the test was ultimately simplified to only assert that a `ValueError` is raised, without matching the exact error message.\n\nDuring the process, there was a temporary change to skip the sklearn integration test for Python 3.6 in the GitHub Actions workflow (`.github/workflows/tests-integration.yml`), but this was reverted once the test was made robust to message variations. The workflow continues to run integration tests on Python 3.6 while ignoring only the known-problematic `test_botorch.py`. Finally, an obsolete TODO comment in the same workflow file, which referenced adding Python 3.9 to the matrix in the future, was removed now that Python 3.9 is already in the matrix.",
        "semantic_memory": "This fix illustrates several general principles about dependency management, testing against external libraries, and CI configuration:\n\n1. **Avoid overly strict version upper bounds unless necessary**: Adding an upper bound like `<1.0.0` can be appropriate when an important dependency (e.g., scikit-optimize) does not support a newer major version of another dependency (scikit-learn). But once upstream support is added, that upper bound becomes technical debt and blocks users from adopting newer versions. Periodically revisiting and removing such constraints improves compatibility.\n\n2. **Error message assertions should be robust across versions**: When testing behavior that depends on external libraries, asserting on the exact error message string is brittle. External libraries may change wording between versions (or even across Python versions), while preserving the exception type and semantics. A more robust strategy is to assert on the exception type and, only when truly necessary, use a relaxed pattern (or partial match) rather than the full, exact string.\n\n3. **Library version changes can affect test expectations indirectly**: Updating a dependency may not break your code directly, but may change error messages, default behaviors, or minor details that test suites rely on. Those tests need adjustment to focus on the contract that matters (e.g., that a `ValueError` is raised when `y` is missing), not on incidental details like exact wording.\n\n4. **CI workflows should evolve with platform and dependency support**: Skipping tests for certain Python versions can be a short-term workaround during transitions. Once compatibility is restored (e.g., by adjusting tests), it's better to run the full suite again to ensure coverage. Similarly, TODOs in CI config (like adding Python 3.9 to the matrix) should be removed once implemented to avoid confusion.\n\n5. **Python-version-dependent dependency resolution**: Some libraries (like scikit-learn) require a minimum Python version for newer releases. Removing an upper bound on such a library does not necessarily break older Python versions: pip will install the newest compatible version for the given Python, respecting the library's own `python_requires`. This can be leveraged to support a wide range of Python versions without overly complex constraints.\n\nOverall, the pattern is: relax constraints when upstream support is established, adjust tests to assert on behavior rather than brittle details, and keep CI configuration aligned with actual support status.",
        "procedural_memory": [
            "When updating support for a new major version of a dependency (e.g., scikit-learn 1.x):",
            "Step 1: Check upstream dependencies (e.g., scikit-optimize) to confirm they officially support the new major version of the library you want to enable. Look at their release notes or documentation.",
            "Step 2: Search your project for any explicit version constraints on that library (e.g., `scikit-learn<1.0.0` in `setup.py`, `pyproject.toml`, or requirements files). Identify where and why they were introduced.",
            "Step 3: Remove or relax those upper bounds where they are no longer necessary, keeping appropriate lower bounds (e.g., `scikit-learn>=0.24.2`) if your code relies on features that require them.",
            "Step 4: Consider the Python version matrix. Ensure that the dependency itself declares appropriate `python_requires` so that removing the upper bound will not force incompatible versions on older Python interpreters. Rely on pip's resolver where possible.",
            "Step 5: Run the full test suite against the updated dependency versions across all supported Python versions in your CI matrix. Pay particular attention to integration tests or tests that depend on external library behavior.",
            "When tests fail due to changed error messages from external libraries:",
            "Step 6: Identify tests that assert on exact error messages from third-party code (e.g., `pytest.raises(ValueError, match='exact message')`). Determine whether the behavior under test is the exception type, the presence of an error, or the semantic meaning of the message.",
            "Step 7: If the semantics are unchanged but only the message wording changed, relax the test. Prefer asserting only on the exception type (`with pytest.raises(ValueError):`) or, if necessary, use a looser regex or substring that captures the essence of the error without depending on the full wording.",
            "Step 8: Re-run tests across different versions of the dependency (and Python) to confirm the new assertions are robust. In particular, check older Python versions where older dependencies may be installed with different messages.",
            "When dealing with CI configuration and version-specific skips:",
            "Step 9: Review any conditional test skips in your CI workflows (e.g., ignoring specific tests on Python 3.6). Verify whether those skips are still needed after updating dependencies and tests.",
            "Step 10: Remove unnecessary skips once the underlying incompatibility is resolved so that all relevant tests run on all supported environments.",
            "Step 11: Clean up obsolete TODO comments in CI or configuration files once the TODOs are addressed (e.g., Python 3.9 already added to the test matrix) to keep configuration readable and current.",
            "Ongoing maintenance:",
            "Step 12: Periodically audit dependency constraints and CI matrices to ensure they reflect current support status, and adjust tests to avoid unnecessary coupling to external libraries' internal or cosmetic changes."
        ]
    }
}
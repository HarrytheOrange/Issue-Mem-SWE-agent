{
    "search_index": {
        "description_for_embedding": "Home Assistant Z-Wave integration did not expose battery level as a dedicated battery sensor. The fix adds discovery support for Z-Wave COMMAND_CLASS_BATTERY, introduces a ZWaveBatterySensor entity with DEVICE_CLASS_BATTERY, and adds tests to verify detection and device_class behavior.",
        "keywords": [
            "homeassistant",
            "home assistant",
            "zwave",
            "z-wave",
            "battery level",
            "battery sensor",
            "COMMAND_CLASS_BATTERY",
            "discovery_schemas",
            "ZWaveSensor",
            "DEVICE_CLASS_BATTERY",
            "sensor platform",
            "entity class",
            "test_sensor.py"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Z-Wave integration in Home Assistant was missing explicit support for Z-Wave battery level sensors. Although nodes could expose COMMAND_CLASS_BATTERY, the code did not have a dedicated entity type or discovery rule to treat these values as battery sensors with the correct device_class. As a result, battery levels either were not discovered as sensors at all, or were discovered generically without proper classification.\n\nTo fix this, the developer updated `homeassistant/components/zwave/discovery_schemas.py` to include `const.COMMAND_CLASS_BATTERY` in the list of recognized command classes for generic Z-Wave sensors. Then, in `homeassistant/components/zwave/sensor.py`, they modified `get_device` to detect when the primary value's command_class is `COMMAND_CLASS_BATTERY` and return a new `ZWaveBatterySensor` entity. This `ZWaveBatterySensor` class subclasses `ZWaveSensor` but overrides the `device_class` property to return `DEVICE_CLASS_BATTERY` from `homeassistant.components.sensor`, ensuring the entity is properly identified as a battery sensor in the UI and automations.\n\nTests in `tests/components/zwave/test_sensor.py` were extended to cover this behavior: a new test constructs a mock node and value with `COMMAND_CLASS_BATTERY`, calls `sensor.get_device`, asserts that the returned entity is an instance of `ZWaveBatterySensor`, and verifies that `device.device_class == homeassistant.const.DEVICE_CLASS_BATTERY`. This boosts coverage and guarantees that both detection and classification of Z-Wave battery sensors work as intended.",
        "semantic_memory": "When adding support for a new kind of device or measurement in a home automation integration (or any plugin-based system), there are typically three key pieces to implement:\n\n1. **Discovery mapping:** The system needs to know that certain low-level protocol features (e.g., a Z-Wave command class like COMMAND_CLASS_BATTERY) should result in a high-level entity (e.g., a battery sensor). This is usually configured in discovery schemas or mapping tables.\n\n2. **Entity specialization:** Even if basic values can be exposed via a generic entity class, it is beneficial to create a specialized entity subtype (e.g., `ZWaveBatterySensor`) when you can attach domain-specific metadata like `device_class`, units, or category. This allows the platform to render, group, and handle the entity more intelligently (e.g., battery icons, low-battery alerts).\n\n3. **Contract verification via tests:** Whenever a new entity type or discovery rule is added, tests should assert both that the correct entity class is chosen during discovery and that critical properties (like `device_class`, unit of measurement, or state) are set correctly. Tests using mock protocol objects (MockNode, MockValue) are effective to validate discovery logic without real hardware.\n\nMore generally, for integrations that consume a device protocol:\n- Map protocol-specific identifiers (command classes, clusters, capabilities) to platform-agnostic entity types and device classes.\n- Provide thin wrappers around a generic base entity to specialize behavior and metadata without duplicating core logic.\n- Keep discovery rules and entity logic consistent—tests should encode the mapping behavior so refactors don’t silently break support for particular device features.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the missing capability\n- Observe that a device feature (e.g., Z-Wave battery level) is not exposed or is exposed generically in the platform.\n- Confirm via logs or introspection that the underlying protocol (e.g., Z-Wave COMMAND_CLASS_BATTERY) is present on the node but no corresponding entity is created.",
            "Step 2: Locate discovery and mapping logic\n- Find the component or integration responsible for protocol-to-entity mapping (e.g., `discovery_schemas.py` or a similar registry).\n- Look for mappings or lists of supported command classes, clusters, or capabilities that determine what entities are created.",
            "Step 3: Add protocol-to-entity mapping for the new capability\n- Add the relevant protocol constant (e.g., `COMMAND_CLASS_BATTERY`) to the appropriate discovery schema or mapping structure that triggers sensor creation.\n- Ensure the mapping is restricted to the correct genre/type (e.g., `DISC_GENRE: GENRE_USER`) so only suitable values are exposed.",
            "Step 4: Implement or extend a specialized entity class\n- If not already present, create a subclass of the generic entity (e.g., `ZWaveSensor`) for the new capability (e.g., `ZWaveBatterySensor`).\n- Override key properties like `device_class`, unit of measurement, or state handling to match the semantics of the capability (e.g., return `DEVICE_CLASS_BATTERY`).\n- Import any necessary constants (e.g., `from homeassistant.components.sensor import DEVICE_CLASS_BATTERY`).",
            "Step 5: Hook the entity class into the factory or selector\n- In the factory method or selector (e.g., `get_device(node, values, **kwargs)`), add a condition that checks for the new capability (e.g., `values.primary.command_class == COMMAND_CLASS_BATTERY`).\n- Return an instance of the new specialized entity class when this condition is met.\n- Place this condition early enough in the decision chain so it is not overshadowed by more generic rules.",
            "Step 6: Add unit tests to cover discovery and behavior\n- Create or extend tests that construct mock protocol objects (e.g., `MockNode`, `MockValue`) with the new command class/capability.\n- Call the entity factory (e.g., `sensor.get_device`) and assert that:\n  - The returned instance is of the expected specialized class (e.g., `ZWaveBatterySensor`).\n  - The key properties such as `device_class` match the expected constants (e.g., `DEVICE_CLASS_BATTERY`).\n- Run the test suite (e.g., `tox`) to ensure all tests pass and coverage is improved or at least maintained.",
            "Step 7: Manually validate with a real device (if possible)\n- Deploy the updated integration in a test environment.\n- Include a device that exposes the new capability (e.g., a battery-powered Z-Wave node).\n- Confirm that the new entity appears, is classified correctly (battery icon / grouping), and updates as expected.",
            "Step 8: Document and maintain\n- Optionally update user-facing documentation to mention support for the new capability.\n- Keep the mapping and entity class consistent with any future platform changes (e.g., renamed device_class constants), ensuring tests guard against regressions."
        ]
    }
}
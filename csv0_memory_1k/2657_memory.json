{
    "search_index": {
        "description_for_embedding": "Home Assistant added a `hass --script check_config` tool that validates user YAML configuration by reusing the real bootstrap/config validation logic instead of static linting. The script mocks component setup to avoid side effects, tracks which YAML files and secrets are used, and reports invalid components/platforms and schema validation errors without crashing. Several bugs were fixed: handling unknown components/platforms (avoiding AttributeError when `get_component` returns None), correcting how failed configs are recorded and printed, ensuring secrets.yaml loading is robust, and exposing a proper `log_exception` function in bootstrap.",
        "keywords": [
            "homeassistant",
            "check_config script",
            "configuration validation",
            "bootstrap.log_exception",
            "loader.get_component mocking",
            "unknown component",
            "unknown platform",
            "secrets.yaml handling",
            "yaml.load_yaml patching",
            "requirements_all scripts",
            "config validation tooling",
            "AttributeError NoneType module.setup"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change introduced and stabilized the `hass --script check_config` script for Home Assistant to validate users' YAML configurations.\n\nOriginally, the script just ran `yamllint` over config files, but the maintainer preferred leveraging the existing Home Assistant bootstrap/config validation instead of duplicating lint rules. The implementation evolved to:\n- Locate the config directory and `configuration.yaml`.\n- Patch `homeassistant.loader.get_component` so that components/platforms are loaded but their `setup`/`setup_platform` functions are replaced with mocks that merely record configuration instead of starting integrations.\n- Patch `homeassistant.util.yaml.load_yaml` to record which YAML files are loaded.\n- Patch the secret handling (`!secret`) to capture which secrets are referenced and what values are resolved (from `secrets.yaml` or keyring).\n- Patch logging-related calls to keep output clean.\n\nDuring testing, a couple of critical bugs surfaced:\n1. **Unknown platform/component crash**: When a configuration referenced `light.demo2` or a non-existent `beer` component, `loader.get_component` returned `None`. The mocked `get_component` implementation in `check_config` unconditionally tried to set `module.setup` / `module.setup_platform`, causing `AttributeError: 'NoneType' object has no attribute 'setup_platform'` (or `setup`). The fix was to:\n   - Detect `module is None` in the mock `get_component` handler.\n   - Record a user-friendly error in `res['except'][ERROR_STR]` (e.g., `\"Component not found: beer\"` or `\"Platform not found: light.beer\"`).\n   - Return `None` without trying to patch attributes.\n\n2. **Failed config/printing issues**: The script initially built `components` as a list of `(name, config)` tuples and mixed them with exception data, which led to confusing output (e.g., everything appearing under `group`). It was refactored to:\n   - Store successful components in a dict keyed by domain, with the domain’s validated config as value.\n   - Store failed domains in `res['except']`, keyed by domain or `ERROR_STR` for general errors.\n   - Add `dump_dict` to pretty-print nested config structures and highlight their origin (`__config_file__`, `__line__`) where available.\n\n3. **Secret handling**:\n   - `_load_secret_yaml` previously expected `secrets.yaml` to exist and had slightly ad‑hoc logic; it now wraps `load_yaml` in a try/except and returns `{}` when the file is missing.\n   - `_secret_yaml` now walks upward from the current file’s directory until it either finds a matching secret key or reaches the config directory (determined via `sys.path[0]`, which bootstrap sets to the config/deps root). As a fallback, it still consults keyring.\n   - The script patches `_secret_yaml` during checking to log secrets used (`res['secrets']`) and, via `yaml.__SECRET_CACHE`, exposes the whole secret cache after bootstrap runs.\n\n4. **Exception logging hook**:\n   - Home Assistant originally used a private `_log_exception` in `bootstrap`. The script needed to capture which domain/config failed validation, so bootstrap was refactored to expose `log_exception` (public name) and `_setup_component`/`from_config_dict` were updated to call `log_exception` instead of `_log_exception`.\n   - `check_config` then monkeypatches `homeassistant.bootstrap.log_exception` to a wrapper that both calls the original logger and records the offending domain+config into `res['except']`.\n\nAdditionally, the script’s CLI gained options:\n- `--files` to list which YAML files were used.\n- `--secrets` to show which secrets were referenced and from which file or keyring.\n- `--info` (e.g., `--info http,light` or `--info all`) to dump full or partial validated config.\n\nThe supporting tooling was updated too:\n- `requirements_all.txt` now includes `colorlog>2.1<3` for this script and ensures script dependencies are tracked by extending `script/gen_requirements_all.py` to traverse `homeassistant.scripts` in addition to `homeassistant.components`.\n- `homeassistant.util.yaml.clear_secret_cache` was corrected (typo and usage), and tests were added for the new behavior.\n- A `patch_yaml_files` helper in `tests.common` lets tests simulate configuration files entirely in-memory by patching `yaml.open`.\n\nComprehensive tests in `tests/scripts/test_check_config.py` now cover:\n- Valid platform config (`light: platform: hue`).\n- Component schema failure (invalid `http` password).\n- Platform schema failure (`light: platform: mqtt_json` with bad platform config).\n- Unknown component (`beer:`) and unknown platform (`light: platform: beer`).\n- Secret resolution via `!secret` and correct recording of used secrets and secrets.yaml loading.\n\nAfter these fixes, `hass --script check_config` reliably reports configuration errors (including unknown components/platforms and schema violations), lists used files and secrets, and no longer crashes when the configuration references missing integrations.",
        "semantic_memory": "This work illustrates several generalizable patterns for building robust configuration validation tooling and for safely mocking runtime behavior:\n\n1. **Reuse the real validation path**:\n   - Instead of creating a separate linter (e.g., yamllint rules), reuse the actual system bootstrap and validation logic. This ensures your check tool matches the runtime behavior and reduces drift between the validator and the real code.\n   - When doing this, isolate side effects (network I/O, device initialization) via mocks; validation should be cheap and safe.\n\n2. **Mock side-effectful entry points, not the whole stack**:\n   - For a plugin-based system, intercept at the component loading level (e.g., `get_component`) and patch only the integration setup functions (`setup`, `setup_platform`). This preserves module import/validation logic while preventing real setup.\n   - Ensure your mocks handle `None` returns from loaders gracefully to avoid `AttributeError` cascades.\n\n3. **Error collection vs. hard failures**:\n   - A good config checker shouldn’t crash on the first error. Instead, it should collect errors into a structured form (e.g., `res['except']`) and continue processing as far as is safe.\n   - For general, non-schema errors like “component not found” or “platform not found”, use a separate bucket (e.g., `ERROR_STR` / `\"General Errors\"`) distinct from domain-specific schema failures.\n\n4. **Tracking configuration provenance**:\n   - When loading config from multiple YAML files, intercept the YAML loader to log which files were accessed. This allows the tool to report unused vs. used files.\n   - When using YAML tags for secrets (`!secret`), route those through a hook that records which secret keys were used and from which file or store they were resolved.\n   - If your loader attaches metadata (like `__config_file__` and `__line__`) to parsed structures, leverage those to print precise source locations in error messages.\n\n5. **Graceful secrets handling**:\n   - Don’t assume `secrets.yaml` exists; wrap loading in a try/except and default to `{}` when missing.\n   - When searching for secrets relative to a file, walk up the directory tree until a known root (e.g., the config directory), but protect against escaping the project root or invalid paths.\n   - Offer a secondary backend (like keyring) but make it optional and clearly logged when used.\n\n6. **Instrumenting exception logging for tooling**:\n   - When validation relies on library/framework functions that log errors, expose a stable logging API (e.g., `log_exception`) that can be monkeypatched by tools/tests. Avoid deep patching private functions where possible.\n   - Your logging hook can both keep normal logging behavior and add structured error collection for further processing or display.\n\n7. **Testing configuration tools**:\n   - Provide test utilities to simulate configuration files in-memory (e.g., patching `open` inside your YAML loader) so tests don’t depend on actual files on disk.\n   - Construct minimal configs that exercise:\n     - Valid paths (ensuring success is captured correctly).\n     - Schema validation failures (bad values or extra keys).\n     - Missing components/platforms.\n     - Secret resolution behavior.\n\n8. **Dependency tracking for non-core modules**:\n   - If you add scripts or auxiliary packages that depend on external libraries, ensure your dependency generation tooling scans those modules as well as core components. This keeps `requirements_all` (or equivalent) accurate and avoids runtime import errors when users run the new script.\n\nOverall, the pattern is: build tools on top of the same code paths used in production, but wrap side effects, log structured outcomes, handle missing pieces gracefully, and verify behavior with focused tests.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify where your configuration is validated.\n- Locate the main bootstrap/config processing function in your application (e.g., `bootstrap.from_config_file`, `from_config_dict`).\n- Determine which functions are responsible for loading plugins/components (e.g., `loader.get_component`) and for performing schema validation (e.g., `CONFIG_SCHEMA`, `PLATFORM_SCHEMA`).",
            "Step 2: Design a config-check script that reuses existing validation.\n- Write a script/entry point that:\n  - Accepts a path to the config directory.\n  - Locates the primary config file (e.g., `configuration.yaml`).\n  - Calls the existing bootstrap/validation entry point instead of reimplementing validation logic.",
            "Step 3: Mock side-effectful setup functions.\n- Intercept plugin/component loading by patching your loader (e.g., `loader.get_component`).\n- In the patched function:\n  - Call the original loader.\n  - If the module is `None`, record a general error like `Component not found: <name>` or `Platform not found: <domain.platform>` and return `None`.\n  - Otherwise, replace `setup` / `setup_platform` with mock functions that simply record the domain and the validated config into a shared result structure.\n- Ensure that your mock `setup` returns `True` so that the rest of the pipeline behaves as if setup succeeded, while no side effects are performed.",
            "Step 4: Track which config files and secrets are used.\n- Patch your YAML loader (e.g., `load_yaml`) to:\n  - Record each filename it reads into a `res['yaml_files']` map.\n  - Then delegate to the original loader to parse content.\n- Patch your secret handler (e.g., `_secret_yaml` or the constructor for `!secret`) to:\n  - Call the original implementation in a try/except block and record the resolution or failure (e.g., `res['secrets'][node.value] = value or None`).\n  - Also record any internal secret cache the loader maintains, so you can later introspect all known secret values and their sources.\n- Make sure to restore the original loader constructors after your script finishes, to avoid impacting future YAML loads.",
            "Step 5: Capture validation errors structurally.\n- Expose or create a dedicated validation logging function (e.g., `log_exception`) in your bootstrap module if one doesn’t exist.\n- Update places that previously called a private function (e.g., `_log_exception`) to call the public one.\n- In your config-check script, monkeypatch this logging function to a wrapper that:\n  - Calls the original logger so logs still appear in the usual way.\n  - Stores each error in a structured dictionary, e.g., `res['except'][domain] = failing_config`. For general errors (component/platform not found), store them under a special key such as `\"General Errors\"`.",
            "Step 6: Handle missing components/platforms without crashing.\n- If you see stack traces like `AttributeError: 'NoneType' object has no attribute 'setup'` or `setup_platform`, check where the component/platform is being loaded.\n- Confirm whether your mock loader is handling the `None` case:\n  - If not, modify it to check `if module is None:` before accessing attributes.\n  - Record an appropriate error message (`\"Component not found: X\"`, `\"Platform not found: domain.X\"`).",
            "Step 7: Make the tool user-friendly with CLI options.\n- Add options such as:\n  - `--files` to list YAML files, distinguishing between used and unused.\n  - `--secrets` to list secrets used and where they were resolved from.\n  - `--info <domain1,domain2,...>` or `--info all` to print validated configuration for specific domains or the whole system.\n- Implement a helper (like `dump_dict`) to pretty-print nested dictionaries/lists, optionally with source line/file info if available.\n- Use colorized output or clear headings for sections like `Failed config`, `Successful config`, and `Used secrets`.",
            "Step 8: Robustify secrets loading.\n- Implement your secrets loader (e.g., `_load_secret_yaml`) to:\n  - Attempt to load `secrets.yaml` with your YAML loader.\n  - Catch `FileNotFoundError` (or equivalent) and return `{}` so that the absence of the secrets file doesn’t crash validation.\n  - Remove any internal flags (like `logger` levels inside `secrets.yaml`) as needed.\n- Implement the `!secret` handler to:\n  - Search in the current directory and then ascend the directory tree until a known root (like the config dir) or until the path becomes invalid.\n  - Optionally, fall back to a secondary store (like keyring) if no file-based secret is found.",
            "Step 9: Ensure dependency tracking includes scripts.\n- If you have a dependency-collection script (like `gen_requirements_all.py`):\n  - Extend it to traverse your scripts packages (e.g., `homeassistant.scripts`) in addition to components.\n  - Run the generator and add any new script-specific dependencies (e.g., `colorlog`, `colorama`) to your requirements file with descriptive comments.\n- Verify that `pip install -r requirements_all.txt` (or equivalent) succeeds and that running the script doesn’t raise ImportError.",
            "Step 10: Write tests using in-memory YAML files.\n- To test your config-check script:\n  - Create a helper (like `patch_yaml_files`) that patches the YAML module’s `open` or loader so that named pseudo-files (`'light.yaml'`, `'secrets.yaml'`, etc.) are served from in-memory strings.\n  - Write tests that pass different pseudo-filenames into your `check()` function to simulate different scenarios:\n    - Valid environment (valid component/platform).\n    - Failing schema for domain (invalid option values).\n    - Unknown component/platform.\n    - Use of `!secret` and `secrets.yaml`.\n  - Assert on the entire result structure (components, errors, secrets, yaml_files) to ensure behavior matches expectations.",
            "Step 11: Clean up patches and global state.\n- In your script and tests, always restore state after patching:\n  - Use context managers or `try/finally` to ensure patches are stopped even if validation raises an exception.\n  - Re-bind any YAML constructors you overrode (e.g., restore the original `!secret` handler) when done.\n- If you maintain a global cache (like `__SECRET_CACHE`), expose a `clear_secret_cache()` function and call it in tearDown/tearDownModule or at the start of tests to avoid cross-test contamination."
        ]
    }
}
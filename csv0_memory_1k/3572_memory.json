{
    "search_index": {
        "description_for_embedding": "Adds a configurable flag `enable_app_emulation_delay` to control whether the bot sleeps to emulate real app delays. By default, these emulation sleeps are disabled to increase performance, and existing sleep calls around Pokémon encounters/catches are conditioned on this flag.",
        "keywords": [
            "enable_app_emulation_delay",
            "sleep control",
            "timing behavior",
            "performance vs realism",
            "PokemonGo bot",
            "pokecli",
            "pokemon_catch_worker",
            "configuration flag",
            "app delay parity",
            "conditional sleep"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced a feature to control artificial delays in a Pokémon Go bot that were originally added to mimic the timing of the official app (\"app delay parity\"). Some users valued these delays for perceived safety, while others wanted maximum XP/hour by removing non-essential waits. To address this, the author added a new configuration/CLI option `enable_app_emulation_delay`, defaulting to false. The option was wired into the config examples (`configs/config.json.*.example`) and the CLI parser in `pokecli.py` via `add_config(..., long_flag=\"--enable_app_emulation_delay\", type=bool, default=False)`. In the `PokemonCatchWorker` (`pokemongo_bot/cell_workers/pokemon_catch_worker.py`), two sleeps that were explicitly for simulating app behavior around the encounter and catch flow were wrapped in a conditional check: `if self.bot.config.enable_app_emulation_delay: sleep(3)` before catch logic, and `if self.bot.config.enable_app_emulation_delay: time.sleep(5)` after catching. This means that by default the bot skips these app-emulation sleeps, running faster, but users can enable them if they want behavior closer to the real client. There was also discussion about refactoring all `time.sleep` calls through a `human_behaviour.sleep()` wrapper to centralize such control in future PRs, but this PR only makes a minimal, targeted change.",
        "semantic_memory": "This change illustrates a general pattern: timing-related behavior (e.g., sleeps used for realism, rate-limits, or UX) should be configurable and clearly separated from sleeps that are strictly required for correctness or protocol constraints. Rather than hardcoding `time.sleep` calls scattered throughout the codebase, it is beneficial to (1) categorize sleeps by purpose (emulation, rate limiting, backoff, etc.), and (2) gate non-essential sleeps behind feature flags or configuration options. This allows different operational modes (e.g., safe/realistic vs. fast/aggressive) without altering core logic. Over time, consolidating sleep behavior behind an abstraction (like a `human_behavior.sleep()` function) enables global control (enable/disable, jitter injection, logging, dynamic tuning) and simplifies reasoning about bot detectability, performance tuning, and user preferences. Defaulting non-essential delays to off, while providing an explicit opt-in, is a typical strategy when optimizing for throughput while still supporting users who want more conservative behavior.",
        "procedural_memory": [
            "When you need to control or disable non-essential sleep/delay logic (e.g., to balance realism vs. performance), follow these steps:",
            "Step 1: Identify and classify sleeps.",
            "Search the codebase for `time.sleep` (and any existing wrapper like `human_behavior.sleep`). For each occurrence, classify whether the sleep is strictly required for correctness (e.g., API rate limits, cooldowns, server constraints) or is primarily for emulation/UX realism (e.g., mimicking a human tapping through screens).",
            "Step 2: Decide on configuration semantics.",
            "Introduce a clear, purpose-specific configuration flag (e.g., `enable_app_emulation_delay`) that describes what kind of sleeps it will control. Define its default behavior according to the main product goal (e.g., default to `false` to favor performance, or `true` to favor safety/realism).",
            "Step 3: Add the config option consistently.",
            "Update configuration schema/examples (e.g., `configs/config.json.example` and any variants) to include the new flag with a sensible default. Update the CLI or config parsing code (e.g., `pokecli.py`) by adding an option via the existing configuration helper (such as `add_config`) so users can override the flag from the command line.",
            "Step 4: Wire the flag into relevant code paths.",
            "In each location where a non-essential, emulation-oriented sleep is used, wrap the sleep in a conditional check for the new flag, e.g.: `if self.bot.config.enable_app_emulation_delay: time.sleep(3)`. Ensure that removing the sleep does not break protocol constraints or cause rate-limit violations.",
            "Step 5: Keep semantics clear and localized.",
            "Optionally, introduce or reuse a common sleep abstraction (e.g., `human_behavior.sleep(duration)`) that internally respects the configuration flag. This allows future sleeps to automatically follow the same policy and consolidates logic for enable/disable, jitter, and logging in one place.",
            "Step 6: Test both modes.",
            "Run the bot (or application) in both modes: with the flag disabled (no emulation sleeps) and enabled (with sleeps). Verify that: (a) performance improves as expected with sleeps off, (b) behavior still matches expectations with sleeps on, and (c) no timing-sensitive errors or rate-limit issues appear in either mode.",
            "Step 7: Document usage and defaults.",
            "Update user-facing documentation and configuration comments to explain what the flag does, its default value, and the trade-offs (e.g., \"enabling this makes the bot behave more like the official app but reduces XP/hour\"). This helps users choose the right setting for their risk tolerance and performance needs."
        ]
    }
}
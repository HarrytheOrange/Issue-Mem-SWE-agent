{
    "search_index": {
        "description_for_embedding": "Home Assistant Kodi media_player platform extended with platform-specific services to search and add songs/albums to the Kodi music playlist and control shuffle. Initial attempt added generic services to the core media_player component, but the final fix moves them into the Kodi platform, prefixes service names with kodi_, unifies multiple playlist services into a single kodi_add_to_playlist service, and keeps the implementation fully async.",
        "keywords": [
            "home-assistant",
            "Kodi",
            "media_player",
            "kodi_add_to_playlist",
            "kodi_set_shuffle",
            "playlist",
            "shuffle",
            "asyncio",
            "platform-specific services",
            "music library search"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request extended the Home Assistant Kodi media_player platform to better integrate with use cases like voice assistants (e.g., Alexa) by enabling music library search and more flexible playlist control.\n\nInitially, the author added several new services directly to the core media_player component: play_song, add_song_to_playlist, add_album_to_playlist, set_shuffle, unset_shuffle, add_all_albums_to_playlist, plus some lookup helpers (get_artists, etc.). Reviewers pointed out that these services were too platform-specific and should not live in the base media_player component. They requested that services be moved to the Kodi platform, prefixed with kodi_, and that multiple overlapping services be consolidated. They also noted that some services duplicated existing capabilities (play_song vs play_media, unset_shuffle vs a parameterized shuffle) and that the implementation should stay async and non-blocking.\n\nOver a sequence of commits, the author:\n- Removed all custom services from the core media_player __init__.py and reverted its behavior to standard HA patterns.\n- Implemented Kodi-specific services in homeassistant/components/media_player/kodi.py:\n  - kodi_add_to_playlist: adds media to the default playlist (id 0), supporting SONG and ALBUM types, with optional lookup by name and artist, and a special case to add all albums of an artist when media_name == 'ALL'.\n  - kodi_set_shuffle: toggles shuffle mode on/off for the first active Kodi player using a boolean shuffle_on argument.\n- Added supporting async helpers in KodiDevice: async_get_artists, async_get_albums, async_get_songs, async_find_artist, async_find_song, async_find_album, and a _find() helper using regex to match whole words in names.\n- Ensured implementations are coroutine-based (asyncio) instead of blocking event loop calls like run_until_complete within entity methods.\n- Registered the new services only for the Kodi platform with a small async_service_handler in async_setup_platform that:\n  - Looks up the correct method from a SERVICE_TO_METHOD map.\n  - Extracts non-entity_id parameters from service.data.\n  - Calls the method on the Kodi entity and schedules an async_update_ha_state if the entity should_poll.\n- Cleaned up style issues (naming, docstrings, pylint, use of comprehensions) and removed redundant services such as play_song, get_artists as a service, and unset_shuffle.\n\nThe final state is that Kodi exposes two platform-specific services, kodi_add_to_playlist and kodi_set_shuffle, while the core media_player component remains generic.",
        "semantic_memory": "Several generalizable patterns and best practices emerge from this change:\n\n1. **Keep platform-specific logic and services in the platform, not the base component.**\n   - Core components like media_player should only expose functionality that is broadly applicable across platforms. Platform-specific behavior (e.g., Kodi's music library queries, playlist semantics) should be implemented as services within that platform module. This maintains API cleanliness and prevents bloating the base integration with niche features.\n   - When adding platform-only services, prefix them with the platform name (e.g., kodi_add_to_playlist) to avoid collisions and to signal scope.\n\n2. **Consolidate overlapping services into more generic, parameterized ones.**\n   - Instead of separate services like add_song_to_playlist, add_album_to_playlist, and add_all_albums_to_playlist, this PR converged on a single kodi_add_to_playlist service with parameters: media_type (SONG or ALBUM), media_id, media_name, artist_name, plus a special sentinel ('ALL') to handle adding all albums for an artist.\n   - Similarly, separate set_shuffle and unset_shuffle services were replaced by a single kodi_set_shuffle service with a boolean shuffle_on argument.\n   - This yields a simpler, more expressive API and reduces maintenance.\n\n3. **Follow Home Assistant service patterns and schemas.**\n   - Each service is described by a voluptuous schema (e.g., MEDIA_PLAYER_ADD_MEDIA_SCHEMA, MEDIA_PLAYER_SET_SHUFFLE_SCHEMA). This validates input and documents expected fields like media_type, media_name, artist_name, and shuffle_on.\n   - A DOMAIN-specific SERVICE_TO_METHOD mapping ties a service name to an async method and schema, and async_setup_platform registers the services using hass.services.async_register.\n   - A platform-level async_service_handler pulls non-entity_id parameters from service.data, calls the appropriate entity method, and schedules state updates.\n\n4. **Use async I/O correctly in Home Assistant platforms.**\n   - Entity methods that perform I/O should be coroutines (async def / @asyncio.coroutine) and should never call run_until_complete inside them, which would block the event loop.\n   - Instead, they await other coroutine calls (e.g., JSON-RPC client methods) and return promptly. This PR fixed earlier patterns that used run_until_complete inside entity methods and refactored them into proper async flows.\n\n5. **Design search utilities as reusable helpers.**\n   - The Kodi platform provides generic async_get_* and async_find_* helpers (artists, albums, songs) and a static _find function that ranks matches by word occurrence using regex with word boundaries.\n   - This pattern (domain-specific fetch + generic scoring and selection logic) can be reused in other integrations that need fuzzy or partial name matching.\n\n6. **Guard against missing runtime context (like no active players).**\n   - Before attempting to change player state (e.g., shuffle), the code checks that there is at least one active player (len(self._players) >= 1) and raises a clear RuntimeError otherwise. This is a good defensive practice for stateful integrations.\n\nOverall, the PR exemplifies best practices for adding new, rich services to a Home Assistant platform: keep them platform-scoped, parameterized, async, and well-validated, and avoid polluting core abstractions with niche or duplicated functionality.",
        "procedural_memory": [
            "When adding platform-specific services to a Home Assistant media_player platform (like Kodi), follow these steps:",
            "Step 1: Decide whether the functionality belongs in the base component or the platform.",
            "- Ask if the feature is generic across many media player platforms. If not (e.g., exploring Kodi's internal audio library), implement it only in the platform file (homeassistant/components/media_player/<platform>.py).",
            "- Prefix service names with the platform name, e.g., kodi_add_to_playlist, kodi_set_shuffle, to avoid collisions and make their scope clear.",
            "Step 2: Define service constants and voluptuous schemas in the platform.",
            "- Add string constants for service names and any new attributes (e.g., ATTR_MEDIA_TYPE, ATTR_MEDIA_NAME, ATTR_MEDIA_ID, ATTR_MEDIA_ARTIST_NAME).",
            "- Create voluptuous schemas describing valid service data, e.g.:",
            "  - MEDIA_PLAYER_ADD_MEDIA_SCHEMA: requires media_type, and optionally media_id, media_name, artist_name.",
            "  - MEDIA_PLAYER_SET_SHUFFLE_SCHEMA: requires a boolean flag (e.g., shuffle_on).",
            "Step 3: Map services to entity methods.",
            "- Define a SERVICE_TO_METHOD dict in the platform mapping each service name to:",
            "  - 'method': the async method name on the entity (e.g., async_add_media_to_playlist, async_set_shuffle).",
            "  - 'schema': the validation schema.",
            "- Example:",
            "  SERVICE_TO_METHOD = {",
            "      SERVICE_ADD_MEDIA: {'method': 'async_add_media_to_playlist', 'schema': MEDIA_PLAYER_ADD_MEDIA_SCHEMA},",
            "      SERVICE_SET_SHUFFLE: {'method': 'async_set_shuffle', 'schema': MEDIA_PLAYER_SET_SHUFFLE_SCHEMA},",
            "  }",
            "Step 4: Register services in async_setup_platform.",
            "- In async_setup_platform, after creating and adding the entity, define an async_service_handler that:",
            "  - Looks up the service in SERVICE_TO_METHOD.",
            "  - Builds a params dict from service.data excluding entity_id: params = {k: v for k, v in service.data.items() if k != 'entity_id'}.",
            "  - Calls the mapped method on the entity via: yield from getattr(entity, method['method'])(**params).",
            "  - If entity.should_poll is True, schedules entity.async_update_ha_state(True) and waits for it.",
            "- Register each service with hass.services.async_register(DOMAIN, service_name, async_service_handler, schema=schema).",
            "Step 5: Implement async entity methods using non-blocking I/O.",
            "- Implement methods like async_add_media_to_playlist and async_set_shuffle as coroutines (async def or @asyncio.coroutine).",
            "- Never call loop.run_until_complete inside these methods; instead, await the JSON-RPC or HTTP client coroutines directly.",
            "- For Kodi:",
            "  - async_set_shuffle(shuffle_on):",
            "    - Ensure there is at least one active player (e.g., if len(self._players) < 1: raise RuntimeError(\"Error: No active player.\")).",
            "    - Call self.server.Player.SetShuffle({'playerid': self._players[0]['playerid'], 'shuffle': shuffle_on}).",
            "  - async_add_media_to_playlist(media_type, media_id=None, media_name='', artist_name=''):",
            "    - If media_type == 'SONG':",
            "      - If media_id is None, resolve it via async_find_song(media_name, artist_name).",
            "      - Call self.server.Playlist.Add({'playlistid': 0, 'item': {'songid': int(media_id)}}).",
            "    - If media_type == 'ALBUM':",
            "      - If media_id is None and media_name == 'ALL', call async_add_all_albums(artist_name) and return.",
            "      - Otherwise resolve the album via async_find_album(media_name, artist_name).",
            "      - Call self.server.Playlist.Add({'playlistid': 0, 'item': {'albumid': int(media_id)}}).",
            "    - Otherwise, raise a RuntimeError for unrecognized media types.",
            "Step 6: Provide and reuse search helpers.",
            "- Implement helper methods like async_get_artists, async_get_albums, async_get_songs that wrap the platform's underlying API (e.g., Kodi's AudioLibrary.* methods).",
            "- Implement async_find_artist/song/album using those getters and a shared static helper _find(key_word, words) that:",
            "  - Splits key_word into tokens.",
            "  - Uses regex with word boundaries (e.g., '(^| )<token>( |$)') to match whole words case-insensitively.",
            "  - Scores each candidate by the number of matching tokens and returns the best match index.",
            "- This pattern makes the search logic reusable for multiple services (playlist ops, future features, etc.).",
            "Step 7: Keep the core media_player component clean.",
            "- Avoid adding platform-specific services or attributes to homeassistant/components/media_player/__init__.py.",
            "- Use the base component only for widely applicable services like play_media, volume control, and source selection.",
            "- Route specialized behaviors into the relevant platform module using the mechanism above.",
            "Step 8: Clean up after review.",
            "- If initial changes touched core components or added redundant services, be prepared to remove or refactor them after peer review.",
            "- Run linting (pylint, flake8) and tests (tox) to ensure style and behavior are consistent with project standards.",
            "- Simplify APIs by merging redundant services and using parameters instead of separate endpoints for on/off or similar variants."
        ]
    }
}
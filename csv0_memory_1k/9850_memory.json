{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant Netatmo binary_sensor where the timeout/offset for camera and tag events did not get a proper default when using auto-discovery, and two separate config options (timeout and offset) represented the same underlying time window. The fix unifies timeout and offset into a single timeout parameter, ensures a default is applied even under discovery, and passes a consistently scaled timeout to the Netatmo camera data API.",
        "keywords": [
            "Home Assistant",
            "Netatmo",
            "binary_sensor",
            "CONF_TIMEOUT",
            "CONF_OFFSET",
            "default timeout",
            "auto-discovery",
            "discovery_info",
            "configuration schema",
            "missing default",
            "time window",
            "event window",
            "unit mismatch",
            "bug fix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Netatmo binary sensors in Home Assistant behaved incorrectly when configured via auto-discovery. The component defined two related configuration options: `timeout` (default 15) and `offset` (default 90). In practice, both represented the same logical concept: the time window in which Netatmo events (motion, presence, tag vibrations, etc.) should be considered 'recent' and thus turn the binary sensor on. However, when the platform was initialized via auto-discovery, the default settings were not properly applied, causing the timeout to be `None` or effectively incorrect for discovered entities. Additionally, the code passed `timeout * 60` for some calls and `offset` for others, creating inconsistency in units and behavior.\n\nThe fix consolidated `timeout` and `offset` into a single `timeout` configuration option with a new default of 90. The `CONF_OFFSET` option and associated constant were removed from the schema and entity class. In `setup_platform`, the code now explicitly checks if `timeout` is `None` (a scenario that can happen with discovery) and assigns the `DEFAULT_TIMEOUT` if so. All Netatmo camera/tag API calls now consistently use `self._timeout` without multiplying by 60 and without using a separate offset parameter. This ensures that binary sensors get a proper, predictable time window both for manual configuration and for auto-discovery, and removes redundant configuration options. A small style fix also removed an unnecessary `else: return None` at the end of `update()`.",
        "semantic_memory": "This case illustrates several generalizable practices for configuration-driven integrations and event-based sensors:\n\n1. **Single source of truth for related parameters**: When two configuration parameters represent the same conceptual value (e.g., `timeout` and `offset` both representing an event lookback window), they should be unified. Maintaining both increases the risk of inconsistencies, confusion, and bugs when one is updated and the other is not.\n\n2. **Consistent defaults across all initialization paths**: Components that can be initialized via multiple pathways (manual configuration, auto-discovery, or other programmatic means) must ensure that defaults are applied uniformly. Relying solely on configuration schema defaults can fail when the config object is partially populated or bypassed by discovery mechanisms. Explicit fallback logic in setup code can prevent `None` values or incorrect behavior.\n\n3. **Unit consistency between configuration and library APIs**: Time-based configuration values must have clearly defined units, and those units must match the expectations of downstream APIs. Mixing seconds, minutes, or other units (e.g., multiplying by 60 in some paths but not others) leads to subtle behavioral bugs, especially in event windows for sensors.\n\n4. **Avoid redundant branching in update loops**: Returning `None` from the tail of an `update()` method in an entity class is usually redundant and can be removed for clarity and style. Update methods typically rely on side effects (setting state) rather than return values.\n\n5. **Discovery-specific regressions**: Auto-discovery often exercises code paths that bypass explicit user configuration. Bugs that only show up under discovery frequently involve missing defaults, missing validation, or assumptions that configuration keys will always be present. Testing both manual and discovery setups is important for integrations.\n\nThese principles apply broadly to any home automation platform or service where devices are discovered automatically and configured via schemas, especially for time-based sensors and event polling windows.",
        "procedural_memory": [
            "When diagnosing issues where discovered sensors behave differently from manually configured ones, compare configuration defaults and initialization paths.",
            "Step 1: Reproduce the problem under both manual configuration and auto-discovery. Verify if behavior (e.g., binary sensor state transitions, event detection windows) differs between the two.",
            "Step 2: Inspect the platform schema and the setup function. Check which options are declared with defaults (e.g., via a validation schema) and how values are read (e.g., `config.get(CONF_TIMEOUT)`). Identify whether discovery populates the same `config` object or uses a different code path.",
            "Step 3: Log or debug-print the effective configuration values during discovery-based setup. Look specifically for `None` or unexpected values for critical parameters (timeouts, hostnames, ports, credentials).",
            "Step 4: Identify redundant or overlapping configuration options (e.g., `timeout` vs. `offset`) that describe the same concept. Review their usage in the code to see if they are kept in sync or used inconsistently.",
            "Step 5: Decide on a single canonical parameter for the concept (e.g., a unified `timeout`) and update the configuration schema to remove the redundant option. Adjust defaults accordingly.",
            "Step 6: In the platform setup function, after reading from `config`, add explicit fallback logic: if a critical parameter is `None`, assign a reasonable default (e.g., `if timeout is None: timeout = DEFAULT_TIMEOUT`). This protects against cases where the schema default is bypassed, such as discovery.",
            "Step 7: Review all downstream calls that use the parameter, ensuring units and semantics are consistent. Remove unnecessary scaling (e.g., `timeout * 60`) if the underlying library expects the same unit as the configuration. Update function signatures to take the unified parameter instead of multiple similar ones.",
            "Step 8: Run existing tests and, if possible, add tests that cover both manual and discovery-based initialization paths. For time-based logic, include tests that verify behavior with the default timeout and custom timeout values.",
            "Step 9: Clean up style issues revealed while refactoring (removing dead branches like `else: return None` in `update()`), and run linters/formatters to ensure code quality.",
            "Step 10: Update documentation to reflect the removal or renaming of configuration options (e.g., removing `offset` and describing the semantics of `timeout` clearly, including its unit and default)."
        ]
    }
}
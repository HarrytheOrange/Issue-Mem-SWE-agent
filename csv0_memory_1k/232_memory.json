{
    "search_index": {
        "description_for_embedding": "Added support for custom viewer-level key bindings in napari. A new `Viewer.key_bindings` dict maps key strings to callables that receive the viewer; these callbacks fire on key press (non auto-repeat) and override layer-specific key handlers. An example script demonstrates using 'a' and 'r' keys to accept or reject an image and load a new one.",
        "keywords": [
            "custom key bindings",
            "keyboard shortcuts",
            "napari viewer",
            "Viewer.key_bindings",
            "on_key_press",
            "event.native.isAutoRepeat",
            "QtViewer",
            "layer key events",
            "UI input handling",
            "example custom_key_bindings.py"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the project needed a way for users to define custom key bindings at the viewer level, as discussed in prior issues (#200 and #210). Previously, only layer-specific key press handlers existed; there was no high-level viewer API for custom global shortcuts. The solution introduced a `key_bindings` attribute on the `Viewer` model, intended as a dictionary mapping key strings (e.g. 'a', 'r') to callables that accept the `viewer` instance. In the Qt viewer's `on_key_press` handler (`napari/components/_viewer/view/main.py`), the logic was updated to first check if the pressed key is in `viewer.key_bindings` and that the event is not an auto-repeat (`not event.native.isAutoRepeat()`). If the key is bound, the associated callback is called with the viewer and the method returns early, meaning these custom bindings override any layer-specific key press behavior. If no custom binding is found, the event is forwarded to the current top layer via `layer.on_key_press(event)` as before. An example script `examples/custom_key_bindings.py` was added to demonstrate usage: pressing 'a' or 'r' prints a message ('good' or 'bad' image) and then generates a new random blob image using `skimage.data.binary_blobs`, updating `viewer.layers[0].image`. A follow-up commit fixed PEP8/style issues (indentation and dict spacing), and another refactor removed an unnecessary property/setter pair for `key_bindings` in favor of a simple public attribute initialized as an empty dict in the viewer's `__init__`.",
        "semantic_memory": "This change illustrates a common pattern for GUI frameworks and visualization tools: providing a simple, declarative way for users to bind keyboard shortcuts to actions at an application or viewer scope, while maintaining compatibility with lower-level or per-component handlers. Key design points include: (1) representing key bindings as a mapping from key identifiers (strings) to callables, which encourages decoupling UI events from business logic; (2) ensuring that keyboard callbacks receive the main application/viewer object (or some context object) so that they can mutate state or trigger navigation; (3) handling auto-repeat key events explicitly to avoid repeated execution when a key is held, which can otherwise cause unintended rapid state changes; (4) defining a clear precedence model between global and component-specific shortcuts (here, global viewer bindings override layer bindings when defined); and (5) providing an example script to demonstrate and validate the new API in a realistic workflow. More generally, when adding extensible input handling, you should consider event ordering, override semantics, preventing double-handling, and making the API minimal but flexible enough to be extended later (e.g., adding key-release or mouse events).",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the missing interaction capability or customization point.\n- Review how keyboard and mouse events are currently handled in the application.\n- Determine whether there is an existing API for global key bindings or only per-widget/per-layer handlers.\n- Check related issues or feature requests to clarify the desired usage pattern and scope (viewer-level vs component-level).",
            "Step 2: Design a minimal, extensible API for custom key bindings.\n- Choose a data structure: typically a dictionary mapping key identifiers (e.g. 'a', 'Ctrl+S') to callables.\n- Decide what arguments the callable should accept (e.g. the viewer/app instance, or an event object) so the handler has enough context.\n- Define precedence rules: should global bindings override component-specific ones, or vice versa?\n- Consider future extensions (key release, mouse events) and avoid locking into an inflexible design.",
            "Step 3: Expose the key bindings on the main model or controller.\n- Add an attribute (e.g. `self.key_bindings = {}`) on the main viewer or application object during initialization.\n- Avoid unnecessary property/setter complexity unless you need validation or side effects.\n- Document the attribute’s expected structure and semantics in the class docstring.",
            "Step 4: Integrate the key bindings into the event pipeline.\n- Locate the central key press handler (e.g. `on_key_press` in the view/controller layer).\n- At the start of this handler, check if the incoming key matches a custom binding:\n  - Extract the key text (e.g. `event.text`).\n  - Filter out auto-repeat events (e.g. `if not event.native.isAutoRepeat():`).\n  - If a binding exists, call the associated function with the appropriate context (e.g. `self.viewer.key_bindings[event.text](self.viewer)`).\n  - If you intend global bindings to override component handlers, return immediately after executing the callback.",
            "Step 5: Preserve or clearly alter existing behavior.\n- If there are existing per-layer or per-component handlers (e.g. `layer.on_key_press(event)`), ensure they still run when no custom global binding is registered.\n- Only change the ordering/priority when you have a clear rationale and it’s documented (e.g. global viewer shortcuts override layer shortcuts).",
            "Step 6: Handle auto-repeat and edge cases.\n- Use the underlying toolkit’s API (Qt, etc.) to detect auto-repeat key events and avoid re-triggering handlers when the key is held down, unless repeated actions are desired.\n- Consider how to handle unknown keys, modifier keys, and focus changes.\n- Make sure the code gracefully handles `None` or empty key binding dictionaries.",
            "Step 7: Provide an example for users and manual testing.\n- Add a small example script (e.g. `examples/custom_key_bindings.py`) that:\n  - Instantiates the viewer or app.\n  - Registers a few key bindings with simple, visible side effects (printing messages, changing the display, loading new data).\n  - Demonstrates the intended control flow (e.g. pressing 'a' or 'r' changes an image).\n- Manually run the example and verify:\n  - Key presses trigger the right callbacks.\n  - Holding down keys does not cause repeated triggering when undesired.\n  - Component-specific shortcuts still work when no global binding is defined.",
            "Step 8: Clean up and conform to style guidelines.\n- Ensure the new code follows the project’s style (PEP8, docstring conventions, naming).\n- Simplify the implementation if there is redundant indirection (e.g. remove unnecessary property setters for a simple dict attribute).",
            "Step 9: Document the new behavior and precedence.\n- Update class or module docstrings to explain the `key_bindings` attribute and how to use it.\n- Describe precedence rules (global vs layer handlers) and limitations (e.g. no key-release or mouse support yet).\n- Optionally, add high-level documentation or a guide section referring to the example script."
        ]
    }
}
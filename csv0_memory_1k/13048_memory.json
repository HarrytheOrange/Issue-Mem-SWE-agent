{
    "search_index": {
        "description_for_embedding": "Home Assistant Homematic: HmIP-STHO-A / IPAreaThermostat temperature sensor was not created because the ACTUAL_TEMPERATURE datapoint was globally ignored by the Homematic discovery logic. Fix adds unit/icon mappings for ACTUAL_TEMPERATURE and introduces an ignore-with-exceptions mechanism (HM_IGNORE_DISCOVERY_NODE_EXCEPTIONS) so ACTUAL_TEMPERATURE stays ignored in general but is allowed for IPAreaThermostat, enabling proper temperature reporting from the HmIP-STHO-A sensor.",
        "keywords": [
            "homeassistant",
            "home assistant",
            "homematic",
            "HmIP-STHO-A",
            "IPAreaThermostat",
            "ACTUAL_TEMPERATURE",
            "ACTUAL_HUMIDITY",
            "HM_IGNORE_DISCOVERY_NODE",
            "HM_IGNORE_DISCOVERY_NODE_EXCEPTIONS",
            "sensor discovery",
            "entity not created",
            "temperature sensor missing",
            "pyhomematic",
            "DISCOVER_SENSORS"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a user reported that the temperature from a Homematic IP STHO-A sensor (class IPAreaThermostat in pyhomematic) was not available in Home Assistant. The root cause was that the Homematic integration's discovery logic globally ignored datapoints named ACTUAL_TEMPERATURE and ACTUAL_HUMIDITY via HM_IGNORE_DISCOVERY_NODE. This worked for most Homematic devices where ACTUAL_TEMPERATURE would be redundant, but for the HmIP-STHO-A sensor the only temperature datapoint is ACTUAL_TEMPERATURE. Because it was on the ignore list, no temperature sensor entity was created.\n\nThe fix proceeded as follows:\n- Initially, ACTUAL_TEMPERATURE was removed from HM_IGNORE_DISCOVERY_NODE, which would have exposed it for all devices, but that risked reintroducing duplicate or conflicting temperature entities for other Homematic classes.\n- To keep the general behavior while allowing an exception, the developer restored ACTUAL_TEMPERATURE in HM_IGNORE_DISCOVERY_NODE and introduced a new mapping HM_IGNORE_DISCOVERY_NODE_EXCEPTIONS, which maps ignored parameters to a list of Homematic class names for which they should *not* be ignored.\n- The code that iterates over Homematic device metadata in `_get_devices` was updated: before skipping a parameter, it now checks whether the current device `class_name` is listed as an exception in HM_IGNORE_DISCOVERY_NODE_EXCEPTIONS for that parameter. If it is (e.g., ACTUAL_TEMPERATURE + IPAreaThermostat), the parameter is not ignored and a sensor entity can be created.\n- The pyhomematic class `IPAreaThermostat` was added to the DISCOVER_SENSORS list so that Home Assistant knows to treat this device as a sensor.\n- The Homematic sensor module (`sensor/homematic.py`) was extended to map ACTUAL_TEMPERATURE to the same unit and icon as TEMPERATURE: 'ACTUAL_TEMPERATURE': '°C' in HM_UNIT_HA_CAST and 'ACTUAL_TEMPERATURE': 'mdi:thermometer' in HM_DEVICE_SENSORS.\n- There were temporary changes to bump the pyhomematic requirement and to add a full requirements_all.txt file, but these were reverted after review. The final state kept the original pyhomematic==0.1.39 requirement and removed the accidental requirements file. Minor style issues (trailing commas, indentation, line breaks) were also fixed to satisfy linting.\n\nAs a result, Home Assistant now exposes the HmIP-STHO-A temperature sensor correctly by using ACTUAL_TEMPERATURE for the IPAreaThermostat class, while preserving the existing behavior of ignoring ACTUAL_TEMPERATURE for other Homematic devices where it would be redundant or conflicting.",
        "semantic_memory": "This fix illustrates several generalizable patterns for integrations that auto-discover device attributes:\n\n1. **Global ignore lists vs. per-device exceptions**: A single protocol parameter name (e.g., ACTUAL_TEMPERATURE) can have different semantics depending on the device class. A global rule like \"always ignore this parameter\" may work for most devices but break others that rely on it. A better pattern is to maintain an ignore list augmented with a per-device (or per-class) exception mechanism, such as a dict mapping parameter names to allowed class names.\n\n2. **Discovery filters as a key failure mode**: When a device or attribute seemingly \"does not exist\" in the UI, a common cause is filtering in the discovery or mapping layer (e.g., ignore lists, whitelists, or missing entries in a device-class registry like DISCOVER_SENSORS). Checking those mappings is essential when diagnosing missing entities.\n\n3. **Consistent unit and icon mapping for new datapoints**: When promoting a new raw datapoint to a user-facing sensor, it should be added to the unit and icon mapping tables to ensure the UI displays it consistently with similar datapoints (e.g., treat ACTUAL_TEMPERATURE just like TEMPERATURE, with '°C' and a thermometer icon).\n\n4. **Separating dependency version bumps from feature changes**: The maintainer requested not to tie this behavior change to a dependency version bump, because the feature did not strictly require a newer pyhomematic version. This reflects the best practice of decoupling integration bug fixes from dependency updates unless the new code actually depends on new APIs.\n\n5. **Lint and style compliance when modifying core logic**: Adjustments to core integration logic must maintain coding standards (import ordering, line length, indentation, etc.), especially when modifying central discovery functions. Automated tooling (pylint/flake8) will enforce this and can cause otherwise correct fixes to be blocked if not respected.\n\n6. **Use domain-specific metadata (class_name) for fine-grained behavior**: The Homematic integration already knew the `class_name` of each device. Leveraging this metadata allowed the implementation of a precise exception list without changing the broader discovery design, showing the value of exposing and using device metadata in integration layers.",
        "procedural_memory": [
            "When a device sensor (e.g., temperature) is missing from an integration that uses auto-discovery, systematically check the discovery and filtering logic, and introduce parameter-level exception handling when a globally ignored parameter must be used for specific device classes.",
            "Step 1: Reproduce and characterize the issue.\n- Confirm that the integration is connected and other entities from the same device are present.\n- Identify exactly which metric is missing (e.g., temperature from HmIP-STHO-A) and which underlying datapoint the device exposes (e.g., ACTUAL_TEMPERATURE from pyhomematic).",
            "Step 2: Inspect discovery mappings and ignore lists.\n- Locate the integration's discovery code (e.g., `_get_devices` in the Homematic integration).\n- Check lists/dicts that influence which parameters are discovered:\n  - Global ignore lists (e.g., `HM_IGNORE_DISCOVERY_NODE`).\n  - Per-type discovery registries (e.g., `DISCOVER_SENSORS`, `DISCOVER_CLIMATE`).\n- Verify if the missing datapoint name (e.g., ACTUAL_TEMPERATURE) is in an ignore list or simply not handled.",
            "Step 3: Decide on global vs. scoped behavior.\n- Determine whether the ignored parameter should generally remain ignored (e.g., to avoid duplicates on other devices) or whether it should be enabled for all.\n- If it should only be active for some device types, plan an exception mechanism rather than removing it from the global ignore list.",
            "Step 4: Implement an ignore-with-exceptions mechanism.\n- Introduce a new mapping, e.g.: `HM_IGNORE_DISCOVERY_NODE_EXCEPTIONS = { 'ACTUAL_TEMPERATURE': ['IPAreaThermostat'], }`.\n- In the discovery loop, before skipping a parameter, check the exceptions:\n  - Pseudocode: `if param in IGNORE_LIST and class_name not in IGNORE_EXCEPTIONS.get(param, []): continue`.\n- Ensure you have access to a device identifier (class_name, model id, etc.) that can be used as the key in the exceptions mapping.",
            "Step 5: Register the device class in the appropriate discovery group.\n- If the device’s class is not yet recognized for the relevant platform, add it to the appropriate list (e.g., add `IPAreaThermostat` to `DISCOVER_SENSORS`).\n- This ensures that once the parameter passes the filter, the integration will actually create the correct type of entity.",
            "Step 6: Map units and icons for new datapoints.\n- Add the new datapoint name to unit mapping tables to ensure correct units in the UI, e.g.: `HM_UNIT_HA_CAST['ACTUAL_TEMPERATURE'] = '°C'`.\n- Add the datapoint to icon mappings, e.g.: `HM_DEVICE_SENSORS['ACTUAL_TEMPERATURE'] = 'mdi:thermometer'`.\n- Use existing similar parameters as a guide (e.g., copy how TEMPERATURE is handled).",
            "Step 7: Validate dependency constraints and avoid unnecessary bumps.\n- Confirm that your changes do not require a newer version of the underlying library than currently specified.\n- If you temporarily bump a requirement to test new classes or features, revert that change unless the new version is strictly required and available on the package index.\n- Avoid committing generated or large requirements files unless explicitly part of the project workflow.",
            "Step 8: Run tests and linters.\n- Run the project’s linting and test suite (e.g., `tox`, `pytest`) to ensure style and correctness.\n- Fix any style issues such as line continuations, indentation, and trailing commas, especially around changed conditional logic in core modules.",
            "Step 9: Manually test affected devices.\n- Restart the application and re-run device discovery.\n- Confirm that the previously missing sensor (e.g., HmIP-STHO-A ACTUAL_TEMPERATURE) now appears, shows the expected unit and icon, and reports valid values.\n- Verify that other devices that rely on the globally ignored parameter remain unaffected (i.e., no duplicate or spurious entities appear).",
            "Step 10: Document patterns for future similar issues.\n- Note in code comments or project docs why a parameter is globally ignored and why certain classes are listed in the exceptions.\n- Use this pattern for future devices where a generally ignored protocol parameter is essential for a specific class, to keep behavior consistent and maintainable."
        ]
    }
}
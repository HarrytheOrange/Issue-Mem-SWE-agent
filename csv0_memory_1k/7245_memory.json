{
    "search_index": {
        "description_for_embedding": "Fixes a WeMo integration bug where the pywemo library leaked UPnP event subscriptions, causing excessive resubscribe log spam and eventual device malfunction. The fix upgrades pywemo to 0.4.19 and adds a workaround: WeMo Insight switches now use polling for power state instead of relying solely on broken subscription updates.",
        "keywords": [
            "WeMo",
            "wemo",
            "pywemo",
            "subscription leak",
            "UPnP event subscription",
            "resubscribe log spam",
            "Insight switch",
            "switch/wemo.py",
            "homeassistant.components.wemo",
            "requirements_all.txt",
            "event-driven vs polling",
            "device not responding",
            "0.4.19",
            "should_poll workaround"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's WeMo integration exhibited a bug where pywemo leaked UPnP event subscriptions. Over time, multiple redundant subscriptions were created and not cleaned up. This resulted in logs filling up with repeated messages like 'Resubscribe for <WeMo Insight \"Couch Light\">' and, after several hours, WeMo devices becoming unreliable or non-functional. The root cause was in the external library pywemo. The fix consisted of two parts: (1) updating the WeMo component's dependency from pywemo==0.4.18 to pywemo==0.4.19 in both homeassistant/components/wemo.py and requirements_all.txt, which addresses the subscription leak; and (2) adding a targeted workaround for WeMo Insight switches in homeassistant/components/switch/wemo.py. Specifically, the switch entity's should_poll property now returns True when self._model_name == 'Insight', forcing periodic polling for Insight devices because subscription-based updates for their power properties are still unreliable after the core subscription fix. This combination stops the log spam and stabilizes device behavior at the cost of using polling for Insight power updates. The change was important enough to be cherry-picked into Home Assistant 0.43.1.",
        "semantic_memory": "This case illustrates several generalizable patterns for integrations with networked devices and third-party libraries:\n\n1. **Event subscription leaks in long-lived services**: Systems that rely on UPnP/event subscriptions or similar long-lived callbacks (webhooks, SSE, MQTT subscriptions) can leak resources if subscriptions are renewed without properly cleaning up previous ones. Symptoms often show up only after hours or days of uptime: log spam about resubscribe operations, increased memory/CPU usage, and devices becoming unresponsive.\n\n2. **Balancing event-driven updates and polling**: When event-driven updates are unreliable or buggy for a subset of devices or properties, it can be pragmatic to selectively fall back to polling for those cases. Implementations often expose a flag (like should_poll) per entity or device type to control this behavior, allowing fine-grained workarounds without sacrificing event-driven efficiency for all devices.\n\n3. **Version pinning and targeted upgrades**: When a bug lives in an external dependency, upgrading to a specific fixed version (e.g., pywemo 0.4.19) and adjusting requirement pins in all relevant files (component-level REQUIREMENTS and global requirements_all.txt) is necessary to ensure deployments actually pick up the fix.\n\n4. **Graceful degradation over perfect design**: Instead of waiting for a perfect upstream fix that covers all edge cases (e.g., event updates for Insight power properties), it's often better to ship a stable workaround (polling) for a problematic subset of devices. This preserves reliability for users while longer-term library fixes are developed.\n\n5. **Using logs as early warning signals**: Repeated, seemingly harmless log lines (like periodic resubscribe messages) can be early indicators of deeper systemic issues (like leaking subscriptions). Monitoring log volume and patterns can help detect such issues before they fully break functionality.\n\n6. **Component-specific behavior toggles**: Having device model awareness (_model_name == 'Insight') in the component allows per-model behavior differences, which is useful when certain models have unique protocol or library quirks.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms and gather logs\n- Monitor logs for repetitive or rapidly increasing messages related to subscriptions or resubscribe operations (e.g., 'Resubscribe for <Device X>').\n- Note whether affected devices become unreliable over time (missed updates, unresponsiveness, or delayed state changes).",
            "Step 2: Confirm the dependency versions\n- Check the integration/component file for a REQUIREMENTS or dependency declaration to see which library version is used (e.g., REQUIREMENTS = ['pywemo==0.4.18']).\n- Cross-reference this version with the library's changelog or known issues to see if subscription or event-related bugs are reported and fixed in later versions.",
            "Step 3: Reproduce under controlled conditions\n- Run the system in a development environment and let it operate for several hours while monitoring logs.\n- Confirm that the number of active subscriptions grows or that resubscribe messages appear more frequently over time.\n- Use debugging tools or library APIs (if available) to inspect active subscriptions or event handlers.",
            "Step 4: Update the third-party library to a fixed version\n- Identify a library version that addresses the subscription leak (e.g., pywemo 0.4.19).\n- Update the component-specific REQUIREMENTS declaration to the new version.\n- Update any global requirements files (e.g., requirements_all.txt) to keep them in sync.\n- Reinstall dependencies or rebuild containers to ensure the new version is actually in use.",
            "Step 5: Add targeted workarounds for remaining edge cases\n- If certain device models or properties still do not receive reliable event updates after the core fix, add a targeted fallback.\n- Example: Override an entityâ€™s should_poll property to return True for a specific model_name (e.g., 'Insight') while keeping others event-driven.\n- Ensure the condition is as specific as possible (by device type/model) to minimize the performance impact of unnecessary polling.",
            "Step 6: Verify behavior after changes\n- Restart the system and monitor logs over an extended period to confirm that log spam (e.g., resubscribe messages) has stopped or significantly reduced.\n- Verify that previously affected devices now remain responsive and accurate over time.\n- Confirm that the polling fallback yields timely and correct state updates for the targeted devices (e.g., power properties on WeMo Insight switches).",
            "Step 7: Add regression protection\n- If feasible, add tests or checks that simulate subscription handling behavior, ensuring that subscriptions do not leak across renewals.\n- Document any model-specific workarounds (e.g., 'Insight switches use polling due to subscription issues') so future maintainers understand why the logic exists and when it can be removed.",
            "Step 8: Release and backport strategically\n- If the bug severely impacts users (log flooding, device failures), prioritize including the fix in the next patch/point release.\n- Cherry-pick the changes into maintenance branches where appropriate, ensuring users on stable versions receive the fix promptly."
        ]
    }
}
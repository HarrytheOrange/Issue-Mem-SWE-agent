{
    "search_index": {
        "description_for_embedding": "Home Assistant Toon integration was violating Toon API quotas because entities were polling too frequently. The fix increased the minimum update interval and applied the Home Assistant Throttle decorator to entity update methods so multiple entities no longer hammer the API.",
        "keywords": [
            "Home Assistant",
            "Toon",
            "toonapilib",
            "API quota violation",
            "rate limiting",
            "polling interval",
            "MIN_TIME_BETWEEN_UPDATES",
            "SCAN_INTERVAL",
            "Throttle decorator",
            "IncompleteStatus 500",
            "Internal Server Error",
            "sensor",
            "climate",
            "binary_sensor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Toon integration was making too many requests to the Toon (Quby) API, leading to quota violations and errors. Users observed frequent exceptions like `toonapilib.toonapilibexceptions.IncompleteStatus: {'code': 500, 'message': 'Internal Server Error', 'description': 'Error communicating with Toon'}` and reported that every Toon sensor would throw errors. A user instrumented the system with a template sensor (`{{relative_time(states.sensor.current_power_usage.last_updated)}}`) to track how often an entity was updated, and noticed updates about every 10–30 seconds.\n\nIn the original Toon component, each entity type (binary_sensor, sensor, climate) defined `MIN_TIME_BETWEEN_UPDATES = timedelta(seconds=5)` and `SCAN_INTERVAL = timedelta(seconds=30)`, but the integration was not actually using the `Throttle` decorator. The `SCAN_INTERVAL` constant was declared but effectively unused within the Toon files, so entities could still be updated too frequently by Home Assistant's internal scheduling, causing many API calls when multiple entities were present.\n\nThe pull request changed the behavior by:\n- Increasing `MIN_TIME_BETWEEN_UPDATES` from 5 seconds to 30 seconds for Toon binary sensors, sensors, and climate entities.\n- Importing and using `homeassistant.util.Throttle`.\n- Decorating each entity's `update()` method (`binary_sensor.update`, `sensor.update`, and `climate.update`) with `@Throttle(MIN_TIME_BETWEEN_UPDATES)` so that even if Home Assistant calls `update()` more often, the actual code accessing the Toon client is rate-limited.\n- Removing the unused `SCAN_INTERVAL` constants from these Toon entity modules.\n\nA temporary personal transformation of a boiler-related sensor value was also added and then removed in a follow-up patch to keep the change focused on rate limiting. Maintainers later commented that, while this change reduces the request rate, it is not the final or preferred solution (and might still violate Toon’s terms of service). They indicated they were working on a more robust architecture where entities do not poll the API directly.\n\nNet effect: the integration now uses the Throttle decorator to enforce a 30-second minimum interval between Toon API calls per entity, reducing the number of calls and mitigating quota violations and related 500 Internal Server Error responses.",
        "semantic_memory": "This case illustrates several generalizable lessons about integrating with third-party APIs in a polling-based home automation system:\n\n1. **Rate limiting must be enforced in code, not assumed.** Merely defining constants like `MIN_TIME_BETWEEN_UPDATES` or `SCAN_INTERVAL` has no effect unless those values are actually used by the framework or applied explicitly (e.g., via decorators like `Throttle` or scheduler configuration). Always confirm that rate-limiting parameters are wired into the call path.\n\n2. **Centralized or shared polling is preferable to per-entity polling.** If each entity independently calls into the API, the effective request rate is multiplied by the number of entities. A better approach is to have a single coordinator (or data update coordinator pattern) that polls at a controlled rate and distributes the data to entities.\n\n3. **Use framework-native mechanisms for update intervals.** Many frameworks (like Home Assistant) provide mechanisms such as `SCAN_INTERVAL` or dedicated throttling utilities. These should be used instead of ad hoc timing logic, as they integrate better with the overall system and can often be configured by users.\n\n4. **Respect third-party API terms and quotas.** Even if the integration appears to work for an individual user, excessive polling can break terms of service or exhaust API quotas, leading to errors (e.g., 500 responses) and potential bans. Solutions should be designed with the provider’s documented limits in mind.\n\n5. **Instrumentation and observation are key to diagnosing over-polling.** Using tooling such as template sensors, logs, or metrics to monitor update timestamps and request counts can reveal when an integration is polling too frequently.\n\n6. **Decorators like `Throttle` are a simple way to enforce minimum intervals.** Wrapping update methods with a throttling decorator is a clean pattern that can be re-used for other integrations to quickly reduce API pressure without redesigning the entire architecture.\n\nOverall, the pattern is: measure actual polling behavior; identify unnecessary or duplicated API calls; enforce minimum intervals via framework tools (Throttle, SCAN_INTERVAL, coordinators); and align those intervals with external API constraints.",
        "procedural_memory": [
            "When diagnosing and fixing an integration that is hitting an external API too frequently, follow steps like these:",
            "Step 1: Detect symptoms of over-polling.\n- Look for error responses from the external API, especially rate-limit or server overload indicators (e.g., HTTP 429 or 500 with messages about too many requests).\n- Check logs for frequent exceptions or warnings related to the integration.\n- If available, monitor the provider’s dashboard or logs for excessive request counts.",
            "Step 2: Measure actual update frequency.\n- Add lightweight instrumentation to see how often entities are updating (e.g., a template sensor that reports `relative_time(last_updated)` or log messages in `update()` methods).\n- Confirm whether the observed polling interval matches your intended or documented interval.",
            "Step 3: Inspect the integration’s polling configuration.\n- Search the code for constants like `SCAN_INTERVAL`, `MIN_TIME_BETWEEN_UPDATES`, or similar update interval settings.\n- Verify that these values are actually used: Is there a decorator (e.g., `@Throttle`)? Is the integration using the framework’s scheduling APIs that read `SCAN_INTERVAL`?\n- Check whether each entity is polling independently, or if there is a shared coordinator.",
            "Step 4: Apply proper rate limiting.\n- If using a framework like Home Assistant, prefer:\n  - `SCAN_INTERVAL` for default update scheduling when supported by the platform, and/or\n  - `homeassistant.util.Throttle` (or equivalent) on functions that perform API calls.\n- Increase `MIN_TIME_BETWEEN_UPDATES` or equivalent to a value aligned with the API’s allowed rate (e.g., 30 seconds instead of 5 seconds).\n- Decorate all relevant `update()` or fetch methods with the throttle decorator so that multiple calls within the interval are effectively no-ops with respect to the remote API.",
            "Step 5: Reduce duplicate API calls across entities.\n- If many entities are polling the same API, refactor to use a single shared data fetch:\n  - Implement a central data update coordinator that polls the API on a schedule, caches the results, and shares them with entities.\n  - Ensure each entity’s `update()` reads from the shared state instead of hitting the API directly.\n- This prevents the request rate from scaling linearly with the number of entities.",
            "Step 6: Test under realistic conditions.\n- Run the integration locally with typical configuration (same number of entities as users would have).\n- Confirm via logs or instrumentation that:\n  - API calls occur no more frequently than your chosen interval.\n  - Errors from the API decrease or disappear.\n- Observe for at least several typical polling intervals to ensure behavior is stable.",
            "Step 7: Validate against provider limits and policies.\n- Review the third-party API documentation and terms of service to ensure your polling interval and usage conform to their requirements.\n- If necessary, further increase the interval or move to event-based/webhook-based updates instead of polling.",
            "Step 8: Clean up and scope the change.\n- Remove any experimental or personal logic unrelated to rate limiting (e.g., custom transformations that are not part of the bug fix).\n- Keep the patch focused on the rate-limiting behavior so it’s easy to review and reason about.",
            "Step 9: Document the behavior.\n- Document the default polling interval in the integration’s docs.\n- Mention that the update interval can be configured (if supported) and that it affects API usage and compliance with external limits."
        ]
    }
}
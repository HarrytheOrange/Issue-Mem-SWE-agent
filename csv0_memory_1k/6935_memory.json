{
    "search_index": {
        "description_for_embedding": "Initial implementation of the Home Assistant hassio component: wraps the HassIO supervisor HTTP API as HA services and HTTP views, adds connection checking via /supervisor/ping, introduces dynamic timeouts for long-running tasks, and provides comprehensive aiohttp-based tests using aioclient_mock.",
        "keywords": [
            "Home Assistant",
            "hassio",
            "HassIO supervisor",
            "HTTP API wrapper",
            "asyncio",
            "aiohttp",
            "async_timeout",
            "HomeAssistantView",
            "dynamic timeout",
            "supervisor ping",
            "services.yaml",
            "component setup",
            "aioclient_mock",
            "HTTPBadGateway",
            "network/options",
            "addons options"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced the initial 'hassio' component for Home Assistant and iterated on its design to make it robust and testable.\n\nInitially, the component exposed HassIO supervisor actions (host reboot/shutdown/update, network options, supervisor options, Home Assistant update, addon lifecycle operations) as HA services and implemented a simple API wrapper class `HassIO` that read the supervisor host from the `HASSIO` environment variable. Connectivity was determined only by whether the env var was present, and all API calls used a single large timeout (900s). Services were wired directly to hard-coded REST endpoints, with options for network and supervisor passed through.\n\nSubsequent patches cleaned this up substantially:\n- Introduced HTTP API views (`HassIOBaseView`, `HassIOBaseEditView`, `HassIOAddonsView`) based on `HomeAssistantView` to expose `/api/hassio/*` endpoints for host, supervisor, network, homeassistant, and addons. These views proxy to the HassIO API and translate failures into `HTTPBadGateway`.\n- Refactored `HassIO` to accept the host explicitly and to perform a real connectivity check via `/supervisor/ping` (`is_connected`), instead of just checking that the environment variable exists. Component setup (`async_setup`) now fails early if ping fails.\n- Split timeouts into `DEFAULT_TIMEOUT` (10s) and `LONG_TASK_TIMEOUT` (900s) and used the longer timeout only for operations known to run long, such as Home Assistant image updates and addon install/update. The `send_command` and `send_raw` methods accept a timeout parameter and use `async_timeout.timeout` appropriately.\n- Simplified the service layer by removing direct network and supervisor options services (those are now handled via the HTTP views), collapsing addon service schemas (dropping per-call `options` for start), and registering all services via a `SERVICE_MAP` that ties service names to voluptuous schemas.\n- Refactored `HassIO.send_command` to delegate to `send_raw`, centralizing HTTP/JSON handling, and making `send_command` responsible only for interpreting the `result` and `data` fields of the returned JSON.\n\nThe tests were expanded significantly. They now:\n- Use `aioclient_mock` to mock out all supervisor HTTP calls, including the initial `/supervisor/ping` used during setup.\n- Verify that each service results in the correct underlying HTTP requests, payloads, and error handling for timeouts, aiohttp client errors, non-200 statuses, and API-level error responses.\n- Add integration-style tests for the new HTTP views using `test_client`, asserting that `/api/hassio/host`, `/api/hassio/homeassistant`, `/api/hassio/supervisor`, `/api/hassio/network`, and `/api/hassio/addons/{addon}` correctly forward requests and responses and that POSTs send the right JSON options.\n\nAn additional testing utility change allowed the aiohttp mock to support the `json` keyword argument by mapping it into `data`, ensuring compatibility with `websession.get(..., json=payload)` used in the component.\n\nOverall, this PR both introduced the hassio integration and fixed early design shortcomings: non-validated connectivity, overly coarse timeouts, duplicated API/HTTP wiring, and insufficient test coverage.",
        "semantic_memory": "This PR illustrates several generalizable patterns and best practices for integrating an external HTTP-based supervisor or service into an asynchronous framework like Home Assistant:\n\n1. **Explicit connection validation, not just configuration presence**\n   - Simply having configuration or environment variables is not sufficient to assume connectivity. A small, cheap health-check endpoint (here `/supervisor/ping`) should be used at startup to validate the integration. If the check fails, the component should abort setup early with clear logging.\n\n2. **API wrapper separation of concerns**\n   - The `HassIO` class cleanly separates low-level HTTP operations (`send_raw`) from domain-level success semantics (`send_command`). `send_raw` is responsible for making HTTP requests and returning parsed JSON or raising/handling network errors; `send_command` interprets the API contract (`result` and `data` fields), logs API-level failures, and returns a clean value (`data` or `True`/`False`). This layered design makes both testing and reuse easier.\n\n3. **Dynamic, context-aware timeouts**\n   - Long-running operations (e.g., updating Docker images, installing addons) require much larger timeouts than quick control or info calls. Defining separate constants (e.g., `DEFAULT_TIMEOUT`, `LONG_TASK_TIMEOUT`) and passing them explicitly per call leads to more robust behavior under variable network and operation durations.\n\n4. **Use of async HTTP views as a thin proxy layer**\n   - Exposing supervisor functionality through internal HTTP views (`HomeAssistantView` subclasses) is a clean way to provide a stable application-facing API while delegating actual work to an external service. These views can handle authentication, map internal routes to external ones, and standardize error propagation (e.g., mapping backend failures to `HTTPBadGateway`). This pattern is useful any time you need to surface or proxy a backend service through your app.\n\n5. **Consistent service registration and schema validation**\n   - Collecting services in a `SERVICE_MAP` from service name to voluptuous schema simplifies registration and ensures that inputs to each service are validated. This reduces boilerplate and the chance for inconsistencies between how services are described (in `services.yaml`) and how they are actually registered.\n\n6. **Comprehensive async testing with HTTP mocks**\n   - For async integrations, mocking the client session (`aioclient_mock`) and using a test HTTP client (`test_client`) are effective patterns. They allow verification not only of business logic but also of HTTP method, URL, payload, and interaction counts. Making sure your mocks support the same interface used in the production code (e.g., handling `json=payload` arguments) is critical.\n\n7. **Clear error handling and logging**\n   - The component logs errors for network timeouts and client errors, non-200 HTTP status codes, and API-level error results. HTTP endpoints translate unhandled backend failures into appropriate HTTP responses (like 502 Bad Gateway). This layered error handling provides good observability and a clear contract to clients.\n\nThese patterns apply broadly to any integration where a main application uses an HTTP/JSON API to control or query an external supervisor, service, or microservice, especially in an asynchronous Python ecosystem.",
        "procedural_memory": [
            "Step-by-step instructions on how to design, diagnose, and improve a similar async HTTP-based integration with an external supervisor-like service:",
            "Step 1: Define the domain and services",
            "Identify which operations your application needs from the external supervisor (e.g., host reboot/shutdown, update, addon install/update/start/stop, query status). Map these into clear domain concepts and service names (e.g., `host_update`, `supervisor_update`, `addon_install`). Document them in a service description file (e.g., `services.yaml`) and define input schemas using a validation library (like voluptuous).",
            "Step 2: Implement an API wrapper class",
            "Create a dedicated class (like `HassIO`) responsible for communicating with the external API. This class should:\n- Hold shared resources like event loop and HTTP session.\n- Be initialized with connection parameters (host, base URL, auth tokens) rather than reading them ad hoc.\n- Provide a low-level `send_raw` method that performs HTTP requests, handles timeouts (`async_timeout.timeout`), parses JSON, and logs HTTP-level errors.\n- Provide a higher-level `send_command` method that interprets the service-specific JSON contract (e.g., `result` / `data` / `message`) and returns simple Python values or booleans.",
            "Step 3: Add a health check / connectivity method",
            "Implement an `is_connected` method that calls a cheap, stable API endpoint (e.g., `/supervisor/ping`) via `send_command`. Use this in component setup to validate that the external supervisor is reachable and responding as expected. If this health check fails, log a clear error and abort setup (`return False` from `async_setup`). Do not assume connectivity just because configuration variables (like `HASSIO`) are present.",
            "Step 4: Use context-appropriate timeouts",
            "Classify your operations into quick control/info calls vs. long-running jobs. Define constants for each (e.g., `DEFAULT_TIMEOUT = 10`, `LONG_TASK_TIMEOUT = 900`). In `send_command` or when calling it from services, pass the appropriate timeout value. Use shorter timeouts for status/info calls and longer ones for operations like image updates, installs, or migrations.",
            "Step 5: Wire services to API calls",
            "In the component's setup function (`async_setup`):\n- Define a single async service handler that looks at `service.service` and routes to the appropriate `HassIO` call and URL.\n- Extract and transform service data into the API's expected payload (e.g., constructing `{'version': ...}` only if a version is provided).\n- Use a `SERVICE_MAP` to register services in a loop, associating each service name with its schema and description from `services.yaml`.\n- For services related to long-running tasks, call `send_command` with the long timeout constant.",
            "Step 6: Expose HTTP views as proxies (if needed)",
            "If your application needs to expose supervisor functionality as HTTP endpoints:\n- Subclass your framework's HTTP view base class (`HomeAssistantView`, or equivalent).\n- For read-only endpoints, implement `get` to call the API wrapper (`send_command`) and return the `data` or raise `HTTPBadGateway` on failure.\n- For editable resources, subclass a base view and add `post` that reads `request.json()`, passes it to `send_raw` or `send_command`, and returns the raw response JSON or an error HTTP status.\n- Ensure these views require authentication where appropriate (`requires_auth = True`).",
            "Step 7: Handle and propagate errors consistently",
            "At the HTTP client level:\n- Catch `asyncio.TimeoutError` and log a timeout message.\n- Catch `aiohttp.ClientError` and log a client/network error.\n- If the response status is not 200, log an error and return a sentinel (e.g., `None` or `False`).\nAt the API contract level:\n- If the JSON indicates failure (e.g., `answer['result'] != 'ok'`), log the returned error message and return `False`.\nAt the HTTP view level:\n- If `send_command` or `send_raw` returns a falsy value when success is expected, raise an appropriate HTTP exception (e.g., `HTTPBadGateway`) to signal backend failure to the client.",
            "Step 8: Write comprehensive async tests with HTTP mocks",
            "Use an HTTP mocking utility (like `aioclient_mock`) that integrates with your async HTTP client. Ensure your mock supports the same arguments as production code (e.g., `json=` for request body). For each service and view:\n- Mock the underlying API endpoint with success and error payloads.\n- Call the HA service (or HTTP view) and use `block_till_done` or equivalent to wait for completion.\n- Assert the number of mock calls, URLs, and JSON payloads sent match expectations.\n- Test timeouts by configuring the mock to raise `asyncio.TimeoutError` and verifying correct logging/behavior.\n- Test aiohttp client errors by raising `aiohttp.ClientError`.\n- Test non-200 status codes and API-level error responses (e.g., `result: 'error'`).\n- For HTTP views, use a test HTTP client to assert response codes and bodies for both GET and POST requests.",
            "Step 9: Refactor iteratively and keep tests aligned",
            "As you evolve the integration (e.g., adding views, changing which operations are exposed as services vs. HTTP endpoints), keep the mapping between services, schemas, and external API consistent. Update tests to reflect behavioral changes (such as removing services, changing payloads, or introducing new timeouts) and add tests for new surface area (e.g., new views).",
            "Step 10: Monitor logs and adjust",
            "After deployment, monitor logs for timeout errors, client errors, and API error messages. Use this information to tune timeouts, add retries where appropriate, or expose additional diagnostic endpoints. Keep the health check endpoint stable and reliable to detect systemic failures early."
        ]
    }
}
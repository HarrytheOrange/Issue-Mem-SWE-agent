{
    "search_index": {
        "description_for_embedding": "Refactor to move BaseAPI and jsexpose from st2common.models.base into the API-specific package st2common.models.api.base, and update all API models, controllers, and tests to import from the new location. This fixes a mislocated module and cleans up API-related code organization.",
        "keywords": [
            "BaseAPI",
            "jsexpose",
            "st2common.models.base",
            "st2common.models.api.base",
            "module relocation",
            "import path update",
            "API models",
            "controllers",
            "test_model_base",
            "Python package structure",
            "StackStorm",
            "refactor",
            "namespace cleanup"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the project had an API-specific helper module, base.py, living under st2common/st2common/models/base.py. This file contained BaseAPI and jsexpose, which are used heavily by API models and controllers. The developers realized during work on new utilities that this module was conceptually API-specific and therefore mislocated in a generic models package.\n\nTo correct this, the pull request moved base.py into an API-focused namespace: from st2common.models.base to st2common.models.api.base (physically: st2common/st2common/models/api/base.py). The content of the file itself did not change; only its package location did.\n\nAfter moving the file, all imports across the codebase that referenced BaseAPI or jsexpose were updated. Specifically:\n- API model classes (access.py, action.py, actionrunner.py, datastore.py, history.py, reactor.py, rule.py) were changed from `from st2common.models.base import BaseAPI` to `from st2common.models.api.base import BaseAPI`.\n- The unit test test_model_base.py was updated to import `base` from `st2common.models.api` instead of `st2common.models`.\n- Multiple API controllers and the auth controller, which previously imported `jsexpose` from `st2common.models.base`, were updated to import it from `st2common.models.api.base` instead.\n\nThe result is that API-related infrastructure is now grouped under the api module, aligning the physical file layout with the logical responsibilities. The change is purely organizational but required a comprehensive import path update to avoid runtime ImportError and maintain compatibility within this codebase.",
        "semantic_memory": "This change illustrates a common pattern in large Python codebases: over time, modules end up in semantically incorrect locations (e.g., generic-sounding packages that actually contain highly specific functionality). When such misplacements are discovered, moving the module to a more appropriate namespace improves clarity and maintainability, but requires careful handling of import paths.\n\nGeneralizable lessons:\n- **Align module location with responsibility**: API-specific utilities (e.g., BaseAPI abstractions, request/response decorators like jsexpose) should live in an `api` or similarly named namespace, not in a generic `models` or `common` root, to communicate intent and reduce coupling.\n- **Refactors must update all references**: Moving a module without updating all import sites leads to ImportError at runtime or failing tests. Use automated search (grep/rg/IDE search) to find and update all references.\n- **Keep tests in sync with structure**: Tests that import modules by path (e.g., `from st2common.models import base`) must be updated when the implementation is reorganized. Otherwise, tests will either fail or give a false sense of coverage.\n- **Decoupling and namespacing**: Having a clear `api` subpackage allows future API-specific utilities to be added in a consistent place, reduces the risk of circular imports across generic vs API code, and makes the system easier to navigate for new contributors.\n- **Refactors can be non-functional but high impact**: Even when no code inside the file changes, structural refactors can be risky because they touch many modules. Good test coverage is crucial to validate such changes.\n\nIn essence, the fix reinforces the best practice of coherent package design and disciplined refactoring when responsibilities are clarified.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify mislocated modules\n- Review modules whose names or responsibilities no longer match their package path (e.g., API-specific code inside a generic `models` or `common` package).\n- Look for patterns: if most API-related classes live under `models/api/` but one core helper is in `models/`, that may signal a misplacement.\n- Use code search to see how and where the module is used (e.g., `rg \"BaseAPI\"` or `rg \"jsexpose\"`).",
            "Step 2: Plan the new module location and API\n- Decide on a clear, semantically correct package for the module (e.g., `st2common.models.api.base`).\n- Ensure the new location does not create circular dependencies with existing modules.\n- Confirm that the public interface (class names, function names) can remain the same to minimize changes at call sites.",
            "Step 3: Physically move the module\n- Move the file in the repository: e.g., `git mv st2common/st2common/models/base.py st2common/st2common/models/api/base.py`.\n- Verify that package `__init__.py` files still form a proper Python package chain so the module is importable from the new path.",
            "Step 4: Update all import paths\n- Use a global search to find all import statements referencing the old module path (e.g., `from st2common.models.base import BaseAPI` or `jsexpose`).\n- Update them to use the new path (e.g., `from st2common.models.api.base import BaseAPI`/`jsexpose`).\n- Include application code, controllers, and tests in this sweep. Pay special attention to any wildcard or package-level imports (`from st2common.models import base`).",
            "Step 5: Update tests to reflect the new structure\n- Adjust test imports to point to the new module location (e.g., `from st2common.models.api import base`).\n- Run the relevant unit test suites to ensure there are no missing imports or broken assumptions about module locations.",
            "Step 6: Run the full test and linting suite\n- Execute unit tests, integration tests, and any linters or static analyzers configured in the project.\n- Look for ImportError or ModuleNotFoundError, which usually indicate a missed import path update or package misconfiguration.",
            "Step 7: Consider backward compatibility (if needed)\n- If external users or plugins depend on the old import path, consider adding a temporary shim module:\n  - Create a stub at the old location (e.g., `st2common/models/base.py`) that re-exports from the new location:\n    - `from st2common.models.api.base import *`\n  - Mark it as deprecated and schedule its removal in a future major version.\n- Document the new recommended import path in release notes or migration guides.",
            "Step 8: Document the structural change\n- Update internal docs, architecture diagrams, or developer guides to reflect the new module layout.\n- Briefly explain the rationale (e.g., \"BaseAPI and jsexpose are API-specific and now live under st2common.models.api.base\").\n- Encourage future additions of API helpers to use the new `api` namespace for consistency.",
            "Step 9: Monitor after merging\n- After merging, watch CI pipelines and, if applicable, production error logs or plugin ecosystems for import-related issues.\n- Be prepared to quickly add compatibility shims or fix overlooked import paths if new errors appear."
        ]
    }
}
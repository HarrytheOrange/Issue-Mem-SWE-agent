{
    "search_index": {
        "description_for_embedding": "Ecobee Home Assistant integration had insufficient validation for service call parameters when creating or deleting vacations. Date/time fields accepted arbitrary strings that could be rejected by the ecobee API, and vacation_name did not enforce the actual length limit used by ecobee (12 chars). The fix adds dedicated date/time validation utilities, applies them in the service schemas, constrains vacation_name length, and adds tests.",
        "keywords": [
            "ecobee",
            "homeassistant",
            "Home Assistant",
            "climate",
            "service schema",
            "voluptuous",
            "input validation",
            "date format",
            "time format",
            "vacation_name",
            "length constraint",
            "API contract",
            "schema utilities",
            "unit tests"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant ecobee integration, the create_vacation and delete_vacation services accepted several parameters with weak validation. The date and time fields (start_date, start_time, end_date, end_time) were defined as raw strings in the voluptuous service schemas. This allowed users to pass values that did not conform to the ecobee API’s expected formats (YYYY-MM-DD for dates, HH:MM:SS 24-hour for times). Such malformed inputs could reach the ecobee backend and fail there, causing hard-to-diagnose errors.\n\nAdditionally, the vacation_name parameter had no length restriction, even though real ecobee devices enforce a maximum of 12 characters. This mismatch meant that users could pass a longer vacation name, which would then be rejected by the device/API at runtime.\n\nTo fix this, the developer created a new module homeassistant/components/ecobee/util.py with two validation helpers: ecobee_date and ecobee_time. Each uses datetime.strptime to verify that the given string matches the required format. If parsing fails, they raise voluptuous.Invalid with a descriptive error message. These functions are then imported and used in the ecobee climate service schemas: the Inclusive fields for ATTR_START_DATE, ATTR_START_TIME, ATTR_END_DATE, and ATTR_END_TIME now validate via ecobee_date/ecobee_time instead of simple cv.string.\n\nFor vacation_name, both CREATE_VACATION_SCHEMA and DELETE_VACATION_SCHEMA were updated to use vol.All(cv.string, vol.Length(max=12)), ensuring that any provided vacation name is a string and at most 12 characters long, aligning Home Assistant validation with real ecobee behavior discovered in testing.\n\nFinally, the PR adds tests under tests/components/ecobee/test_util.py. These tests verify that ecobee_date and ecobee_time return the original input for correctly formatted strings and raise voluptuous.Invalid when the format is wrong (e.g., missing dashes in dates, missing seconds in times). The tests were refactored from unittest.TestCase style to standalone pytest functions. This improved coverage around the new utility functions and ensured that invalid inputs are caught at the schema-validation layer rather than at runtime against the ecobee API.",
        "semantic_memory": "This fix illustrates best practices for aligning local validation with external API constraints in a home automation integration.\n\nKey concepts:\n\n1. **Schema-based validation against external APIs**: When a service or API client accepts user input, you should validate not just basic types (string, number) but also the semantic format expected by the upstream system. For example, date strings should be validated against the exact pattern (e.g., YYYY-MM-DD) that the external API requires.\n\n2. **Validation via reusable utility functions**: Encapsulating format checks (e.g., ecobee_date, ecobee_time) in dedicated utility functions makes the rules easy to reuse across multiple schemas and endpoints. It also centralizes potential changes: if the external API changes its formats, only the utility functions need to be updated.\n\n3. **Raising domain-appropriate validation errors**: Using the validation framework’s standard error type (here, voluptuous.Invalid) ensures that invalid inputs are rejected early, and error messages are propagated consistently to users or higher-level error handlers.\n\n4. **Mirroring undocumented or empirically discovered constraints**: Sometimes APIs have practical limits (like a maximum 12-character vacation_name) that are not fully documented. Once discovered through testing or experimentation, these constraints should be codified in the local schemas (e.g., vol.Length(max=12)) to prevent users from sending values that will later be rejected by the external service.\n\n5. **Coupling inclusive field groups with stricter validation**: The existing schema used vol.Inclusive to ensure that related fields (start_date, start_time, end_date, end_time) are provided together. Enhancing those fields with strict format validators preserves the logical grouping while improving robustness.\n\n6. **Testing validation utilities explicitly**: When adding utility functions for validation, unit tests should cover both the successful paths (valid input passes through unchanged) and failure paths (invalid input raises the expected exception). This prevents regressions and ensures that schemas relying on these utilities behave predictably.\n\nOverall, the pattern is: derive validation rules from the external API contract (and real-world behavior), encode them in reusable validators, plug those validators into schemas, and back them with clear tests.",
        "procedural_memory": [
            "When an integration or service interacts with an external API and accepts user input, ensure local validation matches the external API’s expectations in both format and constraints.",
            "Step 1: Identify problematic or weakly validated inputs.\n- Review service schemas or input handling code (e.g., voluptuous schemas) and look for fields defined as generic types (like cv.string) where the external API expects specific formats (dates, times, IDs) or constraints (length, allowed set of values).\n- Use bug reports, test failures, or logs from the external API to locate where invalid data is being rejected downstream.",
            "Step 2: Determine the exact external constraints.\n- Consult the external API documentation for expected data formats (e.g., 'YYYY-MM-DD' for dates, 'HH:MM:SS' for times) and constraints (max length, allowed characters).\n- If documentation is incomplete, infer constraints from error messages or experimentation (e.g., discovering that vacation_name must be <= 12 characters).",
            "Step 3: Implement reusable validation utilities.\n- Create small utility functions that validate a single value according to the external API’s rules.\n- For format-based constraints, use standard library parsing (e.g., datetime.strptime for date/time) to verify correctness.\n- On invalid input, raise the validation library’s standard exception type (e.g., voluptuous.Invalid) with a clear, user-facing error message.\n- Return the original value (or a normalized version) when it passes validation.",
            "Step 4: Integrate validators into existing schemas.\n- Import the new utility functions into the module that defines the service or API schemas.\n- Replace generic field validators (e.g., cv.string) with the new specific validators (e.g., ecobee_date, ecobee_time).\n- For length or other scalar constraints, wrap the base validator with additional checks (e.g., vol.All(cv.string, vol.Length(max=12))).\n- Ensure inclusive/required group constraints (e.g., vol.Inclusive groups) still apply correctly with the new validators.",
            "Step 5: Add or update unit tests.\n- Create tests specifically for the new validation utilities that cover:\n  - Valid inputs returning the expected output.\n  - Invalid inputs raising the correct exception type.\n- Use your project’s preferred testing style (e.g., pytest functions with pytest.raises) for consistency.\n- Optionally, add tests that exercise the schema end-to-end, ensuring that service calls with invalid values are rejected as expected.",
            "Step 6: Run the full test suite and validate behavior.\n- Run all unit tests and integration tests to confirm no regressions.\n- If possible, run a manual end-to-end test against the external API (e.g., create a vacation via the service) to confirm that valid inputs are accepted and that invalid inputs are rejected early by the schema, not by the external API.",
            "Step 7: Document or communicate the constraints.\n- Even if the external API doesn’t document certain limits (like maximum name length), include them in code comments, commit messages, or user-facing documentation so future maintainers understand why the constraints exist.\n- This helps maintain alignment between local validation and external behavior over time."
        ]
    }
}
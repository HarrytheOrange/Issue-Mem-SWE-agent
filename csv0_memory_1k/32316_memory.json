{
    "search_index": {
        "description_for_embedding": "Home Assistant GitHub integration sensor state was returning an 8-character truncated commit SHA instead of the conventional 7-character short SHA. The fix adjusts the state to use a 7-character short SHA while keeping the full SHA available in attributes, which changes the entity state format and may require automation updates.",
        "keywords": [
            "Home Assistant",
            "GitHub integration",
            "github sensor",
            "latest_commit_sha",
            "short SHA",
            "commit hash truncation",
            "entity state breaking change",
            "frontend representation",
            "identifier formatting"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant codebase, the GitHub integration exposes a sensor that reflects information about a repository, including the latest commit. Originally, the sensor's state was set as a shortened version of the commit SHA by slicing the full hash: `self._state = self._github_data.latest_commit_sha[0:8]`. This produced an 8-character short hash. However, the convention in Git tooling and user expectations is a 7-character short SHA, and the UI/UX discussion around the prior PR indicated that the entity state should reflect that conventional short SHA for a more meaningful frontend representation.\n\nUsers relied on the sensor state (`latest_commit_sha`) for automations and displays, and the mismatch in length made the state less standard and potentially confusing. The fix in this PR was a minimal code change in `homeassistant/components/github/sensor.py` within the `update` method of the GitHub sensor entity: the slice was updated from `[0:8]` to `[0:7]` (`self._state = self._github_data.latest_commit_sha[0:7]`). This makes the sensor state follow the 7-character short SHA convention.\n\nImportantly, the full commit SHA is still preserved in the sensor attributes via `self._github_data.latest_commit_sha`, so no information is lost; only the state representation changes. Because automations may compare or parse the state, the PR is marked as a breaking change and users are warned that any automations depending on an 8-character state need to be updated to the new 7-character length. The change was directly linked to a previous related PR and discussed with maintainers to ensure the description and breaking change notice were clear.",
        "semantic_memory": "This fix illustrates several generalizable principles for software design and maintenance:\n\n1. **Consistent and Conventional Identifier Representation**: When exposing identifiers such as commit SHAs, ticket IDs, or other hashes to users or external systems, it is important to match established conventions (e.g., 7-character Git short SHA). Deviating from these conventions can cause confusion, break expectations, or complicate interoperability with other tools.\n\n2. **Separation of Display Value vs. Full Data**: It's often useful to expose a human-friendly representation as the primary state or display value (short SHA) while retaining the full, precise value (full SHA) in metadata or attributes. This balances UX and functionalityâ€”users see concise values, while automations and integrations can still use the full data when needed.\n\n3. **Small UI Changes Can Be Breaking Changes**: Even seemingly trivial formatting changes (like shortening an identifier by one character) can be breaking changes if they affect public APIs or machine-consumed values such as entity states. Any such change should be clearly documented, and users should be alerted to adjust automations or scripts that rely on exact string matches.\n\n4. **Use of Slicing and Off-by-One Errors**: When truncating or slicing strings programmatically, off-by-one errors are easy to introduce. This case shows how a simple `[0:8]` slice produced an 8-character value instead of the intended 7-character short SHA. Always double-check slice ranges against the desired length and document the intent (e.g., \"return 7-char short SHA\").\n\n5. **Backward Compatibility and Attribute Preservation**: When changing the primary representation of a piece of data, preserving the original, full information in attributes or secondary fields reduces the impact and risk. Consumers who need the full value can still access it, and only those relying on the specific formatting of the primary field need to adapt.\n\n6. **Communicating Changes Through Metadata and PR Templates**: Marking a change as breaking and clearly documenting what changes (e.g., sensor state length) and how users must adapt (e.g., update automations that compare SHA strings) is vital for maintainability in large, user-facing projects.",
        "procedural_memory": [
            "How to diagnose and fix identifier formatting / short SHA issues in sensors or APIs:",
            "Step 1: Identify the symptom: Users or tests report unexpected identifier formats (e.g., commit SHA length, ID formatting) in sensor states, APIs, or logs. Look for mismatches between what the UI shows and what conventions or documentation state.",
            "Step 2: Confirm the intended convention: Determine the expected format and length (e.g., Git's standard short SHA length of 7 characters, specific ID patterns). Check documentation, related issues, or prior PRs.",
            "Step 3: Locate where the value is derived: Search the code for where the field/state is set (e.g., `self._state = ...` for Home Assistant sensors). Look for slicing, substring, or formatting operations applied to the raw identifier.",
            "Step 4: Check for off-by-one or incorrect slicing: Validate that the slice or format matches the intended length (e.g., `identifier[0:7]` for 7 characters rather than `0:8`). Fix the slice or formatting expression to match the desired convention.",
            "Step 5: Preserve full data if needed: If you're truncating for display, ensure the original full identifier remains accessible as an attribute or secondary field (e.g., `self._github_data.latest_commit_sha` stored in attributes). This avoids data loss and supports advanced use cases.",
            "Step 6: Assess breaking impact: Determine if the formatting change affects public APIs, entity states, or machine-readable outputs that users might depend on (e.g., automations comparing exact strings). If yes, treat it as a breaking change.",
            "Step 7: Update documentation and PR description: Clearly describe what changed (e.g., 'entity state now uses 7-character short SHA instead of 8-character'), why it changed, and how users must update their automations or integrations. Link to related issues/PRs for context.",
            "Step 8: Add or adjust tests: If possible, add tests that assert the exact length/format of the exposed identifier (e.g., assert `len(state)` equals 7). This prevents regressions where a future edit reintroduces incorrect slicing.",
            "Step 9: Run tests and validate in UI: Execute the test suite and, if applicable, run the system locally to confirm that the frontend displays the expected short identifier and that the full identifier remains available in attributes.",
            "Step 10: Communicate release notes: When merging, ensure release notes or changelog entries highlight the formatting change as a breaking change, so users can proactively adjust their automation logic."
        ]
    }
}
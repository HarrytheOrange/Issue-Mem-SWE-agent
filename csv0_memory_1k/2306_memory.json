{
    "search_index": {
        "description_for_embedding": "Fix for a regression in parameter default resolution where an action parameter schema without a default was incorrectly overriding a runner parameter schema that had a default, resulting in the final parameter value being None instead of the runner default. The fix adjusts the default-processing logic in st2common.util.param._process_defaults to re-process parameters whose current graph value is None, and adds a unit test to cover this edge case.",
        "keywords": [
            "parameter default resolution",
            "param dependency override regression",
            "st2common.util.param",
            "_process_defaults",
            "runner vs action parameters",
            "None vs unset",
            "immutable parameters",
            "configuration merge bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "A regression was introduced after a previous change (#2288) in how StackStorm finalized parameters by merging runner and action parameter schemas. The symptom: when an action parameter was declared without a default (e.g., `p1: {}`) and the corresponding runner parameter had a default (e.g., `p1: {default: '...'}`), the resulting finalized parameter value became `None` instead of using the runner's default. This happened in the `_process_defaults` function in `st2common/util/param.py`, which built a graph of parameters and their defaults. The old logic only processed defaults when a parameter node was absent in the graph or when it was marked immutable: `if name not in G.node or value.get('immutable', False): _process(G, name, value.get('default', None))`. Because the parameter node existed but had a `value` of `None`, it was considered present and skipped, effectively treating an empty action param specification as a hard override of the runner default. The fix changes the condition to also re-process parameters whose current value is `None`: `absent = name not in G.node; is_none = G.node.get(name, {}).get('value') is None; immutable = value.get('immutable', False); if absent or is_none or immutable: _process(G, name, value.get('default'))`. The call to `value.get('default')` also drops the explicit default of `None` in the function call, letting `_process` handle the absence. A new unit test was added in `test_get_finalized_params_order` to verify that when runner params are `{'r1': {}, 'r2': {'default': 'r2'}, 'r3': {}}` and action params are `{'r1': {}, 'r2': {}, 'r3': {'default': 'a3'}}`, the finalized params correctly become `{'r1': None, 'r2': 'r2', 'r3': 'a3'}`, confirming that an empty action param definition no longer wipes out a non-empty runner default.",
        "semantic_memory": "This fix illustrates a common pitfall when merging layered configuration or parameter schemas: confusing 'unset' with 'explicitly set to null' and treating an empty higher-level declaration as an override that clears a lower-level default. In systems where parameters can be defined at multiple layers (e.g., runner-level vs action-level, global config vs user config), merge logic must distinguish between:\n- A key that is absent (no override requested),\n- A key that exists but has no explicit default in the schema (meaning 'inherit lower-level default unless a runtime value is provided'), and\n- A key explicitly set to null/None (meaning 'override and clear the value', if that semantic is desired).\n\nThe bug came from only checking whether the node existed in the internal graph, not whether its value was meaningful. As a result, a node with `value == None` was treated as a valid override and prevented the runner default from being applied. The generalizable lesson is: when building dependency graphs or resolving defaults, the presence of a node or key is not enough â€” the code must also consider the stored value and the intent behind empty or null entries in higher-level schemas. Additionally, regression risks are high around subtle merge/override semantics; adding targeted tests for edge cases (such as 'empty override on top of non-empty default') is essential to prevent silent behavior changes.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the behavior with a minimal failing test.\n- Create a test scenario that mimics the layering: a base/runner schema with a default and an overlay/action schema that declares the same parameter without a default or with an empty object.\n- Call the parameter finalization or configuration merge function and assert the resulting value.\n- Confirm that the result incorrectly becomes None or otherwise loses the lower-level default.",
            "Step 2: Trace the merge/default resolution pipeline.\n- Identify the function(s) responsible for merging schemas and applying defaults (here, `st2common.util.param._process_defaults`).\n- Inspect how it determines whether to apply defaults: check conditions like `if key not in graph`, `if value is None`, and any flags like `immutable`.\n- Log or inspect the intermediate graph/data structure to see what value is stored for the problematic parameter before and after processing.",
            "Step 3: Differentiate between 'absent' and 'present-but-empty'.\n- Explicitly check how the code treats:\n  - Keys that do not exist in the data structure,\n  - Keys that exist but with `{}` or `None` as their value,\n  - Keys that have an explicit default.\n- Decide on the intended semantics: should an empty higher-level schema entry override the lower-level default, or should it be treated as 'no opinion, inherit default'?",
            "Step 4: Adjust the condition for applying defaults.\n- Update checks that only look at key presence to also consider the value. For example:\n  - Instead of only `if name not in G.node`, use something like:\n    - `absent = name not in G.node`\n    - `is_none = G.node.get(name, {}).get('value') is None`\n    - `immutable = value.get('immutable', False)`\n    - `if absent || is_none || immutable: apply default`.\n- Ensure that calling `get('default')` without a fallback lets the downstream logic distinguish between 'no default defined' and 'default is explicitly None', if that distinction is needed.",
            "Step 5: Re-run and extend tests.\n- Re-run the previously failing test to confirm the bug is fixed (the runner default now survives when the action schema is empty).\n- Add additional tests for similar edge cases:\n  - Action defines a different default than runner (ensure override works).\n  - Action explicitly sets a parameter value to None (define and test the expected behavior).\n  - Immutable parameters at either layer.\n- Ensure tests cover both order of evaluation and multiple levels of overrides.",
            "Step 6: Review for regressions in related paths.\n- Search for other places in the codebase where layered configuration or parameters are merged.\n- Verify that they also correctly distinguish between absent keys and None/empty values.\n- If necessary, refactor common merge/default logic into shared utilities with comprehensive tests.",
            "Step 7: Document the override semantics.\n- Document how defaults, empty schemas, and null values are treated in layered parameter definitions.\n- This reduces ambiguity for future contributors and helps prevent reintroducing similar bugs."
        ]
    }
}
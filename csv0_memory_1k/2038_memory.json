{
    "search_index": {
        "description_for_embedding": "Standardized event payloads in napari's viewer model and Qt UI by switching from ad-hoc attributes like `event.text` and `event.item` to a unified `event.value` field, updating all emitters and listeners (status, title, help, active_layer, layer controls) to prepare for an evented viewer model.",
        "keywords": [
            "napari",
            "event system",
            "event payload",
            "event.value",
            "viewer_model",
            "qt_main_window",
            "qt_layer_controls_container",
            "active_layer event",
            "status bar event",
            "title change event",
            "help text event",
            "API breaking change",
            "event schema standardization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the napari project refactored its event payload schema in preparation for an evented viewer model. Previously, different events used different attribute names on the event object (`event.text` for status, title, and help messages, and `event.item` for layer changes). This inconsistency made it harder to reason about events and to build an evented viewer model with a clear, uniform API.\n\nThe fix standardized these payloads to use a single, consistent field: `event.value`. In `viewer_model.py`, event emit calls were updated:\n- `self.events.status(text=self._status)` became `self.events.status(value=self._status)`\n- `self.events.help(text=self._help)` became `self.events.help(value=self._help)`\n- `self.events.title(text=self._title)` became `self.events.title(value=self._title)`\n- `self.events.active_layer(item=self._active_layer)` became `self.events.active_layer(value=self._active_layer)`.\n\nOn the receiving side, all corresponding Qt handlers were updated to consume `event.value` instead of the old fields:\n- In `_qt/qt_main_window.py`, `_status_changed`, `_title_changed`, and `_help_changed` now read `event.value` instead of `event.text` when updating the status bar, window title, and help label.\n\nFor the layer controls container, the logic was also cleaned up. Previously, the constructor called `self._display(None)` and `_display` accepted `event` being `None`, then extracted `layer = event.item` when present. With the new standardized event interface:\n- The constructor now directly sets the default widget with `self.setCurrentWidget(self.empty_widget)` instead of faking a call with a `None` event.\n- `_display` now simply does `layer = event.value` and no longer needs to handle a `None` event object. If `layer` is `None`, it shows the `empty_widget`; otherwise, it shows the corresponding layer control widget.\n\nThis refactor is marked as a breaking change because any external code listening to or emitting these events using `text` or `item` will need to be updated to use `value`. The underlying behavior (updating status, title, help text, active layer, and layer controls) remains the same; only the event payload contract has changed to be more consistent and future-proof.",
        "semantic_memory": "This change illustrates an important pattern in event-driven and observer-based architectures: standardizing the event payload schema greatly improves maintainability, composability, and the ability to evolve the system.\n\nKey generalizable concepts:\n1. **Consistent event payload interfaces**: Using a single well-defined attribute (e.g., `event.value`) for the primary payload avoids a proliferation of ad-hoc field names (`text`, `item`, etc.) that create implicit coupling and confusion between emitters and listeners.\n2. **Contract between emitters and listeners**: Events form an API. When the schema of an event changes (field names or types), all producers and consumers must be updated together. Failing to do so leads to subtle runtime bugs where listeners read the wrong attribute or see `None` unexpectedly.\n3. **Refactoring towards an evented model**: When transitioning to a more sophisticated evented architecture (e.g., a fully evented viewer model or an event-driven state store), enforcing a uniform payload shape simplifies generic tooling (logging, debugging, schema validation, serialization) and makes it easier to build generic listeners.\n4. **Avoiding special cases in event handlers**: Instead of having handlers that accept `None` as a pseudo-event and branch on that (`if event is None`), it is cleaner to directly perform initialization where needed (e.g., setting the current widget in the constructor) and keep event handlers focused on handling real events with a consistent structure.\n5. **Breaking changes are sometimes necessary for long-term clarity**: Consolidating multiple field names into a single canonical attribute may break existing code, but it yields a clearer and more stable API going forward, reducing the probability of future bugs and confusion.\n\nThese principles apply widely to GUI frameworks, message buses, pub/sub systems, and any application where state changes are propagated via events or signals.",
        "procedural_memory": [
            "When facing inconsistent or fragile behavior in an event-driven UI or model (e.g., certain UI elements not updating correctly after refactors), systematically verify the event payload schema and alignment between emitters and listeners.",
            "Step 1: Identify the events and handlers involved.\n- List the events emitted for the problematic behavior (e.g., status changes, title updates, active selection changes, etc.).\n- Locate where those events are emitted and where they are connected/handled in the UI or other subsystems.",
            "Step 2: Inspect the event objects and their payloads.\n- Check the event class or documentation to see what fields are intended to carry the payload (e.g., `value`, `data`, `item`, `text`).\n- Confirm the actual usage in emit calls, e.g., `events.status(text=...)` vs `events.status(value=...)`.\n- At runtime (if possible), log or debug-print the event objects to ensure their attributes align with expectations.",
            "Step 3: Standardize on a canonical payload field.\n- Choose a single field name for the primary payload (e.g., `value`).\n- For each event type, update emitters to use that field: `events.foo(value=payload)` instead of varying names like `text` or `item`.\n- Avoid special-case field names unless they are absolutely necessary and well-documented.",
            "Step 4: Update all listeners/handlers to the new schema.\n- Search the codebase for all event handlers that reference the old attributes (e.g., `event.text`, `event.item`).\n- Update them to use `event.value` (or the chosen canonical field).\n- Ensure any initialization code that previously faked events (e.g., calling a handler with `None`) is refactored to perform initialization directly instead of abusing the event signature.",
            "Step 5: Remove ad-hoc or special-case paths.\n- If handlers contained branches for `event is None` or similar hacks, replace them with explicit initialization in constructors or setup functions.\n- Keep event handlers assuming a consistent, non-null event object with the agreed schema.",
            "Step 6: Add or adjust tests to cover event flow.\n- Write tests that emit the relevant events and assert that the UI/model reacts correctly.\n- Specifically test that `event.value` is used and that listeners no longer depend on deprecated fields.\n- Run coverage or mutation testing to ensure there are no remaining usages of old fields.",
            "Step 7: Communicate and manage the breaking change.\n- Document the event schema change clearly in release notes or migration guides (e.g., \"status, help, title, and active_layer events now use `value` instead of `text`/`item`\").\n- If feasible, provide a temporary compatibility layer or warnings when old attributes are accessed, to ease adoption.\n- Encourage client code to update all event handlers to the standardized payload field.",
            "Step 8: For future development, treat events as part of the public API.\n- Design events with a clear, versioned schema.\n- Avoid introducing new payload field names without strong justification.\n- Consider using typed models or schemas (e.g., dataclasses, pydantic models) for event payloads to make changes explicit and discoverable."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix for StackStorm Orquesta st2kv function and datastore utilities so that keys with empty string or null values are returned correctly, missing keys raise a specific not-found error, and st2kv can optionally return a caller-supplied default value instead of failing. Includes refactor of keyvalue persistence to raise StackStormDBObjectNotFoundError and updates to Orquesta function API to use kwargs.",
        "keywords": [
            "StackStorm",
            "Orquesta",
            "st2kv",
            "datastore",
            "key-value",
            "empty string",
            "null value",
            "None",
            "default value",
            "StackStormDBObjectNotFoundError",
            "ExpressionEvaluationException",
            "keyvalue.get_by_scope_and_name",
            "st2common.util.keyvalue.get_key",
            "secret decrypt",
            "YAQL",
            "Jinja"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Orquesta st2kv function in StackStorm behaved incorrectly for datastore entries whose values were empty strings ('') or None. The function st2kv_ called st2common.util.keyvalue.get_key(), which in turn used KeyValuePair.get_by_scope_and_name(). The util function previously did a simple truthiness check on the returned key-value record (if value: ... else None). As a result, a present key with value '' or None was treated as 'no value', and Orquesta raised an ExpressionEvaluationException indicating the key did not exist. Additionally, st2kv had no way to distinguish between a truly missing key and a present key when adding a 'default' parameter because default=None was indistinguishable from 'no default provided'.\n\nThe fix involved several coordinated changes:\n\n1) The persistence layer method KeyValuePair.get_by_scope_and_name(scope, name) was changed to raise StackStormDBObjectNotFoundError when no record is found instead of silently returning None. This provides a clear signal for the 'key does not exist' case. The error message now explicitly says: 'The key \"<name>\" does not exist in the StackStorm datastore.'\n\n2) Callers that previously relied on the old behavior were updated. In st2common.services.config.set_datastore_value_for_config_key() and st2common.services.keyvalues.ConfigScopedKV/_get_kv(), calls to KeyValuePair.get_by_scope_and_name() are wrapped in try/except StackStormDBObjectNotFoundError and treat that as 'no existing key' (e.g., setting existing_kvp_db = None or returning ''). This preserves existing semantics for those services while allowing the persistence layer to be strict.\n\n3) The utility function st2common.util.keyvalue.get_key() was updated to work with the new behavior. It now:\n   - Calls KeyValuePair.get_by_scope_and_name(scope, key_id) directly, letting StackStormDBObjectNotFoundError propagate if the key truly does not exist.\n   - If a record is found, it checks kvp.value. If kvp.value is None, it returns None directly without attempting to decrypt or deserialize. Otherwise, it calls deserialize_key_value(kvp.value, decrypt). This change ensures that keys with value '' or None are returned as-is and not misinterpreted as missing.\n\n4) The Orquesta function st2kv_ was refactored to use keyword arguments so a 'default' parameter can be supported without ambiguity:\n   - Signature changed from st2kv_(context, key, decrypt=False) to st2kv_(context, key, **kwargs).\n   - decrypt is read from kwargs with decrypt = kwargs.get('decrypt', False) and type-checked as bool.\n   - A new 'default' parameter is supported. The function tracks has_default = 'default' in kwargs and default_value = kwargs.get('default').\n   - st2kv_ calls kvp_util.get_key(key=key, user_db=user_db, decrypt=decrypt) inside a try/except:\n     * If StackStormDBObjectNotFoundError is raised and has_default is False, it wraps the error message in an orquesta.exceptions.ExpressionEvaluationException and re-raises, causing the workflow to fail with a clear 'key does not exist' message.\n     * If StackStormDBObjectNotFoundError is raised and has_default is True, st2kv_ returns default_value instead of failing. This supports default values of any type, including None and ''.\n     * Any other Exception is always wrapped as ExpressionEvaluationException and re-raised (never treated as a missing key/default case).\n\n5) Tests were expanded and refined:\n   - Unit tests for user and system scopes create KVPs with values 'bar', '', and None, plus secret keys whose encrypted values are stored in the DB. Tests verify that st2kv_ returns 'bar', '', and None exactly as stored for existing keys, and that decrypt=True returns the decrypted plaintext while decrypt=False leaves the ciphertext (ensuring no unintended decryption).\n   - Tests confirm that calling st2kv_ with a nonexistent key (e.g., 'foobar' or 'system.foo' when not present) raises ExpressionEvaluationException with the message from StackStormDBObjectNotFoundError: 'The key \"...\" does not exist in the StackStorm datastore.'\n   - New unit tests check the default behavior: st2kv_ returns the provided default value for a missing key, including defaults of 'foosball', '', and None, for both user scope and system scope (e.g., 'system.foobar').\n   - Additional tests mock kvp_util.get_key to raise a generic Exception('Mock failure.') and verify that st2kv_ wraps it in ExpressionEvaluationException and never returns default in this case, confirming that the default is only applied when the not-found DB exception is raised.\n\n6) Integration-level Orquesta tests were added with new example workflows:\n   - contrib/examples/actions/orquesta-st2kv-default.yaml and its workflow contrib/examples/actions/workflows/orquesta-st2kv-default.yaml were introduced. The workflow exposes input parameters key_name, decrypt, and default (default: null). It demonstrates both YAQL and Jinja usage:\n     * value_from_yaql: <% st2kv(ctx().key_name, decrypt => ctx().decrypt, default => ctx().default) %>\n     * value_from_jinja: \"{{ st2kv(ctx().key_name, decrypt=ctx().decrypt, default=ctx().default) }}\".\n   - The existing orquesta-st2kv example workflow was simplified to set output.value directly from task(task1).result.stdout.\n   - Integration tests (st2tests/integration/orquesta/test_wiring_functions_st2kv.py) verify:\n     * For a nonexistent key without default (examples.orquesta-st2kv with key_name 'system.matt' and decrypt=True), the workflow fails with the expected 'does not exist in the StackStorm datastore' error message in result.errors[0].message.\n     * For the new orquesta-st2kv-default workflow with key_name 'system.matt', decrypt=True, and default set to 'stone', '', or None, the workflow succeeds and both output.value_from_yaql and output.value_from_jinja equal the provided default.\n\n7) Minor cleanups were also done: mock context variable names were shortened (MOCK_ORCHESTRA_CTX to MOCK_CTX) and a lint issue was fixed in the test file.\n\nOverall, the bug where st2kv treated empty-string and null-valued keys as missing has been resolved, and st2kv now supports an optional default return value for truly missing datastore keys, while using explicit DB not-found exceptions to distinguish between 'missing key' and 'present but falsy value'.",
        "semantic_memory": "Several generalizable patterns and best practices emerge from this fix:\n\n1. Do not use truthiness checks to distinguish between 'not found' and 'value is falsy':\n   In key-value retrieval code, using 'if value:' or 'if record:' conflates 'no record' with 'record exists but has a falsy value such as '', 0, or None'. Instead, the data access layer should explicitly signal 'not found' via a dedicated exception or sentinel. This is especially important when empty string or null are valid stored values that need to be returned as-is.\n\n2. Let the persistence layer own the 'not found' semantics:\n   By having KeyValuePair.get_by_scope_and_name() raise StackStormDBObjectNotFoundError when no record exists, higher-level services can make clear decisions:\n   - Some services treat that as an error and propagate it.\n   - Others interpret it as 'no existing key yet' and proceed accordingly (e.g., create new record or return a default or empty string).\n   This separation keeps low-level DB access consistent and allows service-level policy to vary.\n\n3. Use explicit exceptions to gate default-value logic:\n   When adding a 'default' parameter (e.g., st2kv(key, default=...)), default handling should only activate in specific, well-defined cases. Here, the default is returned only when the DB layer signals 'not found' via StackStormDBObjectNotFoundError. Any other exception (like DB connectivity errors or decryption failures) is treated as a real error and propagated. This avoids accidentally masking legitimate failures with default values.\n\n4. Use kwargs to distinguish between 'no default provided' and 'default=None':\n   If a function allows default=None as a legitimate value, positional arguments or simple default argument values are ambiguous (you cannot tell whether the caller omitted the parameter or intentionally passed None). Using **kwargs and checking 'default' in kwargs lets you differentiate:\n   - has_default = 'default' in kwargs\n   - default_value = kwargs.get('default')\n   so that default=None is handled correctly and only applied when explicitly provided.\n\n5. Be careful with decryption and None values:\n   If a key's value can be None, decryption utilities typically expect strings/bytes and may error on NoneType. Guard decryption by checking for None before calling decrypt functions, and return None directly when appropriate. This prevents type errors and matches the semantic meaning of a null value.\n\n6. Maintain backwards compatibility by handling new exceptions at the service boundary:\n   When changing a low-level API (e.g., from returning None to raising an exception), all callers must be audited and updated. Service-level code may need to catch the new exception and translate it back into legacy behavior (such as returning '' for missing keys) to avoid breaking downstream code while still gaining the clarity of explicit exceptions in the core persistence layer.\n\n7. Validate Orquesta function arguments early and clearly:\n   The st2kv_ function checks that 'key' is a string and 'decrypt' is a bool. Early validation simplifies debugging and prevents cryptic errors deep in the stack. It also ensures consistent behavior regardless of where or how the function is invoked (YAQL vs Jinja, different workflows, etc.).\n\n8. Test both templating engines when adding new expression semantics:\n   When a function like st2kv is available via both YAQL and Jinja expressions, features such as a new 'default' parameter must be tested in both contexts. Differences in syntax (YAQL's 'decrypt => ctx().decrypt' vs Jinja's 'decrypt=ctx().decrypt') can hide bugs if only one side is exercised.\n\n9. Integration tests for workflow functions should cover error and success paths:\n   For a function used by workflows, tests should assert both failure behavior (correct error message and status when key is missing and no default is provided) and success behavior (correct output when default is provided, including edge cases like empty string and null). This ensures the orchestration engine, function wiring, and datastore all interact as intended.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and characterize the incorrect behavior.\n- Write or run a minimal workflow (or unit test) that calls the function in question (e.g., st2kv) on keys whose values are '', None, and a normal non-falsy value.\n- Confirm exactly what is returned or what exceptions are raised for each case.\n- Also test behavior for truly nonexistent keys to see how the function distinguishes between 'key exists with falsy value' and 'key does not exist'.",
            "Step 2: Inspect low-level data access behavior.\n- Locate the persistence/DAO method used to fetch the record (e.g., KeyValuePair.get_by_scope_and_name()).\n- Check how it indicates 'not found': does it return None, an empty queryset, or raise an exception?\n- Add logging or targeted tests to see the raw behavior from the DB layer, independent of higher-level services.",
            "Step 3: Identify incorrect truthiness checks.\n- In any util or service function that wraps the DAO (e.g., st2common.util.keyvalue.get_key()), look for patterns like 'if value:' or 'if record:'.\n- Determine whether these checks incorrectly treat empty or null values as equivalent to 'no record found'.\n- If so, refactor to distinguish between 'record is None' (not found) and 'record exists but has a falsy value'.",
            "Step 4: Introduce explicit not-found signaling at the DAO level.\n- Modify the DAO method to raise a dedicated 'not found' exception (e.g., StackStormDBObjectNotFoundError) when no record matches the query.\n- Ensure the error message is descriptive (e.g., 'The key \"<name>\" does not exist in the <system> datastore.').\n- Update existing DAO tests or add new ones to assert this new behavior.",
            "Step 5: Update util/service layers to handle the new exception appropriately.\n- In utility functions like get_key(), allow the 'not found' exception to propagate or handle it explicitly depending on desired semantics.\n- If you need to preserve old behavior for some callers (like returning '' for missing keys), wrap the DAO call in try/except and convert the exception into the prior return behavior.\n- In functions that must distinguish between missing keys and falsy values, do not catch the 'not found' exception; let it propagate so callers can respond differently from the 'falsy value' case.",
            "Step 6: Handle decryption/processing of nullable values robustly.\n- Before calling decryption or transformation functions, check whether the value is None.\n- If None is a legitimate stored value, return it directly instead of attempting to decrypt or deserialize, which may raise TypeError or other errors.\n- Add tests for keys with value None to ensure correct behavior with decrypt=True and decrypt=False.",
            "Step 7: Design default-value semantics carefully.\n- If you want a function like st2kv to support a default value when the key is missing, decide exactly when the default should apply (e.g., only on 'not found', not on other errors).\n- Use kwargs for optional parameters and check for presence via 'param_name in kwargs' so you can distinguish between 'parameter omitted' and 'parameter provided with None'.\n- Implement logic such that:\n  - When the DAO raises a 'not found' exception and a default was provided, return the default.\n  - When the DAO raises 'not found' and no default was provided, re-raise or wrap as a user-facing exception.\n  - When any other exception occurs, propagate or wrap it as an error and do not apply the default to avoid masking real problems.",
            "Step 8: Map internal exceptions to workflow-friendly exceptions.\n- For functions used inside workflows (like Orquesta expressions), catch internal exceptions (e.g., StackStormDBObjectNotFoundError, generic Exceptions) and convert them to workflow-specific exceptions (e.g., orquesta.exceptions.ExpressionEvaluationException) with clear messages.\n- Do not swallow error messages; propagate them so that workflow execution logs clearly show what failed and why.",
            "Step 9: Update and extend unit tests.\n- Add tests for existing keys with values '', None, and typical non-falsy values, verifying correct return values.\n- Add tests for secret/encrypted keys with decrypt=True and decrypt=False to ensure decrypting only happens when requested.\n- Add tests for missing keys to verify that the correct exception type and message are produced.\n- Add tests for default behavior to cover defaults of non-empty strings, empty strings, and None.\n- Include tests that simulate generic failures (e.g., mock get_key to raise Exception) and verify they are not mistaken for 'not found' and do not pick up default values.",
            "Step 10: Add integration tests that reflect real workflow usage.\n- Create example workflows that use the function under test via both YAQL and Jinja (if applicable), including cases with and without the default parameter.\n- Ensure that workflows:\n  - Fail with a clear error when expected (e.g., missing key and no default).\n  - Succeed with expected outputs when default values are provided.\n- Run the full integration suite to verify that orchestrated behavior matches unit-level expectations.",
            "Step 11: Audit all callers after changing low-level behavior.\n- Search the codebase for all usages of the modified DAO or util methods (e.g., get_by_scope_and_name, get_key).\n- For each caller, decide whether it should:\n  - Catch the new 'not found' exception and translate it into previous behavior (e.g., treat as empty or create new record).\n  - Allow the exception to propagate as a hard error.\n- Adjust code and tests accordingly to maintain or intentionally change behavior in each context.",
            "Step 12: Document the behavior and usage.\n- Update changelogs and developer documentation to describe the new behavior of the datastore functions, including how missing keys, empty strings, null values, and default parameters are handled.\n- Provide short examples for both YAQL and Jinja usage (e.g., st2kv('system.my_key', decrypt => true, default => 'foo') and the Jinja equivalent) so users know how to adopt the new feature."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant konnected integration refactor: moved the third-party 'konnected' library imports from inside functions/constructors to module-level imports, and normalized Home Assistant constant/helper imports for style and clarity. No functional behavior change; complies with core import guidelines and avoids unnecessary dynamic imports.",
        "keywords": [
            "Home Assistant",
            "konnected integration",
            "imports inside functions",
            "move imports to top-level",
            "dynamic import refactor",
            "code style compliance",
            "HA integration guidelines",
            "Python import best practices"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the konnected integration for Home Assistant was updated to move imports from function scope to module scope. Previously, the 'konnected' Python library was imported inside the async_setup function and inside the KonnectedClient.__init__ constructor. This pattern deviated from Home Assistant's development guidelines, which prefer imports at the top of the module unless there is a strong reason (e.g., optional or heavy dependencies). The issue referenced (#27284) explicitly requested this change.\n\nThe fix consisted of:\n- Adding 'import konnected' as a top-level import in homeassistant/components/konnected/__init__.py.\n- Removing the in-function imports of 'konnected' from async_setup and KonnectedClient.__init__ and using the module-level import instead.\n- Cleaning up and reordering other imports: consolidating Home Assistant constants, helpers, and local const imports, and ensuring a consistent order (standard library, third-party, Home Assistant, then local modules).\n- In handlers.py, related imports were similarly reordered for consistency, but there was no functional logic change.\n\nNo runtime bug was being fixed; this was a code health/style refactor to conform to Home Assistant's import conventions and facilitate easier static analysis, readability, and performance (avoiding repeated imports on function calls). Tests were reported to pass, confirming no behavioral regression.",
        "semantic_memory": "This change illustrates a common best practice in Python and in large frameworks like Home Assistant: imports should generally live at the module level instead of inside functions or methods. Module-level imports:\n- Are executed once at import time, avoiding repeated overhead on every function call.\n- Make dependencies more explicit and discoverable, which improves readability and maintainability.\n- Play nicer with tooling (linters, static analyzers, type checkers) that expect imports in predictable locations.\n- Help enforce consistent style across a large codebase.\n\nFunction-level imports are generally reserved for scenarios such as:\n- Avoiding circular import issues.\n- Lazily importing heavy or rarely used dependencies to optimize startup time.\n- Optional dependencies that may not be installed, where the import is guarded and error-handled.\n\nIn integrations like Home Assistant components, following the project’s import style guide (top-level imports, clear grouping and ordering, and moving shared constants/helpers out of inner scopes) leads to cleaner, more maintainable modules and fewer surprises during runtime.",
        "procedural_memory": [
            "When you encounter a Home Assistant component (or any Python module) with imports inside functions or methods without a clear necessity (e.g. not optional or heavy dependencies), refactor them to top-level imports to comply with style guidelines and improve code clarity.",
            "Step 1: Identify non-essential function-scope imports.\n- Search for 'import' statements inside functions, methods, or class bodies.\n- Determine whether those imports are truly necessary to be lazy (e.g., optional dependency, circular import workaround, or heavy library used infrequently).\n",
            "Step 2: Decide if imports can safely be moved to module level.\n- Confirm that importing the module at top level will not cause circular imports.\n- Ensure the dependency is always expected to be installed for the integration/component to work.\n- Check that there is no special runtime condition that requires the import to be delayed.\n",
            "Step 3: Move the imports.\n- Add the import statements to the top of the file, grouped appropriately: standard library, third-party, framework (e.g., Home Assistant), then local imports.\n- Remove the in-function imports and rely on the module-level import.\n- Adjust import ordering to match the project’s conventions (e.g., alphabetical within groups, no duplicates).\n",
            "Step 4: Clean up related imports and constants.\n- While editing, normalize the import and constant ordering: group related constants from the same module in a single import, avoid unnecessary reordering that changes semantics.\n- Ensure local constants (e.g., from .const) are imported once at the top and used consistently.\n",
            "Step 5: Run tests and linting.\n- Run the project’s test suite (e.g., 'tox' for Home Assistant) to confirm there are no regressions.\n- Run linters/formatters (e.g., flake8, isort, black if applicable) to ensure import order and styling conform to guidelines.\n- Fix any import-order or unused-import warnings raised by these tools.\n",
            "Step 6: Watch for subtle issues after moving imports.\n- If a circular import arises after moving an import to the top level, consider:\n  - Moving only the problematic import back into the function that needs it.\n  - Refactoring code to reduce cross-module dependencies.\n- If a dependency is optional, wrap the import in try/except ImportError or keep it lazy inside functions, but document this clearly.\n",
            "Step 7: Document the change if it’s part of a broader guideline.\n- In a shared codebase, note in the relevant docs or review comments that imports should be at module level unless there’s a specific reason not to be.\n- Reference the project’s development checklist or style guide so future contributors understand the rationale."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor napari viewer theme and palette handling into a dedicated evented Style dataclass. The viewer now exposes styling through viewer.style.theme and viewer.style.palette instead of viewer.theme, viewer.palette, and viewer.events.palette. Backwards compatibility is preserved via deprecated properties that forward to Style, and all Qt/vispy consumers now subscribe to viewer.style.events. The Style dataclass manages available themes, validates theme names, updates palettes, and provides a method to advance to the next theme.",
        "keywords": [
            "napari",
            "viewer_model",
            "Style",
            "evented_dataclass",
            "theme",
            "palette",
            "viewer.style",
            "viewer.theme deprecation",
            "viewer.palette deprecation",
            "viewer.events.palette removal",
            "Qt palette update",
            "Vispy welcome visual colors",
            "dataclass __hash__ with mutable fields",
            "available_themes",
            "custom theme handling",
            "refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, styling logic for the napari viewer (themes and color palettes) was refactored out of ViewerModel into a dedicated evented Style dataclass.\n\nPreviously, ViewerModel stored its own palette and themes (via napari.utils.theme.palettes), exposed properties viewer.theme and viewer.palette, and emitted a viewer.events.palette event whenever the palette changed. Various Qt widgets and the vispy welcome visual subscribed to viewer.events.palette or read viewer.palette directly to update UI coloring, including the main stylesheet, canvas background color, the welcome screen, and key binding dialogs. Axes and ScaleBar components also directly read the viewer palette to set their background color.\n\nTo make the styling system cleaner and more extensible, the author introduced napari.components.style.Style as an @evented_dataclass. Style encapsulates:\n- a theme attribute (default 'dark'),\n- a palette attribute (a dict of color names to hex strings),\n- access to available themes via the global palettes dict,\n- validation and updating of palette when theme changes (_on_theme_set),\n- detection of the correct theme when the palette is set directly (_on_pallet_set), marking the theme as 'custom' if it doesn't match any known palette,\n- a method _advance_theme to cycle to the next available theme, and\n- a custom __hash__ implementation using id(self) because the dataclass holds a mutable Dict and is used in the event system, which requires hashable instances.\n\nViewerModel now owns a Style instance as viewer.style and connects style.events to a new _on_style_change handler, which updates axes.background_color and scale_bar.background_color based on style.palette['canvas']. The old ViewerModel palette, theme, and themes attributes are preserved but marked as deprecated, emitting DeprecationWarning and forwarding to the Style instance:\n- viewer.palette forwards to viewer.style.palette,\n- viewer.theme forwards to viewer.style.theme,\n- viewer.themes forwards to viewer.style.available_themes.\n\nThe old viewer._toggle_theme method is removed from ViewerModel, and UI code that previously called viewer._toggle_theme now calls viewer.style._advance_theme. Likewise, all Qt and vispy consumers that listened for viewer.events.palette now listen to viewer.style.events, and all direct uses of viewer.palette are rewritten to use viewer.style.palette. This affects:\n- napari/_qt/qt_main_window.py (status bar styling, theme toggle action),\n- napari/_qt/qt_viewer.py (main stylesheet templating and canvas background color),\n- napari/_qt/dialogs/qt_about_key_bindings.py (key bindings color),\n- napari/_vispy/vispy_welcome_visual.py (welcome logo/text colors and background decisions), and\n- examples/set_theme.py and tests.\n\nTests were added for the Style class (napari/components/_tests/test_style.py) to verify:\n- default theme is 'dark' and palette['folder'] matches 'dark',\n- setting theme to 'light' updates palette['folder'] accordingly,\n- setting an invalid theme raises ValueError. The existing viewer tests were updated to use viewer.style.theme and viewer.style.palette rather than viewer.theme / viewer.palette, and to still validate that invalid themes raise ValueError.\n\nOverall, this change centralizes theme and palette management, introduces a dedicated event source (style.events), and maintains backward compatibility while emitting deprecation warnings for legacy viewer.theme / viewer.palette usage.",
        "semantic_memory": "This PR illustrates several broadly useful design and implementation patterns around UI styling, event-driven models, and refactoring with backwards compatibility:\n\n1. **Encapsulate styling into a dedicated model object**:\n   Instead of scattering styling logic (theme name, palette colors, and how they change) directly on a larger model (ViewerModel), it is cleaner to introduce a dedicated Style object that fully owns theme-related state. This isolates styling concerns, simplifies the main model, and makes it easier to evolve styling independently.\n\n2. **Use an evented dataclass for grouped reactive state**:\n   The Style class is implemented as an @evented_dataclass, which combines declarative fields (palette, theme) with an automatic event system. Changes to those fields produce events that UI components can subscribe to. This pattern is useful anywhere a group of related properties should change together and trigger UI updates or downstream effects.\n\n3. **Backwards compatibility via forwarding and deprecation warnings**:\n   When refactoring public attributes (viewer.theme, viewer.palette, viewer.events.palette) to a new structure (viewer.style.theme, viewer.style.palette, viewer.style.events), the code keeps the old properties and methods as thin wrappers that:\n   - emit a DeprecationWarning with a clear replacement,\n   - delegate operations to the new API.\n   This avoids breaking downstream code immediately and gives users time to migrate, while keeping the new design as the primary implementation.\n\n4. **Centralize theme validation and error handling**:\n   Theme validity checks and ValueError raising are moved into Style._on_theme_set. Any component that sets Style.theme automatically benefits from consistent validation. This avoids duplicating validation logic across multiple classes.\n\n5. **Synchronize derived properties when base style changes**:\n   The viewer connects style.events to a handler that updates other visual properties (Axes.background_color, ScaleBar.background_color). This ensures that dependent visuals remain in sync with the style model. When multiple components depend on the same conceptual state, it is better to emit a single style change event and have them all react to it than to scatter manual updates in multiple places.\n\n6. **Provide a mechanism to cycle through themes in the model**:\n   Instead of having ad-hoc theme toggling logic in the UI or viewer, the Style model itself knows how to advance to the next theme via _advance_theme. This respects the single-responsibility principle: the model owns how to interpret and navigate its own state, while the UI merely triggers model actions.\n\n7. **Handling hashability for evented dataclasses with mutable fields**:\n   The event system expects event emitters / listeners to be hashable. Dataclasses with mutable types like Dict typically don't get a safe __hash__ by default. When such a class must be used in hash-based structures (e.g., event registries), you can implement __hash__ in terms of object identity (id(self)), acknowledging that it's an unsafe hash in the sense that the semantics are identity-based rather than value-based. This is acceptable when the object is long-lived and identity is the relevant concept.\n\n8. **Gradual migration of event sources**:\n   When moving from one event source (viewer.events.palette) to another (viewer.style.events), every consumer (Qt dialogs, main window, viewer, vispy visuals) must be updated to subscribe to the new event. Doing this in a focused refactor reduces the risk of inconsistent behavior and makes it easy to search for old API usage.\n\nThese patterns generalize to any large GUI or reactive system that needs to manage themes/styles, refactor core APIs without breaking downstream code, or consolidate eventful state into modular, testable components.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify scattered style/theme logic and event usage.\n- Search the codebase for theme-related properties (e.g., `theme`, `palette`) and associated events (e.g., `events.palette`).\n- Note all places where UI reacts to theme changes (stylesheet templating, background colors, icon colors, welcome screens, etc.).",
            "Step 2: Design a dedicated style model.\n- Create a new class (e.g., `Style`) to own theme and palette data.\n- Decide which fields should be reactive (e.g., `theme: str`, `palette: Dict[str, str]`).\n- If your project uses an event system, make this class integrate with it (e.g., using an `evented_dataclass`).",
            "Step 3: Centralize theme and palette management.\n- Give the style class access to the global theme registry (e.g., `available_themes = palettes`).\n- Implement logic to update the palette when a theme is set:\n  - On setting `theme`, validate it against `available_themes`.\n  - If valid, set `palette` to the corresponding value.\n  - If invalid, raise a clear `ValueError` listing supported themes.\n- Implement logic for setting the palette directly:\n  - When `palette` is set, check if it matches any known theme; if so, adjust `theme` accordingly.\n  - Otherwise, mark `theme` as `'custom'` or similar.",
            "Step 4: Integrate style model into the main model.\n- Add a `style` attribute to your main model (e.g., `self.style = Style()`).\n- Connect `style.events` to a handler on the main model that updates any derived properties (e.g., background colors on other components).",
            "Step 5: Update all UI consumers to use the new style model.\n- Replace direct uses of `model.palette` with `model.style.palette`.\n- Replace subscriptions to `model.events.palette` with `model.style.events` (or specific style events if your system allows fine-grained events).\n- Update any theme toggle actions to call a method on the style model (e.g., `style._advance_theme`) instead of legacy methods on the main model.",
            "Step 6: Preserve backwards compatibility with deprecation wrappers.\n- For each old public attribute/method you are replacing (e.g., `viewer.theme`, `viewer.palette`, `viewer.themes`, `viewer._toggle_theme`):\n  - Keep the old property/method but implement it as a thin wrapper that delegates to `viewer.style`.\n  - Emit a `DeprecationWarning` with a clear message about the new preferred API.\n  - Ensure the wrapper still behaves correctly for existing code until the deprecation period ends.",
            "Step 7: Ensure event system compatibility (hashability).\n- If your style model is an evented dataclass with mutable fields (like `Dict`), verify whether the event system or signal registry requires instances to be hashable.\n- If necessary, implement `__hash__` using `id(self)` or another appropriate identity-based scheme, and document that this is an unsafe hash tied to object identity rather than value.",
            "Step 8: Add and update tests.\n- Write unit tests for the style model:\n  - Default theme and palette.\n  - Changing theme updates palette.\n  - Setting invalid theme raises `ValueError`.\n  - (Optionally) setting palette adjusts theme or marks it as custom.\n- Update existing tests that referenced the old API to use `model.style` where appropriate, while also adding tests for deprecated pathways if you want to enforce deprecation behavior.",
            "Step 9: Verify UI behavior end-to-end.\n- Run the application and:\n  - Toggle themes and ensure all parts of the UI update correctly (status bar, main window, canvas background, overlays, dialogs, etc.).\n  - Confirm that components dependent on background colors (axes, scale bars, welcome visuals) now track changes in the style model.\n  - Ensure DeprecationWarnings are emitted where expected but the old API still functions.",
            "Step 10: Communicate and plan deprecation.\n- Document the new APIs (`model.style.theme`, `model.style.palette`, `model.style.available_themes`) and the forthcoming removal of the old ones.\n- Inform downstream users (e.g., via release notes) that they should migrate off `model.theme`, `model.palette`, and `model.events.palette`.\n- Set a clear version or timeline after which the deprecated API will be removed."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Flaky orquesta integration tests in StackStorm were caused by race conditions due to the coordination backend not being configured. The fix configures a Redis-based coordination backend specifically for CI integration tests, starts a Redis service in GitHub Actions, installs the redis client library, updates st2 config files accordingly, and improves logging to show the coordination driver without leaking credentials. Tests are updated to account for new log lines and coordination behavior, and a skip-duplicate GitHub Action is added to avoid redundant CI runs.",
        "keywords": [
            "StackStorm",
            "orquesta",
            "integration tests",
            "race condition",
            "coordination backend",
            "Redis",
            "GitHub Actions services",
            "st2.dev.conf",
            "st2.ci.conf",
            "tooz coordination",
            "flaky tests",
            "service_setup logging",
            "get_driver_name",
            "skip-duplicate-actions",
            "CI configuration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, orquesta integration tests in the StackStorm project frequently failed due to race conditions. Investigation revealed that the tests were running without a proper coordination backend configured, even though the workflow engine expects one (e.g., via tooz) to manage distributed locks and coordination. To address this, the CI workflow and test setup were modified.\n\nConcretely, the GitHub Actions `ci.yaml` workflow was updated to define a Redis service (`image: redis`) with health checks and an exposed port 6379. This Redis instance is used as the coordination backend during integration tests. In the `scripts/github/prepare-integration.sh` script, the StackStorm configuration files `conf/st2.dev.conf` and `conf/st2.ci.conf` are patched using `sed` to uncomment and set `url = redis://127.0.0.1` in the `[coordination]` section, ensuring StackStorm actually uses Redis for coordination in CI. The script also installs the Python Redis client (`pip install \"redis==3.5.3\"`) so the coordination driver can connect successfully.\n\nAdditional diagnostics were added: on service startup, StackStorm now logs `Using coordination driver: <driver>` and `Using metrics driver: <driver>` in `st2common/service_setup.py`. To avoid leaking credentials that might be embedded in URLs (e.g., `redis://user:pass@host`), the direct URL logging was replaced with a new helper `get_driver_name()` in `st2common/services/coordination.py`. This helper extracts only the scheme (e.g., `redis`, `kazoo`, `file`, `zake`) from the configured URL. Unit tests in `test_synchronization.py` were updated to validate the behavior of both `configured()` and `get_driver_name()`, including URLs with credentials, and integration tests in `test_service_setup_log_level_filtering.py` were updated to expect two additional environment log lines and the new coordination-driver log message.\n\nOn the CI side, transient testing changes were introduced and then reverted: at one point, the same task was executed six times in a loop to stress-test the effect of the coordination backend; after confirming stability across multiple runs, this loop was removed and normal single-run behavior restored. The full CI matrix (lint, compile, pack tests, unit, integration) was re-enabled. To reduce wasted CI resources, a new `pre_job` was added using the `fkirc/skip-duplicate-actions` GitHub Action, with `cancel_others: 'true'`, to prevent redundant workflow runs for duplicate pushes. After several successful runs (six consecutive passes) with the Redis coordination backend enabled, the changes were merged, with the understanding that they significantly reduce but may not completely eliminate race-condition related flakiness.",
        "semantic_memory": "This fix highlights several generalizable patterns for stabilizing distributed or asynchronous test suites and improving CI infrastructure:\n\n1. **Flaky tests often stem from missing or misconfigured coordination primitives**: When a system relies on a distributed coordination backend (e.g., tooz with Redis, Zookeeper, or file-based coordination) for locking, leadership election, or workflow state synchronization, running tests without that backend can introduce uncontrolled race conditions. Ensuring tests use the same coordination mechanism as production (or an appropriate equivalent) dramatically reduces flakiness.\n\n2. **Use containerized services in CI to emulate production dependencies**: GitHub Actions and similar CI platforms provide `services` that can run Docker containers for dependencies like databases, message brokers, and coordination backends. Properly configuring these services (image, ports, health checks) and pointing application configs to them is an effective strategy to make integration tests realistic and deterministic.\n\n3. **Automate configuration tweaks for CI-specific environments**: Instead of maintaining separate hand-edited config files, scripts such as `prepare-integration.sh` can patch base config files at CI runtime (e.g., via `sed`) to enable specific features (like a coordination backend) only where needed. This allows sharing config structure while adjusting behavior between local dev, CI, and production.\n\n4. **Avoid logging secrets; log high-level information instead**: Logging full URLs for backends that might contain credentials (e.g., `redis://user:pass@host`) risks secret leakage in logs. A better practice is to expose only non-sensitive metadata (like the driver or protocol name) using small helpers (e.g., `get_driver_name()`), which still aids observability without compromising security.\n\n5. **When adding new log lines, adjust tests that assert on log output**: Integration tests that assert exact or relative positions of log lines (e.g., \"first 4 lines are environment logs\") are brittle. When adding new log messages, these expectations must be updated (from 4 to 6 lines, in this case) and assertions updated to match new message content. Minimizing order-sensitive log assertions can also help.\n\n6. **Stress-test potential fixes for flakiness**: To gain confidence that a coordination change actually helps, temporarily running the same test suite multiple times in CI (or in a loop locally) is a practical stress test. Once confidence is sufficient, revert to standard CI behavior to keep runtimes reasonable.\n\n7. **Use CI optimizations to avoid redundant work**: For repositories with frequent pushes and PR updates, skip-duplicate workflows or auto-cancellation mechanisms reduce cost and clutter. Using actions like `fkirc/skip-duplicate-actions` as a `pre_job` with `cancel_others` keeps only the latest relevant run active.\n\nOverall, the pattern is: ensure that test infrastructure mirrors production dependencies (including coordination backends); configure external services explicitly in CI; be careful with secrets in logs; and keep tests aligned with logging and service behavior.\n",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of coordination-related flakiness\n- Look for intermittent test failures in integration or workflow-related tests, especially those involving concurrency or distributed state.\n- Check failure logs for timeouts, missing state, or ordering-related issues that resemble race conditions rather than deterministic failures.\n\nStep 2: Verify coordination backend configuration\n- Inspect the application configuration used in tests (e.g., `st2.dev.conf`, `st2.ci.conf`, or equivalent) for the `coordination` (or similar) section.\n- Confirm whether a `url` or backend configuration is set. Typical URLs might look like `redis://host`, `kazoo://host`, `zake://`, `file:///path`, etc.\n- If the URL is commented out or empty, your tests might be running without a real coordination backend.\n\nStep 3: Ensure a coordination service is available in CI\n- If using GitHub Actions (or similar), define an appropriate service in the workflow:\n  - For Redis, add:\n    - `services.redis.image: redis`\n    - Health-check options such as `--health-cmd \"redis-cli ping\"`, `--health-interval 10s`, `--health-timeout 5s`, `--health-retries 5`.\n    - Expose port `6379` (or your chosen port) with `ports: ['6379:6379/tcp']`.\n- Give the container a friendly name via Docker options (e.g., `--name \"redis\"`) to simplify debugging.\n\nStep 4: Wire your tests to use the CI service\n- In a CI preparation script (e.g., `prepare-integration.sh`), patch your config files to point to the CI service:\n  - Use `sed` or equivalent to set the coordination URL, e.g.:\n    - `sed -i \"s#\\#url = redis://localhost#url = redis://127.0.0.1#g\" ./conf/st2.dev.conf`\n    - Do the same for CI-specific configs (e.g., `./conf/st2.ci.conf`), guarding with `|| true` if files may be missing.\n- Optionally log out the effective config files in CI for easier troubleshooting.\n\nStep 5: Install required client libraries\n- Confirm that the application has the necessary client library for the chosen coordination backend.\n- For Redis-backed coordination, ensure you install a compatible version of the Python redis client, e.g., `pip install \"redis==3.5.3\"` in your CI setup step.\n\nStep 6: Improve observability without leaking secrets\n- Add logging on service start-up to show which coordination driver and metrics driver are in use.\n- Instead of logging the full URL, implement a helper that extracts only the \"driver\"/scheme, e.g.:\n  - `url = cfg.CONF.coordination.url`\n  - `driver_name = url.split('://')[0]` if `url` is set.\n- Log messages like `\"Using coordination driver: %s\"` and avoid printing credentials.\n\nStep 7: Update tests that rely on log output\n- Search for tests that assert on early startup log output or specific log messages (e.g., tests checking the first N log lines).\n- Adjust expectations for the number of environment log lines if you add new ones (e.g., change from 4 to 6 lines).\n- Update assertions to expect the new log text, such as `\"Using coordination driver:\"` instead of `\"Using coordination url:\"`.\n- Add or extend unit tests to validate new helpers like `get_driver_name()`, verifying behavior for:\n  - `None` or empty URLs.\n  - Various schemes: `kazoo://`, `file:///`, `zake://`, `redis://user:pass@host`.\n\nStep 8: Stress-test the fix for flakiness\n- Temporarily modify your CI or local test harness to run the critical test suite multiple times in a loop (e.g., run integration tests 5â€“10 times).\n- Monitor whether previously intermittent failures still occur.\n- Once confidence is gained, revert to single-run CI to keep build times reasonable.\n\nStep 9: Optimize CI to avoid redundant runs\n- If your repository has frequent updates, configure a pre-job that uses an action like `fkirc/skip-duplicate-actions`:\n  - Expose `should_skip` as an output.\n  - In your main CI job, add `needs: pre_job` and `if: ${{ needs.pre_job.outputs.should_skip != 'true' }}`.\n  - Set `cancel_others: 'true'` to automatically cancel older redundant runs.\n\nStep 10: Monitor over time\n- After merging the changes, keep track of test stability metrics in CI.\n- If new flakes occur, inspect whether they relate to coordination or other dependencies, and repeat the analysis cycle as necessary."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fixes an infinite/long-running loop in Pokemon catching tasks when many catchable or lured Pokemon are present and catch filters prevent catching some of them, by tracking recently encountered Pokemon IDs and skipping already-processed encounters.",
        "keywords": [
            "infinite loop",
            "repeat processing",
            "duplicate encounters",
            "catch filter",
            "catchable_pokemons",
            "wild_pokemons",
            "lured_pokemon",
            "encounter_id",
            "deduplication",
            "Pokemongo bot",
            "cell_workers",
            "CatchVisiblePokemon",
            "CatchLuredPokemon"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Pokemon Go bot would get stuck in a loop when many catchable Pokemon were detected, especially when configuration catch-filters prevented some of them from being caught. The tasks `CatchVisiblePokemon` and `CatchLuredPokemon` operated roughly as follows: they looked at the current cell's lists of `catchable_pokemons`, `wild_pokemons`, and `lured_pokemon`, chose one Pokemon (often the first or closest), tried to catch it, and then returned `WorkerResult.RUNNING` if more Pokemon remained. However, when catch filters or other logic caused the same Pokemon to remain in the cell data (e.g., not actually removed from the server state or filtered out by config), the worker would repeatedly attempt to process the same `encounter_id` on subsequent iterations, resulting in an effective endless loop of attempts on the same targets.\n\nThe fix introduces a small sliding-window memory of recently encountered Pokemon within both `CatchVisiblePokemon` and `CatchLuredPokemon`. Each task now has:\n- an `initialize` method that sets `self.encountered = [None] * 10`;\n- `add_encountered(pokemon)` that appends the Pokemon's `encounter_id` and discards the oldest entry;\n- `was_encountered(pokemon)` that checks whether the Pokemon's `encounter_id` is already in `self.encountered`.\n\nIn `CatchLuredPokemon.work`, instead of always catching the first lured Pokemon, the worker iterates over `lured_pokemon` and catches only the first one that has not been encountered before. After catching, it records the `encounter_id` and returns `WorkerResult.RUNNING`. If all lured Pokemon have already been encountered, it returns `WorkerResult.SUCCESS` without reprocessing them.\n\nIn `CatchVisiblePokemon.work`, similar logic is applied to both `catchable_pokemons` and `wild_pokemons`. For `catchable_pokemons`, the code still logs information for each Pokemon but only attempts to catch the first Pokemon in the list whose `encounter_id` is not in `self.encountered`. For `wild_pokemons`, after sorting by distance, it iterates and catches the first not-yet-encountered Pokemon. In both cases, if none are new (all were previously encountered), the worker returns `SUCCESS` instead of continuing to report `RUNNING` and reattempting the same encounters. This eliminates the loop caused by repeatedly trying to catch already-processed (or filtered-out) Pokemon while many are present in the vicinity.",
        "semantic_memory": "This fix illustrates a common pattern in event-driven or polling-based systems: when repeatedly scanning and acting on a dynamic list of items, you must guard against reprocessing the same items indefinitely, especially if external conditions (filters, upstream state, or side effects) do not remove them automatically.\n\nKey generalizable concepts:\n1. **Use stable identifiers to prevent reprocessing**: When dealing with entities that may persist in source data across multiple iterations (e.g., `encounter_id` for Pokemon, message IDs in queues, request IDs in APIs), maintain a set or sliding window of recently processed IDs. Before acting on an entity, check whether its ID has already been processed.\n\n2. **Avoid infinite loops in task schedulers**: Workers that return a 'keep running' status (like `WorkerResult.RUNNING`) should progress through the workset. If the data source doesn't shrink or change because of filters, errors, or external state, a naive 'while items exist' strategy can yield loops. Incorporating idempotency and deduplication logic prevents this.\n\n3. **Sliding window vs. unbounded memory**: Instead of keeping an unbounded set of all processed items (which can grow without limit), a fixed-size sliding window of recent IDs often suffices to prevent tight loops, especially in systems where items naturally expire or move out of scope over time.\n\n4. **Separation of detection and handling**: It's useful to separate 'enumeration of available items' (e.g., scanning `catchable_pokemons`, `wild_pokemons`) from 'deciding whether to act on them' (e.g., based on filters and past encounters). This design helps avoid scenarios where changes in one layer (like a catch filter) inadvertently cause pathological behavior in the iteration logic.\n\n5. **Return codes should reflect real progress**: A worker returning a 'RUNNING' status without having made progress (e.g., without having processed any new item) is a red flag. Incorporating checks for \"did I actually do something new?\" before returning 'RUNNING' can prevent starvation and loops.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: **Identify symptoms of looping or repeated processing**\n- Look for logs showing the same item (same ID or attributes) being processed over and over.\n- Observe CPU usage or worker status: tasks that never transition from RUNNING/active to SUCCESS/idle may indicate a loop.\n- In this case, repeated attempts to catch the same Pokemon with the same `encounter_id` while many Pokemon were present indicated a loop.",
            "Step 2: **Inspect the iteration and control-flow logic**\n- Review how the worker or service iterates over available items (lists, queues, maps).\n- Check under what conditions it returns statuses like RUNNING vs SUCCESS/IDLE.\n- Verify whether the iteration logic relies on the data source shrinking (e.g., using `pop(0)`) or assumes items are removed when processed.",
            "Step 3: **Check how items are removed or marked as processed**\n- Identify where, if at all, processed items are removed from the underlying collection or marked as done.\n- Investigate if filters, upstream errors, or conditions prevent removal (e.g., catch filters that result in not catching but leaving the Pokemon present in the cell data).\n- Confirm whether the same items can reappear unchanged across multiple cycles, which can cause reprocessing.",
            "Step 4: **Introduce a processed/encountered tracking mechanism**\n- Choose a stable identifier for items (e.g., `encounter_id`, message ID, primary key).\n- Add a data structure to the worker (e.g., a list, deque, or set) to track recently processed IDs.\n- Implement helper methods, as in this fix:\n  - `initialize` to set up the tracking structure.\n  - `add_encountered(item)` to record a processed ID, optionally using a sliding window of fixed size to avoid unbounded growth.\n  - `was_encountered(item)` to check if the ID has already been seen.",
            "Step 5: **Guard the processing logic using the tracking mechanism**\n- Before acting on an item, call `was_encountered(item)`; skip items that return true.\n- For each new item processed, call `add_encountered(item)` immediately after successful handling or definitive decision (e.g., attempted catch, filtered out, or explicitly skipped for good reasons).\n- Ensure the worker only returns RUNNING after processing at least one new item. If it iterates through all items and finds none new, it should return SUCCESS/IDLE.",
            "Step 6: **Adjust iteration strategy if necessary**\n- If you previously used destructive operations like `pop(0)` on lists, consider whether non-destructive iteration plus encounter tracking is safer, especially when external state controls item lifetime.\n- Maintain sorting or prioritization (e.g., by distance, urgency) but still rely on encounter tracking to prevent reprocessing.",
            "Step 7: **Test with scenarios that previously caused loops**\n- Recreate the conditions: many items available, some of which can't be fully processed due to filters or errors.\n- Verify that:\n  - Each eligible item is processed at most once within the tracking window.\n  - The worker eventually returns SUCCESS when no new items are available.\n  - Logs no longer show repeated handling of the same IDs.",
            "Step 8: **Monitor and tune the tracking window**\n- Choose an appropriate size for the \"recently processed\" window (e.g., 10 in this fix, but may need more for other systems).\n- Balance memory usage against the risk of reprocessing old items that persist for a long time.\n- If necessary, persist state between runs or use stronger idempotency guarantees (e.g., durable processed-ID store) in more critical systems."
        ]
    }
}
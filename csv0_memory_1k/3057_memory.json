{
    "search_index": {
        "description_for_embedding": "Cleanup of deprecated Optuna APIs: removal of optuna.structs module, deprecated wrapper classes (FrozenTrial, StudySummary, TrialPruned), and LightGBMTuner.best_booster property, along with associated tests, lazy imports, and documentation references to avoid CI (flake8, mypy, docs) failures.",
        "keywords": [
            "optuna.structs",
            "FrozenTrial",
            "StudySummary",
            "TrialPruned",
            "LightGBMTuner.best_booster",
            "deprecated API removal",
            "breaking change",
            "flake8 error",
            "mypy error",
            "docs build failure",
            "lazy import cleanup"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the Optuna project performed a cleanup of long-deprecated features. The deprecated property LightGBMTuner.best_booster (which just returned get_best_booster) was removed from optuna.integration._lightgbm_tuner.optimize. The entire optuna.structs module, which existed as a deprecated shim emitting a FutureWarning and re-exporting StudyDirection, TrialState, FrozenTrial, StudySummary, and TrialPruned from their new locations, was deleted. Corresponding tests that explicitly asserted deprecation warnings for these structs-based classes (FrozenTrial, StudySummary, TrialPruned) were removed, and eventually the whole tests/test_structs.py file was deleted. \n\nThe removal of optuna.structs caused several secondary issues: (1) references in tests to optuna.structs.TrialPruned caused import and lint errors, so tests/study_tests/test_optimize.py was updated to no longer import TrialPruned from optuna.structs and then later had the now-unnecessary test that parametrized over different TrialPruned classes completely removed; (2) a lazy import in optuna/__init__.py pointing to 'optuna.structs' became invalid, so it was removed; (3) Sphinx documentation still referenced the deprecated structs module via docs/source/reference/structs.rst and a corresponding entry in docs/source/reference/index.rst, which broke docs tests, so the structs reference page and index entry were deleted.\n\nDuring the process, CI caught several issues: flake8 reported unused imports (e.g., deprecated decorator import in LightGBM tuner and removed TrialPruned imports in tests), mypy complained about references to the removed best_booster property in LightGBMTuner tests, and the docs test failed due to the now-missing structs module. Each of these failures was addressed by removing unused imports, updating/removing tests that referenced the removed APIs, and deleting the structs documentation. After these fixes, the codebase no longer contains the deprecated structs layer or LightGBMTuner.best_booster, and all tests and docs are consistent with the new API surface.",
        "semantic_memory": "This PR illustrates best practices for removing deprecated APIs from a mature codebase:\n\n1. **Fully remove deprecated shims once the deprecation window is over**: optuna.structs was a transitional module that re-exported types from their new locations while emitting a FutureWarning. Once downstream users had sufficient time to migrate, it was entirely deleted instead of keeping obsolete alias layers indefinitely.\n\n2. **Remove both the API and all internal references**: removing an API symbol (e.g., LightGBMTuner.best_booster, optuna.structs.TrialPruned) requires cleaning up references in code, tests, and documentation, as well as lazy imports or re-exports that assume the symbol still exists. Leaving any stray reference will cause runtime import errors, static analysis failures, or broken documentation builds.\n\n3. **Deprecation tests are temporary**: tests that assert deprecation warnings (via pytest.warns(FutureWarning)) are useful while the deprecated path exists, but must themselves be removed once the deprecated API is deleted. Otherwise, tests will fail because they attempt to import or call non-existent symbols.\n\n4. **CI will surface multi-layer breakage**: removing a module can trigger diverse failuresâ€”flake8 complaining about unused or missing imports, mypy about invalid attributes, Sphinx about missing documented modules, and runtime tests about imports. Systematically addressing each class of failure (lint, type, docs, runtime) is essential when performing large-scale API cleanups.\n\n5. **Avoid leaving dead lazy imports / re-exports**: lazy import helpers or __init__-level shims that refer to removed modules need to be pruned. Otherwise, tools or users accessing those attributes will see confusing errors at runtime.\n\n6. **Coordinate documentation with code changes**: the API reference must remain consistent with the actual code. Removing a module or class should be accompanied by deleting or updating its Sphinx .rst pages and any index entries that reference it.\n\nOverall, the pattern is: introduce deprecation with clear messaging and tests, maintain for a defined period, and then perform a thorough, repo-wide cleanup that touches code, tests, and docs together.",
        "procedural_memory": [
            "Step-by-step workflow for safely removing deprecated APIs and their artifacts from a Python project:",
            "Step 1: Identify all deprecated symbols to be removed (modules, classes, functions, properties). Confirm that their deprecation period has elapsed and that migration paths are clearly documented.",
            "Step 2: Remove the deprecated symbols from their implementation locations. For classes/functions/properties, delete their definitions. For deprecated shim modules (like optuna.structs), remove the entire file if it is no longer needed.",
            "Step 3: Search the codebase for all references to the removed symbols (including imports, attribute access, and tests). Update these references to use the new APIs, or remove them if they only exist to test deprecation behavior.",
            "Step 4: Remove tests that only exist to verify deprecation warnings for the old APIs (e.g., pytest.warns(FutureWarning) around deprecated constructors or properties). After the API is removed, such tests are invalid and will fail.",
            "Step 5: Clean up package exports and lazy imports. Check __init__.py files and any lazy-import helpers or public API re-exports (e.g., optuna.structs = _LazyImport(\"optuna.structs\")). Remove entries that refer to removed modules or symbols.",
            "Step 6: Update documentation. Delete or modify Sphinx .rst files that document the removed module or classes, and update any index or toctree entries that include them. Ensure that cross-references (e.g., :mod:`old.module`) no longer point to removed locations.",
            "Step 7: Run static analysis tools (flake8, pylint) and fix any new warnings or errors: remove unused imports that became unnecessary after code/test changes, and resolve import errors due to removed modules.",
            "Step 8: Run type checkers (e.g., mypy) and fix references to removed attributes or types (like a deleted property). Update type hints or test code accordingly.",
            "Step 9: Run documentation builds or doc tests (e.g., Sphinx, doctest) to confirm that no references to the removed APIs remain and that the docs build successfully.",
            "Step 10: Run the full test suite (unit, integration, and system tests) to ensure that removing the deprecated APIs did not introduce regressions and that all remaining code paths use the new APIs correctly.",
            "Step 11: Optionally, update release notes or changelog to clearly communicate that the deprecated APIs have now been removed and that downstream users must rely on the newer replacements."
        ]
    }
}
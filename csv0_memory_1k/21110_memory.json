{
    "search_index": {
        "description_for_embedding": "Home Assistant integration adding Environment Canada support for weather, sensor, and camera (radar) platforms. Uses the env_canada library, introduces configuration validation (station ID regex, lat/long, forecast mode), throttle-based updates, icon-code mapping to standard weather conditions, and structured alert sensors. Migrates dependency handling to manifest.json, updates requirements_all.txt and CODEOWNERS, and resolves CI issues including coverage by excluding the new component in .coveragerc.",
        "keywords": [
            "homeassistant",
            "environment_canada",
            "env_canada",
            "ECData",
            "ECRadar",
            "weather platform",
            "sensor platform",
            "camera platform",
            "radar imagery",
            "manifest.json",
            "requirements_all.txt",
            "CODEOWNERS",
            ".coveragerc",
            "Throttle",
            "forecast array",
            "icon code mapping",
            "alert sensors",
            "configuration validation",
            "station id regex",
            "pylint",
            "codecov coverage drop",
            "static-check",
            "hassfest"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced a new Environment Canada integration into Home Assistant, providing weather, sensor, and radar camera platforms backed by the third-party env_canada library.\n\nThe work started as a simple weather platform under homeassistant/components/weather/environment_canada.py. It implemented an ECWeather entity using ECData from env_canada to provide current conditions (temperature, humidity, wind, pressure, visibility) and a forecast. It mapped Environment Canada icon codes to Home Assistant's standardized condition strings via ICON_CONDITION_MAP, and built forecast arrays for 'daily' and 'hourly' modes. For the daily forecast, Environment Canada's half-day forecasts (day/night) were combined into full-day entries, using the first half-day as a high and the next as a low where appropriate.\n\nThe platform schema allowed configuration via station ID (validated with a regex '^[A-Z]{2}/s0000\\d{3}$'), explicit latitude/longitude, or fallback to Home Assistant's configured coordinates. Updates were throttled to at most once every 10 minutes using homeassistant.util.Throttle, and all temperatures were natively Celsius with Home Assistant converting to imperial when configured.\n\nShortly after, the integration was migrated to the new folder structure under homeassistant/components/environment_canada/, with an empty __init__.py initially and the weather platform moved to environment_canada/weather.py. Two additional platforms were added: a radar camera and a sensor suite.\n\nThe camera platform (ECCamera) uses env_canada.ECRadar to fetch GIF radar imagery. It supports configuration of a specific station or coordinates, the precipitation type (RAIN or SNOW), and whether to serve an animated loop vs the latest frame (CONF_LOOP). The initial implementation updated the radar object directly in camera_image, but this was refactored: camera_image now delegates to an update method guarded by Throttle, and update decides whether to call get_loop() or get_latest_frame(). The platform was also updated to import ECRadar inside setup_platform (lazy import, per HA guidelines), to make CONF_LOOP optional (with default True), and to call add_devices(..., True) so entities perform an initial update before first use.\n\nThe sensor platform (ECSensor) exposes many Environment Canada fields as individual sensors: temperature, dew point, wind chill, humidex, pressure, tendency, humidity, visibility, condition, wind speed/gust/direction, daily high/low temperatures, chance of precipitation (pop), and several alert-related sensors. Configuration uses CONF_MONITORED_CONDITIONS to select from a SENSOR_TYPES dictionary, with optional station or coordinates; ECData is created similarly to the weather platform.\n\nInitially there was a single 'warning' sensor; later changes split alerts into multiple sensors: 'warnings', 'watches', 'advisories', 'statements', and 'endings'. As env_canada evolved to provide richer alert structures, the update method incorporated ec_data.alerts into ec_data.conditions and changed how alert sensor state and attributes are derived. For list-based sensors (alerts), the state is now a ' | '-joined list of alert titles, with additional attributes for detailed text and times:\n- ATTR_DETAIL: joined alert details\n- ATTR_TIME: joined alert dates\n\nThe ECSensor entity exposes ATTR_ATTRIBUTION, ATTR_UPDATED (timestamp parsed and converted to local time using dt.as_local), ATTR_LOCATION, ATTR_STATION, and ATTR_HIDDEN. Hidden is set based on whether the state is None or empty; this logic was simplified to `hidden = bool(self._state is None or self._state == '')`. Naming conventions were also corrected: originally sensors were prefixed with 'EC ', but feedback led to removing the prefix and standardizing on either just the sensor name (e.g., 'Temperature') or 'PlatformName Temperature' when a platform name is given.\n\nThroughout development the env_canada library was bumped several times (0.0.3 → 0.0.10) to pick up fixes and new capabilities, particularly around forecasts and alerts. Corresponding updates were made to requirements_all.txt to keep the global dependency list in sync.\n\nThere was a back-and-forth on how to build the daily forecast timestamps and how to detect which half-day is 'high'. One attempt used a temperature_class field and dt.now() for timestamps; this was later reverted to use env_canada's forecast_time (parsed into ref_time) and to detect highs via 'High' in the text_summary. Ultimately the final version used temperature_class and dt.now() in one branch, but then was reverted back in the migration patch to the ref_time-based approach.\n\nAs Home Assistant's integration model evolved, REQUIREMENTS constants in the platform modules were removed and replaced with a manifest.json for the environment_canada domain. The manifest lists the domain, name, documentation URL, requirements (env_canada version), dependencies (empty), and codeowners (@michaeldavie). This change was necessary for script/gen_requirements_all.py and hassfest to work correctly; before that, the author was confused why env_canada wasn't being added to requirements_all.txt until they learned requirements are now read from manifests.\n\nCI and tooling issues also arose and were resolved:\n- static-check complained about CODEOWNERS being out of date; because hassfest failed due to unrelated integrations missing manifest.json, the author manually added a CODEOWNERS entry for homeassistant/components/environment_canada/*.\n- codecov reported a significant coverage drop because the new integration had no tests. Rather than add tests in this PR, .coveragerc was updated to omit homeassistant/components/environment_canada/* from coverage, which brought coverage back up and satisfied maintainers.\n- Pylint errors were fixed by simplifying conditional logic (e.g., removing redundant else branches and rewriting hidden flag computation) and by removing unused imports and unnecessary initialization calls in __init__ and entity constructors.\n\nThe final state of the PR is a stable Environment Canada integration with:\n- weather platform (daily/hourly forecast, current conditions, icon mapping),\n- sensor platform (conditions + rich alert sensors with metadata),\n- radar camera platform (loop or single-frame GIF imagery),\n- proper manifest-based dependency declaration,\n- requirements_all.txt and CODEOWNERS entries, and\n- exclusion from coverage until tests are added. The integration was tested by multiple users in the community, and runs reliably up through Home Assistant 0.91–0.92.",
        "semantic_memory": "This case illustrates several general patterns and best practices when adding or evolving integrations in a large Python/async home automation codebase like Home Assistant:\n\n1. **Integration design patterns**\n- **Central data object, multiple platforms**: Use a central data abstraction from a third-party library (here, env_canada.ECData and ECRadar) and expose it through multiple platforms (weather, sensor, camera). This avoids duplicating HTTP/parse logic and enforces consistency across entities.\n- **Config flexibility with validation**: Allow configuration via different mechanisms (explicit station ID, coordinates, or Home Assistant defaults), and validate user input early with voluptuous schemas (e.g., regex for station ID). This prevents runtime errors and surfaces config issues clearly.\n- **Standards-aligned naming and units**: Follow platform and project conventions for names (no redundant prefixes like 'EC') and units (report native units and let the core handle conversions to user preferences). Use consistent mappings from provider-specific states (icon codes) to core enums or condition strings.\n\n2. **Throttling and update semantics**\n- **Throttle costly I/O in entities**: Use a throttling mechanism like homeassistant.util.Throttle for entities that fetch external data, especially when the same underlying data is shared across entities. This reduces load on both the integration and the remote service.\n- **Separate `update()` from accessors**: Accessor methods like camera_image() should call update() or rely on the scheduler, instead of directly performing remote calls. Centralize external I/O in update(), guarded by Throttle, so repeated accesses do not cause repeated network calls.\n- **Initial state population**: When adding devices, call add_devices(entities, True) to ensure update() runs once before Home Assistant first reads their state. Avoid calling update() inside __init__ to keep constructors side-effect free and easier to test.\n\n3. **Representing complex provider data in entities**\n- **Mapping half-day to full-day forecasts**: When a provider offers half-day (day/night) forecasts, you can assemble them into full-day forecasts by pairing entries and treating the first as high and the second as low. Use explicit metadata (like a temperature_class indicating 'high'/'low') when available, and fall back to textual analysis only if necessary.\n- **Alert handling**: Providers may expose alerts as structured lists with title, detail, and timestamps. A good pattern is:\n  - Use the main state to surface a concise summary (e.g., joined alert titles).\n  - Put detailed text and time metadata into attributes (e.g., `alert detail`, `alert time`).\n  - Keep the state machine-friendly and readable, and attributes rich and verbose.\n- **Hidden/disabled behavior via attributes**: If a sensor's state is None or empty, it can be marked as hidden or otherwise de-emphasized via attributes. Encapsulate this logic simply (e.g., a single boolean expression) rather than multiple branches.\n\n4. **Dependency and manifest management**\n- **Manifest-centric dependencies**: In modern Home Assistant, integration dependencies are declared in manifest.json, not per-module REQUIREMENTS constants. Tools like script/gen_requirements_all.py and hassfest rely on these manifests to generate requirements_all.txt and validate integrations.\n- **Syncing requirements_all.txt**: When bumping a library version in manifest.json, also update requirements_all.txt. Keep these in sync to avoid CI failures or mismatched runtime environments.\n\n5. **Project-level tooling and CI**\n- **CODEOWNERS and hassfest**: New components should have a CODEOWNERS entry. If automated scripts (hassfest) fail due to unrelated issues, it's acceptable to manually edit CODEOWNERS, but the long-term fix is to ensure all integrations have manifests.\n- **Coverage pragmatism**: When adding a new integration without tests, coverage tools may show drops. If tests are not feasible in the initial PR, it is acceptable (with maintainer approval) to temporarily add the new integration to .coveragerc omit list. This should be a stopgap; tests can be added later and the omit removed.\n- **Handling evolving core patterns**: Large projects can change architectural patterns (e.g., from REQUIREMENTS constants to manifest.json). When building or updating an integration, always check the current guidelines and existing up-to-date components for reference.\n\n6. **Incremental, library-driven evolution**\n- **Iteratively bumping upstream libraries**: As an upstream library (env_canada in this case) is improved, the integration can incrementally bump the dependency version to leverage new features like better forecasts or richer alert data. Ensure the integration code adapts to new data structures (e.g., alerts switching from simple strings to objects).\n- **Backward-compatible field handling**: When provider data models change (e.g., from 'High' in text_summary to a separate temperature_class field), write code that prefers explicit fields but can handle older or missing fields gracefully when possible.\n\nOverall, this PR embodies the pattern of building an integration around a well-defined third-party library; cleanly mapping its domain concepts to Home Assistant abstractions; and resolving supporting project plumbing (schemas, manifests, requirements, coverage, code ownership) to integrate smoothly into a large, CI-driven codebase.",
        "procedural_memory": [
            "Step-by-step instructions on how to design, implement, and land a new external-service integration (like a national weather service) into a large, CI-driven Python project such as Home Assistant.",
            "Step 1: Design the integration boundary\n- Identify or create a dedicated Python library that encapsulates all interaction with the external service (e.g., env_canada for Environment Canada).\n- Ensure the library provides clear objects and methods for all needed data (current conditions, forecasts, imagery, alerts).\n- Decide which platforms/entities you will expose (weather, sensor, camera, etc.) and what fields each should represent.",
            "Step 2: Create the integration skeleton\n- Add a new integration directory (e.g., homeassistant/components/my_service/).\n- Add an __init__.py file with a simple module docstring to satisfy tooling.\n- Create a manifest.json with:\n  - 'domain' and 'name'.\n  - 'documentation' URL.\n  - 'requirements' array listing the library and version (e.g., 'env_canada==0.0.10').\n  - 'dependencies' (often empty for simple integrations).\n  - 'codeowners' list with maintainer GitHub handles.\n- Do not define REQUIREMENTS constants in individual platform modules; rely on the manifest.",
            "Step 3: Implement configuration schemas and validation\n- For each platform module (weather.py, sensor.py, camera.py), import voluptuous and homeassistant.helpers.config_validation as cv.\n- Define PLATFORM_SCHEMA by extending the base platform schema, specifying valid options and defaults:\n  - Example: optional station ID, validated via a regex helper (validate_station) that raises vol.error.Invalid on invalid input.\n  - Inclusive lat/long pairs with vol.Inclusive(CONF_LATITUDE, 'latlon') and vol.Inclusive(CONF_LONGITUDE, 'latlon').\n  - Optional forecast mode with vol.Optional(CONF_FORECAST, default='daily') and vol.In([...]) to limit valid values.\n- Perform only syntactic validation in schemas; leave semantic checks to runtime where necessary.",
            "Step 4: Implement setup_platform and entity creation\n- In each platform's setup_platform(hass, config, add_devices, discovery_info=None):\n  - Import the third-party library inside the function (lazy import), per project guidelines.\n  - Instantiate the library's data object using one of:\n    - Explicit station ID from config.\n    - Configured coordinates.\n    - Home Assistant's global hass.config.latitude, hass.config.longitude.\n  - Construct entity instances (e.g., ECWeather, ECSensor, ECCamera) passing the shared data object and any relevant config.\n  - Call add_devices(entities, True) so that entities perform an initial update before being exposed.",
            "Step 5: Implement entity classes with throttled updates\n- For each entity class, store the library data object and any config (name, forecast type, etc.).\n- Use homeassistant.util.Throttle with a suitable MIN_TIME_BETWEEN_UPDATES (e.g., 10 minutes) to decorate update() methods.\n- In update():\n  - Call the library's update() or equivalent to refresh data (once per throttling interval).\n  - Populate entity state and attributes based on the library's data structures.\n- Avoid calling update() in __init__ to keep constructors side-effect free; rely on add_devices(..., True) instead.\n- For non-standard entities like cameras, keep I/O in update() and have camera_image() call update() and then return cached bytes.",
            "Step 6: Map provider-specific data to platform conventions\n- For weather conditions, define a mapping from provider icon codes (or similar) to core condition strings (e.g., 'sunny', 'rainy', 'fog', etc.). Implement a helper function (e.g., icon_code_to_condition) to look up the condition.\n- For forecasts:\n  - If the provider offers half-day forecasts, convert them to full-day forecasts by pairing high and low entries. Use explicit metadata like a 'temperature_class' field if available.\n  - Use provider timestamps (e.g., forecast_time) as reference points where possible; parse with datetime.strptime and convert to ISO strings.\n  - For hourly forecasts, convert provider periods to local time using homeassistant.util.dt.as_local.\n- Keep numeric fields numeric (floats or ints) so the core framework can handle units and conversions.",
            "Step 7: Represent complex lists (like alerts) cleanly\n- When the provider returns lists of structured alert objects, choose a representation pattern:\n  - Main state: a short, human-readable summary (e.g., ' | '-joined alert titles).\n  - Attributes: additional metadata such as detailed text and timestamps (e.g., two attributes 'alert detail' and 'alert time').\n- Ensure the code handles both list and scalar cases:\n  - If sensor_data is a list, compute state and attributes by iterating over the list.\n  - If it is not a list, treat it as a scalar state and leave alert-specific attributes empty or absent.",
            "Step 8: Implement attributes and hidden logic\n- Build a dict of state attributes for each sensor, including common fields:\n  - ATTR_ATTRIBUTION: string crediting the external service.\n  - ATTR_UPDATED: parsed and localized timestamp (if available).\n  - ATTR_LOCATION and ATTR_STATION: descriptive location fields.\n  - ATTR_HIDDEN: boolean indicating whether the sensor should be hidden when the state is empty.\n- Use a simple expression for hidden, such as `hidden = bool(self._state is None or self._state == '')`.\n- For camera entities, include ATTR_LOCATION and a station code, if applicable, along with ATTR_ATTRIBUTION.",
            "Step 9: Wire up project-level plumbing (requirements, coverage, owners)\n- Run script/gen_requirements_all.py to generate/update requirements_all.txt. If the integration's manifest lists a requirement, it should appear under a comment like '# homeassistant.components.environment_canada' with the correct version.\n- Add a CODEOWNERS entry for the new integration directory (e.g., 'homeassistant/components/environment_canada/* @yourhandle').\n- If the integration initially has no tests and coverage drops:\n  - Discuss with maintainers whether it's acceptable to temporarily exclude the integration from coverage.\n  - If agreed, add the component path to the 'omit' section of .coveragerc (e.g., 'homeassistant/components/environment_canada/*').",
            "Step 10: Resolve CI issues and iterate\n- If static-check or hassfest fails due to missing manifests in other integrations, you can:\n  - Fix those integrations (ideal but broader in scope) or\n  - Manually fix the minimal necessary files (like CODEOWNERS) to get your PR passing.\n- Address pylint errors by simplifying conditionals, removing unused variables or imports, and adhering to style rules.\n- Rebase on the latest dev/main branch to resolve conflicts (e.g., in requirements_all.txt) and to pick up core changes.\n- Rerun tests and tools (tox, pylint, static-check, script/gen_requirements_all.py) until CI passes.",
            "Step 11: Communicate limitations and unit handling\n- Document any known limitations (e.g., service provides only metric units). If the core framework converts temperatures but not other units (wind speed, pressure), clarify that behavior in documentation.\n- Ensure the code returns native units (e.g., Celsius, km/h, kPa) so the framework can do conversions where supported.\n\nBy following these steps, a developer can design, implement, and successfully integrate a new external-service-backed component into a complex home automation framework, handling not only the domain logic but also configuration validation, performance, project tooling, and CI constraints."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Large refactor and feature PR for a PokemonGo bot: introduces a plugin system with GitHub/zip loading, a centralized inventory abstraction, a configurable Pokemon optimizer/evolver, throw-parameter customization for catches, colorized logging, GA heartbeat hardening, encrypt library detection, and many small bug fixes (session re-login, map catching, lured pokemon, spin/fort loops, task enabling, etc.).",
        "keywords": [
            "PokemonGo-Bot",
            "PluginLoader",
            "GithubPlugin",
            "TreeConfigBuilder",
            "BaseTask.TASK_API_VERSION",
            "SUPPORTED_TASK_API_VERSION",
            "Inventory abstraction",
            "Candies",
            "Items",
            "Pokemons",
            "PokemonOptimizer",
            "EvolvePokemon",
            "PokemonCatchWorker",
            "catch_throw_parameters",
            "MoveToMapPokemon",
            "SpinFort loop fix",
            "HandleSoftBan MoveToFort None config",
            "UTF-8 lure fix",
            "catchable-username.json fix",
            "encrypt.so detection",
            "libencrypt_location",
            "colorized logging",
            "ColoredLoggingHandler",
            "Google Analytics heartbeat",
            "no_pokeballs event",
            "WorkerResult",
            "UpdateLiveStats",
            "SleepSchedule",
            "RecycleItems min_empty_space",
            "ItemRecycler",
            "docker build encrypt.so"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR (Pr/5) significantly evolves a PokemonGo bot codebase. The author introduced a plugin system, a centralized inventory abstraction, a Pokemon optimization task, and multiple stability and UX improvements.\n\nFor plugins, a PluginLoader class was added. It can add directories or zip files to sys.path and dynamically import classes by dotted namespace. A GithubPlugin helper parses 'user/repo#sha' strings, downloads and caches zip archives, extracts them to a `plugins` folder, and remembers repo SHAs via `.sha` files. `TreeConfigBuilder` was taught to interpret task type strings with dots as plugin classes instead of internal workers. `pokecli.py` now reads a `plugins` list from config and calls `PluginLoader.load_plugin` for each path or GitHub spec. Tests verify loading from plain directories, zip files, and GitHub download/extraction, and teardown via `remove_path`.\n\nTo keep plugins and tasks compatible, `BaseTask` got a `TASK_API_VERSION` constant and each task class now declares a `SUPPORTED_TASK_API_VERSION`. `TreeConfigBuilder.build` compares the two and raises a `MismatchTaskApiVersion` with a detailed message when a task requires a different API version, including guidance on whether to update the bot or the task. Tests explicitly cover both 'task version too high' and 'task version too low' cases.\n\nA large refactor introduced `inventory.py` with `Inventory`, `Pokemons`, `Candies`, and `Items` components. It centralizes inventory parsing from GET_INVENTORY responses, classifies eggs vs pokemons, computes IVs, and exposes higher-level operations like `candies().get(pokemon_id)`, `pokemons().all()`, and `items().get(item_id)`. EvolvePokemon was rewritten to iterate over `inventory.pokemons()`, apply the CP/IV filters, check `can_evolve_now()` using candies, and consume candies via `inventory.candies().get(...).consume(...)`. `PokemonCatchWorker` now uses a local `Pokemon` model with iv/iv_display, and updates candy counts through this new inventory API rather than recalculating. `RecycleItems` and `TransferPokemon` also migrated to use Inventory: both now work atop `inventory.items()`/`inventory.pokemons()` instead of raw dicts and manual get_inventory calls.\n\nA new `PokemonOptimizer` task was added. It uses Inventory and a configurable 'keep' strategy to decide which pokemon to keep, evolve, and transfer. It supports ranking criteria like iv, cp, normalized CP (ncp), max_cp, and IV sub-stats. It handles multi-branch evolutions (like Eevee) by computing groups separately and only evolving enough per branch. It supports enabling/disabling transfer/evolve actions (`transfer`, `evolve` flags) and can automatically trigger a Lucky Egg when enough evolutions are queued (`use_lucky_egg`, `minimum_evolve_for_lucky_egg`). It emits consistent events like `pokemon_release` and `pokemon_evolved` and updates candies.\n\nCatching was heavily reworked. `PokemonCatchWorker` now returns `WorkerResult` and emits richer events (e.g. 'pokemon_escaped' instead of 'pokemon_fled', 'no_pokeballs', 'pokemon_not_in_range', 'pokemon_inventory_full'). Catch logic selects balls and berries based on catch rates and configuration, and uses new `catch_throw_parameters` in config to randomize throw quality (excellent/great/nice/normal) and spin odds. This replaced the older `catch_randomize_reticle_factor` and `catch_randomize_spin_factor` utilities in `human_behaviour.py`. The worker now calculates the correct `normalized_reticle_size`, `spin_modifier`, and `normalized_hit_position` per throw type before calling `catch_pokemon`. A bug where `catch_visible_pokemon` wrote to 'user_web_catchable' instead of a per-user file was fixed: it now writes correctly to `web/catchable-<username>.json`.\n\nFor mapping and sniping, `MoveToMapPokemon` was rewritten to be event-driven: it now emits events for map updates, teleporting to/from a target, movement, and failure conditions. `update_map_location` now pings `/loc` on the external PokemonGo-Map server using a configurable `map_path` (e.g. 'raw_data'), updating location only when both time and distance thresholds are exceeded. Sniping logic (`snipe` flag) teleports, triggers an encounter, teleports back, and then uses the catch worker. Several bugs were fixed: incorrect placeholder `{last_long}` in a format string, failure to teleport back properly when sniping, and ensuring the bot's last_position is preserved and restored.\n\nStability improvements abound. `BotEvent` health-record analytics gained a heartbeat timer and a persistent `client_id` so clients are not double-counted by Google Analytics; network failures are now caught (`requests.exceptions.HTTPError`) and ignored instead of crashing the bot. `pokecli.py` initializes `bot = False` at function start so the exception handler can safely call `report_summary(bot)`. `PokemonGoBot.check_session` got a fix: after re-login, it now re-activates the encrypt signature library via `api.activate_signature(self.get_encryption_lib())` to avoid 'Possibly searching too often' errors. `raise e` was replaced with bare `raise` to preserve stack traces.\n\nEncrypt library loading was generalized: `PokemonGoBot.get_encryption_lib()` now detects the platform (Linux, Darwin, Windows/32/64), chooses the correct file ('encrypt.so', 'encrypt.dll', 'encrypt_64.dll'), and allows overriding path via `libencrypt_location` (config). It logs detailed info if the file is missing and exits gracefully. The Dockerfile was updated to download and compile `pgoencrypt` into `/usr/src/app/encrypt.so`, clean up temp files, set `LD_LIBRARY_PATH`, and pre-install requirements, improving docker build caching. The compose file was updated to mount configs, web, and data volumes.\n\nLogging was reworked with a new `ColoredLoggingHandler` using Python's logging infra. Instead of manually writing to stdout with ANSI escapes, the handler maps event names to colors (red, yellow, green, cyan, blue, white) and levels, and formats messages accordingly, fixing issues around 'struct() argument 1 must be string, not unicode' and non-TTY output. `logging_color` in config toggles between the old `LoggingHandler` and `ColoredLoggingHandler`.\n\nThe `UpdateTitleStats` task was renamed to `UpdateLiveStats`, gained a `captures_per_hour` metric along with login, username, xp, stardust, etc., and was made more flexible: `terminal_log` and `terminal_title` flags control whether stats are logged, shown in the terminal title, or both. It now uses `bot.metrics.captures_per_hour()` and flushes stdout after writing titles. Unit tests cover multiple platforms and configuration combinations.\n\nMany small bug fixes and enhancements were included: lured pokemon name encoding was corrected to proper Unicode instead of `.encode('utf8')`; `CatchVisiblePokemon` now correctly writes per-user 'catchable' files; `SpinFort` and `MoveToFort` now respect `ignore_item_count` config, avoid infinite loops by filtering forts with cooldowns into `bot.fort_timeouts`, and return `WorkerResult.RUNNING` when multiple forts are in range; `HandleSoftBan` now passes an empty config dict to `MoveToFort` instead of `None`; `RecycleItems` gained a `min_empty_space` threshold and now avoids recycling until needed, using a new `ItemRecycler` service and inventory-based item counts; `UpdateLiveStats` and `SleepSchedule` were added to config examples but disabled by default; and the Docker and setup scripts were cleaned up (automatic encrypt build, better Python/protobuf dependencies, run.sh loop messaging, Windows batch loop run.bat).",
        "semantic_memory": "Several generalizable patterns emerge from this PR:\n\n1. **Plugin architecture with versioning**: The project uses a `PluginLoader` and a `GithubPlugin` helper to load external modules either from local paths or GitHub-specified zips (`user/repo#sha`). This is combined with an explicit `BaseTask.TASK_API_VERSION` and per-class `SUPPORTED_TASK_API_VERSION`, checked centrally in `TreeConfigBuilder`. This is a clean pattern for introducing plugins while guarding against API breakage; the strategy is to treat dotted strings as third-party task classes and enforce cross-version compatibility via clear error messages.\n\n2. **Centralized inventory abstraction**: Instead of letting each worker parse raw GET_INVENTORY responses, a dedicated `Inventory` module (`Inventory`, `Pokemons`, `Candies`, `Items`) was introduced. This encapsulates low-level details (individual stats, candies, item counts, etc.) and exposes a small API (`candies().get`, `pokemons().all`, `items().get`, `get_space_left`) that all tasks can rely on. This both reduces duplication and prevents divergences between tasks in how they interpret inventory state.\n\n3. **Separation of concerns for item recycling**: Recycling logic was decomposed into (a) when to recycle (`RecycleItems.should_run`), (b) what to recycle (`get_amount_to_keep`, `item_should_be_recycled`), and (c) how to recycle (`ItemRecycler` service). This cleanly isolates stateful API interactions from configuration decisions and allows recycling to be reused or tested in isolation.\n\n4. **Event-driven architecture and logging**: The project consistently emits events (`event_manager.emit`) rather than logging directly. `ColoredLoggingHandler` then colors messages based on event names. By decoupling event emission from presentation, they were able to switch from ad-hoc stdout writes to structured logging without touching all call sites. This pattern also plays nicely with web UI and WebSocket handlers listening to events.\n\n5. **Safer external integrations**: The GA heartbeat code now wraps `requests.post` in a try/except, logs its own client ID, and uses `response.raise_for_status()`. Similarly, network calls to external PokemonGo-Map servers are wrapped in connection error handling and emit specific error events instead of throwing. This shows a good pattern: when integrating with external services, always anticipate connection issues and make analytics optional.\n\n6. **Config-driven behavior for tasks**: The code consistently uses config flags to enable/disable tasks and adjust thresholds (`enabled` flag on tasks, `ignore_item_count`, `min_empty_space`, throw probabilities, plugin paths, etc.). This pattern makes tasks composable and reduces the need to edit code for behavior changes.\n\n7. **Throw modeling instead of arbitrary randomness**: Instead of a vague 'randomize_reticle_factor/spin_factor', the new design models throw outcomes explicitly: excellent/great/nice/normal, each with configurable odds, and spin success rate. This is a more realistic and testable interface that mimics human play rather than relying on arbitrary random floats.\n\n8. **WorkerResult and run loop correctness**: Tasks return `WorkerResult.SUCCESS`, `RUNNING`, or `ERROR`, and the main loop uses these to decide whether to continue, retry, or skip. This is crucial for tasks like SpinFort and MoveToMapPokemon, which may need to be reentered when there is still outstanding work, and helps avoid infinite loops and silent failures.\n\n9. **Robust OS & environment detection**: The encrypt library loader uses Python's `sys.platform` and a 32/64-bit check to choose correct library names and logs clear error messages if missing, instead of hardcoding a single path. The Dockerfile was adjusted to compile and stage `encrypt.so`, with cleanup and environment variables to ensure compatibility. This pattern is reusable for any native binding integration.\n\n10. **Tests for non-obvious logic**: Complex logic flows (plugin installation, GitHub zip formats, API version mismatch, stats title building, Windows title updates, item recycling thresholds) are covered in dedicated tests. This improves confidence when refactoring and provides documentation for the intended behavior of these subsystems.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Introduce a plugin system safely\n- Define a base API version constant in your core task interface (e.g. `BaseTask.TASK_API_VERSION`).\n- For each task class (including plugins), define a `SUPPORTED_TASK_API_VERSION` that states the version range they support.\n- In your central builder/factory (e.g. `TreeConfigBuilder`), detect dotted task type strings as external plugin classes and use `importlib.import_module`/`getattr` to load them.\n- After loading a task class, compare `BaseTask.TASK_API_VERSION` with `task.SUPPORTED_TASK_API_VERSION` and raise a dedicated error when they differ.\n- Implement a simple plugin locator: handle paths, zips, and GitHub specs (user/repo#sha); place installed plugins in a dedicated folder and track SHAs to avoid repeated downloads.\n- Write tests covering valid/invalid plugin specs and API version mismatch messages.",
            "Step 2: Centralize inventory logic\n- Create an `Inventory` object that owns subsets for pokemon, candy, and items, each with a well-defined parse method.\n- Have a single `refresh()` method that performs one GET_INVENTORY API call and then populates each subset from the result.\n- Replace ad-hoc parsing code in tasks (EvolvePokemon, TransferPokemon, RecycleItems, etc.) with calls into this Inventory API.\n- Implement convenience methods such as `candies().get(pokemon_id)`, `pokemons().all()`, `items().get(item_id)`, `items().get_space_left()` to hide low-level dict structure.\n- Ensure that state updates (e.g. after a catch, transfer, or evolution) either refresh the inventory or adjust the in-memory models (e.g. increment/decrement candy counts) to stay consistent.",
            "Step 3: Design item recycling in three layers\n- Decide when to recycle: define a `should_run()` method that checks item inventory free space vs a configurable `min_empty_space` threshold. If enough space, skip the task.\n- Decide what to recycle: implement configuration that expresses per-item 'keep' counts by name or id, and compute `amount_to_recycle = current_count - keep` for each item.\n- Decide how to recycle: factor out API call details into a service class (e.g. `ItemRecycler`) that sends `recycle_inventory_item`, checks the result, adjusts Inventory and emits events.\n- In the main task, loop over `inventory.items().all()`, compute amount to recycle, and for each positive amount call the recycler and aggregate its result.\n- Write tests that simulate inventory fullness and verify that items are only recycled when necessary and that events/logs show the correct counts.",
            "Step 4: Implement configurable throw behavior\n- Replace coarse randomness (e.g. generic 'randomize X factor') with explicit behavioral parameters: `excellent_rate`, `great_rate`, `nice_rate`, `normal_rate`, `spin_success_rate`.\n- Add these parameters to your config under a dedicated key (`catch_throw_parameters`) with sensible defaults.\n- In your catch worker, create a helper that draws from these weighted probabilities to decide the throw type and then sets `normalized_reticle_size`, `normalized_hit_position`, and `throw_type_label` accordingly.\n- Create another helper that uses `spin_success_rate` to decide whether to apply spin (`spin_modifier >= 0.5`) or not.\n- Use these parameters to call the catch API, ensuring that the combination of reticle size and hit position matches the chosen throw type.\n- Optionally log or emit the chosen throw type to help in debugging and tuning.",
            "Step 5: Harden external network calls and analytics\n- For each network call to external services (e.g. Google Analytics, PokemonGo-Map), wrap `requests.post` or `requests.get` in try/except blocks.\n- If you use HTTP libraries such as `requests`, always call `response.raise_for_status()` to centralize HTTP error handling.\n- In the exception handler, log the error at warning/error level or emit a specific event, but do not crash the bot; it's better to skip analytics or map updates than to halt the main loop.\n- If you need client uniqueness (e.g. GA), generate and store a uuid once per `BotEvent` instance and reuse it across requests instead of using a new random id for every event.\n- Provide a config toggle (e.g. `health_record`) to disable analytics entirely.",
            "Step 6: Use WorkerResult and events for better control flow\n- Define a small enum or class (e.g. `WorkerResult`) with values such as `SUCCESS`, `RUNNING`, and `ERROR`.\n- Make each task's `work()` method return one of these values based on whether it finished, has more work to do, or encountered an unrecoverable problem.\n- In the main loop, use these return values to decide whether to repeat the same task, move on to the next one, or log an error.\n- For anything that should be visible to the user or the web UI, emit structured events (e.g. pokemon_evolved, pokemon_release, move_to_map_pokemon_fail) instead of writing to stdout. This allows different handlers (logs, web UI, sockets) to consume the same events.\n- Avoid infinite loops by checking for both \"no more work\" conditions and configured thresholds, and by cleaning up any per-task caches between runs."
        ]
    }
}
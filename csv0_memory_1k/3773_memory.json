{
    "search_index": {
        "description_for_embedding": "GUI example tests in napari were starting a real Qt QApplication event loop via napari.run(), causing hangs and instability (especially on CI/Windows). The fix removed using a qapp fixture and instead monkeypatched napari.run to a no-op and Window.show to do nothing, so examples can be imported and executed without starting the event loop while still validating API correctness.",
        "keywords": [
            "napari",
            "pytest",
            "Qt",
            "QApplication",
            "event loop",
            "GUI testing",
            "examples testing",
            "napari.run",
            "Window.show",
            "monkeypatch",
            "CI flakiness",
            "Windows CI",
            "test hangs"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the tests for the napari example scripts were relying on a real Qt QApplication and event loop, created via a qapp pytest fixture using napari._qt.qt_event_loop.get_app(). Some examples explicitly call napari.run(), which starts the Qt event loop and normally waits for the user to close the application. In tests, this was mitigated by a QTimer.singleShot(100, app.quit) to stop the loop, but this approach remained fragile and made tests heavier and more error-prone, particularly on CI and Windows. The new approach eliminates the need to start a QApplication at all when testing examples. The qapp fixture and its use of QTimer were removed. Instead, the test imports Window once at module level and monkeypatches Window.show to a no-op to prevent actual windows from appearing, and monkeypatches napari.run to a no-op so that any example code calling napari.run() will not start the event loop. The test still sets a custom sys.excepthook to re-raise exceptions so failures are visible, and it now calls napari.Viewer.close_all() at the end of the test for cleanup. Additionally, special handling for the 'to_screenshot.py' example on Windows CI was consolidated into a single conditional that removes that example from the test list when running under CI on Windows. This change makes example tests faster and more stable by validating that the examples' API calls succeed without requiring a running Qt event loop.",
        "semantic_memory": "When testing GUI applications or example scripts that normally start an event loop (e.g., Qt, GTK, etc.), spinning up a full application and running the event loop in automated tests can lead to fragile, slow, or hanging tests, especially in CI and on platforms with stricter GUI constraints (like Windows). A more robust pattern is to treat these tests as API smoke tests: import and execute the example code, but stub out or monkeypatch side-effectful operations such as starting the event loop and showing windows. Specifically, functions like napari.run(), app.exec_(), or widget.show() can be replaced with no-op callables so that the core logic is exercised without opening real windows or blocking on the event loop. Cleanup should still occur (e.g., closing viewers or windows) to avoid leaked global state between tests. It is also useful to override any global exception hooks that could hide errors, ensuring that exceptions propagate so tests fail clearly. Platform-specific quirks (e.g., examples that require extra tools or OS capabilities) should be handled by conditionally skipping or removing those examples from the test set in CI. Overall, GUI tests benefit from separating event-loop/UI concerns from core logic, using monkeypatching and proper cleanup to keep tests deterministic and CI-friendly.",
        "procedural_memory": [
            "To diagnose and fix hanging or fragile GUI example tests that start a real event loop:",
            "Step 1: Identify the source of blocking behavior. Search your tests and examples for calls that start the GUI event loop (e.g., napari.run(), app.exec_(), QApplication.exec_(), mainloop()) and for fixtures that create and run the GUI application.",
            "Step 2: Reproduce the issue locally and on CI. Confirm whether tests hang, spawn actual windows, or behave differently on certain platforms (e.g. Windows vs. Linux). Check CI logs for stalled tests or timeouts.",
            "Step 3: Decide what you actually need to test. For example scripts, you generally want to ensure that imports and API calls execute without errors, not that the UI event loop runs correctly.",
            "Step 4: Remove or minimize real event loop usage in tests. Eliminate fixtures that start a full application unless absolutely necessary. Instead, rely on module-level imports for types you need (e.g., main window classes) without launching the app.",
            "Step 5: Monkeypatch event-loop and UI entry points. In the test, use pytest's monkeypatch to replace any event-loop starter functions with no-ops, for example: monkeypatch.setattr(app_module, 'run', lambda *a, **k: None). Similarly, patch window-showing methods (e.g., Window.show) to no-op to prevent UI from appearing.",
            "Step 6: Ensure exceptions are not swallowed. If your application overrides sys.excepthook or similar global handlers, monkeypatch them in tests so that exceptions are re-raised and cause test failures instead of being logged silently.",
            "Step 7: Add proper cleanup. At the end of tests, explicitly close or tear down any global viewers, windows, or other singleton-like UI objects (e.g., napari.Viewer.close_all()) to avoid cross-test interference.",
            "Step 8: Handle platform-specific examples. If some examples rely on external dependencies or OS capabilities that are not reliable in CI (e.g., screenshot utilities on Windows CI), use conditional logic to remove or skip those examples when running in CI on those platforms.",
            "Step 9: Re-run tests on all supported platforms and CI. Confirm that tests no longer hang, coverage remains acceptable, and example scripts are still exercised as intended.",
            "Step 10: Document the testing strategy. Note in your test code or contributing docs that examples are executed without starting the GUI event loop, and that event-loop-related functions are intentionally monkeypatched to maintain stability."
        ]
    }
}
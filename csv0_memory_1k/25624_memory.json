{
    "search_index": {
        "description_for_embedding": "Home Assistant cert_expiry integration refactored to support config entries and UI-based configuration. Added a config flow with validation to prevent duplicate host/port pairs and to verify that an SSL certificate can be fetched. Extracted socket/SSL certificate fetching into a shared helper. Updated sensor setup to import from YAML into config entries and added tests and coverage config.",
        "keywords": [
            "cert_expiry",
            "Home Assistant",
            "config entries",
            "config_flow",
            "async_setup_entry",
            "async_setup_platform",
            "SOURCE_IMPORT",
            "SSL certificate",
            "socket timeout",
            "host resolution",
            "duplicate configuration",
            "helper module",
            "TIMEOUT",
            "coverage",
            ".coveragerc"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant `cert_expiry` integration was upgraded from a legacy YAML-only sensor configuration to a full config entry–based integration with UI-driven setup.\n\nPreviously, `cert_expiry` exposed only a traditional platform-based `sensor` with synchronous setup logic. The PR introduced several major changes:\n\n1. **Config Flow and Config Entries**\n   - Added `config_flow.py` implementing `CertexpiryConfigFlow(config_entries.ConfigFlow, domain=DOMAIN)`.\n   - The flow collects `name`, `host`, and `port` from the user (`async_step_user`) and supports `async_step_import` for migration from YAML.\n   - It enforces uniqueness of `(host, port)` pairs via `certexpiry_entries(hass)` and `_prt_in_configuration_exists(user_input)`. If a host/port combo already exists, UI errors/aborts with `host_port_exists`.\n   - Before creating an entry, `_test_connection` uses a shared helper (`get_cert`) to attempt an SSL connection and certificate retrieval. Depending on the failure mode, it sets specific error keys on `CONF_HOST`:\n     - `resolve_failed` on `socket.gaierror` (host cannot be resolved)\n     - `connection_timeout` on `socket.timeout` (connect timeout)\n     - `certificate_fetch_failed` on generic `OSError` (e.g., SSL handshake or certificate issues)\n   - On success, it slugifies the provided or default name (`DEFAULT_NAME` = \"SSL Certificate Expiry\") to generate the entry title and stores only `CONF_HOST` and `CONF_PORT` in the entry data.\n   - `async_step_import` reuses the same validation and defaults; it passes YAML-derived `user_input` through `_prt_in_configuration_exists` and `_test_connection` via `async_step_user`.\n\n2. **Component Initialization and Entry Setup**\n   - Updated `__init__.py` to support config entries:\n     - `async_setup` now simply returns `True` (basic component setup).\n     - `async_setup_entry` registers a `EVENT_HOMEASSISTANT_START` callback, which forwards the entry to the `sensor` platform via `hass.config_entries.async_forward_entry_setup(entry, \"sensor\")` when Home Assistant has fully started. This ensures the sensor is set up after HA is ready.\n\n3. **Sensor Platform Changes and YAML-to-Config-Entry Migration**\n   - The sensor now supports async entry setup:\n     - Introduced `async_setup_platform` instead of sync `setup_platform`. It no longer creates the entity directly. Instead, it kicks off a config flow import:\n       ```python\n       hass.async_create_task(\n           hass.config_entries.flow.async_init(\n               DOMAIN,\n               context={\"source\": SOURCE_IMPORT},\n               data=dict(config),\n           )\n       )\n       ```\n       and returns. This enables migration from legacy YAML configuration to config entries.\n     - Added `async_setup_entry` that creates `SSLCertificate` entities from the config entry (`entry.title`, `entry.data[CONF_HOST]`, `entry.data[CONF_PORT]`) and returns `True`.\n   - The previous synchronous, event-based creation of entities at `EVENT_HOMEASSISTANT_START` inside `setup_platform` was removed.\n\n4. **Shared Helper for SSL Certificate Retrieval**\n   - Introduced `helper.py` with `get_cert(host, port)`:\n     - Uses `ssl.create_default_context()` and `socket.create_connection` with a `TIMEOUT` (now defined in `const.py` as `TIMEOUT = 10.0`).\n     - Wraps the socket with SSL (`ctx.wrap_socket(..., server_hostname=address[0])`), calls `getpeercert()` and returns the certificate.\n     - Does not swallow exceptions; they propagate so callers can distinguish error types.\n   - `sensor.SSLCertificate.update` now calls `get_cert(self.server_name, self.server_port)` instead of duplicating socket/SSL logic. It catches `socket.gaierror`, `socket.timeout`, and `OSError` to set `_available` and log appropriate messages while leaving certificate parsing logic intact.\n   - `config_flow._test_connection` also calls `get_cert` to reuse the same connection logic, translating exceptions into flow errors.\n\n5. **Constants, Manifest, and Translations**\n   - Added `const.py` with shared constants: `DOMAIN = \"cert_expiry\"`, `DEFAULT_NAME`, `DEFAULT_PORT = 443`, and `TIMEOUT = 10.0`.\n   - Updated `manifest.json` to include `\"config_flow\": true` and set codeowner `\"@cereal2nd\"`.\n   - Added UI strings (`strings.json` and `.translations/en.json`) for the config flow title, form labels, and error messages including the new error reasons.\n\n6. **Generated Config Flows and CODEOWNERS**\n   - Updated `homeassistant/generated/config_flows.py` to register `\"cert_expiry\"` as a config flow–capable domain.\n   - Added `homeassistant/components/cert_expiry/* @cereal2nd` to the root `CODEOWNERS` file.\n\n7. **Tests and Coverage**\n   - Created `tests/components/cert_expiry/test_config_flow.py` to validate the new behavior:\n     - `test_user` confirms the user form is shown initially and that a valid host/port creates an entry with the expected slugified title.\n     - `test_import` exercises various YAML import scenarios: host-only, host+name, host+port, and host+port+name, verifying default name/port behavior and resulting entry titles.\n     - `test_abort_if_already_setup` uses `MockConfigEntry` to pre-add a `cert_expiry` entry and validates:\n       - Import aborts with `host_port_exists` when the same host/port is provided.\n       - Manual user step returns a form with error `{CONF_HOST: 'host_port_exists'}` for the same host/port.\n       - A new port with the same host is allowed and creates an entry.\n     - `test_abort_on_socket_failed` patches `socket.create_connection` to raise `socket.gaierror`, `socket.timeout`, and `OSError`, ensuring `_test_connection` surfaces the correct config flow error keys.\n     - A pytest fixture `test_connect` patches `_test_connection` to always succeed in the positive-path tests.\n   - Updated `.coveragerc` to exclude `homeassistant/components/cert_expiry/sensor.py` and `helper.py` from coverage, as they talk to external resources and are harder to test deterministically.\n\nOverall, the incident was that `cert_expiry` lacked config entries and robust validation. The fix was to restructure the integration around HA's config flow API, add a shared SSL helper, ensure YAML setups are migrated via import, and add tests and error translations for host/port validation and connection failures.",
        "semantic_memory": "This change illustrates several generalizable patterns for evolving an integration to use config entries and robust network validation:\n\n1. **Migrating from YAML-based to Config Entry–based Configuration**\n   - When an integration is historically configured via YAML, you can gradually migrate it to config entries by:\n     - Implementing a `ConfigFlow` for the domain that supports both UI (`async_step_user`) and import-based (`async_step_import`) configuration.\n     - In the legacy `async_setup_platform` (or `setup_platform`), instead of creating entities directly, trigger `config_entries.flow.async_init` with `SOURCE_IMPORT` and the original config. This lets the new config flow create a persistent config entry for the YAML data while maintaining backward compatibility.\n     - Use defaults (e.g., `DEFAULT_PORT`, `DEFAULT_NAME`) consistently in both user and import flows, and derive the entry title from a slugified name.\n\n2. **Forwarding Entries to Platforms After Startup**\n   - For integrations where entities belong to a platform (e.g., `sensor`), use `async_setup_entry` in the component's `__init__.py` to forward the entry to the platform with `hass.config_entries.async_forward_entry_setup(entry, 'sensor')`.\n   - If entities depend on HA being fully bootstrapped, register a callback on `EVENT_HOMEASSISTANT_START` and call the forwarder from there.\n\n3. **Shared Network Logic in a Helper Module**\n   - Network or protocol-specific logic (like opening sockets, handling TLS, and retrieving certificates) should be placed in a shared helper module rather than duplicated in both the config flow and entities. This minimizes duplication and ensures consistent behavior and error handling.\n   - Helpers should expose a clean, narrow function (e.g., `get_cert(host, port)`) and avoid swallowing exceptions so callers can map low-level errors to high-level semantics (UI errors, logs, availability flags).\n\n4. **Robust Validation in Config Flows**\n   - Config flows can perform actual network validation before creating entries, which helps catch incorrect configuration early:\n     - Check for duplicate configurations by comparing the incoming configuration against existing entries, e.g., keeping a set of `(host, port)` pairs.\n     - Attempt to connect to the remote service; for certificate checks, establish a TLS connection and call `getpeercert()`.\n     - Map different failure modes to different error codes (`resolve_failed`, `connection_timeout`, `certificate_fetch_failed`), and localize them in translation files. This gives users clear guidance on what went wrong.\n\n5. **Testing Config Flows and Network Error Paths**\n   - Config flows are best tested with unit tests that:\n     - Instantiate the flow, call `async_step_user` and `async_step_import`, and assert on `type`, `step_id`, `title`, and `data` fields.\n     - Use `MockConfigEntry` to simulate existing configuration and verify that duplicates are rejected appropriately.\n     - Use `unittest.mock.patch` or pytest fixtures to mock network-dependent helpers or `socket.create_connection`, ensuring that both success and failure paths can be tested deterministically.\n   - By mocking the helper (`_test_connection` or `get_cert`), tests remain fast, offline, and reproducible.\n\n6. **Centralizing Defaults and Timeouts**\n   - Constants like default ports, integration names, and timeouts should live in a shared `const.py`. This ensures consistency across the integration (config flow, helper, entities) and makes it easy to adjust behavior later.\n\n7. **Config Flow UX and Translations**\n   - All user-facing error reasons returned by config flows should be declared in `strings.json` and translated in `.translations/*`. This includes both logical errors (e.g., duplicate host/port) and network errors. Ensuring parity between config flow error keys and translation keys is key to a polished user experience.\n\nThese practices are broadly applicable when modernizing existing integrations, adding validation, and reducing duplicated networking logic in any asynchronous home automation or microservice-style system.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify integration limitations.\n- Look for integrations that only support legacy YAML configuration or synchronous platform setup functions (`setup_platform`) and lack config entry support (`config_flow`, `async_setup_entry`).\n- Check if there is duplicated low-level network logic in multiple places (e.g., both the sensor and the configuration code) and whether error handling is coarse (e.g., generic failures with no specific feedback to users).",
            "Step 2: Introduce config entry support and config flow.\n- Create a `const.py` for the integration with a `DOMAIN`, default values (e.g., `DEFAULT_PORT`, `DEFAULT_NAME`, `TIMEOUT`), so these can be reused everywhere.\n- Implement `ConfigFlow` for the integration domain:\n  - Subclass `config_entries.ConfigFlow` with `domain=DOMAIN`.\n  - Implement `async_step_user` to present a form for required data (host, port, name) using `vol.Schema`.\n  - Implement `async_step_import` to handle YAML-derived `user_input`; call `async_step_user(user_input)` after filling in any missing defaults.\n  - Add logic to avoid duplicates by checking existing entries for the same `(host, port)` pair and returning an appropriate error reason key when a duplicate is detected.",
            "Step 3: Add shared networking helper(s).\n- Extract common networking or protocol logic into a helper module (e.g., `helper.py`). For SSL certificate checks:\n  - Implement a function like `get_cert(host, port)` that uses `ssl.create_default_context()` and `socket.create_connection` with a shared timeout, then performs SSL handshake and certificate retrieval.\n  - Ensure the helper does not swallow exceptions; let `socket.gaierror`, `socket.timeout`, `OSError`, and others propagate to callers.\n- Replace duplicated networking code in the sensor/entity classes and config flow with calls to this helper.",
            "Step 4: Enhance validation in the config flow.\n- In `async_step_user`, before creating an entry, call a small wrapper (e.g., `_test_connection`) that invokes the helper and catches specific exceptions:\n  - On `socket.gaierror`, set an error key like `resolve_failed` on `CONF_HOST`.\n  - On `socket.timeout`, set `connection_timeout`.\n  - On `OSError`, set `certificate_fetch_failed` or a similar key.\n- If validation passes, slugify the name (or use a default) and call `async_create_entry` with the host and port.\n- If validation fails, re-display the form with `errors=self._errors` so the user sees the error message.",
            "Step 5: Migrate YAML setup to config entries.\n- Replace the body of legacy `setup_platform`/`async_setup_platform` with a call to `hass.config_entries.flow.async_init` using `SOURCE_IMPORT` and the YAML `config`:\n  - `hass.async_create_task(hass.config_entries.flow.async_init(DOMAIN, context={\"source\": SOURCE_IMPORT}, data=dict(config)))`.\n- Ensure `PLATFORM_SCHEMA` still validates the YAML fields so invalid YAML configurations are caught early.\n- From this point on, actual entity creation should occur inside `async_setup_entry` for the platform.",
            "Step 6: Adjust component-level setup.\n- In `__init__.py`, implement:\n  - `async_setup(hass, config)` to perform any basic initialization and return `True`.\n  - `async_setup_entry(hass, entry)` to forward the entry to platform(s) via `hass.config_entries.async_forward_entry_setup(entry, 'sensor')`.\n- If necessary, wrap the forward call in an `EVENT_HOMEASSISTANT_START` listener so setup is deferred until HA is fully started.",
            "Step 7: Update manifest, config flow registry, and translations.\n- In `manifest.json`, set `\"config_flow\": true` and ensure `domain`, `name`, `documentation`, and `codeowners` are correctly set.\n- Update any generated config flow registration (e.g., `homeassistant/generated/config_flows.py`) to include the domain.\n- Add or update `strings.json` and `.translations/*` to include:\n  - The config flow title and step titles.\n  - Field labels for data schema (`name`, `host`, `port`).\n  - Error and abort messages for all error keys returned by the config flow (`host_port_exists`, `resolve_failed`, `connection_timeout`, `certificate_fetch_failed`).",
            "Step 8: Write comprehensive tests.\n- Add tests to validate both config flow and error handling:\n  - Create a helper function to instantiate the config flow and assign `hass`.\n  - Test that `async_step_user()` initially returns a form, and that providing valid input results in a `RESULT_TYPE_CREATE_ENTRY` with the correct `title` and `data`.\n  - Test `async_step_import()` for various combinations of input (host-only, host+name, host+port, host+port+name) and verify default behavior.\n  - Use `MockConfigEntry` to simulate existing configuration and test that duplicate `(host, port)` combinations are rejected with the expected error codes.\n  - Patch network dependencies (e.g., `socket.create_connection` or the helper function) to simulate DNS failures, timeouts, and generic OS errors, ensuring the config flow surfaces the correct error labels.\n- Use fixtures to patch `_test_connection` globally in tests that focus on non-error paths, so tests remain fast and deterministic.",
            "Step 9: Configure coverage for hard-to-test modules.\n- If certain modules (e.g., direct network helpers, low-level device adapters) are inherently hard to test or rely on external resources, add them to `.coveragerc` under `omit` to avoid coverage noise.\n- Prefer to keep as much logic as possible testable; reserve coverage exclusions for code that cannot reasonably be tested via unit or integration tests.",
            "Step 10: Verify and iterate.\n- Run all tests (`tox` or equivalent) and ensure the new integration passes.\n- Manually test the integration:\n  - Configure a new entry via the UI with a valid host/port and confirm that the entity is created and updates correctly.\n  - Attempt to configure invalid hosts or ports and verify that UI errors match expectations.\n  - Migrate an existing YAML configuration and confirm it results in a config entry and entities with the correct titles and data.\n- Address any feedback by refining error messaging, default handling, and test coverage."
        ]
    }
}
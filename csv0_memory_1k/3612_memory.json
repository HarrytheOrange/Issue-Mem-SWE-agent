{
    "search_index": {
        "description_for_embedding": "Fix for a crash when adding plugin dock widgets in napari: calling inspect.signature on Widget.__init__ raised ValueError for certain builtin/compiled __init__ methods in the bundled app, causing viewer startup to fail. The fix wraps inspect.signature in try/except ValueError and skips signature-based injection of the napari_viewer argument when no signature is available.",
        "keywords": [
            "napari",
            "dock widget",
            "plugin widget",
            "qt_main_window",
            "inspect.signature",
            "builtin __init__",
            "ValueError: no signature found",
            "signature inspection failure",
            "napari_viewer injection",
            "bundled application crash"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, certain plugin widgets (e.g. from cellpose-napari) caused the napari bundled viewer to crash when adding them as dock widgets. The stack trace showed `ValueError: no signature found for builtin <method-wrapper '__init__' of function object ...>` originating from `inspect.signature(Widget.__init__)` in `napari/_qt/qt_main_window.py`. This code path inspects the widget class's `__init__` parameters so it can automatically pass the `napari_viewer` instance if the constructor expects it, either by parameter name `napari_viewer` or by type annotation `napari.viewer.Viewer` / `Viewer`. In the bundled app, some widget classes had a builtin or otherwise non-inspectable `__init__` method, so `inspect.signature` raised `ValueError`, crashing the viewer instead of simply instantiating the widget without extra kwargs.\n\nThe fix modifies `add_plugin_dock_widget` in `qt_main_window.py` so that the call to `inspect.signature(Widget.__init__)` is wrapped in a `try/except ValueError`. If `inspect.signature` raises, the code now just `pass` and leaves `kwargs` empty, meaning the widget is created without attempting signature-based parameter injection. If the signature is successfully retrieved, the logic remains the same: iterate over parameters and, upon finding one named `napari_viewer` or annotated with the viewer type, supply `self.qt_viewer.viewer` as an argument. This prevents the crash for widgets with non-inspectable `__init__` while preserving automatic viewer injection when possible.",
        "semantic_memory": "When using introspection utilities like `inspect.signature` in plugin systems or dynamic widget factories, you cannot assume that every callable will have an inspectable Python-level signature. Builtin or extension functions, method wrappers, or objects altered by packaging/freeze tools (e.g. PyInstaller, bundled apps) may cause `inspect.signature` to raise `ValueError` with messages like 'no signature found'. If this exception is not handled, the entire application or plugin loading flow can crash merely because one component lacks an introspectable signature.\n\nThe generalizable pattern is:\n- Use introspection to adapt behavior (e.g. automatically injecting context objects like a viewer, app, or config) based on a callable's parameters.\n- Treat introspection as a best-effort optimization, not a hard requirement. If signature inspection fails, fall back to a safe default (e.g. instantiate the widget without extra kwargs, or skip optional behavior) instead of propagating the error.\n- Wrap `inspect.signature` (and similar reflection calls) in `try/except` for `ValueError` and sometimes `TypeError`, logging or ignoring the failure as appropriate.\n- In plugin architectures, this is especially important because you do not control the implementation details of third-party plugin classes. A single non-conforming plugin should not be able to crash the host application just because introspection failed.\n\nMore broadly, APIs that dynamically decide what to pass into constructors/functions (based on param names or annotations) must be defensive: they should only rely on information that is reliably available, and they should gracefully degrade when the information is missing.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the crash and capture the stack trace.\n- Run the application or test that triggers dynamic widget/plugin creation.\n- Note the exact exception type and message. In this case: `ValueError: no signature found for builtin <method-wrapper '__init__' ...>`.\n- Identify where in the code `inspect.signature` or other introspection utilities are being called.",
            "Step 2: Identify the callable causing the introspection failure.\n- From the stack trace, locate the specific line calling `inspect.signature`, e.g. `inspect.signature(Widget.__init__)`.\n- Log or inspect `Widget.__init__` (or the callable being analyzed) to determine its type. For example, check `inspect.isbuiltin`, `inspect.ismethod`, and `type(Widget.__init__)`.\n- Confirm that it is a builtin, C-extension, or otherwise non-standard function where Python can't provide a signature.",
            "Step 3: Decide on safe fallback behavior when introspection fails.\n- Ask: what was introspection used for? In this case, to detect whether to inject `napari_viewer` into the widget constructor.\n- Determine a behavior that is safe if you *cannot* know the signature. Here, simply don't inject any extra kwargs and let the widget be instantiated normally.\n- Ensure that this fallback is non-breaking for callables that don't need the extra context.",
            "Step 4: Guard the introspection calls with try/except.\n- Wrap `inspect.signature` in a try/except block catching `ValueError` (and optionally `TypeError`). For example:\n  ```python\n  kwargs = {}\n  try:\n      sig = inspect.signature(Widget.__init__)\n  except (ValueError, TypeError):\n      # Cannot inspect signature; fall back to default behavior\n      pass\n  else:\n      for param in sig.parameters.values():\n          if param.name == 'napari_viewer':\n              kwargs['napari_viewer'] = viewer\n              break\n          if param.annotation in ('napari.viewer.Viewer', Viewer):\n              kwargs[param.name] = viewer\n              break\n  widget = Widget(**kwargs)\n  ```\n- Keep the original introspection logic inside the `else` so it only runs when a signature is actually available.",
            "Step 5: Verify behavior across environments (dev vs bundled).\n- Test in the normal development environment to ensure that widgets expecting the context (e.g. `napari_viewer`) still receive it correctly.\n- Test in the bundled or frozen environment (where the issue was observed) to confirm that widgets with non-inspectable `__init__` no longer cause a crash and are instantiated successfully.\n- If possible, add automated tests that simulate or mock a callable whose `inspect.signature` raises `ValueError`, ensuring future changes don't reintroduce the crash.",
            "Step 6: Document the limitation and pattern for plugin authors.\n- Clarify that the framework will attempt to inject context objects only when it can successfully inspect the constructor signature.\n- Note that if a plugin uses a builtin or C-level `__init__` without a Python signature, automatic parameter injection may not occur, but the plugin will still load.\n- Encourage plugin authors to define Python-level `__init__` signatures if they rely on automatic injection of context parameters."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant Homematic integration where device UNREACH/availability state was not correctly updated and system variables stopped updating. The patch subscribes to the correct Homematic channel for UNREACH events, uses proper string comparison, reworks hub/variable handling to periodically poll system variables via the hub entity, and changes the variable set service to operate on Homematic central hubs instead of individual variable entities.",
        "keywords": [
            "homeassistant",
            "homematic",
            "UNREACH",
            "device availability",
            "system variables",
            "HMHub",
            "track_time_interval",
            "event subscription",
            "channel 0",
            "entity state not updating",
            "service schema",
            "pyhomematic==0.1.21",
            "STATE_UNKNOWN",
            "schedule_update_ha_state"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Homematic integration exhibited two related problems:\n\n1) UNREACH / availability bug\nHomematic devices occasionally became unreachable, but Home Assistant did not correctly reflect this in the entity availability or state. The component's event callback checked `if attribute is 'UNREACH'`, which is wrong for string comparison in Python and could fail in some cases. Additionally, the integration was not subscribing to Homematic channel 0, which is where the UNREACH datapoint is reported.\n\nThis resulted in Homematic devices not updating their availability when they became unreachable or came back, causing state/restore inconsistencies and misleading UI status.\n\nThe fix:\n- Subscribe explicitly to channel 0 in `_subscribe_homematic_events` using `channels_to_sub = {0: True}` so UNREACH events are delivered.\n- Correct the comparison in `_hm_event_callback` to `if attribute == 'UNREACH':` and set `self._available = bool(value)`, marking `have_change = True` to ensure a state update is pushed to Home Assistant.\n\n2) System variable handling / update bug\nSystem variables exposed by the Homematic central (CCU/HomeGear) stopped updating in Home Assistant. The previous design created one entity per variable (`HMVariable`), and the hub maintained a `_store` of variables that was supposed to be updated from the CCU. This mechanism was brittle and was no longer updating values as expected.\n\nAdditionally, the service for setting variable values (`homematic.set_variable`) used `entity_id` to identify variable entities directly, but the new design operates at the hub level instead.\n\nThe fix:\n- Remove the `HMVariable` entity class and the per-variable entity model; instead, embed all system variables into the `HMHub` entity's `state_attributes`.\n- Introduce two scan intervals: `SCAN_INTERVAL_HUB` (300s) for hub service messages and `SCAN_INTERVAL_VARIABLES` (30s) for system variables.\n- Use `track_time_interval` to periodically call `_update_hub` and `_update_variables`. Both now accept a `now` argument and call `schedule_update_ha_state()` when data changes.\n- On initialization of `HMHub`, immediately call `_update_hub(None)` and `_update_variables(None)` so state is populated before the first timer tick.\n- Store variables in a local dict `self._variables`. In `_update_variables`, compare the new values from `getAllSystemVariables` with the cache and only call `schedule_update_ha_state()` when something changes.\n- Implement `hm_set_variable(self, name, value)` on `HMHub`. It validates that the variable exists, derives the correct type from the old value (boolean → `cv.boolean`, otherwise `float`), calls `setSystemVariable(self.name, name, value)` on the Homematic connection, updates the local cache, and schedules a state update.\n- Adjust the `homematic.set_variable` service schema: `name` of the variable is now required, `entity_id` is optional and refers to one or more Homematic hub entities (e.g., `homematic.ccu2`), not individual variable entities.\n- Update the service handler to resolve hub entities from `entity_hubs`; if no `entity_id` is specified, all hubs are used. For each hub, call `hub.hm_set_variable(name, value)`. Log an error if no matching hub or variable is found.\n\nFinally, the integration’s dependency on `pyhomematic` was updated from 0.1.20 to 0.1.21, ensuring compatibility with the improved UNREACH and variable handling in the underlying library.\n\nAfter these changes, UNREACH states are properly reflected in Home Assistant, and Homematic system variables reliably update and can be set through the service API.",
        "semantic_memory": "This fix highlights several generalizable patterns when dealing with home automation integrations and state synchronization:\n\n1) Event subscription and availability state\n- Device availability often comes from special datapoints (like Homematic's UNREACH on channel 0) that must be explicitly subscribed to. If those events are not subscribed or handled, the integration may silently fail to update availability.\n- Using identity comparison (`is`) on strings is incorrect in Python and can lead to nondeterministic behavior; use `==` for value comparison.\n- Availability changes should be treated as state changes and immediately propagate via `schedule_update_ha_state()` (or the equivalent mechanism) to avoid stale or misleading UI state.\n\n2) Centralizing related attributes vs. many small entities\n- For dynamic auxiliary data (like controller-wide system variables), it can be more robust to represent them as attributes of a single hub entity rather than many separate entities. This simplifies update logic, avoids complex cross-entity stores, and reduces the risk of partial desynchronization.\n- When representing a large set of attributes in a single entity, maintain an internal cache and only trigger state updates when actual changes occur to avoid unnecessary churn.\n\n3) Polling and scheduling vs. throttling\n- `Throttle` is suited to guarding on-demand updates (`update()` calls), but for integrations where data should be updated periodically regardless of external requests, scheduled callbacks (`track_time_interval`) are clearer and more reliable.\n- Passing the `now` argument required by scheduler callbacks and explicitly initializing state by calling update methods once at startup ensures that the entity has valid state before the first scheduled interval.\n\n4) Service design and schema alignment\n- Service schemas should reflect the domain model. If variables are no longer individual entities, the service should target the hub or controller level and accept a variable name rather than an entity ID of a variable entity.\n- Provide clear error messages when target hubs or variables cannot be found to aid debugging.\n- When setting remote values, type conversion should be based on the existing state (e.g., boolean vs. numeric) to avoid mismatched types and potential integration bugs.\n\n5) Dependency alignment\n- When a bug fix depends on behavior in an external library, update the declared dependency version (e.g., `pyhomematic==0.1.21`) to ensure consumers get the matching behavior.\n\nOverall, robust device integrations require careful event subscription, explicit availability handling, a consistent state model (which entities exist and what they represent), and a polling/scheduling strategy that matches how the backend exposes changes.",
        "procedural_memory": [
            "When diagnosing and fixing bugs around device availability (e.g., UNREACH) and central variables in a home automation integration, follow these steps:",
            "Step 1: Reproduce and characterize the symptom",
            "• Observe which aspects are failing: device availability not updating, system variables not changing, or services that set variable values not working.\n• Check logs for missing callbacks, lack of state changes, or invalid entity IDs.\n• Confirm if the problem is with event reception (callbacks), polling, or how state is exposed to the platform.",
            "Step 2: Verify event subscription for special datapoints (e.g., UNREACH)",
            "• Consult the device/protocol documentation (e.g., Homematic) to learn on which channels and attributes availability/UNREACH are reported.\n• Inspect the subscription logic (e.g., `_subscribe_homematic_events`) and ensure that all necessary channels are included (for Homematic, add channel 0 for UNREACH events: `channels_to_sub = {0: True}`).\n• Ensure that callbacks are set with the correct arguments and the handler (`_hm_event_callback`) is being invoked.",
            "Step 3: Fix attribute handling in event callbacks",
            "• In the event callback, confirm that attribute names are compared using value equality, not identity (`if attribute == 'UNREACH'`, not `if attribute is 'UNREACH'`).\n• When an availability datapoint changes, update an internal availability flag (e.g., `self._available = bool(value)`) and mark that a change occurred (e.g., `have_change = True`).\n• At the end of the callback, if `have_change` is true, trigger a state update in the host system (`self.schedule_update_ha_state()`).",
            "Step 4: Decide on the representation of variables (entity-per-variable vs. hub attributes)",
            "• Evaluate whether variables should be individual entities or attributes of the hub/controller entity.\n• If the per-variable entity model is brittle or overcomplicated, consider embedding variables as a dictionary in the hub entity's state attributes.\n• Implement a `state_attributes` property on the hub that returns a copy of the internal variables dict.",
            "Step 5: Implement robust periodic updates with a scheduler",
            "• Replace or complement throttled `update()` methods with scheduled callbacks using the platform's scheduler (e.g., `track_time_interval`).\n• Define appropriate scan intervals (e.g., a slower interval for hub service messages, a faster interval for variables).\n• Implement `_update_hub(now)` and `_update_variables(now)` methods that:\n  - Read current state from the backend (e.g., `getServiceMessages`, `getAllSystemVariables`).\n  - Compare new data with cached data.\n  - Only call `schedule_update_ha_state()` if a change is detected.\n• On initialization of the entity, call these update methods once with `None` to seed the initial state before the first timer tick.",
            "Step 6: Implement variable-setting logic at the appropriate level",
            "• Implement a method on the hub entity to set variables (e.g., `hm_set_variable(self, name, value)`) that:\n  - Checks that the variable name exists in the current variables dict; if not, log an informative error and return.\n  - Determines the proper type for the new value based on the existing value (e.g., boolean vs. numeric) and performs conversion (`cv.boolean`, `float`, etc.).\n  - Calls the backend API to set the variable (e.g., `setSystemVariable(self.name, name, value)`).\n  - Updates the local cache and calls `schedule_update_ha_state()` to propagate the new value.",
            "Step 7: Align the service schema and handler with the new model",
            "• Update the service schema to reflect how variables are now addressed:\n  - Require a `name` field for the variable name.\n  - Keep `entity_id` optional and interpret it as one or more hub entities (e.g., `homematic.ccu2`), not variable entities.\n• In the service handler:\n  - Extract `entity_ids` with `service.data.get('entity_id')`.\n  - If provided, filter the list of hub entities to those IDs; if not provided, apply to all hubs.\n  - If no matching hubs are found, log an error and abort.\n  - For each hub, call `hub.hm_set_variable(name, value)`.\n• Update any service documentation (e.g., `services.yaml`) to clarify what `entity_id` refers to and provide accurate examples.",
            "Step 8: Ensure dependency version compatibility",
            "• If the fix relies on changes in the underlying library (e.g., additional events, improved UNREACH handling), bump the dependency version in both the component definition and the global requirements file.\n• For example, change `pyhomematic==0.1.20` to `pyhomematic==0.1.21`.\n• Verify that the integration still initializes correctly and that the updated library behaves as expected.",
            "Step 9: Test end-to-end",
            "• Restart the home automation platform and verify that:\n  - Devices correctly transition between available/unavailable when UNREACH changes, and that this is reflected in the UI.\n  - System variables on the Homematic central update over time when changed on the controller.\n  - The `set_variable` service can set values by specifying the hub entity and variable name, with proper type handling.\n• Monitor logs to confirm that no error messages are produced for variable lookup or event subscriptions during normal operation."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Qt-based napari viewer was not remembering the last working directory for open/save dialogs across actions and sessions. The fix introduced persistent open/save directory history stored in application settings, along with helper functions to update and retrieve that history, and updated all file dialogs to use QFileDialog instances with setHistory and a history-based default directory.",
        "keywords": [
            "napari",
            "QFileDialog",
            "last working directory",
            "open history",
            "save history",
            "recent folders",
            "Qt dialogs",
            "persistent settings",
            "ApplicationSettings",
            "SETTINGS",
            "utils.history"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the goal was to make napari remember the last directories used for opening and saving files, and to surface that history in subsequent QFileDialog dialogs.\n\nPreviously:\n- The viewer had a _last_visited_dir attribute initialized to the user's home directory and used it for some dialogs, but this was local state and not persisted across sessions.\n- Different dialogs (open, save, screenshot, performance trace) were using QFileDialog static helpers like getOpenFileNames/getSaveFileName directly, which do not easily support setHistory, and there was no centralized history for directories.\n- There was no separation between \"open\" history and \"save\" history, nor a list of recent directories.\n\nWhat was implemented:\n1. Settings schema changes:\n   - In napari/utils/settings/_defaults.py, the ApplicationSettings model was extended to include two new list fields:\n     - open_history: List\n     - save_history: List\n   - Both are initialized to a list containing the directory of the user's home (using os.path.dirname(Path.home())).\n   - NapariConfig.fields was updated to persist these new settings fields (\"open_history\" and \"save_history\").\n   - The older last_visited_dir setting/usage was removed in favor of separate histories.\n\n2. New history helper module:\n   - A new module napari/utils/history.py was introduced with four key functions:\n     - update_open_history(filename):\n       * Takes a file path, derives its directory with os.path.dirname, and updates SETTINGS.application.open_history.\n       * If the directory already exists in the list, it is moved to the front; otherwise it is inserted at the front.\n       * The list is truncated to the 10 most recent entries.\n     - update_save_history(filename):\n       * Same logic as update_open_history, but for SETTINGS.application.save_history.\n     - get_open_history():\n       * Returns the list of open_history directories filtered to only those that currently exist on disk (os.path.isdir).\n     - get_save_history():\n       * Same as get_open_history, but using save_history.\n   - Docstrings were added explaining that these functions manage recent directories for open/save operations.\n\n3. Wiring history into Qt dialogs:\n   - All places that previously used the viewer's _last_visited_dir or static QFileDialog calls were updated to use open/save history from SETTINGS via the new helper functions.\n\n   In napari/_qt/qt_viewer.py:\n   - The viewer attribute _last_visited_dir and direct use of SETTINGS.application.last_visited_dir were removed.\n   - _save_layers_dialog:\n     * Instead of QFileDialog.getSaveFileName, a QFileDialog instance is created: dlg = QFileDialog().\n     * The save history is fetched with hist = get_save_history().\n     * dlg.setHistory(hist) is called, and getSaveFileName is invoked with directory=hist[0] as the initial directory.\n     * After performing the save via viewer.layers.save, if there are no warnings and something was saved, update_save_history(saved[0]) is called to record the directory of the saved file.\n   - _screenshot_dialog:\n     * Uses ScreenshotDialog, now supplied with both the current directory and history: hist = get_save_history(); ScreenshotDialog(self.screenshot, self, hist[0], hist).\n     * After a successful dialog execution, update_save_history(dial.selectedFiles()[0]) records the directory where the screenshot was saved.\n   - _open_files_dialog:\n     * Uses a QFileDialog instance rather than the static method.\n     * Retrieves hist = get_open_history(), calls dlg.setHistory(hist), and then dlg.getOpenFileNames with directory=hist[0].\n     * On success, viewer.open(filenames) is called and update_open_history(filenames[0]) records the directory.\n   - _open_files_dialog_as_stack_dialog:\n     * Same pattern as _open_files_dialog, but opens the files as a stack (stack=True) and updates open history via update_open_history.\n   - _open_folder_dialog:\n     * Uses a QFileDialog instance with hist = get_open_history(), dlg.setHistory(hist), and dlg.getExistingDirectory(directory=hist[0]).\n     * If a folder is chosen, viewer.open([folder]) is called and update_open_history(folder) records that directory in the open history.\n\n   In napari/_qt/dialogs/screenshot_dialog.py:\n   - ScreenshotDialog.__init__ was extended with a history parameter.\n   - The dialog now calls self.setDirectory(directory) and self.setHistory(history) so that the screenshot save dialog shows recent directories.\n\n   In napari/_qt/perf/qt_debug_menu.py:\n   - The performance trace save dialog was updated to use the new history helpers:\n     * Instead of using SETTINGS.application.last_visited_dir, the code creates a QFileDialog instance, calls hist = get_save_history(), dlg.setHistory(hist), and then dlg.getSaveFileName with directory=hist[0].\n     * After the user selects a file, update_save_history(filename) is called so that the chosen directory becomes the most recent save location.\n\n   In napari/_qt/qt_main_window.py:\n   - _screenshot_dialog (main window version) was also updated:\n     * Uses hist = get_save_history().\n     * Constructs ScreenshotDialog(self.screenshot, self.qt_viewer, hist[0], hist).\n     * After a successful dialog, update_save_history(dial.selectedFiles()[0]) persists the directory.\n   - An unused os import introduced during rebase was removed.\n\nOutcome:\n- Napari now maintains persistent, separate histories for open and save directories across sessions.\n- All relevant file dialogs (open files, open as stack, open folder, save layers, save screenshot, and save performance traces) use these histories for both the initial directory and the OS-level recent-places history via QFileDialog.setHistory.\n- The user experience is improved: the next open/save dialog starts in the most recently used directory for that operation and shows a list of recent directories. The latest visited directories are stored in SETTINGS.application.open_history and SETTINGS.application.save_history, capped at 10 entries.",
        "semantic_memory": "This change illustrates a general pattern for implementing persistent and user-friendly file dialog behavior in GUI applications.\n\nKey concepts and best practices:\n1. Separate concerns: open vs save history\n   - Maintain separate histories for directories used for opening files and directories used for saving files. These often correspond to different workflows (e.g., one folder for source data, another for results/exports).\n   - Persist these histories as part of the application's user settings so that they last across sessions.\n\n2. Use centralized helpers for history management\n   - Encapsulate the logic for updating and reading histories in a dedicated module or helper functions, rather than scattering directory manipulation and settings updates across the codebase.\n   - This makes it easier to change the storage mechanism later (e.g., moving away from a global SETTINGS object) and keeps the API for history management small and well-defined.\n\n3. Limit and sanitize history lists\n   - Limit the number of history entries (e.g., 10) to avoid unbounded growth of settings and overly long history lists in dialogs.\n   - Filter history to include only directories that currently exist on disk; this avoids presenting stale or broken paths to users.\n   - When adding a directory that already exists in history, move it to the front rather than creating duplicates. This preserves recency ordering.\n\n4. Prefer dialog instances over static helper methods when you need advanced features\n   - Qt's static QFileDialog methods (getOpenFileNames, getSaveFileName, getExistingDirectory) are convenient but do not expose configuration methods like setHistory.\n   - When you need to set history, modify options, or otherwise customize the dialog beyond the static interface, create a QFileDialog instance, configure it (setHistory, setDirectory, filters, etc.), and then call the appropriate exec-like method or instance methods.\n\n5. Keep UI and persistence concerns decoupled\n   - The UI layer (Qt dialogs) uses simple, high-level helpers like get_open_history and update_save_history without knowing how the history is stored.\n   - The persistence layer (settings) is the only place that knows about the underlying storage mechanics (global SETTINGS object, Pydantic models, etc.), making it easier to refactor settings storage later.\n\n6. Consistent default directory semantics\n   - Using the first element of the history as the default directory for new dialogs creates consistent behavior: the most recently used directory is what the user sees first.\n   - This can be extended to support different policies (e.g., per-action defaults: open, save, export, import) by maintaining multiple histories.\n\nThis pattern generalizes to any GUI application that uses file dialogs and wants to provide good usability with persistent, configurable recent directories or files, while keeping the implementation maintainable and testable.",
        "procedural_memory": [
            "How to add persistent open/save directory history to Qt file dialogs in a GUI application:",
            "Step 1: Extend your settings model to store history",
            " - Add fields to your application's settings (or config) model to store recent directories for different operations, e.g. `open_history` and `save_history` as lists of strings.",
            " - Initialize them with a sensible default, such as the user's home directory.",
            " - Ensure these fields are included in whatever persistence mechanism you use (e.g., add them to a list of recorded settings fields).",
            "Step 2: Create helper functions for history management",
            " - Implement a small module (e.g., `utils.history`) that abstracts reading and writing these history lists.",
            " - Provide functions like `get_open_history()` and `get_save_history()` that:\n   * Read the corresponding list from settings.\n   * Filter out entries that are no longer valid directories (using `os.path.isdir`).\n   * Return the cleaned list; if empty, optionally fall back to a default directory.",
            " - Provide update functions like `update_open_history(filename)` and `update_save_history(filename)` that:\n   * Take a file path (or directory), derive the directory with `os.path.dirname(filename)` if needed.\n   * Insert the directory at the front of the history list.\n   * If the directory already exists in the list, move it to the front instead of duplicating it.\n   * Truncate the list to a fixed max length (e.g., 10 entries).\n   * Write the updated list back to the settings object.",
            "Step 3: Switch from static QFileDialog methods to instance-based dialogs",
            " - In places where you currently use static methods like `QFileDialog.getOpenFileNames`, `getSaveFileName`, or `getExistingDirectory`, switch to creating a `QFileDialog` instance when you need advanced features like history.",
            " - Typical pattern:\n   * `dlg = QFileDialog(parent)` or `dlg = QFileDialog()`\n   * `hist = get_open_history()` or `get_save_history()`\n   * `dlg.setHistory(hist)`\n   * Use the first history entry as the default directory: e.g., `directory=hist[0]` in `getOpenFileNames` or `getSaveFileName`.\n   * Call the corresponding instance method to show the dialog (depending on the toolkit version, either `dlg.exec_()` or a convenience method like `dlg.getOpenFileNames`).",
            "Step 4: Update history after successful dialog use",
            " - Once the user has selected a file or directory and the operation has succeeded (e.g., the file was actually opened or saved without fatal errors), call the appropriate update function to record the directory:\n   * For open dialogs: `update_open_history(selected_filenames[0])` or `update_open_history(selected_folder)`.\n   * For save dialogs: `update_save_history(selected_filename)`.\n   - Make sure to call the history update only when the user did not cancel the dialog and the operation completed, to avoid adding unusable or unintended paths.",
            "Step 5: Apply consistently across all dialogs",
            " - Identify all file dialogs in your application that should benefit from persistent directory history (e.g., open file, open folder, open-as-stack, save, export, screenshot, debug trace output).\n   - For each of these dialogs, decide whether they should use open history or save history (or potentially another dedicated history type).\n   - Refactor the code for each dialog to follow the instance-based pattern and hook into the history helpers.",
            "Step 6: Ensure tests and future refactors are straightforward",
            " - Because history logic is centralized in one module, you can unit test the helper functions (update/get) independently of the UI.\n   - If you later move away from a global settings singleton, you only need to adjust the history moduleâ€™s access pattern, not every caller.\n   - Consider adding tests that verify:\n   * Directories are added, reordered, and truncated correctly.\n   * Non-existent directories are filtered out by the get_*_history functions.\n   * Dialogs actually use the history (e.g., default directory equals the most recent history entry)."
        ]
    }
}
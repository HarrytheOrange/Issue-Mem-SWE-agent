{
    "search_index": {
        "description_for_embedding": "Home Assistant build/install was breaking because the latest 'requests' releases dropped support for older pip versions used during installation. The fix was to hard-pin 'requests' to version 2.13 in package constraints, requirements, and setup.py to avoid installing incompatible newer versions.",
        "keywords": [
            "requests",
            "pip compatibility",
            "dependency pinning",
            "installation failure",
            "Home Assistant",
            "package_constraints.txt",
            "setup.py",
            "requirements_all.txt",
            "environment markers",
            "old pip crash"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, installing Home Assistant in environments with older pip versions caused crashes when the 'requests' library was upgraded to newer releases (>=2.14). The newer 'requests' versions relied on pip features only available in more recent pip releases, so during 'pip install', the old pip process would encounter metadata it couldn't handle and fail. Although Home Assistant itself depends on a newer pip in its dependency chain, 'requests' is installed as part of the same 'pip install' invocation, meaning the initial installation still runs under the old pip and crashes before pip can be upgraded. The fix was to stop using a broad version range ('requests>=2,<3') and instead hard-pin 'requests' to a specific known-good version, 2.13, which remains compatible with older pip versions. This pin was added consistently in three places: 'homeassistant/package_constraints.txt', 'requirements_all.txt', and 'setup.py'. A comment in setup.py documents the reason for the pin and links to the upstream 'requests' GitHub issue (kennethreitz/requests#4006). After this change, installations no longer try to fetch incompatible 'requests' versions, preventing the crash on older pip while remaining compatible with the minimum supported Python version.",
        "semantic_memory": "This fix highlights a common dependency management issue: when a popular library increases its minimum tooling or runtime requirements (e.g., requiring a newer pip, setuptools, or Python version), projects that install that library in environments with older tooling can experience installation failures before their own dependencies (including updated tooling) are applied. A robust approach is to constrain or pin the problematic dependency to a version range known to be compatible with the lowest supported environment (e.g., oldest pip or Python version) of the project. Consistency is important: all requirement sources (setup.py, constraints files, and aggregated requirements files) must be kept in sync to avoid conflicting constraints. Additionally, documenting the reason for pins with links to upstream issues helps future maintainers know when and why the pin was introduced and when it may be safe to relax. More generally, when external libraries change behavior or metadata in ways that older tooling can't parse (environment markers, wheels metadata, etc.), pinning or conditional dependencies are often required until the ecosystem catches up.",
        "procedural_memory": [
            "When encountering installation failures related to a dependency that recently released new versions, first reproduce the issue in a clean environment using the same tool versions (pip, Python) as affected users.",
            "Step 1: Inspect the error logs from 'pip install' to determine which package is causing the failure and whether the error stems from an incompatibility with the pip version (e.g., environment markers or metadata parsing errors).",
            "Step 2: Check the recent release history and changelog of the suspect package (e.g., 'requests') to see if they have raised their minimum supported pip/Python/setuptools version or changed metadata format.",
            "Step 3: Identify the last known-good version of the dependency that works with your minimum supported environment (e.g., the pip version that ships with your minimum Python version). Verify this by installing that specific version in a test environment with the old tooling.",
            "Step 4: Pin the dependency to the known-good version or a compatible bounded range in all relevant places: primary requirements files (requirements.txt, requirements_all.txt), constraints files (package_constraints.txt), and setup.py/install_requires. Ensure there are no conflicting constraints elsewhere.",
            "Step 5: Add comments next to the pin explaining why it is constrained and, if applicable, linking to the upstream issue or documentation that explains the incompatibility.",
            "Step 6: Run test installations in environments matching your supported matrix (oldest and newest Python/pip versions) to confirm that the installation no longer fails and that functionality remains intact.",
            "Step 7: Monitor the upstream issue/library for a fix or clearer compatibility guarantees. When the ecosystem stabilizes or your minimum supported tooling version increases, revisit and potentially relax or remove the strict pin.",
            "Step 8: Communicate the pin in release notes or upgrade guides so users and maintainers are aware of the intentional constraint and its rationale."
        ]
    }
}
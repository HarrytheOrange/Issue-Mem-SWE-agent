{
    "search_index": {
        "description_for_embedding": "Fixes an AttributeError in napari's running_as_bundled_app utility when running under pdb or other contexts where the __main__ module has no __package__ attribute, by safely accessing sys.modules['__main__'].__package__ with a try/except and returning False when absent.",
        "keywords": [
            "napari",
            "running_as_bundled_app",
            "__main__.__package__",
            "AttributeError",
            "briefcase bundle detection",
            "importlib_metadata",
            "python -m pdb",
            "module __package__ missing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a user ran `python -m pdb script.py`, where the script imported napari. During napari initialization, the function `running_as_bundled_app` in `napari/utils/misc.py` tried to determine if napari was running as a briefcase-bundled app. It did this by directly accessing `sys.modules['__main__'].__package__`. Under pdb, however, the `__main__` module did not define a `__package__` attribute, causing `AttributeError: module '__main__' has no attribute '__package__'`. This crashed the program during import. The fix wrapped the access in a try/except block: it attempts to read `sys.modules['__main__'].__package__`, and if an AttributeError is raised (because `__package__` is missing), the function returns False immediately, treating the situation as 'not a bundled app'. If the attribute exists, it continues as before, using `importlib_metadata.metadata(app_module)` to check for briefcase metadata. This prevents napari from crashing in debugging or other non-package execution contexts where `__main__` has no `__package__`.",
        "semantic_memory": "When inferring environment or packaging state from the `__main__` module, it is unsafe to assume that all standard attributes (like `__package__`) are present. Certain execution contexts—such as running modules under debuggers (e.g., `python -m pdb`), custom launchers, or bundled environments—may omit or alter typical module attributes. Direct attribute access on modules (e.g., `sys.modules['__main__'].__package__`) can therefore raise AttributeError.\n\nRobust code should handle missing attributes gracefully. This can be done by:\n- Using `getattr(obj, 'attr', default)` to provide a safe fallback, or\n- Wrapping attribute access in a try/except AttributeError and handling the absence explicitly.\n\nFor environment/bundle detection logic, the conservative default should be to return a 'safe' value (e.g., 'not a bundled app') when necessary metadata cannot be determined, instead of crashing. Also, feature-detection logic that relies on package metadata (`importlib.metadata`) should be prepared for both missing package names and missing metadata, treating these as normal cases rather than fatal errors.\n\nIn general, code that runs at import time is particularly sensitive: any unhandled exceptions there will prevent the entire package from being imported, so defensive programming (especially around introspection of execution context) is important.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the error in the exact execution context. For issues involving `__main__` or execution environment, run the program the same way the user did (e.g., `python -m pdb script.py`, a debugger, or a bundler/launcher). Capture the full traceback to see which module and line caused the error.",
            "Step 2: Inspect the failing attribute access. Look at the code line raising the AttributeError (e.g., `sys.modules['__main__'].__package__`). In a Python shell or debugger, print out `sys.modules['__main__']` and `dir(sys.modules['__main__'])` to confirm whether the expected attribute actually exists in that context.",
            "Step 3: Understand why the attribute might be missing. Check Python docs and the specific execution environment (pdb, briefcase, PyInstaller, custom launch scripts) to see if they modify or omit typical module attributes like `__package__`, `__file__`, etc. Recognize that `__main__` is special and may vary by launcher.",
            "Step 4: Choose a safe access pattern. Replace direct attribute access with a safer approach:\n- Prefer `getattr(module, '__package__', None)` when a default makes sense, or\n- Wrap in `try: ... except AttributeError: ...` if you need to distinguish between presence and absence. Decide on a conservative fallback behavior (e.g., assume not bundled, or skip optional feature) rather than crashing.",
            "Step 5: Adjust the environment-detection logic. If the logic is trying to detect a bundled app or specific packaging (here, briefcase), treat missing attributes or metadata as 'not detected' rather than erroneous. For example, when `__package__` is missing from `__main__`, simply return False from `running_as_bundled_app`.",
            "Step 6: Preserve existing behavior when attributes are present. Ensure that the new error-handling only changes behavior in the exceptional cases. For normal runs where `__main__.__package__` exists and metadata can be loaded, the code should behave exactly as before (e.g., checking `importlib_metadata.metadata(app_module)` for specific markers).",
            "Step 7: Add or adapt tests if possible. Create tests that simulate or approximate the problematic execution context: e.g., mock `sys.modules['__main__']` without a `__package__` attribute, or set up a small script run under `python -m pdb` or similar. Assert that imports no longer raise AttributeError and that the function returns the expected fallback value.",
            "Step 8: Re-run in the problematic context. After applying the fix, re-run `python -m pdb script.py` (or the equivalent environment) to confirm that the package imports cleanly, the previous traceback no longer occurs, and behavior is consistent with expectations (e.g., no bundled-app detection when `__package__` is missing).",
            "Step 9: Document assumptions and links. Optionally, add comments in the code referencing the environment-specific issue (e.g., briefcase or pdb behavior) and the rationale for the defensive check. This helps future maintainers avoid reverting or breaking the safeguard."
        ]
    }
}
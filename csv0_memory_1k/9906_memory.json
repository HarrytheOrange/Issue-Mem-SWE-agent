{
    "search_index": {
        "description_for_embedding": "Home Assistant SPC alarm component enhancement: adds a 'changed_by' attribute to alarm_control_panel.spc to expose which SPC user last armed/disarmed the alarm. The SIA websocket message parser now extracts the user from the incoming description field and passes it through an 'extra' dict to async_update_from_spc. The alarm entity initializes 'changed_by' from last_set_user_name / last_unset_user_name and updates state asynchronously via async_schedule_update_ha_state. The obsolete 'OQ' SIA message handling was removed, tests were updated to cover the new attribute and to wait for async updates.",
        "keywords": [
            "Home Assistant",
            "SPC",
            "alarm_control_panel",
            "binary_sensor",
            "changed_by attribute",
            "SIA message parsing",
            "websocket",
            "async_update_from_spc",
            "async_schedule_update_ha_state",
            "entity registration",
            "async_added_to_hass",
            "OQ message removal",
            "test race condition",
            "state attribute test"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the SPC (Siemens SPC) integration for Home Assistant was enhanced to expose which user last armed or disarmed the alarm. The existing SPC alarm_control_panel implementation did not provide a 'changed_by' attribute, unlike the Verisure integration, so users could not see or automate based on who operated the alarm.\n\nTo address this, the SpcAlarm entity constructor was refactored to accept the SPC API instance and an 'area' dict. On initialization, it computes its initial state from area['mode'] and sets a new internal field '_changed_by'. If the area is disarmed, '_changed_by' is taken from 'last_unset_user_name'; otherwise from 'last_set_user_name', defaulting to 'unknown' if unavailable. A new 'changed_by' property exposes this value as an entity state attribute.\n\nThe message-processing pipeline in homeassistant.components.spc._async_process_message was updated to support user metadata. For area-related SIA codes ('BA', 'CG', 'NL', 'OG'), the handler now creates an 'extra' dict and parses the incoming 'description' field, which is formatted as 'AreaName¦UserName¦Id'. When three segments are present, extra['changed_by'] is set to the middle field (UserName). This 'extra' dict is then passed, along with the derived new state, into device.async_update_from_spc(new_state, extra). Zone (sensor) messages still pass an extra dict but don't consume it.\n\nSpcAlarm.async_update_from_spc was updated to accept this extra payload: it updates both _state and _changed_by, then calls async_schedule_update_ha_state() instead of awaiting async_update_ha_state(), to better integrate with Home Assistant's async scheduling and avoid potential race conditions observed in tests. Binary sensor entities were adjusted to accept the new signature (state, extra) while retaining their behavior.\n\nEntity registration was moved from the SpcAlarm constructor into the async_added_to_hass lifecycle callback. The alarm device now registers itself with the shared SpcRegistry in async_added_to_hass using self._area_id. async_setup_platform was updated to pass api = hass.data[DATA_API] into SpcAlarm rather than the full hass instance.\n\nAdditionally, processing of the 'OQ' SIA code, which was no longer needed, was removed from both the code and the state mapping.\n\nTests were expanded and fixed. alarm_control_panel/spc tests now verify that initial 'changed_by' is correctly derived from 'last_set_user_name' and 'last_unset_user_name' for armed and disarmed areas. The main SPC tests were parameterized to check multiple SIA codes ('NL', 'CG', 'OG') and assert that the alarm entity's state and 'changed_by' attribute update correctly when messages like {\"sia_code\": \"NL\", \"sia_address\": \"1\", \"description\": \"House¦Sam¦1\"} are processed. A race condition in tests was mitigated by awaiting hass.async_block_till_done() after firing _async_process_message, ensuring the async scheduled state update completed before assertions.\n\nSensor tests were similarly parameterized for 'ZO' and 'ZC' (on/off) codes and updated to rely on standard STATE_ON/STATE_OFF constants rather than raw strings. The tests also adapted to the removal of hass.states.is_state_attr by retrieving the State object and checking state_obj.attributes['changed_by'] directly. Overall, this PR added the requested user attribution, cleaned up unnecessary SIA handling, improved async patterns, and stabilized tests.",
        "semantic_memory": "This change illustrates several generalizable patterns for integrating protocol-level metadata into a home automation platform and maintaining robust async behavior and tests.\n\n1. **Propagating domain metadata through the stack**: When external systems provide useful metadata (such as which user performed an action), it is often not enough to update only the main entity state. The API surface between the protocol layer and entity layer should support passing additional context. Here, this is done by extending the update method signature from async_update_from_spc(state) to async_update_from_spc(state, extra), where 'extra' is a dict carrying metadata like 'changed_by'. This pattern allows non-breaking extensibility: existing devices can ignore extra, while new ones consume it.\n\n2. **Deriving initial attributes from discovery data**: For entities that are discovered with rich status information, it is best to initialize both state and attributes based on the discovery payload. In this case, initial 'changed_by' is computed from last_set_user_name or last_unset_user_name depending on the discovered alarm mode. This ensures that the entity's attributes are meaningful from the moment they are added, not only after the first live event.\n\n3. **Entity lifecycle: use async_added_to_hass for registration**: Registering entities in shared registries or global indexes should occur in lifecycle callbacks like async_added_to_hass, not in __init__. At __init__ time, the entity may lack a proper hass reference or may be constructed in contexts other than a running Home Assistant instance (e.g., tests). Moving registry registration into async_added_to_hass aligns with framework conventions and reduces coupling.\n\n4. **Non-blocking state updates in async frameworks**: When updating entity state in an async environment like Home Assistant, using async_schedule_update_ha_state() is often preferable to awaiting async_update_ha_state() from within background tasks or callbacks. The schedule variant queues the update on the event loop and returns immediately, preventing deadlocks and race conditions where multiple updates might block each other or tests query states before updates are applied.\n\n5. **Robust parsing of structured message fields**: Protocols sometimes embed multiple fields in a single text field using delimiters. Rather than assuming a fixed format, robust code should split on the delimiter and validate expected length before accessing indices. In this case, the SIA description \"AreaName¦UserName¦Id\" is parsed with split('¦') and used only if len(data) == 3, guarding against malformed messages.\n\n6. **Pruning unused protocol cases**: Maintaining support for protocol message types that are not needed or not surfaced at the entity layer adds complexity and potential for bugs. Removing handling of an unnecessary SIA code ('OQ') simplifies the mapping and reduces surface area. This pattern is important in long-lived protocol integrations: periodically re-evaluate which messages are actually used.\n\n7. **Async test reliability**: Tests that interact with async code must ensure the event loop processes all scheduled tasks before assertions. The use of hass.async_block_till_done() after triggering an async action ensures entity state updates have been applied, eliminating flakiness caused by race conditions. Additionally, using parametrize in tests encourages broader coverage across multiple event types with minimal duplication.\n\n8. **Decoupling tests from helper APIs**: When framework helper methods (like is_state_attr) are removed or changed, tests should fall back to checking states and attributes directly via hass.states.get(). This decouples tests from convenience helpers and makes behavior under test more explicit.\n\nThese patterns are applicable to any event-driven or IoT system where external messages update internal entity state: design extensible update pathways that carry both state and metadata, align entity construction with the framework lifecycle, use non-blocking updates, and write async-aware tests that wait for all work to complete before asserting.",
        "procedural_memory": [
            "How to add a 'changed_by'-style attribute sourced from a device protocol to an entity, and ensure async updates and tests work correctly.",
            "Step 1: Identify where protocol messages are received and where entities are updated.\nLocate the central message-processing function (e.g., _async_process_message) and the entity method that applies state changes (e.g., async_update_from_spc). Confirm how messages map from protocol codes to entity states.",
            "Step 2: Extend the update method signature to carry metadata.\nChange the entity update method signature from something like async_update_from_spc(self, state) to async_update_from_spc(self, state, extra), where extra is a dict for additional context. Update all callers to pass an extra dict (use {} when no extra data is available) so the interface remains consistent for all devices.",
            "Step 3: Extract metadata in the protocol handler.\nIn the message-processing function, parse the incoming payload for the desired metadata. For example, if you need the user who triggered an alarm change and the protocol encodes it as 'AreaName¦UserName¦Id' in a description field, do:\n\nextra = {}\nparts = msg['description'].split('¦')\nif len(parts) == 3:\n    extra['changed_by'] = parts[1]\n\nThen, when you call the entity, use: yield from device.async_update_from_spc(new_state, extra).",
            "Step 4: Initialize attributes from discovery or initial data.\nWhen constructing the entity from discovery info (e.g., an 'area' dict), compute initial values for the new attribute. For an alarm, if area['mode'] indicates disarmed, set changed_by from area.get('last_unset_user_name', 'unknown'); otherwise from area.get('last_set_user_name', 'unknown'). Store it in a private field (e.g., self._changed_by) and expose it via a property def changed_by(self): return self._changed_by.",
            "Step 5: Use the correct entity lifecycle for registration.\nIf your entity must register itself with a shared registry or manager, do this in async_added_to_hass instead of __init__. Implement:\n\n@asyncio.coroutine\ndef async_added_to_hass(self):\n    self.hass.data[DATA_REGISTRY].register_alarm_device(self._area_id, self)\n\nEnsure async_setup_platform constructs the entity with only what it needs (e.g., api and area), and the framework will call async_added_to_hass when ready.",
            "Step 6: Prefer scheduled async updates over direct awaits inside callbacks.\nInside entity update methods, after mutating internal state and attributes, call self.async_schedule_update_ha_state() rather than yield from self.async_update_ha_state(). This queues an update for the event loop and avoids blocking the caller, reducing chances of deadlocks or tests reading state before updates are applied.",
            "Step 7: Update all dependent components to match new interfaces.\nIf multiple components (e.g., alarm_control_panel.spc and binary_sensor.spc) share the same update method shape, update them all to accept the new extra parameter even if some ignore it. This keeps a uniform contract and prevents runtime argument errors.",
            "Step 8: Clean up unused protocol codes and mappings.\nReview the state mapping dictionary from protocol codes to entity states. Remove entries for codes you no longer intend to support (e.g., 'OQ' if it's redundant or unused) and adjust logic that branches on these codes accordingly. This reduces complexity and potential confusion.",
            "Step 9: Adjust tests to cover new behavior and async timing.\nAdd or update tests to:\n- Verify that initial attributes (like changed_by) are correctly derived from discovery data.\n- Simulate incoming protocol messages (via a helper like _async_process_message) that carry metadata and assert that entity state and attributes are updated as expected.\nUse pytest.mark.parametrize to cover multiple protocol codes with a single test function.\nAfter firing the message, call yield from hass.async_block_till_done() to ensure all scheduled updates complete before assertions.",
            "Step 10: Make tests robust against framework changes.\nIf framework helper methods like hass.states.is_state_attr are removed or unstable, replace them by directly retrieving the state object:\n\nstate_obj = hass.states.get(entity_id)\nassert state_obj.state == expected_state\nassert state_obj.attributes['changed_by'] == expected_user\n\nThis keeps tests explicit and less dependent on non-essential helpers.",
            "Step 11: Run the full async test suite and verify coverage.\nExecute the project's test runner (e.g., tox) to ensure all tests pass and there are no interface mismatches (like missing parameters). Use any race conditions or intermittent failures as a signal to review async scheduling and to add hass.async_block_till_done() where appropriate."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Added a new Home Assistant sensor platform `sensor.fints` to read German FinTS (HBCI) bank account data. The integration logs into a FinTS bank, auto-detects which SEPA accounts support balance vs holdings, and exposes them as separate sensors. It supports configuration of which accounts/holdings to expose, represents balances with the bank's currency and holdings as a total EUR value with per-holding attributes, and polls at a reasonable interval. Includes a FinTsClient wrapper to encapsulate connection logic and account type detection, plus clean-up to satisfy static analysis (no type hints, correct logging, schema validation).",
        "keywords": [
            "FinTS",
            "HBCI",
            "Home Assistant",
            "sensor.fints",
            "bank account balance",
            "holdings account",
            "SEPAAccount",
            "FinTS3PinTanClient",
            "Python integration",
            "polling sensor",
            "configuration schema",
            "requirements fints==0.2.1"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request attempted to add a new Home Assistant sensor platform for FinTS (German HBCI) bank accounts. The goal was to read bank balances and holdings from institutions supporting FinTS and represent them as Home Assistant sensors.\n\nInitial implementation:\n- Created `homeassistant/components/sensor/fints.py` with a `PLATFORM_SCHEMA` requiring bank identification number (BLZ), username, PIN, and FinTS URL, and optional sensor name and list of accounts.\n- Defined a `BankCredentials` namedtuple and a simple `_connect` helper returning a `FinTS3PinTanClient` instance.\n- Implemented a `FinTsAccount` Entity that, on `update()`, opens a new client, finds the configured SEPA account by IBAN/accountnumber, retrieves the balance via `get_balance`, and exposes `state` as the numeric amount and `unit_of_measurement` as the currency. Attributes included the IBAN; all sensors used an EUR icon.\n- Sensors were created per SEPA account (with IBAN) returned by `get_sepa_accounts`, optionally filtered by a configured list of IBANs.\n\nSubsequent iterations enhanced and cleaned up the implementation:\n- The scan interval was increased from 1 hour to 4 hours to reduce load on bank servers.\n- Configuration schema changed from `iban` to a more generic `account` field and split into two lists: `accounts` (balance accounts) and `holdings` (securities/portfolio accounts).\n- A `FinTsClient` wrapper class was introduced around `FinTS3PinTanClient`. Its `detect_accounts()` method iterates `get_sepa_accounts()` and attempts `get_balance` and `get_holdings` to classify each account as balance-capable, holdings-capable, or both, catching `IndexError` and `FinTSDialogError` to handle unsupported operations. This avoids hardcoding account types.\n- Two entity classes were introduced:\n  - `FinTsAccount` for balance accounts: exposes the balance amount as state and the currency as unit. Attributes include `account` (IBAN), `account_type='balance'`, and optional `bank` name.\n  - `FinTsHoldingsAccount` for holdings accounts: calls `get_holdings` to fetch portfolio items. `state` is the sum of `holding.total_value` across holdings. Attributes include `account` (accountnumber), `account_type='holdings'`, optional `bank` name, and individual attributes of the form \"<name> x <pieces>\" -> `total_value` per holding. The unit is hard-coded to EUR because the upstream library does not expose a currency for holdings and FinTS is predominantly used in the Eurozone.\n- Logging was improved to indicate when accounts are created or skipped based on configuration.\n- The code went through style cleanup: spacing fixes, removal of Python type hints that violated project style, and explicit handling of `IndexError` vs `FinTSDialogError` to satisfy static analysis. The new module was added to `.coveragerc` and `requirements_all.txt` gained `fints==0.2.1`.\n\nThere was some project-level friction: the branch also contained many unrelated core commits (version bumps, other component fixes), and maintainers requested a clean PR rebased on `dev`. The author later opened a new PR, making this one effectively superseded, but the FinTS sensor design in this diff captures how the feature was structured and iterated.",
        "semantic_memory": "This change encapsulates several generalizable patterns for integrating external financial APIs (or any multi-account, multi-type service) into a Home Assistant-style system:\n\n1. **Encapsulate external client logic in a wrapper**:\n   - Instead of letting each Entity instantiate and interpret the API client, use a dedicated client wrapper (here `FinTsClient`) that owns the credentials and exposes higher-level operations like `detect_accounts()`. This avoids duplicated connection logic and makes it easier to adapt to library changes.\n\n2. **Detect account capabilities by attempting operations**:\n   - When an external API does not explicitly tag account types, you can discover capabilities by trying operations and handling expected exceptions. Here, `get_balance` and `get_holdings` are tried; catching `IndexError` or `FinTSDialogError` is used to infer whether an account is a balance account, a holdings account, or both.\n   - This pattern applies widely: when an external system's metadata is incomplete, you can use capability probing.\n\n3. **Map a single external domain into multiple internal entity types**:\n   - One bank connection surfaces multiple conceptual resources: balance accounts vs holdings portfolios. Modeling each category as a distinct Entity class (`FinTsAccount`, `FinTsHoldingsAccount`) with tailored `state`, `unit_of_measurement`, and attributes leads to clearer semantics than a generic \"bank account\" entity.\n\n4. **Use configuration to filter and rename resources**:\n   - The platform supports lists of `accounts` and `holdings`, each element specifying an `account` id and optional display `name`. This pattern of \"discover everything, then apply user-specified filters and overrides\" is a good approach for user-friendly discovery while respecting user control.\n\n5. **Respect resource constraints and privacy**:\n   - Banking APIs are sensitive and rate-limited. Increasing `SCAN_INTERVAL` from 1 to 4 hours reflects a best practice: poll infrequently by default for expensive or sensitive external services.\n   - Attributes include useful metadata (account id, bank name, account type) but not excessive details like full login credentials.\n\n6. **Cleanliness and static-analysis alignment**:\n   - Removing type hints in a codebase that doesn’t use them consistently, and splitting broad `except ... or ...` patterns into separate except blocks, are reminders to align with project-wide code style and static analysis expectations.\n\n7. **Attribute modeling for complex financial instruments**:\n   - For holdings accounts, the total portfolio value is the numeric `state`, while detailed holdings are exposed as attributes keyed by human-readable strings. This is a practical pattern when a system’s state model allows a single scalar state and arbitrary attributes but you still want to surface rich structured data.\n",
        "procedural_memory": [
            "Step-by-step instructions on how to design and implement a Home Assistant sensor for a banking/financial API similar to FinTS:",
            "Step 1: Define configuration schema.\n- Decide what credentials and parameters you need (e.g., BLZ/bank ID, username, PIN, API URL, optional friendly bank name).\n- Define optional lists for different resource types you plan to expose (`accounts`, `holdings`, etc.), each with required identifiers (`account`, `iban`, etc.) and optional custom display names.\n- Use `PLATFORM_SCHEMA.extend` and `voluptuous` in Home Assistant to validate this configuration.",
            "Step 2: Wrap the third-party client in a dedicated helper class.\n- Create a small wrapper (like `FinTsClient`) that:\n  - Stores credentials and any shared context.\n  - Provides a `client` property or method that instantiates the underlying API client (e.g., `FinTS3PinTanClient`) when needed.\n  - Offers higher-level methods like `detect_accounts()` that implement account discovery and classification.\n- Avoid holding long-lived network connections if the library is not designed for it; (re)instantiate the client per interaction if necessary.",
            "Step 3: Detect account types and capabilities.\n- After instantiating the client, retrieve the list of accounts (e.g., via `get_sepa_accounts()`).\n- For each account, attempt supported operations (e.g., `get_balance(account)` and `get_holdings(account)`) and catch the expected exceptions (e.g., `IndexError`, `FinTSDialogError`).\n- Use success/failure of each operation to classify accounts into categories (e.g., balance accounts vs holdings accounts). Return these groupings to the platform setup code.",
            "Step 4: Implement entity classes per account type.\n- For balance accounts:\n  - Implement an Entity subclass (e.g., `FinTsAccount`).\n  - In `update()`, create a client instance, call `get_balance(account)` and set:\n    - `self._balance = balance.amount.amount`\n    - `self._currency = balance.amount.currency`.\n  - `state` returns the numeric balance, `unit_of_measurement` returns the currency.\n  - `device_state_attributes` should include identifiers like `account`, `account_type='balance'`, and optional `bank` name.\n- For holdings accounts:\n  - Implement another Entity subclass (e.g., `FinTsHoldingsAccount`).\n  - In `update()`, call `get_holdings(account)` and store the returned holdings list.\n  - Compute the total portfolio value (e.g., `sum(h.total_value for h in holdings)`) and expose it as `state`.\n  - For attributes, include account identifiers and per-holding details (e.g., `\"<name> x <pieces>\": total_value`). Choose an appropriate or documented unit (e.g., EUR) when the API library does not provide one explicitly.",
            "Step 5: Implement `setup_platform` to wire config to entities.\n- Parse `config` to build maps from user-specified account identifiers to display names for both balance accounts and holdings.\n- Instantiate your client wrapper with the credentials and optional bank name.\n- Call `client.detect_accounts()` to get lists of balance accounts and holdings accounts.\n- For each discovered account:\n  - If no filters are configured, create an entity for all; otherwise, only for accounts present in the corresponding config lists.\n  - Determine the entity’s friendly name: user-configured name if present, or a sensible default like `'<bank_name> - <iban>'` or `'<bank_name> - <accountnumber>'`.\n  - Log what you are creating/skipping (`_LOGGER.debug/info`) for traceability.\n- Call `add_devices(entities, True)` to register them with an initial update.",
            "Step 6: Choose an appropriate polling interval.\n- For banking or other rate-limited/sensitive APIs, set `SCAN_INTERVAL` relatively high (e.g., 4 hours) to avoid excessive traffic.\n- Ensure your entities implement `should_poll = True` and that `update()` is efficient and robust (handle exceptions and log failures; set state attributes to `None` or leave previous values when appropriate).",
            "Step 7: Align with project style and static analysis.\n- Avoid project-prohibited features (like inline type hints, if the codebase does not use them), and satisfy linters (`pylint` etc.) by fixing spacing, avoiding broad `except A or B` forms, and giving explicit constructors / docstrings where expected.\n- Add the new module to coverage exclusion if necessary, and update any shared requirements files with the external dependency (`fints==0.2.1`), confirming the package is available and maintained.\n",
            "Step 8: Test and iterate.\n- Test with several banks and account types to ensure account detection works and that both balance and holdings accounts are represented correctly.\n- Verify that configuration filters behave as expected (only selected accounts appear, with custom names when given).\n- Confirm that sensitive information is not logged or exposed via attributes beyond what is necessary for identification."
        ]
    }
}
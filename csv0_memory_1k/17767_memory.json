{
    "search_index": {
        "description_for_embedding": "Home Assistant Fire TV media_player integration migrated from a Python 2 HTTP firetv-server to native Python 3 ADB via the firetv library. Added ADB authentication (adbkey), proper config validation, robust connection/reconnection handling, and a non-blocking lock/decorator around ADB calls to avoid concurrent command issues while removing reliance on private library attributes.",
        "keywords": [
            "homeassistant",
            "media_player.firetv",
            "Fire TV",
            "ADB authentication",
            "adbkey",
            "python-firetv",
            "firetv==1.0.7",
            "native ADB support",
            "concurrency",
            "threading.Lock",
            "non-blocking lock",
            "protected attribute access",
            "config validation",
            "requirements_all.txt",
            "breaking change host port semantics"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant Fire TV media_player platform was reworked to natively control Fire TV devices via ADB using the Python 3 `firetv` library instead of the old Python 2 `firetv-server` HTTP bridge. Previously, `host` and `port` in configuration pointed at a remote firetv-server instance; now they point directly to the Fire TV device (default port 5555). This is a breaking change that requires users to update their configuration.\n\nThe implementation introduced new configuration options:\n- `adbkey`: path to the ADB private key used for authentication (with implicit `.pub` public key),\n- `get_source`: whether to query the currently active app,\n- `get_sources`: whether to query the list of running apps.\n\nInitially, setup created the `FireTVDevice` entity and then introspected its internal `.firetv._adb` attribute to debug connection issues and key file presence. This caused pylint violations and relied on private attributes of the third-party library. The code was refactored to construct a `FireTV` instance directly in `setup_platform`, validate the `adbkey` paths with a config validator (ensuring both private and `.pub` files exist), and check `ftv.available` (a public API) before creating the entity. If the device is not available, setup logs a warning and returns without adding the entity.\n\nThe initial implementation also accessed multiple private attributes on the `firetv` object (`_adb`, `_screen_on`, `_awake`, `_wake_lock`, etc.). After the library was updated (firetv==1.0.7), the integration was changed to use the public properties `available`, `screen_on`, `awake`, `wake_lock`, `running_apps`, and `current_app`. This removed `pylint` complaints about protected access and made the integration more robust to internal library changes.\n\nConnection robustness and concurrency were key concerns. A decorator (`adb_decorator`) was introduced to wrap all ADB-related methods. It:\n- Skips command execution if the device is unavailable (unless explicitly overridden, as in `update()` for reconnection attempts),\n- Uses a non-blocking `threading.Lock` to avoid running overlapping ADB commands; if the lock cannot be acquired, it logs an info message and skips that command instead of blocking,\n- Catches a defined set of exceptions (TypeError, ValueError, AttributeError and ADB protocol errors such as InvalidCommandError, InvalidResponseError, InvalidChecksumError) and, on failure, logs an error and flags the device as unavailable so that the next `update()` can attempt to reconnect.\n\nThe `update()` method was restructured to:\n1. Try to reconnect if `available` is false (using `firetv.connect()`) and then re-check `firetv.available`.\n2. Abort further state updates if the ADB connection remains unavailable.\n3. If connected, compute the Home Assistant state based on:\n   - `screen_on` (OFF vs on),\n   - `awake` (IDLE vs launcher or playing),\n   - `current_app` (used alongside launcher/settings package names to decide STANDBY vs active),\n   - `wake_lock` (used to distinguish PLAYING vs PAUSED/standby),\n   - `get_source` / `get_sources` flags (to control whether current app and/or running apps are fetched, and whether current app should be the only reported source).\n\nThe integration’s REQUIREMENTS were simplified to `REQUIREMENTS = ['firetv==1.0.7']`. The author had trouble with `script/gen_requirements_all.py` and accidentally committed unrelated changes; this was resolved by reverting to the `dev` branch versions of `requirements_all.txt`/`requirements_test_all.txt` and then manually adding the `firetv` requirement line while ensuring tests passed. Linting issues (bare except, logging formatting, protected-access, no-name-in-module) were addressed by:\n- Catching specific exceptions instead of using bare `except`,\n- Using parameterized logging (`_LOGGER.error('msg %s', var)`) and simplified message strings,\n- Moving imports inside functions where required and eliminating `pylint: disable` directives when no longer necessary.\n\nAs a result, the Fire TV platform now:\n- Controls Fire TV devices directly via ADB (no external Python 2 server),\n- Supports ADB authentication via `adbkey`,\n- Uses clean, public APIs from the `firetv` library,\n- Avoids unsafe concurrent ADB calls with a non-blocking lock/decorator,\n- Handles connection failures and reconnections gracefully,\n- And passes Home Assistant’s linting and requirements checks.",
        "semantic_memory": "Generalizable lessons from this change include:\n\n1. **Prefer native integrations over custom bridge servers**: When an upstream library becomes compatible with your runtime (e.g., Python 3), it is beneficial to remove intermediate servers or bridges (like a Python 2 firetv-server). Direct integration simplifies deployment, eliminates extra failure points, and makes configuration more intuitive (here, `host`/`port` now target the actual Fire TV).\n\n2. **Do not rely on private attributes of third-party libraries**: Accessing `._internal` attributes tightly couples your code to an implementation detail that can change without notice and triggers static analysis warnings. Instead, rely on the library’s public API, push for missing getters to be added upstream, and bump the dependency once supported.\n\n3. **Centralize device I/O and concurrency control with decorators and locks**: Wrapping all outbound calls to a device library with a decorator gives a single enforcement point for:\n   - Checking availability,\n   - Serializing access (via locks),\n   - Handling exceptions and recovery.\n   Using a non-blocking lock for operations like ADB commands can prevent thread pile-ups and keep the system responsive at the cost of occasionally skipping commands.\n\n4. **Explicitly model device availability vs state**: Distinguish between \"device unavailable\" (connection/ADB broken) and \"device off or idle\" (a valid state). Expose an `available` flag separate from `state`, and only update state when the underlying connection is healthy. This improves UI consistency and reconnection logic.\n\n5. **Use configuration schemas to validate file paths and invariants**: Instead of doing ad-hoc existence checks (e.g., manual `os.path.exists` and `open()` calls) in setup code, implement a custom validator integrated with your config schema (here, verifying that both the private ADB key and its `.pub` file exist). This allows invalid configs to fail fast at parse time with clear errors.\n\n6. **Handle library-specific exceptions explicitly**: When calling external libraries, identify and catch the specific exceptions they raise (e.g., ADB protocol errors `InvalidCommandError`, `InvalidResponseError`, `InvalidChecksumError`) along with typical Python runtime errors. Centralized exception handling lets you log helpful messages and implement recovery strategies (e.g., mark unavailable and reconnect on next update).\n\n7. **Be explicit with dependency versions and project-wide requirement files**: For tightly coupled libraries (like `firetv` that expose the APIs you depend on), pin to a specific version (e.g., `firetv==1.0.7`) and ensure that project-wide requirement aggregators (`requirements_all.txt`, `requirements_test_all.txt`) include the same version. If auto-generation tooling produces noisy diffs, prefer reverting non-related changes and editing only the minimal required lines.\n\n8. **Consider user-facing breaking changes and update docs accordingly**: When changing core semantics (e.g., `host`/`port` moving from a server to a device), clearly document breaking changes, provide migration examples, and link to updated docs or forum threads. Marking such PRs with breaking-change labels helps downstream users and maintainers.\n\n9. **Feature gating expensive or unstable queries**: Fetching additional device data (like running apps or current app) can be costly or unstable for some devices. Adding boolean flags (`get_source`, `get_sources`) allows users to disable problematic features while still using the integration.\n\n10. **Separate reconnection logic from normal operation**: Reconnections should usually occur in a controlled place (e.g., `update()`) where you can manage state reset and avoid concurrent reconnection attempts. Avoid ad hoc reconnection logic scattered across various command methods.\n\nThese patterns apply broadly to any integration with networked devices or third-party control libraries, especially in home automation and other event-driven systems.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify legacy integration patterns and new upstream capabilities.\n- Check whether your integration still relies on external bridges or legacy runtimes (e.g., Python 2 services) when upstream libraries now support your primary runtime (e.g., Python 3).\n- Review the upstream library’s public API to see if it can replace your custom wrapper or server.",
            "Step 2: Plan the migration to native library usage.\n- Decide how configuration semantics will change (e.g., `host` now refers to the device, not a server).\n- Mark and document any breaking changes.\n- Ensure that the upstream library exposes the functionality you need (e.g., properties like `available`, `screen_on`, `awake`). If not, contribute changes upstream first.",
            "Step 3: Replace custom clients with direct library objects.\n- In your setup function, import and instantiate the third-party client directly (e.g., `FireTV(host, adbkey)`), rather than going through HTTP or custom adapters.\n- Check the library’s own availability flag (e.g., `ftv.available`) and only create entities/devices if the initial connection succeeds. Log meaningful warnings and return early otherwise.",
            "Step 4: Add robust configuration validation for external resources.\n- For fields like file paths to keys or certificates, create custom validators (e.g., `has_adb_files`) that verify existence and any required companion files (`.pub`, etc.).\n- Use your framework’s config validation system (like `voluptuous` in Home Assistant) so misconfigurations fail fast at configuration load time.\n- Avoid manual `os.path.exists` checks and `open()` in the main setup logic unless necessary.",
            "Step 5: Encapsulate device I/O and concurrency with a decorator.\n- Create a decorator (e.g., `adb_decorator`) that:\n  - Checks if the device is available (or if a forced call like `update()` should proceed anyway),\n  - Uses a shared `threading.Lock` to prevent simultaneous device calls. Consider `lock.acquire(blocking=False)` to skip commands rather than block if a prior command is still running,\n  - Catches a well-defined set of exceptions from the device library and standard Python errors,\n  - On error, logs a clear message and marks the device as unavailable so the next update can try to reconnect.\n- Apply this decorator consistently to all methods that call into the third-party device library (turn_on/off, media controls, etc.).",
            "Step 6: Refactor to use public library APIs instead of private attributes.\n- Identify all uses of `object._private` attributes in your integration.\n- Replace them with corresponding public properties or methods (`available`, `screen_on`, `awake`, `wake_lock`, `running_apps`, `current_app`, etc.).\n- If a required piece of information isn’t exposed publicly, extend the library upstream and bump your dependency version once merged.\n- Remove related `pylint` disable markers once private access is gone.",
            "Step 7: Implement clear connection and reconnection logic.\n- Maintain a separate `available` flag in your integration that mirrors the underlying library’s connectivity status.\n- In your periodic update method:\n  - If unavailable, try `connect()` and update `available` based on the library’s `available` property;\n  - If still unavailable after reconnect, abort further state updates for that cycle;\n  - If available, compute your integration’s state based on library properties (e.g., off/idle/playing/paused/standby logic using `screen_on`, `awake`, `wake_lock`, and `current_app`).",
            "Step 8: Gate optional or unstable functionality with configuration flags.\n- For operations that may be expensive or unstable on some devices (e.g., querying running apps), add boolean config options (`get_source`, `get_sources`).\n- In your update logic, only call those library methods if the corresponding config flag is true.\n- Provide documentation and examples showing how users can disable problematic queries.",
            "Step 9: Clean up and align dependency management.\n- Pin your external library to a known-good version if you rely on specific APIs (e.g., `REQUIREMENTS = ['firetv==1.0.7']`).\n- Add the same dependency to project-wide requirements files (e.g., `requirements_all.txt`, `requirements_test_all.txt`).\n- If your requirement generation script produces large diffs, revert unrelated changes and manually add only the lines relevant to your integration.\n- Re-run linting and tests to ensure everything passes.",
            "Step 10: Resolve linting and style issues.\n- Replace bare `except:` with concrete exception tuples.\n- Use parameterized logging (`_LOGGER.error('msg %s', var)`) instead of f-strings or string concatenation inside logging calls.\n- Avoid `pylint: disable` pragmas where possible by adjusting code to meet style guidelines (imports inside functions, no protected-access, etc.).",
            "Step 11: Communicate breaking changes and provide migration guidance.\n- Update documentation to reflect:\n  - New semantics of existing config fields (e.g., `host`/`port` now pointing to the Fire TV device),\n  - New options like `adbkey`, `get_source`, and `get_sources`,\n  - Example configurations for common scenarios (with and without ADB authentication).\n- Mark the PR or change as a breaking change in your project’s release notes so users know they must adjust their configurations."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant HaveIBeenPwned sensor updated from deprecated API v2 (no auth) to API v3 requiring an API key and new request format, including config schema changes, updated endpoint URL, new headers, and JSON manifest formatting fix.",
        "keywords": [
            "HaveIBeenPwned",
            "HIBP",
            "API v3",
            "API deprecation",
            "authentication",
            "api key header",
            "Home Assistant sensor",
            "platform schema",
            "CONF_API_KEY",
            "truncateResponse=false",
            "manifest.json trailing comma",
            "third-party API migration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The HaveIBeenPwned (HIBP) sensor in Home Assistant was still using the v2 HIBP API endpoint, which was being deprecated and scheduled for shutdown. API v2 did not require authentication, but API v3 does require a paid API key and has slightly different usage expectations. If left unchanged, the sensor would stop working after HIBP disabled v2.\n\nTo fix this, the integration was updated to use the v3 breachedaccount endpoint (`https://haveibeenpwned.com/api/v3/breachedaccount/`) instead of the v2 endpoint. The platform configuration schema was extended to require an `api_key` in addition to the list of `email` addresses. The data holder class `HaveIBeenPwnedData` was modified to accept and store this API key. When making requests, the code now builds a URL including `?truncateResponse=false` to get full breach details and adds the required headers: the existing Home Assistant `User-Agent` and a new `hibp-api-key` header containing the user-provided API key. The request call was simplified to a single `requests.get` invocation with the updated headers and a 5-second timeout.\n\nDuring review, the Home Assistant maintainers requested that the code be formatted with Black. The author ran Black, which updated both `sensor.py` and the integration's `manifest.json`. That formatting pass added a trailing comma in the `codeowners` list in `manifest.json`, which is invalid JSON. A follow-up patch removed the stray trailing comma to restore JSON validity. The final result is a correctly formatted, API v3–compatible HIBP sensor that requires an API key and a valid manifest.",
        "semantic_memory": "When a third‑party service deprecates an API version or changes its authentication model, client integrations must be updated in several coordinated ways:\n\n1. **Endpoint and protocol changes**: Update the base URL, query parameters, and any new required behaviors (such as using `truncateResponse=false` to control the response shape). Verify these against the provider's latest documentation.\n\n2. **Authentication and headers**: When an API moves from unauthenticated to authenticated access, integrations must: (a) extend their configuration schema to capture secrets (e.g., API keys), (b) store them securely in the integration's data model, and (c) send them using the provider's required mechanism (custom header, Authorization header, etc.). For HIBP v3, this is the `hibp-api-key` header plus an appropriate `User-Agent`.\n\n3. **Config schemas and breaking changes**: Adding required configuration fields is a breaking change. The integration needs updated schema validation (e.g., `vol.Required(CONF_API_KEY)`) and corresponding documentation and examples so users know to supply the new configuration. This must be coordinated with release notes because existing installations without the new field will fail.\n\n4. **Error handling continuity**: While changing API versions, maintain and reuse existing error handling patterns (e.g., catching `requests.exceptions.RequestException` and logging errors) so the system degrades gracefully when network or API errors occur.\n\n5. **Code style automation**: Automated formatting tools like Black can introduce syntactic changes in JSON or other non-Python files (e.g., trailing commas). Those changes must be validated (for JSON, by a linter or validator) to avoid subtle build/runtime failures.\n\n6. **Release timing for API deprecations**: When an API shutdown date is known, the fix should be scheduled and released before that date (possibly as a patch release) to avoid a widespread integration outage in production environments.\n\nOverall, upgrading an integration to a new API version is not just about changing a URL: it involves configuration, request construction, error handling, documentation, and release planning, all kept consistent with project style and tooling.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Confirm the deprecation and new API requirements\n- Monitor third-party provider communications (blog posts, docs, deprecation notices).\n- Identify the old endpoint and authentication method (e.g., HIBP v2 without API key).\n- Identify the new endpoint, required headers, authentication scheme, and any query parameter or response-format changes (e.g., HIBP v3 with `hibp-api-key` and `truncateResponse` parameter).",
            "Step 2: Update integration configuration schema\n- Locate the platform/component schema definition (e.g., `PLATFORM_SCHEMA`).\n- Add new required fields for authentication, such as `CONF_API_KEY`, using the appropriate validation (`vol.Required(CONF_API_KEY): cv.string`).\n- Mark them as required if the API will not function without them; otherwise use `vol.Optional` with defaults.\n- Update configuration examples and docs to show the new field.",
            "Step 3: Propagate new configuration through the integration\n- Modify setup functions (`setup_platform`, `async_setup_entry`, etc.) to read the new config value (e.g., `api_key = config[CONF_API_KEY]`).\n- Pass the new value into any data/service classes that need it (e.g., `HaveIBeenPwnedData(emails, api_key)`).\n- Store it on the data object (`self._api_key = api_key`) or similar so it is available during requests.",
            "Step 4: Update API call construction\n- Replace deprecated URLs with the new endpoint base (e.g., `https://haveibeenpwned.com/api/v3/breachedaccount/`).\n- Adjust how URLs are built (path vs query parameters); add any required parameters such as `?truncateResponse=false`.\n- Construct headers dict including both existing headers (e.g., `User-Agent`) and new ones (e.g., `\"hibp-api-key\": self._api_key`).\n- Update the request call to use these headers and maintain timeouts and redirect behaviors: `requests.get(url, headers=headers, allow_redirects=True, timeout=5)`. ",
            "Step 5: Maintain and verify error handling\n- Keep existing try/except structures around network calls, catching `requests.exceptions.RequestException` or more specific exceptions.\n- Log meaningful error messages including the context (e.g., the email or resource being queried) without leaking secrets.\n- Consider mapping new API error codes (e.g., 401/403 vs 404) to user-visible states or logs if behavior changed.",
            "Step 6: Validate data usage and state updates\n- Confirm the new API response shape matches what the integration expects (field names, list vs single object, etc.).\n- If response fields changed, update parsing logic accordingly before storing data in `self.data` or entity state/attributes.\n- Ensure that any time-based throttling or email-rotation logic continues to work with the new calls.",
            "Step 7: Run formatting and validate non-code files\n- Run project-mandated formatting tools (e.g., Black) over the modified files.\n- After formatting, explicitly validate JSON/YAML and other non-Python files for syntax errors, especially trailing commas or quoting issues.\n- Fix any invalid JSON or config introduced by the formatter (e.g., remove trailing commas from the last element in `manifest.json`).",
            "Step 8: Add or update tests\n- Add tests or update existing ones to cover the configuration changes (presence of `api_key`).\n- Mock the HTTP calls to ensure that the correct URL, headers, and parameters are being used.\n- Add tests for failure scenarios (missing key, network errors, 401/403 responses).",
            "Step 9: Coordinate release and user communication\n- Note that requiring a new config field is a breaking change; ensure it is documented in release notes and component docs.\n- If the upstream API shutdown date is near, schedule the fix into a patch release so users are upgraded before the deadline.\n- Provide migration guidance, including example configuration snippets with the new key.",
            "Step 10: Post-deployment monitoring\n- Once deployed, monitor logs or issue trackers for authentication errors or unexpected response handling issues.\n- Be prepared to adjust to any subtle changes in the third-party API behavior not captured in the initial migration."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Implementation of a notify-based multi-factor authentication (MFA) module for Home Assistant using HOTP codes delivered via the notify service. Includes login flow integration, per-session OTP generation, retry limits, session expiration handling, non-persistent secret storage, and robust error handling for missing services and invalid codes.",
        "keywords": [
            "Home Assistant",
            "multi-factor authentication",
            "MFA",
            "notify",
            "HOTP",
            "pyotp",
            "auth.providers",
            "auth.mfa_modules.notify",
            "login_flow",
            "invalid_code",
            "MAX_RETRY_TIME",
            "MFA_SESSION_EXPIRATION",
            "session expiration",
            "secret storage",
            "include/exclude services"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set adds a new notify-based multi-factor authentication module to Home Assistant and refines the overall MFA login handling.\n\nThe new `notify` MFA module (`homeassistant/auth/mfa_modules/notify.py`) sends HOTP one-time codes through an existing `notify` service (e.g., SMS, email, push). The configuration schema allows specifying included/excluded notify services and a customizable message template. For each user, a `NotifySetting` is stored with the chosen notify service and target; HOTP secrets and counters are intentionally not persisted.\n\nOriginally, the module stored the HOTP secret and counter in persistent storage and advanced the counter on every validation attempt. Through several iterations, this was refactored: now a per-session secret and counter are generated only when the MFA login step starts, and they are kept in memory only. Persistent storage only keeps the association to the notify service and target. When a login MFA step is initiated (`async_initialize_login_mfa_step`), a new secret and random 8-digit-like counter are generated, a code is computed via `pyotp.HOTP`, and delivered via the configured notify service.\n\nThe generic MFA base class `MultiFactorAuthModule` gained a `MAX_RETRY_TIME` setting (default 3; the TOTP module overrides to 5). The login flow (`homeassistant/auth/providers/__init__.py`) now tracks `invalid_mfa_times` per flow. On each invalid MFA code, the counter increments and, if it reaches the module's `MAX_RETRY_TIME`, the flow aborts with `too_many_retry`. Additionally, a new constant `MFA_SESSION_EXPIRATION` (5 minutes) ensures that if the MFA step takes too long, the flow aborts with `login_expired`.\n\nThe login flow was also adjusted to:\n- Call `async_initialize_login_mfa_step` on the MFA module when first entering the MFA step (to generate and send the code) instead of relying on an ad-hoc `async_generate` API.\n- Treat both `invalid_auth` (bad username/password) and `invalid_code` (bad MFA) as failed login attempts, invoking `process_wrong_login` for both, so MFA failures are logged and rate-limited like normal password failures.\n\nThe notify module also implements include/exclude logic for notify services safely. It discovers `notify` services from `hass.services.async_services()` and returns the intersection with any configured `include` list minus any `exclude` entries. If no eligible services exist, the setup flow aborts with `no_available_service`.\n\nSeveral bugs and edge cases were fixed along the way:\n- Correctly loading stored user settings by reconstructing `NotifySetting` objects from dicts.\n- Ensuring type hints, assertions, and `None`-checks prevent runtime errors when `_user_settings` is not yet initialized.\n- Handling the case where the configured notify service no longer exists without raising exceptions during login; the code logs an error instead.\n- Ensuring test expectations around default MFA configuration (only TOTP is created by default; notify must be explicitly configured) and allowing for 3 retries in the notify MFA flow.\n\nNew tests were added or updated to cover validation, counter behavior, setup/teardown of users, login flow integration (valid and invalid codes, retries, aborts), notify service selection, include/exclude filtering, missing service behavior, and MFA session expiration.",
        "semantic_memory": "This work illustrates several generalizable patterns for implementing and hardening multi-factor authentication and login flows:\n\n1. **Use existing notification infrastructure for MFA**: Instead of building a new messaging channel, an MFA factor can be delivered through an existing notification subsystem (SMS, email, push). This requires only mapping users to a chosen notify service and target.\n\n2. **Separate persistent configuration from ephemeral secrets**: Only long-lived user preferences (e.g., selected notify service and target) should be persisted. Sensitive, short-lived data such as HOTP secrets and counters can be generated per session and held solely in memory. When persisting models with attr-based dataclasses, selective filtering (e.g., `attr.asdict(..., filter=attr.filters.exclude(...))`) prevents secrets from being written to disk.\n\n3. **Initialize MFA codes lazily per login session**: Generate one-time codes only when an MFA step is actually entered (e.g., via an `async_initialize_login_mfa_step` hook). This avoids unnecessary code generation and ensures each login session has its own fresh secret/counter.\n\n4. **Bounded retries and session expiration for MFA**: Track invalid MFA attempts per session and enforce `MAX_RETRY_TIME` to prevent brute-force attempts. Additionally, constrain the time window for an MFA step with a dedicated session expiration (here, `MFA_SESSION_EXPIRATION` of 5 minutes) independent of access token lifetime.\n\n5. **Unify error handling for MFA and password failures**: Treat invalid MFA codes similarly to invalid passwords from a security perspective. Both should contribute to login failure metrics, be rate-limited, and possibly trigger lockouts or IP throttling, so the system calls the same `process_wrong_login` logic for `invalid_code` as for `invalid_auth`.\n\n6. **Extensible MFA interface design**: MFA modules expose a small, coherent API: `async_setup_user`, `async_is_user_setup`, `async_validate`, optional `async_initialize_login_mfa_step`, and a `MAX_RETRY_TIME` attribute. The auth provider orchestrates login flows generically by consulting this interface; new MFA modules can be plugged in without changing core login logic.\n\n7. **Safe service discovery with include/exclude filters**: When integrating with a service registry (like notify services), gather available services and apply both include and exclude filters, with exclude having priority. This allows admins to limit which channels can be used for MFA while keeping discovery dynamic.\n\n8. **Comprehensive auth flow testing**: For authentication features, unit tests must simulate full flows across multiple steps: incorrect credentials, correct credentials leading to MFA, code sending, invalid codes, max retries aborting, session expiry, and eventual success. Mocking external calls (like notify service and pyotp) allows deterministic verification of side effects (e.g., message contents) without requiring actual external services.\n\n9. **Increment counters on generation, not validation, for HOTP**: For one-time-password implementations, it's often safer to advance counters or secrets when generating codes rather than on validation attempts, especially when there is a separate retry mechanism. This reduces drift and avoids burning codes just because a user mistypes input.\n\n10. **Use small, focused constants for auth timing**: Distinguish between general access token lifetimes and MFA session lifetimes. This enables tighter windows for sensitive operations (login/MFA) without affecting long-lived tokens.",
        "procedural_memory": [
            "When adding a new notify-based MFA module or debugging similar functionality, follow these steps:",
            "Step 1: Define the MFA module interface and configuration schema.",
            "  - Implement a class deriving from the MFA base (e.g., MultiFactorAuthModule) with methods: `async_setup_user`, `async_is_user_setup`, `async_validate`, and an optional initialization hook like `async_initialize_login_mfa_step`.",
            "  - Define a `CONFIG_SCHEMA` that extends the base MFA schema, including module-specific options such as included/excluded services and message template.",
            "  - Register the module in the MFA module registry so it can be instantiated from config.",
            "",
            "Step 2: Model user-specific settings and decide what to persist.",
            "  - Create a small data model (e.g., an `attr.s` class) for per-user settings. Include only long-lived, non-sensitive fields (such as `notify_service` and `target`) that must be persisted.",
            "  - For sensitive or ephemeral fields (e.g., HOTP `secret`, `counter`), define them with factory functions and exclude them from persistence using `attr.asdict` with `attr.filters.exclude(...)` when saving to storage.",
            "  - Implement storage load/save helpers (e.g., `_async_load`, `_async_save`) that reconstruct the in-memory model from stored dicts and gracefully handle missing data (`None` -> create empty dict).",
            "",
            "Step 3: Implement code generation and validation correctly.",
            "  - Wrap HOTP operations in small helpers like `_generate_secret`, `_generate_random`, `_generate_otp`, and `_verify_otp`. This centralizes crypto behavior and makes it testable.",
            "  - Generate new HOTP secrets and counters at the start of each MFA login step (inside `async_initialize_login_mfa_step`). Store them in memory-only fields on the user setting object.",
            "  - When validating (`async_validate`), retrieve the user's in-memory settings, return False if they are missing, and call the verify helper with the stored secret and counter.",
            "  - Do not advance counters during validation if you're using a separate retry tracking mechanism; let retries reuse the same code until a new MFA session is created.",
            "",
            "Step 4: Integrate MFA into the login flow.",
            "  - In the login flow handler, add an `async_step_mfa` that retrieves the chosen MFA module from the auth manager.",
            "  - When user_input is None (i.e., first visit to the MFA step), call the module's initialization hook (e.g., `async_initialize_login_mfa_step(user.id)`) if it exists so that it can generate and send the initial code.",
            "  - On subsequent POSTs with user_input, first check that the MFA session has not expired (e.g., `created_at + MFA_SESSION_EXPIRATION`), aborting with `login_expired` otherwise.",
            "  - Call `auth_module.async_validate(user.id, user_input)` and handle a False result by setting `errors['base'] = 'invalid_code'` and incrementing a per-flow `invalid_mfa_times` counter.",
            "  - Enforce a retry cap using `auth_module.MAX_RETRY_TIME` (e.g., abort with `too_many_retry` if `invalid_mfa_times >= MAX_RETRY_TIME`).",
            "  - Upon successful validation and no errors, call `async_finish(user)` to complete login.",
            "",
            "Step 5: Implement and test notify service selection with include/exclude.",
            "  - Implement a helper (e.g., `aync_get_available_notify_services`) that discovers existing `notify` services via `hass.services.async_services().get('notify', {})`.",
            "  - Filter the discovered services: remove any listed in `exclude`, and if `include` is defined, intersect the discovered set with `include`.",
            "  - In the setup flow (`NotifySetupFlow`), if no available services remain, abort with a clear reason like `no_available_service`.",
            "  - Provide a form where users select a notify service and optional target; generate and send a test code and verify it before saving the MFA configuration.",
            "",
            "Step 6: Handle error logging and security events uniformly.",
            "  - In the HTTP handler for login flows, check the result of each step. If the result is not a successful entry and `result['errors']['base']` is either `invalid_auth` or `invalid_code`, call the shared `process_wrong_login(request)` function to log and rate-limit failed attempts.",
            "  - Ensure that MFA failures are treated as security events, not just form-validation errors.",
            "",
            "Step 7: Write comprehensive tests for the full auth flow.",
            "  - Create unit tests for the MFA module alone: valid and invalid code verification, behavior when the user is not configured, and that no exceptions are raised when notify services are missing.",
            "  - Add integration tests for the login flow: bad username, bad password, correct credentials leading to MFA, sending codes via the notify service (using mocked services), invalid codes triggering retries, hitting the retry limit, restarting the flow after abort, and eventual success.",
            "  - Test include/exclude logic for notify services by registering multiple mock services and verifying that only the correct ones show up in `aync_get_available_notify_services`.",
            "  - Test session expiration by advancing time beyond `MFA_SESSION_EXPIRATION` and confirming that the MFA step aborts with `login_expired`.",
            "",
            "Step 8: Refactor and clean up iteratively.",
            "  - As issues surface (e.g., secrets being persisted, typos in method names, incorrect default MFA modules), correct them and add tests that would fail without the fix.",
            "  - Keep method names and semantics clear (`async_initialize_login_mfa_step` is more descriptive than a generic `async_generate`) so the login flow can discover optional behavior without ambiguity."
        ]
    }
}
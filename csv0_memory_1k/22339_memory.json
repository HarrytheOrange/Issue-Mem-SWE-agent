{
    "search_index": {
        "description_for_embedding": "Implemented per-camera preferences in Home Assistant, focusing on a `preload_stream` option that controls whether camera streams are started and kept alive on Home Assistant startup and when requesting streams. Added persistent storage for camera preferences, WebSocket APIs to get/update prefs, and wired the `keepalive` flag through the stream component so existing streams update their keepalive behavior.",
        "keywords": [
            "camera",
            "stream",
            "preload_stream",
            "keepalive",
            "Home Assistant",
            "camera preferences",
            "DATA_CAMERA_PREFS",
            "websocket API",
            "entity preferences",
            "hass.helpers.storage",
            "stream reuse"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set adds a preference system for camera entities in Home Assistant, centered around the ability to preload and keep camera streams alive.\n\nPreviously, the camera component had no per-entity configuration for whether a camera stream should be preloaded at startup or kept alive across requests. The `stream` component also did not adjust an existing stream's `keepalive` behavior when preferences changed; `keepalive` was only applied at stream creation time.\n\nTo address this, a new module `homeassistant/components/camera/prefs.py` was introduced along with a new constants module `camera/const.py`. The `CameraPreferences` class manages persistent per-entity camera preferences using `hass.helpers.storage.Store`, keyed by the camera's `entity_id`. A thin wrapper, `CameraEntityPreferences`, exposes preference accessors like `preload_stream` with sensible defaults.\n\nDuring `async_setup` of the camera component, a `CameraPreferences` instance is initialized and stored in `hass.data[DATA_CAMERA_PREFS]`. A `preload_stream` callback is registered on `EVENT_HOMEASSISTANT_START`. When Home Assistant finishes starting, this callback loops over all camera entities; for each camera that has a `stream_source` and whose preferences indicate `preload_stream == True`, it calls `request_stream` with `keepalive=True` to start and keep the stream alive.\n\nAll code paths that request camera streams were updated to respect these preferences:\n- `async_request_stream` (service wrapper) now looks up `camera_prefs` via `hass.data[DATA_CAMERA_PREFS].get(entity_id)` and calls `request_stream` with `keepalive=camera_prefs.preload_stream`.\n- The `camera/stream` WebSocket endpoint (`ws_camera_stream`) now uses the `preload_stream` flag when calling `request_stream`.\n- The `camera.play_stream` service handler (`async_handle_play_stream_service`) also uses `keepalive=camera_prefs.preload_stream`.\n\nOn the stream side, `homeassistant/components/stream/__init__.py` was updated: if a stream for a given `stream_source` already exists, `request_stream` now updates `stream.keepalive` to the latest value instead of leaving it unchanged. This ensures preference changes take effect even when reusing existing streams.\n\nTwo new WebSocket commands were added:\n- `camera/get_prefs` returns the current preferences for a given `entity_id` as a dict.\n- `camera/update_prefs` accepts fields like `preload_stream`, updates persistent storage via `CameraPreferences.async_update`, and returns the updated prefs dict in the WebSocket response.\n\nCamera domain constants (`DOMAIN`, `DATA_CAMERA_PREFS`, `PREF_PRELOAD_STREAM`) were moved into `camera/const.py`. Other components that used `DOMAIN` (e.g., `local_file`, `logi_circle`, `onvif`, `push`) were updated to import `DOMAIN` from `camera.const` instead of `camera.__init__`.\n\nA comprehensive set of tests were added or updated:\n- WebSocket tests for `camera_thumbnail`, `camera/stream`, `camera/get_prefs`, and `camera/update_prefs`.\n- Tests to ensure `preload_stream` preference is honored on `EVENT_HOMEASSISTANT_START` (both when false and true).\n- Updated stream tests to use `io.BytesIO()` for mock `stream_source`.\n- A helper `mock_camera_prefs` in `tests/components/camera/common.py` to seed camera preferences for tests.\n\nFinally, `websocket_update_prefs` was refined to return the updated preference dictionary to the frontend (instead of an empty result), making the API more immediately useful for UI components toggling the `preload_stream` option.",
        "semantic_memory": "This PR illustrates several reusable patterns and best practices for adding per-entity configuration and integrating it with existing streaming infrastructure in a home automation system.\n\nKey concepts:\n\n1. **Per-entity preference storage**: Instead of overloading core configuration or entity states, store user-configurable preferences in a dedicated, versioned storage layer keyed by `entity_id`. Use a small wrapper object (e.g., `CameraEntityPreferences`) to provide typed accessors and defaults while keeping the underlying storage flexible.\n\n2. **Centralized constants**: Create a `const.py` module for a component to define `DOMAIN`, data keys (`DATA_*`), and preference keys (`PREF_*`). This prevents circular imports and tight coupling between the main component module and its consumers.\n\n3. **Startup-triggered preloading**: When certain entities (like cameras) benefit from pre-warmed resources (e.g., active video streams), register an `EVENT_HOMEASSISTANT_START` callback that inspects per-entity preferences to decide what to preload. This pattern decouples startup behavior from static configuration and allows the frontend to toggle behavior at runtime without restart.\n\n4. **Respect preferences on each request**: Whenever a resource is requested (service calls, WebSocket commands, etc.), re-read the preferences and apply them (e.g., passing `keepalive` to `request_stream`). Do not assume that preferences are static across the lifetime of the process.\n\n5. **Updating shared resource options**: When multiple request paths can reuse a shared resource (like a video stream keyed by its source URL), `request_stream` should update existing resource options (e.g., `stream.keepalive`) instead of ignoring new values. This allows runtime preference changes to take effect without destroying and re-creating the resource.\n\n6. **WebSocket-based preference management**: For UI-driven configuration, define WebSocket commands for reading and updating preferences. Returning the updated preference object from update calls makes it easy for the frontend to synchronize state without extra round-trips.\n\n7. **Testing asynchronous and lifecycle behavior**: Tests should cover:\n   - WebSocket endpoints (request/response semantics, success/errors).\n   - Service handlers honoring new flags or preferences.\n   - Lifecycle events, such as startup preloading based on preferences.\n   - Interaction between multiple layers (camera component, stream component, storage) using mocks and fixtures.\n\nThese patterns generalize to any component that needs user-tunable runtime behavior (e.g., preloading, caching, logging levels, or performance-related toggles) on a per-entity basis, especially when a shared resource pool is involved.",
        "procedural_memory": [
            "When implementing or debugging per-entity preferences for streams or similar resources, follow this process:",
            "Step 1: Identify the behavior that should be user-controllable (e.g., whether camera streams are preloaded and kept alive). Define clear preference keys (like `PREF_PRELOAD_STREAM`) and a data namespace (`DATA_CAMERA_PREFS`).",
            "Step 2: Create a dedicated preferences manager for the component (e.g., `CameraPreferences`). Use `hass.helpers.storage.Store` or an equivalent persistence mechanism to load and save a simple dict keyed by `entity_id`.",
            "Step 3: Wrap raw preference dicts in a small helper class (e.g., `CameraEntityPreferences`) that exposes typed properties and defaults. This keeps calling code simple and makes it safe to call `prefs.get(entity_id)` even when no preferences exist yet.",
            "Step 4: Initialize the preferences manager in the component's setup (`async_setup`) and store it in `hass.data[DATA_*]` so it is easily accessible from services, WebSocket handlers, and other internal code.",
            "Step 5: Integrate preferences into all resource-request paths. For camera streams, this means updating:\n- The service helpers (e.g., `async_request_stream`).\n- Any WebSocket endpoints that request a stream (e.g., `camera/stream`).\n- Other service handlers that request streams (e.g., `play_stream`).\nEach of these should fetch the preferences and propagate relevant flags (e.g., `keepalive=camera_prefs.preload_stream`) down into the core `request_stream` function.",
            "Step 6: Ensure that your shared resource factory (e.g., `stream.request_stream`) respects updated options even when reusing existing instances. If a stream already exists for a given source, update its options (like `stream.keepalive`) so preference changes take effect immediately.",
            "Step 7: If behavior depends on system lifecycle (such as preloading on startup), register listeners on appropriate events (e.g., `EVENT_HOMEASSISTANT_START`). In the handler, iterate over relevant entities, read their preferences, and apply actions only when the preference is enabled and prerequisites (like `stream_source`) are present.",
            "Step 8: Expose preference read/update operations through an API suitable for the frontend, such as WebSocket commands:\n- A `get_prefs` command that returns the current preference dict for an entity.\n- An `update_prefs` command that validates input, calls the preferences manager's update method, persists changes, and returns the new prefs to the caller.",
            "Step 9: Update imports and constants to avoid circular dependencies. Move `DOMAIN` and related constants into a `const.py` module and update all component/platform modules to import from there.",
            "Step 10: Add tests that cover:\n- Initializing preferences and default values.\n- WebSocket `get_prefs` and `update_prefs` commands, including that `update` returns the new prefs.\n- Service handlers and WebSocket stream handlers using the preference-derived flags (mock `request_stream` and assert `keepalive` behavior indirectly).\n- Startup event handling: fire the startup event in tests and assert whether `request_stream` was called depending on `preload_stream` being true or false.",
            "Step 11: When debugging issues where streams are not kept alive or not preloaded as expected, check:\n- That `hass.data[DATA_CAMERA_PREFS]` is initialized and contains the correct entry for the `entity_id`.\n- That your handlers call `request_stream` with the intended `keepalive` argument.\n- That the `stream` component updates `stream.keepalive` when reusing an existing stream.\n- That the startup event callback is actually registered and invoked, and that entity `stream_source` properties are available at that time."
        ]
    }
}
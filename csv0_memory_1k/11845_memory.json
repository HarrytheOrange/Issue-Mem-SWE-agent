{
    "search_index": {
        "description_for_embedding": "Refactor of the Home Assistant Egardia/Woonveilig integration from a single alarm_control_panel platform into a generic hub component (egardia) that exposes both an alarm_control_panel and binary_sensor platforms. Shared connection & report-server logic moved to the main component, platforms now use hass.data and discovery. Added sensor support by creating binary sensors mapped from Egardia sensor metadata, and updated pythonegardia to 1.0.34.",
        "keywords": [
            "Egardia",
            "Woonveilig",
            "homeassistant.components.egardia",
            "alarm_control_panel.egardia",
            "binary_sensor.egardia",
            "hub component",
            "shared hass.data",
            "discovery.async_load_platform",
            "pythonegardia 1.0.34",
            "sensor support",
            "report_server",
            "Home Assistant integration refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The Egardia/Woonveilig integration in Home Assistant initially existed only as an alarm_control_panel platform (homeassistant/components/alarm_control_panel/egardia.py). It handled its own configuration, created an EgardiaDevice and EgardiaServer directly in the platform, and did not expose any of the panel’s physical sensors as Home Assistant entities. The PR re-architected this integration into a generic domain component with multiple platforms.\n\nA new top‑level component, homeassistant/components/egardia.py, was introduced with its own CONFIG_SCHEMA under the DOMAIN 'egardia'. It now parses all configuration (host, port, username, password, version, report server options), creates a single EgardiaDevice instance, and stores shared objects in hass.data (keys like 'egardiadevice', 'egardianame', 'egardia_rs_enabled', 'egardia_rs_codes', etc.). It also sets REQUIREMENTS = ['pythonegardia==1.0.34'] and updates requirements_all.txt accordingly.\n\nThe alarm_control_panel.egardia platform was rewritten to depend on this central component instead of directly reading YAML configuration. Its setup_platform now pulls the name, EgardiaDevice, and report server configuration from hass.data and constructs an EgardiaAlarm entity. The EgardiaAlarm entity is stored back in hass.data['egardia_dev'] so that the core component can later register its handle_status_event callback with the EgardiaServer. The platform no longer imports pythonegardia nor creates the server itself; that logic has been centralized.\n\nThe new egardia component uses discovery to load platforms. It uses discovery.listen_platform to wait for the alarm_control_panel platform to be loaded; once loaded and if report_server is enabled, it sets up a single EgardiaServer instance, binds it, starts it, and registers the EgardiaAlarm.handle_status_event callback. It also listens for EVENT_HOMEASSISTANT_STOP to stop the EgardiaServer cleanly. Additionally, it calls egardiasystem.getsensors() and uses discovery.async_load_platform to load a binary_sensor platform with discovered sensor metadata.\n\nA new binary_sensor platform, homeassistant/components/binary_sensor/egardia.py, was added. It defines a mapping from Egardia sensor types to Home Assistant device_class values (e.g., 'IR Sensor'/'IR' -> 'motion', 'Door Contact' -> 'opening') and converts sensor 'cond' values to ON/OFF states. async_setup_platform receives sensors via discovery_info['egardia_sensor'], instantiates EgardiaBinarySensor entities for each sensor, and registers them. EgardiaBinarySensor polls the shared EgardiaDevice via hass.data['egardiadevice'].getsensorstate(sensor_id) to update its state.\n\n.coveragerc was updated to omit both the new base component and all egardia platforms from coverage. A small linting fix was applied in binary_sensor/egardia.py to fix indentation. During CI, the author saw gen_requirements_all.py failing due to the apiai component even though their branch was clean; this was an external build issue and not caused by the Egardia changes. The PR was eventually superseded by a newer one, but the core design pattern remains: refactor to a generic component, centralize configuration and connectivity, and expose sensors as binary_sensor entities.",
        "semantic_memory": "This PR demonstrates a general integration pattern in Home Assistant and similar systems: when an external device/ecosystem exposes multiple entity types (e.g., an alarm panel plus sensors), it is best to model it as a hub or domain component responsible for connection management, shared state, and cross‑platform coordination, rather than duplicating that logic in each platform.\n\nKey generalizable concepts:\n\n1. **Centralizing configuration and connectivity**:\n   - Define a top‑level DOMAIN component with a CONFIG_SCHEMA that validates config for all sub‑platforms.\n   - Create a single client/device object (here, EgardiaDevice) in the domain setup, then store it in a shared container (hass.data or equivalent) for reuse across platforms.\n   - Avoid importing and instantiating external client libraries in multiple platform modules; this reduces duplication and connection issues.\n\n2. **Using shared state via hass.data (or equivalent)**:\n   - Use common keys in a central registry (hass.data) to share objects such as client instances, entities, configuration flags, and server handles between the main component and its sub‑platforms.\n   - Sub‑platforms read from this registry instead of parsing configuration themselves, making refactoring and multi‑platform setups easier.\n\n3. **Platform discovery and load ordering**:\n   - Use discovery mechanisms (discovery.async_load_platform, discovery.listen_platform) to orchestrate when to load dependent platforms and when to attach callbacks that require entities to exist.\n   - For example, start an external callback server (EgardiaServer) only after the alarm entity (EgardiaAlarm) has been created so you can immediately register its event handler.\n\n4. **Centralized external server/callback management**:\n   - When an integration requires a listening server or callback mechanism, instantiate and manage that server once in the domain component, not in each platform.\n   - Register platform entity callbacks (like handle_status_event) with this central server instance and ensure it is properly stopped when the host application shuts down.\n\n5. **Entity modeling of device sensors**:\n   - Translate physical or protocol‑level sensors into appropriate entity types (binary_sensor, sensor, etc.) and map protocol‑specific attributes to standardized fields (device_class, state).\n   - Implement clear mapping from device‑specific type strings to Home Assistant device_class values and from raw condition values to ON/OFF or other canonical states.\n\n6. **Dependency and project hygiene**:\n   - When bumping a library version (pythonegardia 1.0.34), update both the component’s REQUIREMENTS and the global requirements_all.txt to keep tooling like gen_requirements_all.py consistent.\n   - Maintain coverage configuration (.coveragerc) as the component structure changes, especially when adding new files or moving logic.\n\nThese patterns apply broadly to any modular home automation integration, microservice‑based system, or plugin architecture where multiple modules/plug‑ins share a common underlying connection or state.",
        "procedural_memory": [
            "Use a hub component pattern when a device or service powers multiple platforms (alarm, sensors, switches, etc.).",
            "Step 1: Identify duplicated or monolithic integration logic",
            "Review existing integration modules (e.g., alarm_control_panel.<device>) and identify where they duplicate configuration parsing, client instantiation, or server/callback management.",
            "Determine if the integration should expose more than one entity type (e.g., sensors, switches, binary_sensors) or if multiple platforms will share the same underlying device connection.",
            "Step 2: Introduce a top-level domain component",
            "Create a new module, e.g., homeassistant/components/<domain>.py.",
            "Define DOMAIN and CONFIG_SCHEMA for this component, including all necessary config keys (host, port, credentials, feature flags).",
            "In setup() (or async_setup()), import the external client library, instantiate a single device/client object, and handle connection/authorization errors cleanly (e.g., raising PlatformNotReady or logging UnauthorizedError).",
            "Store the instantiated client and other shared configuration values in hass.data (or an equivalent shared structure) under well-defined keys.",
            "Step 3: Move external server / callback logic into the domain component",
            "If the integration requires a listening server or callback handler (e.g., EgardiaServer), create and manage it in the domain component.",
            "Bind the server, start it, and store the server instance in hass.data so it can be reused or referenced by other parts of the integration.",
            "Register a listener on the host application's shutdown event (e.g., EVENT_HOMEASSISTANT_STOP) to stop the server cleanly.",
            "Step 4: Use discovery to load sub-platforms",
            "Use discovery.async_load_platform to load each relevant platform (alarm_control_panel, binary_sensor, sensor, etc.), passing discovery_info payloads when needed (e.g., sensor metadata).",
            "If callbacks must reference entities created in a platform, use discovery.listen_platform (or a similar hook) to wait until that platform is loaded before registering callbacks with your server.",
            "Step 5: Refactor platform modules to use shared state instead of config",
            "In each platform module (e.g., alarm_control_panel/<domain>.py):",
            "- Remove platform-specific PLATFORM_SCHEMA and direct parsing of config.yaml.",
            "- Replace it with setup_platform/async_setup_platform that reads the shared objects from hass.data (client, names, flags).",
            "- Instantiate entities using these shared objects and store back any global entity references (e.g., the alarm entity) into hass.data when necessary.",
            "Ensure platform modules no longer import heavy external dependencies directly if the main domain component already manages the client objects.",
            "Step 6: Model sensors as entities with proper device classes and state mapping",
            "In sensor or binary_sensor platforms, define mapping functions from protocol-specific sensor metadata (type, condition) to standardized Home Assistant values (device_class, ON/OFF).",
            "Create one entity per sensor record provided via discovery_info or fetched from the shared client object.",
            "Implement update/async_update to fetch state from the shared client (e.g., client.getsensorstate(sensor_id)) and convert it to the standardized state.",
            "Step 7: Update dependencies and project configuration",
            "If you upgrade or change the external library version, update both the component’s REQUIREMENTS constant and any project-wide requirements files (e.g., requirements_all.txt).",
            "Run script/gen_requirements_all.py (or its equivalent) to ensure dependency lists stay consistent; investigate failures that mention other components as they may indicate a global issue rather than a problem in your changes.",
            "Update .coveragerc (or similar coverage config) to add or adjust coverage rules for new files and moved logic, avoiding redundant or missing entries.",
            "Step 8: Handle CI and external tool failures",
            "If CI fails with errors in modules you did not touch (like gen_requirements_all.py failing on another component), verify your local fork is up to date with upstream and re-run the tooling.",
            "If the failure persists, it may be a global or upstream issue; coordinate with maintainers rather than attempting to patch unrelated components in your feature branch.",
            "Step 9: Test and validate end-to-end behavior",
            "Run unit tests and integration tests (`tox`, or equivalent), focusing on both the new domain component and all platforms that use it.",
            "Verify that:",
            "- The main component sets up without errors and handles wrong credentials gracefully.",
            "- The alarm entity functions as before (arm, disarm, triggered states).",
            "- Binary sensors (or other new platforms) appear correctly, with correct device classes and state updates.",
            "- The external callback server (if any) starts and stops correctly and updates entity states in response to events."
        ]
    }
}
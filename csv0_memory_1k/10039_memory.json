{
    "search_index": {
        "description_for_embedding": "Home Assistant Google Assistant integration: add support for color temperature and RGB color for lights, correctly advertise color temperature ranges, and change the default behavior so unsupported Google Assistant commands no longer map to a turn_off service (preventing accidental device shutdown). Also improve QUERY responses with color state and fix handling when no service is returned.",
        "keywords": [
            "Home Assistant",
            "Google Assistant",
            "smart_home",
            "http",
            "determine_service",
            "color temperature",
            "RGB color",
            "Kelvin mired conversion",
            "unsupported command",
            "default action",
            "accidental turn_off",
            "QUERY intent",
            "EXECUTE intent",
            "light.ATTR_RGB_COLOR",
            "light.ATTR_KELVIN",
            "ATTR_SUPPORTED_FEATURES"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Google Assistant integration needed two major improvements: better light color support and safer handling of unsupported commands.\n\nOriginally, the smart_home.determine_service() function had a problematic default: if it couldn't match an incoming Google Assistant command to a known action, it returned SERVICE_TURN_OFF for the entity. This meant that an unsupported or mis-specified Google Assistant command could unexpectedly turn off a light or other device, which was reported in issue #10026.\n\nAt the same time, the integration did not yet support color temperature or RGB color for lights, nor did it expose color information properly in QUERY responses, and Actions on Google requires color capability metadata (min/max temperature) for devices that support color temperature.\n\nThe fix implemented several changes:\n\n1. Color support in SYNC and QUERY:\n- entity_to_device(entity) was extended so that when a light exposes the TRAIT_COLOR_TEMP trait, it calculates temperatureMinK and temperatureMaxK based on the light's ATTR_MAX_MIREDS and ATTR_MIN_MIREDS attributes, using homeassistant.util.color.color_temperature_mired_to_kelvin(). These attributes are added under device['attributes'], satisfying Google Actions requirements.\n- query_device(entity) was updated to include color state in QUERY responses when the light supports color temperature or RGB (based on ATTR_SUPPORTED_FEATURES with light.SUPPORT_COLOR_TEMP or light.SUPPORT_RGB_COLOR). It now returns a 'color' object with:\n  - temperature: current color temperature converted from mireds to Kelvin.\n  - name: ATTR_COLOR_NAME if available.\n  - spectrumRGB: an integer RGB representation derived from ATTR_RGB_COLOR using color.color_rgb_to_hex() and then interpreting the hex string as base-16.\n\n2. Color support in EXECUTE:\n- determine_service() now handles COMMAND_COLOR (action.devices.commands.ColorAbsolute). It reads params['color'] and:\n  - If color.temperature > 0, sets service_data[light.ATTR_KELVIN] to the given temperature and returns (SERVICE_TURN_ON, service_data).\n  - Else, if color.spectrumRGB > 0, converts the integer into a 6-character hex string, then into an RGB triplet via color.rgb_hex_to_rgb_list(), and sets service_data[light.ATTR_RGB_COLOR] accordingly, again returning (SERVICE_TURN_ON, service_data).\n- Tests were added to validate these behaviors, including pure temperature changes and RGB-only changes (e.g., blue, yellow).\n\n3. Safer handling of unsupported commands:\n- determine_service()'s default behavior was changed. Previously, the fallthrough case returned (SERVICE_TURN_OFF, service_data) for any unrecognized command. Now:\n  - COMMAND_ACTIVATESCENE maps to SERVICE_TURN_ON as before.\n  - COMMAND_ONOFF maps explicitly: 'on': true → SERVICE_TURN_ON; 'on': false → SERVICE_TURN_OFF.\n  - Any other command that is not explicitly handled (e.g., a malformed or unsupported ColorAbsolute payload, such as a 'color' object with no 'temperature' or 'spectrumRGB') returns (None, service_data) instead of turning the device off.\n- In homeassistant/components/google_assistant/http.py, handle_execute() was updated to respect this behavior:\n  - success is initialized to False for each device.\n  - It only calls hass.services.async_call(domain, service, service_data, blocking=True) if service is not None.\n  - This prevents accidental device shutdowns when no valid mapping exists for a command.\n- Tests were added for the 'unhandled action/service' case, asserting that determine_service() returns (None, {'entity_id': 'light.test'}) when given a ColorAbsolute command with no usable color parameters.\n\n4. Additional cleanups and merge fixes:\n- Temporary _LOGGER.debug() dumps of params and device dicts were removed after development.\n- A previously added deviceInfo block (manufacturer/model/firmware) was removed from entity_to_device(), as it is not part of the device state for Google Assistant in this context.\n- After merges, the climate.DOMAIN attribute handling (availableThermostatModes, thermostatTemperatureUnit) was re-ordered so that it no longer disrupts the light-specific color temperature attribute setup. The climate attributes are now set after the trait-based processing block.\n- Tests for QUERY and EXECUTE were updated to account for the new color semantics (including specific expectations for spectrumRGB, temperature, and the number of command results returned in the EXECUTE response).\n\nThe net result is that Home Assistant's Google Assistant integration now correctly supports color temperature and RGB color for lights, reports accurate capabilities and state to Google, and no longer performs a destructive 'turn_off' operation when faced with unsupported commands.",
        "semantic_memory": "This fix highlights several generalizable best practices for integrating with external smart home platforms and handling device capabilities:\n\n1. Never use a destructive action as a default fallback:\nWhen mapping generic external commands to internal services, the fallback behavior must be conservative. Returning 'turn_off' for any unrecognized command is dangerous: unexpected payloads, version mismatches, or partial implementations can cause devices to turn off without explicit user intent. A safer pattern is to return 'no-op' (e.g., service=None) and report an error or unsupported status back to the caller. This significantly reduces the risk of unintended side effects.\n\n2. Explicit command mapping and separation of concerns:\nThe command routing logic (determine_service) should map specific external commands to internal services in an explicit, easily testable way:\n- COMMAND_ONOFF → SERVICE_TURN_ON / SERVICE_TURN_OFF\n- COMMAND_COLOR → light color/temperature services\n- COMMAND_ACTIVATESCENE → service that activates a scene\nAnything not explicitly handled should be treated as unsupported. The HTTP layer or protocol adapter should interpret 'no service' as an error, not as 'turn_off'. This separation keeps protocol handling logic straightforward and robust.\n\n3. Use canonical attribute names and helpers for cross-model conversions:\nSmart home integrations often need to convert between different representations of capabilities and state:\n- Color temperature: platform uses mired (MIRED) internally; external API expects Kelvin. The fix leverages a dedicated utility (color_temperature_mired_to_kelvin) instead of ad-hoc math, ensuring consistent and tested behavior.\n- RGB color: platform uses tuples (R, G, B); external API uses integer spectrumRGB. Using helper functions (color_rgb_to_hex, rgb_hex_to_rgb_list) avoids off-by-one or formatting errors and makes the logic clearer.\nThese helpers encapsulate domain-specific knowledge, making the integration less error-prone.\n\n4. Capabilities must match traits and state:\nIf a device advertises a trait such as color temperature (TRAIT_COLOR_TEMP), the integration must also:\n- Advertise capability ranges (temperatureMinK, temperatureMaxK) derived from actual device attributes (ATTR_MAX_MIREDS, ATTR_MIN_MIREDS).\n- Provide corresponding state in QUERY responses (current color temperature, RGB, optional color name).\nThis alignment ensures the external platform has accurate information about what the device can do, avoids validation errors, and matches user expectations.\n\n5. Rely on supported_features to drive behavior:\nRather than hard-coding assumptions, use ATTR_SUPPORTED_FEATURES (plus constants like SUPPORT_COLOR_TEMP, SUPPORT_RGB_COLOR) to decide when to expose color capabilities and state. This pattern allows a single integration to work across devices with different feature sets (plain dimmer vs RGB vs tunable white) without special-casing each model.\n\n6. Tests as guards for protocol behavior:\nAdding explicit tests for:\n- Color temperature and RGB conversions.\n- QUERY responses that include correct brightness and color data.\n- EXECUTE flows that update device state as expected.\n- Unhandled/unsupported commands returning None and not altering device state.\nThese tests encode the contract between the external platform and the integration, preventing regressions when refactoring.\n\n7. Avoid leaking non-spec attributes in protocol responses:\nEven if internal entities have manufacturer, model, or firmware information, they should only be exposed to the external platform in ways that are consistent with the external spec. Adding custom fields (like deviceInfo) in the wrong part of the payload can cause validation issues. The fix explicitly removes deviceInfo from the device state representation for Google Assistant.\n\n8. Merge-time re-validation of capabilities:\nWhen merging changes that touch shared structures (like entity_to_device), it is easy to introduce bugs by changing ordering or scoping (e.g., climate vs light attributes). Re-validating that all previously supported traits still get their required attributes after merges is critical, and tests that cover multiple domains (lights, climate) help catch such issues.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and characterize the problem\n- Trigger the problematic behavior through the external platform (e.g., Google Assistant) using real or simulated devices.\n- Observe unexpected side effects, such as devices turning off when an unsupported or malformed command is sent.\n- Inspect logs and payloads to see which external command and parameters are being received (e.g., ColorAbsolute with unusual color payloads).",
            "Step 2: Locate the command-to-service mapping logic\n- Identify the function or module that maps external commands to internal service calls (in this case, determine_service in smart_home.py and the EXECUTE handler in http.py).\n- Review the control flow for each command type handled (ON/OFF, scenes, color, etc.), and specifically examine the default or fallback case at the end of the routing logic.",
            "Step 3: Ensure the fallback behavior is non-destructive\n- If the default behavior invokes a strong side-effect (e.g., turning off a device), replace it with a safe default:\n  - Return an indication of \"no-op\" or \"unsupported\" (e.g., (None, service_data)).\n- Make sure the caller (HTTP handler or adapter) checks for this condition and does not fire any service call when no service is provided.\n- Initialize any related flags (like success) defensively to avoid using uninitialized variables when no service is called.",
            "Step 4: Add or refine support for new capabilities (e.g., color)\n- Identify the external command that corresponds to the capability (e.g., action.devices.commands.ColorAbsolute / COMMAND_COLOR).\n- Map its parameters to the internal platform's attribute model:\n  - For color temperature: map color.temperature (Kelvin) to internal light.ATTR_KELVIN.\n  - For RGB color: map color.spectrumRGB (integer) to an (R, G, B) tuple using a helper (integer → hex string → RGB list), then set light.ATTR_RGB_COLOR.\n- Return a suitable service (typically SERVICE_TURN_ON) along with the prepared service_data.",
            "Step 5: Advertise capabilities and state correctly in SYNC/QUERY\n- In the device description function (e.g., entity_to_device), ensure traits accurately reflect the device features based on ATTR_SUPPORTED_FEATURES.\n- When a trait requires specific metadata (e.g., color temperature ranges), compute and expose it from existing attributes (e.g., ATTR_MAX_MIREDS and ATTR_MIN_MIREDS converted to Kelvin using a helper).\n- In the QUERY handler (e.g., query_device), enrich the response with state fields that match both the external spec and the advertised traits (e.g., include color.temperature and color.spectrumRGB only when the device supports them).",
            "Step 6: Use helper utilities for unit and format conversions\n- Avoid manual math and string operations for domain-specific conversions. Instead, use existing helpers:\n  - For color temperatures, use color_temperature_mired_to_kelvin and the platform's own attributes (ATTR_COLOR_TEMP).\n  - For RGB conversions, use color.color_rgb_to_hex and color.rgb_hex_to_rgb_list to move between internal tuples and external integer representations.\n- This ensures consistency, easier maintenance, and reduces the risk of off-by-one or formatting bugs.",
            "Step 7: Align integration data with the external platform's specification\n- Verify that all fields sent in SYNC and QUERY payloads conform to the external specification.\n- Remove or relocate any non-spec fields (e.g., deviceInfo in a state payload) that might cause issues.\n- For domain-specific devices (like climate), ensure the attributes (availableThermostatModes, thermostatTemperatureUnit, etc.) are placed in the correct portion of the device description and do not interfere with other traits.",
            "Step 8: Add focused tests for new behavior and regressions\n- Add unit tests that cover:\n  - Correct mapping of color.temperature and color.spectrumRGB into internal attributes and services.\n  - QUERY responses that include correct brightness and color state for a representative device.\n  - EXECUTE flows that update device state as expected (e.g., color temperature and RGB for a light) and handle unsupported commands gracefully.\n  - The unhandled-action case returning (None, service_data) and resulting in no service call.\n- Adjust expectations for response shapes (e.g., number of commands in payload['commands']) as new scenarios are added.",
            "Step 9: Re-test across domains and after merges\n- After making changes and merging branches, run the full test suite and re-validate:\n  - Lights: ensure brightness, on/off, and color/temperature still work end-to-end.\n  - Climate devices: ensure their attributes (operation modes, units) are still correctly exposed and haven't been disturbed by changes to shared code.\n- If ordering or scoping changes occurred in shared functions, verify that trait-specific attributes are still set correctly for each domain."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor of StackStorm RBAC utilities to decouple them from pecan.request. All request_user_* helpers in st2common.rbac.utils were removed or converted to user_* functions that accept a user_db object. Controllers and RBAC decorators now fetch user_db from the HTTP request (pecan.request) at the edges and pass it into framework-agnostic RBAC utility functions. get_requester() was updated to use rbac_utils.get_user_db_from_request. This reduces coupling to the web framework, improves testability, and centralizes admin/permission checks around explicit user objects rather than global request state.",
        "keywords": [
            "RBAC",
            "authorization",
            "admin check",
            "pecan.request",
            "StackStorm",
            "st2common.rbac.utils",
            "request_user_is_admin",
            "user_is_admin",
            "get_user_db_from_request",
            "framework coupling",
            "refactor",
            "decorators",
            "controllers",
            "keyvalue API",
            "rules API",
            "actionexecutions",
            "aliasexecution",
            "packviews",
            "AccessDeniedError",
            "ResourceAccessDeniedError"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request refactors StackStorm's RBAC utilities to remove their direct dependency on pecan.request and HTTP-layer concerns.\n\nPreviously, st2common.rbac.utils exposed many helpers like request_user_is_admin, request_user_is_system_admin, request_user_has_role, request_user_has_permission, request_user_has_resource_db_permission, and request_user_has_rule_trigger_and_action_permission. These functions internally pulled the authenticated user from pecan.request.context and performed permission checks. As a result, a core RBAC module depended directly on the web framework and on the global request object, making it harder to test and to reuse in non-HTTP contexts.\n\nIn this refactor, the RBAC utility API is redesigned around user_db-centric functions:\n- New or emphasized functions: user_is_admin, user_is_system_admin, user_has_role, user_has_permission, user_has_resource_api_permission, user_has_resource_db_permission, user_has_rule_trigger_permission, user_has_rule_action_permission, and assert_* equivalents that accept user_db explicitly.\n- Old request_* functions are removed from the public API. The assert_* functions are renamed and updated (e.g., assert_request_user_is_admin -> assert_user_is_admin) and no longer fetch the user themselves; instead they require a user_db argument.\n\nAll HTTP controllers and decorators that previously called request_* helpers are updated to:\n- Obtain a user_db from the request via rbac_utils.get_user_db_from_request(request=pecan.request).\n- Call the new user_db-based assert_* functions instead of the old request_* ones.\n\nExamples of this change:\n- BaseRestControllerMixin._get_mask_secrets now does:\n  - user_db = rbac_utils.get_user_db_from_request(request=request)\n  - if show_secrets and rbac_utils.user_is_admin(user_db=user_db): mask_secrets = False\n\n- ActionExecutionsController._handle_schedule_execution:\n  - user_db = rbac_utils.get_user_db_from_request(request=pecan.request)\n  - assert_user_has_resource_db_permission(user_db=user_db, resource_db=action_db, permission_type=PermissionType.ACTION_EXECUTE)\n  - assert_user_is_admin_if_user_query_param_is_provided(user_db=user_db, user=user)\n\n- KeyValueController methods (get_one, get_all, put, delete) now:\n  - Fetch user_db once from the request.\n  - Use rbac_utils.user_is_admin(user_db=user_db) for admin decisions.\n  - Use assert_user_is_admin_if_user_query_param_is_provided(user_db=user_db, user=user) instead of the request-based variant.\n\n- PackViewsController.get_one now fetches user_db and calls assert_user_has_resource_db_permission(user_db=..., resource_db=pack_db, permission_type=PermissionType.PACK_VIEW) for non-whitelisted paths.\n\n- RulesController.post/put now call assert_user_has_rule_trigger_and_action_permission(user_db=user_db, rule_api=rule) after converting the API object to a model.\n\nThe RBAC decorators (in st2common.rbac.decorators) are also updated to be the only places that touch pecan.request for RBAC checks. Each decorator now:\n- Retrieves user_db = utils.get_user_db_from_request(request=pecan.request) inside the wrapper.\n- Calls the corresponding assert_user_* or assert_user_has_* function with that user_db.\n\nAdditionally, st2common.util.api.get_requester is generalized to accept an optional request parameter and now delegates user resolution to rbac_utils.get_user_db_from_request. This keeps the logic for extracting the user from the request in a single place. If no user is found, it logs a warning and returns the configured system_user name as before.\n\nassert_user_is_admin_if_user_query_param_is_provided is updated to accept user_db and an optional request (defaulting to pecan.request). It retrieves the requester_user via get_user_db_from_request and compares the supplied user parameter (a string) to requester_user.name (with fallback to the system user) to decide if admin privileges are required.\n\nUnit tests that specifically exercised request_* helpers in test_rbac_utils.py are removed because those functions no longer exist. The remaining tests continue to verify the behavior of user_is_system_admin, user_is_admin, and user_has_role.\n\nOverall, the incident addressed here is not a runtime bug but an architectural smell: core RBAC utilities were tightly bound to the web framework. The fix is a systematic refactor that moves pecan.request handling to the edges (controllers/decorators) and makes RBAC utilities operate on explicit user_db objects. This improves modularity, testability, and future reuse in non-HTTP environments.",
        "semantic_memory": "Generalizable lessons from this change:\n\n1. **Decouple core authorization logic from the web framework and global request state.**\n   RBAC/authorization utilities should work with pure domain objects (e.g., user_db, resource_db) and not depend on framework-specific objects like HTTP requests, contexts, or global thread-locals. This makes them usable from CLI tools, background workers, and tests without having to mock the entire web stack.\n\n2. **Push framework-specific concerns to the edges.**\n   The correct layering is: controllers and decorators (HTTP layer) know about pecan.request and call into RBAC utilities with explicit arguments. The RBAC module itself only knows about domain concepts (users, roles, permissions, resources). This reduces coupling and makes each layer easier to reason about.\n\n3. **Prefer explicit dependencies over hidden globals.**\n   Functions like request_user_is_admin hide where their data comes from (global request context) and are hard to reason about and test. By replacing them with user_is_admin(user_db) and leaving it to the caller to supply user_db, you:\n   - Clarify which inputs the function needs.\n   - Make it trivial to unit-test with synthetic user_db objects.\n   - Avoid surprises due to missing or misconfigured global state.\n\n4. **Maintain a single, centralized translation from framework objects to domain objects.**\n   The function get_user_db_from_request becomes the single point where the code understands how to extract a user from an HTTP request. All other code works with user_db. This is a good pattern: one place knows the mapping from framework world to domain world.\n\n5. **Use decorators to enforce cross-cutting concerns at the edges.**\n   RBAC decorators wrap controller methods and handle authentication/authorization before executing the core business logic. They are ideal places to interact with pecan.request and to call user-db-based RBAC helpers. This keeps the controllers cleaner and reduces duplication of permission checks.\n\n6. **When refactoring APIs, align assert_* and query functions around the same data model.**\n   The refactor consistently moves from request_user_* to user_* for both query (user_has_*) and assert (assert_user_*) functions. This consistency improves discoverability and reduces cognitive load.\n\n7. **Be careful when changing how the current user is resolved.**\n   get_requester and assert_user_is_admin_if_user_query_param_is_provided both changed to use get_user_db_from_request for identifying the current user, and comparisons now rely on user_db.name with sensible fallbacks. When making such changes, ensure semantics stay consistent (e.g., how system users are handled) and that all call sites still behave correctly under both auth-enabled and auth-disabled configurations.\n\nOverall pattern: design RBAC and other core services as framework-agnostic libraries, and adapt them to specific frameworks at entry points (controllers, middleware, decorators) where requests are first received.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving RBAC or core utilities being too tightly coupled to a web framework:",
            "Step 1: Identify framework-dependent code in core modules.",
            "Search for imports of web framework modules (e.g., pecan, Flask, Django) and global request/context usage inside core utility modules (like RBAC, business logic, data access). Functions named request_* or that access thread-local request/context objects are red flags.",
            "Step 2: Define framework-agnostic function signatures.",
            "For each framework-dependent function, design an equivalent that accepts explicit domain objects instead of a request. For example, replace request_user_is_admin(request) with user_is_admin(user_db), request_user_has_resource_db_permission(request, resource_db, perm) with user_has_resource_db_permission(user_db, resource_db, perm), etc.",
            "Step 3: Implement the new user-centric helpers.",
            "Implement new helpers in the core module that operate solely on domain objects (user_db, resource_db, rule_api, etc.). Move the actual permission logic into these helpers. Do not import the web framework or access global request state here.",
            "Step 4: Refactor assertion helpers to use the new core helpers.",
            "If you have assert_* functions, update them to accept user_db and to call the new user_has_* functions. For example, assert_user_is_admin(user_db) uses user_is_admin(user_db); assert_user_has_resource_db_permission(user_db, resource_db, perm) uses user_has_resource_db_permission(user_db, resource_db, perm). Remove or deprecate any assert_request_* variants.",
            "Step 5: Centralize request-to-user translation.",
            "Create or reuse a helper like get_user_db_from_request(request) in a thin adapter layer. This function knows how to pull the authenticated user from the HTTP request context and returns a user_db object (or None). Keep this logic out of core modules.",
            "Step 6: Update controllers and decorators to use the new API.",
            "In controllers and decorators:\n- Fetch user_db = get_user_db_from_request(request=pecan.request or equivalent).\n- Replace calls to request_user_* or assert_request_* with calls to the new user_* or assert_user_* functions, passing user_db explicitly.\n- Ensure any logic that depends on admin checks, resource permissions, or rule-trigger/action permissions now uses the new helpers.",
            "Step 7: Adjust auxiliary utilities like get_requester.",
            "If you have utilities that previously inspected the request directly to find the current user, refactor them to accept an optional request parameter and delegate user resolution to the centralized get_user_db_from_request. Maintain existing behavior (e.g., fall back to a system user when auth is disabled), but route all user lookup logic through one place.",
            "Step 8: Clean up and update tests.",
            "Remove or rewrite tests that specifically target the old request_* helpers. Add or extend tests for user_* helpers and for any decorators/controllers that now use them. Use synthetic user_db fixtures instead of mocking the whole request stack when possible.",
            "Step 9: Verify behavior under different configuration modes.",
            "Test your changes with auth on and off, RBAC on and off, and as different user roles (system admin, admin, regular user). Confirm that permission checks still behave as expected, especially around features like `user` query parameters that require admin privileges.",
            "Step 10: Monitor for subtle changes in identity comparison semantics.",
            "When changing how you compare the requested user vs the authenticated user (e.g., string username vs user_db.name with fallback to a system user), carefully review for edge cases. Add tests to cover scenarios where `user` is omitted, matches the current user, or refers to another user, and ensure admin checks are enforced correctly."
        ]
    }
}
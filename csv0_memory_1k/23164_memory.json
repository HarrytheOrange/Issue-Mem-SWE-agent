{
    "search_index": {
        "description_for_embedding": "Home Assistant Homematic integration was always resolving the configured host to an IP address before passing it to pyhomematic. This broke SSL/TLS certificate validation because certificates are typically issued for hostnames, not raw IPs. The fix passes the configured host string directly to pyhomematic and removes the unused socket import.",
        "keywords": [
            "Home Assistant",
            "homematic",
            "pyhomematic",
            "SSL",
            "TLS",
            "certificate validation",
            "hostname vs IP",
            "socket.gethostbyname",
            "integration configuration",
            "CONF_HOST",
            "network configuration bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Homematic component had a subtle bug in how it handled host configuration for connections to pyhomematic. The configuration option `host` could be set to a hostname (e.g., `ccu.example.com`) or an IP address. However, the integration was unconditionally resolving this value to an IP via `socket.gethostbyname` and then passing that IP to pyhomematic as the `'ip'` field in the remotes dictionary.\n\nThis behavior caused SSL/TLS certificate validation to fail when using HTTPS with certificates bound to the hostname. Certificates are generally issued for fully qualified domain names, so when the client connects via an IP address, the certificate's Common Name or SAN does not match the connection host, resulting in validation errors or making proper validation impossible.\n\nThe fix was small but important: instead of wrapping `CONF_HOST` with `socket.gethostbyname`, the code now passes the configured host string as-is to pyhomematic for both interface and host configurations. Specifically:\n- In the `setup` function for Homematic, for each remote in `CONF_INTERFACES`, the `'ip'` field is now set to `rconfig.get(CONF_HOST)` instead of `socket.gethostbyname(rconfig.get(CONF_HOST))`.\n- Similarly, for each remote in `CONF_HOSTS`, the `'ip'` field is now set to `sconfig.get(CONF_HOST)` instead of a resolved IP.\n\nAfter these changes, the `socket` module was no longer used anywhere in `homeassistant/components/homematic/__init__.py`, so its import was removed. The pyhomematic maintainer confirmed that passing the hostname is acceptable and that renaming the `'ip'` key to `'host'` in pyhomematic was not necessary at this time. The change restored the ability to use SSL certificate validation with Homematic by ensuring the original hostname reaches the underlying library.",
        "semantic_memory": "This fix illustrates a common pitfall in networked applications involving SSL/TLS: prematurely resolving hostnames to IP addresses can break or complicate certificate validation. TLS certificates are tied to hostnames (CN/SAN), and verification routines typically compare the certificate's hostname against the hostname used to establish the connection, not the raw IP address.\n\nKey generalizable ideas:\n1. **Preserve the original hostname for TLS connections**: When an API accepts a host parameter, and there is any chance SSL/TLS will be used, pass the original host string through whenever possible rather than resolving to an IP. Let the underlying TLS/HTTP library perform DNS resolution so it can properly associate the certificate with the hostname.\n\n2. **Avoid unnecessary DNS resolution in application code**: Manually calling `socket.gethostbyname` or similar before passing the host to lower-level libraries can:\n   - Break hostname-based security mechanisms (TLS validation, SNI).\n   - Remove flexibility (e.g., switching targets via DNS, load balancing, split-horizon DNS).\n   - Introduce errors in environments with special DNS setups.\n\n3. **Configuration semantics need to align with usage**: If a configuration option is documented as `host`, treat it as a generic host identifier (hostname or IP) and do not silently transform it unless there is a strong, documented reason.\n\n4. **Small interface mismatches can have large security implications**: Here, the library `pyhomematic` expected an identifier (unfortunately named `'ip'`), but the calling code enforced a stricter interpretation (always an IP). This mismatch made it hard or impossible to use TLS correctly, even though the underlying library and environment could have supported it.\n\n5. **Clean up unused imports after refactoring**: Once the resolution logic was removed, the `socket` import became dead code and was correctly removed, reducing clutter and potential confusion.\n\nOverall best practice: when designing or maintaining integrations that support SSL/TLS, maintain the integrity of the hostname throughout the connection stack and avoid unnecessary transformations that may undermine the security model.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify SSL/TLS validation symptoms\n- Observe that SSL/TLS connections fail when using a hostname but either work when disabling certificate verification or cannot be made to validate properly.\n- Check error logs for messages about hostname mismatch, certificate common name mismatch, or similar TLS errors.",
            "Step 2: Inspect configuration and connection parameters\n- Review user-facing configuration options related to the remote host (e.g., `host`, `server`, `url`).\n- Determine whether users are expected to provide hostnames, IP addresses, or either.\n- Confirm how these config values are used in code when establishing network connections.",
            "Step 3: Check for manual DNS resolution in the integration\n- Search the integration/component for calls such as `socket.gethostbyname`, `getaddrinfo`, or any custom DNS resolution logic.\n- Verify if the result of this resolution is what gets passed to the underlying HTTP/TLS client or external library.\n- Identify places where hostnames from configuration are converted to IPs unnecessarily.",
            "Step 4: Verify expectations of underlying libraries\n- Inspect the third-party libraryâ€™s documentation (e.g., pyhomematic) to see how it interprets the connection parameters (`host`, `ip`, `address`).\n- Confirm that it can accept a hostname even if the parameter is unfortunately named `ip`.\n- Reach out to the library maintainer if unclear, as was done with pyhomematic in this PR.",
            "Step 5: Modify the code to preserve hostnames\n- Replace `socket.gethostbyname(config.get(CONF_HOST))` with direct usage of `config.get(CONF_HOST)` wherever SSL-capable connections are established.\n- Apply this change uniformly across all relevant configuration paths (e.g., interfaces and hosts sections).\n- Ensure that the final value passed down is exactly what the user has configured, unless there is a compelling reason to alter it.",
            "Step 6: Clean up related code\n- After removing manual resolution, remove any now-unused imports such as `socket`.\n- Run tooling (linters, static analysis) to detect unused imports or dead code related to the old approach.",
            "Step 7: Test the changes locally\n- Configure the integration with a hostname that has a valid TLS certificate.\n- Confirm that the connection succeeds with certificate verification enabled.\n- Optionally, test with both hostnames and raw IPs to ensure no regression for users who prefer direct IP configuration.",
            "Step 8: Add or update documentation and comments\n- If relevant, document that the `host` configuration accepts hostnames and that hostnames are recommended for TLS usage.\n- Optionally add inline comments near the connection code explaining why the hostname is intentionally not resolved early (to preserve TLS hostname validation).",
            "Step 9: Run the full test suite and integration-specific tests\n- Execute unit tests and integration tests to ensure the change does not break other behavior.\n- If possible, add tests that simulate or verify that the host string is passed unchanged (e.g., mocking the client and capturing the parameter).",
            "Step 10: Review for broader applicability\n- Check other integrations or similar components in the project for the same anti-pattern (manual DNS resolution before TLS) and plan similar fixes if found.\n- Share the pattern with the team so future code avoids breaking TLS hostname verification by converting hostnames to IPs prematurely."
        ]
    }
}
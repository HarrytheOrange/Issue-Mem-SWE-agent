{
    "search_index": {
        "description_for_embedding": "Added advanced filtering support to the StackStorm API list endpoints (notably action executions) via a new 'filter' query parameter that allows field-path:value tokens, validates model fields, and returns clear 400 errors on malformed or unknown filters.",
        "keywords": [
            "StackStorm",
            "advanced filters",
            "REST API filtering",
            "action executions",
            "query parameters",
            "MongoEngine LookUpError",
            "invalid format for filter",
            "_lookup_field validation",
            "openapi.yaml",
            "resource controller _get_all"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The issue was about adding support for more powerful filters on list endpoints, especially for action executions in StackStorm. Previously, the API only supported simple AND-based filtering using standard query parameters mapped to model fields. There was a desire for more flexible and consistent filtering but full OR/AND composability (e.g., via pql) was not yet implemented.\n\nTo address this incrementally, the `ResourceController._get_all` method was extended with a new `advanced_filters` argument. A new `filter` query parameter was introduced in the OpenAPI spec (`openapi.yaml` and its template) and mapped via `x-as: advanced_filters`. The `ActionExecutionsController.get_all` and its internal method `_get_action_executions` were updated to accept and pass through this `advanced_filters` argument.\n\nThe implementation parses the `filter` string as a series of space-separated tokens, each token in the form `field_path:value`. For each token:\n- It splits on `:` (once) to obtain the field path (`k`) and value (`v`).\n- If the token does not contain `:`, it raises a `ValueError` with message `invalid format for filter \"<token>\"`.\n- It splits the field path on `.` to produce a path list.\n- It uses `self.model.model._lookup_field(path)` (MongoEngine API) to ensure the field exists. If `_lookup_field` raises `LookUpError`, this is converted into `ValueError(str(e))`.\n- On success, it adds the filter to the Mongo query dict using `__`-joined field paths as keys (`filters['__'.join(path)] = v`).\n\nThese `advanced_filters` entries are combined with existing filters, but conceptually they provide a more flexible way to specify filters directly against underlying model fields. The OpenAPI description warns that the advanced filter string overrides other filters conceptually.\n\nUnit tests were added in `test_executions_filters.py` to verify that:\n- For each supported filter (except excluded ones like `parent`, `timestamp`, etc.), sending `/v1/executions?filter=<field_path>:<value>` returns a 200 response, with a non-empty list and a positive `X-Total-Count`.\n- Malformed advanced filters return correct 400 errors:\n  - `filter=a:b,c:d` results in `400` with `{\"faultstring\": \"Cannot resolve field \\\"a\\\"\"}` because `a` is not a valid model field and `_lookup_field` raises `LookUpError`.\n  - `filter=action.ref` (no `:`) results in `400` with `{\"faultstring\": \"invalid format for filter \\\"action.ref\\\"\"}`.\n\nFinally, a minor lint fix adjusted whitespace in the test file. The net result is that StackStorm now exposes a robust, validated advanced filtering mechanism through a single `filter` query parameter, with clear error reporting for invalid or unknown filters.",
        "semantic_memory": "This change illustrates a pattern for incrementally enhancing REST API filtering capabilities while maintaining safety and clear error semantics.\n\nKey concepts extracted from this fix:\n\n1. **Advanced filter syntax via a single query parameter**\n   - Rather than proliferating many query parameters, a single `filter` (or similarly named) parameter can accept a compact, expressive filter grammar (e.g., `field.subfield:value other.field:value2`). This allows complex field paths and is easier to extend in the future.\n\n2. **Mapping textual filters to ORM/ODM queries**\n   - Client-supplied filters can be parsed into a dictionary of field lookups which are then transformed into ORM/ODM-specific query keys (e.g., MongoEngine uses `field__subfield` with `__` separators). This provides a bridge between human-readable filter syntax and the underlying data layer.\n\n3. **Field validation before querying**\n   - Using the model's introspection (`_lookup_field` in MongoEngine) to validate that a filter refers to an actual field path is crucial. It prevents silent failures or broad queries caused by typos and ensures that invalid user input results in deterministic and explicit errors.\n\n4. **Clear and specific error messages**\n   - Distinguishing between different error conditions improves API usability:\n     - Unknown field path: return a message like `Cannot resolve field \"<field>\"` (from `LookUpError`).\n     - Malformed filter token (missing delimiter): return `invalid format for filter \"<token>\"`.\n   - Converting internal exceptions to consistent 400 Bad Request responses gives API consumers a predictable contract.\n\n5. **Backwards-compatible extension of existing controllers**\n   - Adding an `advanced_filters` argument to a shared `_get_all` method and threading it through specific controllers (like `ActionExecutionsController`) provides a single place to enhance behavior while minimizing duplication.\n   - Maintaining existing filter mechanisms alongside an advanced one allows phased adoption.\n\n6. **OpenAPI documentation alignment**\n   - When extending filter behavior, updating the OpenAPI spec (and its template) is essential so that API clients and automated tooling understand new parameters, their semantics, and how they map into the backend (`x-as` binding).\n\nOverall, this case demonstrates a general approach to enriching API query capabilities: define a compact filter DSL, validate filter fields against the model, handle parse errors early, map filters to the persistence layer's query format, and document the behavior clearly in the API spec.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Clarify requirements for advanced filtering\n- Identify what is missing from current API filters (e.g., nested fields, multiple conditions, future OR/AND logic).\n- Decide on a concise filter syntax (e.g., `field.path:value` tokens, separated by spaces or another delimiter).\n- Determine whether the new filters should replace or augment existing query parameters.",
            "Step 2: Design the filter representation\n- Choose a single query parameter (e.g., `filter`) to carry the advanced filters.\n- Define the grammar precisely: how tokens are separated, how key/value are separated, what constitutes a valid field path, and whether operations beyond equality (>, <, etc.) are supported.\n- Document how the advanced filter interacts with existing filters (e.g., does it override them, combine with them, or is it mutually exclusive?).",
            "Step 3: Wire the new parameter into the API layer\n- Update controller method signatures to accept an `advanced_filters` (or similar) argument alongside existing filter parameters.\n- Thread this new argument through any internal helper methods (e.g., `_get_all`, `_get_<resource>()`) instead of duplicating parsing logic in multiple endpoints.\n- Update routing or framework-specific parameter binding so that the query parameter (e.g., `filter`) maps to the new argument.",
            "Step 4: Implement robust parsing and validation\n- In a central location (e.g., the shared resource controller), parse the `advanced_filters` string:\n  - Split the string into tokens based on your delimiter (spaces in this case).\n  - For each token, split once on `:` (or chosen key/value separator). If splitting fails, raise a descriptive error (e.g., `invalid format for filter \"<token>\"`).\n  - Split the key (`k`) into path components on `.` to support nested fields.\n- Validate that the field path exists on the underlying model using ORM/ODM introspection (e.g., MongoEngine's `model._lookup_field(path)`).\n  - Catch specific exceptions such as `LookUpError` and re-raise as user-facing `ValueError` or framework-appropriate HTTP error with the original message.\n- Map the validated field path to the query engine syntax (e.g., join with `__` for MongoEngine) and populate a filters dict.",
            "Step 5: Integrate with existing query construction\n- Merge advanced filter-derived criteria into the existing filters dictionary used by the data access layer.\n- If advanced filters are meant to override older filters, ensure that they overwrite conflicting keys or skip building the older ones when `advanced_filters` is present.\n- Keep the logic centralized in a generic `_get_all` or similar method so all resources benefit from the enhancement consistently.",
            "Step 6: Map backend errors to HTTP responses\n- Ensure that `ValueError` or custom filter-related exceptions are translated into a 400 Bad Request by your web framework.\n- Provide a consistent error schema in the response body (e.g., `{ \"faultstring\": \"<message>\" }`).\n- Test that unknown field paths and malformed tokens yield clear, distinct error messages.",
            "Step 7: Update API specification and client-facing docs\n- Modify the OpenAPI / Swagger spec to include the new `filter` query parameter:\n  - Describe its purpose and format (`Advanced filter string. Overrides other filters.`).\n  - Use vendor extensions (like `x-as`) if needed to map it to internal argument names.\n- Regenerate client SDKs or share updated docs so API consumers can use the new functionality correctly.",
            "Step 8: Add unit tests for valid and invalid filters\n- Create tests that:\n  - Verify advanced filters return 200, with non-empty result sets, for each supported field or a representative subset.\n  - Exercise nested field paths to ensure lookup and mapping work (e.g., `action.ref:value`).\n  - Check behavior when field paths are invalid (e.g., `a:b,c:d` causing an unresolved field), expecting a 400 with `Cannot resolve field \"a\"` or equivalent.\n  - Check behavior when tokens are malformed (e.g., missing `:`), expecting a 400 with `invalid format for filter \"<token>\"`.\n- Run tests against the APIs to confirm that filter parsing, validation, querying, and error reporting behave as expected.",
            "Step 9: Consider future enhancements\n- Once basic advanced filtering works, plan for:\n  - Support for multiple conditions with OR/AND semantics (e.g., grouping, parentheses, or a more expressive query language).\n  - Operator support (>, <, !=, in, etc.).\n  - Pagination, sorting, and performance implications of complex filters.\n- Keep the current filter DSL easily extensible so these future features can be layered on without breaking existing clients."
        ]
    }
}
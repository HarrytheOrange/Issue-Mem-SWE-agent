{
    "search_index": {
        "description_for_embedding": "Revert of Optuna's Study.report ask-and-tell API: removes the Study.report method, restores Trial.report as the single reporting interface, and inlines trial-id resolution logic into Study.tell. The change simplifies the public API, avoids duplicated functionality, keeps pruner behavior unchanged, and adjusts tests and error/warning behavior for trial-number based access and storages that don’t support trial-number lookups.",
        "keywords": [
            "Optuna",
            "Study.tell",
            "Trial.report",
            "ask and tell API",
            "Study.report reverted",
            "public API rollback",
            "intermediate_values reporting",
            "pruner integration",
            "multi-objective NotImplementedError",
            "storage.get_trial_id_from_study_id_trial_number",
            "trial number vs trial id mapping",
            "ValueError for non-existent trials",
            "UserWarning for slow storage fallback"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request reverts a recently introduced public API in Optuna: Study.report. Previously, Trial.report contained the core logic to record intermediate objective values (by step) used by pruners. A new \"ask and tell\" style interface had been added where Study.report(trial_or_number, value, step) delegated to Study.report, and Trial.report essentially became a thin wrapper around it. This duplication turned out to be an overly intrusive change to the public API, especially given that the core need was satisfied by being able to restore a Trial object instead of reporting via the Study.\n\nThe fix removes Study.report entirely and restores the original behavior where Trial.report directly handles reporting. The removed Study._get_trial_id helper (which mapped a Trial or trial-number to a trial_id via storage) is inlined and specialized inside Study.tell. Study.tell still accepts both Trial and int (trial number), but now it resolves trial_number and trial_id internally: it first tries storage.get_trial_id_from_study_id_trial_number, and if that’s not implemented, it warns that the operation may be slow, falls back to fetching all trials and indexing by trial_number, and raises ValueError when the trial number has not been created or is out of range.\n\nIn Trial.report, the full logic is reintroduced: it checks that multi-objective optimization is not used (len(study.directions) must be 1, otherwise NotImplementedError), casts the value to float (raising TypeError for invalid types), validates that step is non-negative (ValueError otherwise), fetches intermediate_values from storage, skips if the given step is already reported, and finally stores the intermediate value via storage.set_trial_intermediate_value.\n\nCorresponding tests for Study.report are removed, as that API no longer exists. The test that previously checked storage behavior when get_trial_id_from_study_id_trial_number is not implemented is renamed to test_tell_storage_not_implemented_trial_number and now only covers Study.tell, expecting a UserWarning when tell is used with a valid trial number and a ValueError when tell is used with a non-existent trial number. Any tests referencing Study.report or assuming it as an alternative reporting interface are removed. The end result is a simpler, less intrusive public API centered around Trial.report while preserving tell’s ability to accept either Trial objects or trial numbers.",
        "semantic_memory": "Key takeaways from this change revolve around API design, rollback strategy, and internal consistency of behavior:\n\n1. Avoid duplicative public APIs for the same operation.\nIf you already have a clear, canonical method (Trial.report) for a core operation (reporting intermediate metrics to drive pruning), adding a second public entry point on another class (Study.report) can create confusion. Users now have two ways to do the same thing, documentation complexity increases, and maintaining consistent behavior between the two interfaces becomes error-prone.\n\n2. Prefer object-centric methods over manager-level shortcuts when the object is fundamental.\nIn Optuna’s design, Trial is the natural owner of reporting behavior; the study is a higher-level coordinator. Keeping reporting on Trial (Trial.report) is more intuitive and reduces the need for extra routing logic (like Study._get_trial_id and Study.report). If the underlying issue is that users can’t get back to a Trial instance (e.g., in ask-and-tell workflows), it can be better to improve trial restoration than to add a new Study-level reporting API.\n\n3. Rolling back a public API is sometimes the correct fix.\nIf a new public API proves too intrusive, confusing, or misaligned with the library’s design principles, reverting it early is preferable to supporting it indefinitely. Rolling back requires carefully restoring previous behavior, adjusting tests, and ensuring backward compatibility for the existing, stable API.\n\n4. Handling identifier indirection (number vs internal ID) requires clear error semantics and performance considerations.\nMapping user-visible identifiers (trial numbers) to internal storage IDs can be expensive if the storage backend doesn’t support direct lookup. A robust pattern is:\n- Attempt fast-path lookups through backend-specific methods (e.g., get_trial_id_from_study_id_trial_number).\n- If not supported, warn about potential performance issues and fall back to a slower but correct path (e.g., fetching all trials and indexing by number).\n- Enforce clear errors when a requested entity does not exist (ValueError for non-existent trial numbers, KeyError internally translated to ValueError).\n\n5. Keep multi-objective behavior explicit and fail fast when unsupported.\nWhen an operation (like reporting a single scalar value) is only defined for single-objective optimization, explicitly guard with a NotImplementedError if len(directions) > 1, rather than letting it fail later or behave silently incorrectly.\n\n6. Tests should align closely with the public surface.\nWhen a public API is removed (Study.report), tests that validate its behavior should be deleted or updated rather than kept around as dead references. Tests that validate shared mechanisms (e.g., trial-number to id mapping, warnings for storage) should be focused on the surviving APIs (Study.tell and Trial.report) to reflect how users will interact with the library.",
        "procedural_memory": [
            "When a newly introduced public method duplicates existing behavior, evaluate and potentially revert it:",
            "Step 1: Identify overlapping APIs. Find any new methods (e.g., Study.report) that primarily wrap or duplicate existing ones (e.g., Trial.report). Determine whether the new API adds clear value or just adds complexity.",
            "Step 2: Restore ownership to the canonical class. If the operation conceptually belongs to a specific object (e.g., Trial), ensure that the core logic resides in that object’s method rather than in a higher-level manager. Move logic back into Trial.report or the equivalent object-centric method.",
            "Step 3: Inline or reduce generic helpers where they are no longer justified. If you had introduced shared helpers purely to support the duplicated API (e.g., Study._get_trial_id), inline their logic into the places that still need it (like Study.tell) and delete the helper, keeping the code simpler and more focused.",
            "Step 4: Maintain type-flexible arguments with clear checks. If your method accepts multiple types for an argument (e.g., Trial or int for a trial identifier), gate this clearly:\n- Validate the parameter type at the top and raise TypeError for unsupported types.\n- For object types, access internal identifiers directly (trial._trial_id).\n- For numeric identifiers, resolve them via storage, handling backend capabilities and mapping errors explicitly.",
            "Step 5: Handle storage backends with and without direct lookup support. For mapping user-level IDs (like trial numbers) to internal IDs:\n- Attempt to call a fast mapping method on the storage (e.g., get_trial_id_from_study_id_trial_number).\n- If NotImplementedError is raised, warn the user that the operation may be slow and fall back to fetching all records and indexing by number.\n- If the trial number is out of range or the backend indicates it does not exist, translate that into a clear ValueError stating that the trial has not been created.",
            "Step 6: Implement robust value and argument validation in reporting methods. For methods like Trial.report:\n- Convert incoming values to float, catching TypeError/ValueError and re-raising with a clear message about expected type.\n- Validate that step is non-negative; raise ValueError for negative steps.\n- Retrieve existing intermediate values and no-op if the step is already present to avoid clobbering or unexpected behavior (optionally log or warn if duplicate reporting is suspicious).",
            "Step 7: Enforce multi-objective constraints explicitly. If the method is only meaningful in a single-objective context:\n- Check the number of optimization directions (e.g., len(study.directions)).\n- If more than one, raise NotImplementedError with a message explaining that the method does not support multi-objective optimization.",
            "Step 8: Update and simplify tests to reflect the final public surface. After reverting or removing a public method:\n- Remove or rewrite tests that directly call the removed method (e.g., tests for Study.report).\n- Rename and adjust tests that covered shared behavior to focus on the remaining public APIs (e.g., test_tell_storage_not_implemented_trial_number, focusing on Study.tell only).\n- Ensure tests still cover edge cases: invalid trial numbers, backends lacking direct ID mapping, error types (TypeError vs ValueError vs NotImplementedError), and warnings.",
            "Step 9: Communicate the rollback. In documentation and release notes, explain that the reverted API was experimental or problematic, highlight the preferred usage pattern (e.g., always use Trial.report), and, if necessary, explain how users can restore Trial instances in ask-and-tell workflows instead of relying on the removed method."
        ]
    }
}
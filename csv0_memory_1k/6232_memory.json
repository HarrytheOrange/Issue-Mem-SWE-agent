{
    "search_index": {
        "description_for_embedding": "Test HTTP servers in Home Assistant were using a sequential, globally-incremented port number starting from the default SERVER_PORT, which caused intermittent 'address already in use' errors and made parallelization unsafe. The fix replaces the custom global counter with aiohttp.test_utils.unused_port for dynamic port allocation, letting the OS pick an available port for each test instance.",
        "keywords": [
            "dynamic port allocation",
            "test HTTP server",
            "aiohttp.test_utils.unused_port",
            "address already in use",
            "port conflict",
            "Home Assistant tests",
            "parallel test execution",
            "SERVER_PORT"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant test suite, HTTP-based tests needed to run multiple HomeAssistant instances. Previously, tests obtained a port via a custom get_test_instance_port function that used a global _TEST_INSTANCE_PORT starting at the default SERVER_PORT and incremented for each new test. This was originally a workaround for the default HTTP port not always being freed correctly between tests.\n\nHowever, this sequential scheme is fragile: ports can still be in use (e.g., due to lingering sockets, OS TIME_WAIT states, or parallel test runs), causing errors like 'Failed to create HTTP server at port XXXX: [Errno 98] address already in use'. The test suite also needed to move toward safe parallelization, which requires more robust per-test port selection.\n\nThis PR eliminates the manual global port counter and instead imports aiohttp.test_utils.unused_port as get_test_instance_port, delegating port selection to aiohttp's helper which asks the OS for an available dynamic port. The import replaces the local implementation, and the unused SERVER_PORT-based logic (and related constant import) is removed from tests/common.py. As a result, each test HTTP instance gets a dynamically allocated port chosen by the OS, reducing port collisions and making the test system more robust and more amenable to parallel execution.\n\nDuring discussion, it was noted that requesting an 'unused' port by binding then closing the socket and later binding to the same numeric port is inherently racy: another process or test might claim that port in between. The ideal long-term fix is to have the HTTP component support binding directly to port 0 or reuse the already-bound socket. But in this PR, the immediate step was to stop using a naive sequential counter and rely instead on aiohttp's unused_port helper for dynamic allocation in tests.",
        "semantic_memory": "When running HTTP or network-based tests, naively choosing ports (e.g., via a global incrementing counter or by probing for a free port, closing it, and then reusing the port number later) can cause intermittent 'address already in use' failures. This becomes especially problematic when tests are run in parallel or when the OS holds sockets in TIME_WAIT.\n\nMore robust patterns include:\n- Letting the OS choose a free port by binding to port 0 on the server socket and reading back the assigned port.\n- If a test framework provides an 'unused_port' or similar utility, use it, but recognize that a 'bind-then-close' selection pattern is still inherently racy unless the same socket is reused for the server.\n- Avoid global/shared state for port allocation across tests, because it doesn't guarantee availability and complicates parallelization.\n\nIn general, network tests should either: (1) bind once to port 0 and reuse the resulting socket (or its port) directly, or (2) have the system under test support dynamic binding, so the test can simply pass port 0 and discover the actual bound port afterward. Sequential port assignment and pre-allocating 'free' ports that are later reused only by port number should be considered temporary or fragile workarounds.\n\nThe broader best practice is: rely on OS-level dynamic port assignment where possible, minimize assumptions about specific port numbers, and design components so tests don't need to manage port selection manually.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of port conflicts.\n- Look for intermittent test failures with messages like 'Failed to create HTTP server at port XXXX: [Errno 98] address already in use'.\n- Note whether failures become more common under parallel test execution (e.g., pytest -n N or CI with multiple jobs).",
            "Step 2: Inspect how tests choose ports.\n- Search the test utilities for helpers like get_test_instance_port, unused_port, or hardcoded port numbers.\n- Check for global counters, static offsets from a base port (e.g., SERVER_PORT + N), or utilities that bind to get a free port and then close the socket but only return the numeric port.",
            "Step 3: Assess if port allocation is inherently racy.\n- If the tests:\n  - increment a global port without checking if it's actually free, or\n  - call a helper that binds to a free port, closes it, and then later tries to bind the same port number for the real server,\n  then there is a race where another process/test can claim that port in between.\n- Consider the impact of TIME_WAIT state and lingering sockets on port reuse.",
            "Step 4: Prefer binding to port 0 or reusing the same socket.\n- If you control the service/component under test:\n  - Add support to accept port=0 or an already-bound socket.\n  - On the test side, bind a socket with port=0, read the assigned port, and either pass the socket into the server or let the server bind to port=0 itself.\n- This ensures the OS selects an available port at the moment of server creation, eliminating the gap between 'selecting' and 'using' the port.",
            "Step 5: Use framework utilities for dynamic ports where appropriate.\n- If the framework offers a utility like aiohttp.test_utils.unused_port, use it instead of a custom global counter.\n- Replace any manual sequential port logic with a call to such a utility, as was done by importing 'unused_port as get_test_instance_port' in tests/common.py.\n- Be aware that if the utility itself uses the bind-then-close pattern, there is still a theoretical race; it may be acceptable in practice for serial tests, but consider longer-term adjustments toward direct port-0 binding.",
            "Step 6: Remove dependencies on fixed constants like SERVER_PORT in tests.\n- Avoid importing and relying on application-level constants (e.g., SERVER_PORT) for test ports.\n- Refactor tests so they work with dynamically chosen ports (for example, by reading the bound port from the server instance or by passing it through fixture returns).",
            "Step 7: Validate under parallel execution.\n- After changing port allocation, run the test suite with parallel workers to ensure no more 'address already in use' errors occur.\n- Monitor CI runs where contention is more likely due to concurrent jobs.",
            "Step 8: Document the port-allocation strategy.\n- Add comments in test utilities explaining why dynamic port allocation is used and the limitations of any helper functions.\n- Encourage future contributors to use the established helper instead of introducing new hardcoded ports or global counters."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Added a new Home Assistant sensor platform for Monzo bank accounts, including configuration schema, throttled API access via the monzo Python library, currency-aware icons, and authentication error handling during platform setup.",
        "keywords": [
            "Monzo",
            "Home Assistant",
            "sensor.monzo",
            "external API integration",
            "bank balance sensor",
            "voluptuous config validation",
            "Throttle",
            "authentication error handling",
            "ForbiddenError",
            "UnauthorizedError",
            "mdi currency icons",
            "requirements_all",
            "REQUIREMENTS"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request implemented a new Home Assistant sensor platform to integrate with the Monzo bank API. The feature allows users to monitor Monzo account data such as balance, currency, spend_today, local_currency, and local_exchange_rate.\n\nThe new file homeassistant/components/sensor/monzo.py defines the Monzo platform. It declares REQUIREMENTS = ['monzo==0.5.3'] and updates requirements_all.txt accordingly. The platform uses voluptuous for configuration validation: CONF_ACCESS_TOKEN is required, CONF_ACCOUNT_ID is optional, and CONF_MONITORED_VARIABLES is optional with a default of ['balance']. The platform also supports customizing the sensor name.\n\nMonzoData encapsulates communication with the external monzo Python library. The monzo dependency is imported inside __init__ to keep imports local to usage, per project guidelines. MonzoData is initialized with an access token and an optional account_id; if no account_id is provided, it calls monzo.get_first_account() and uses that account's id. The update method, throttled by MIN_TIME_BETWEEN_UPDATES (10 minutes) using homeassistant.util.Throttle, fetches the latest balance data from Monzo and caches it.\n\nMonzoSensor is an Entity that exposes individual metrics based on the monitored_variables list. Its update method uses the shared MonzoData instance to read the cached balance dict and map different keys to sensor state and unit_of_measurement based on type: 'balance', 'currency', 'spend_today', 'local_currency', and 'local_exchange_rate'. Currency-based sensors set unit_of_measurement to the currency code.\n\nInitially, the icon selection logic used a long if/elif chain for specific currency codes (EUR, GBP, INR, NGN, RUB, TRY, USD). The second patch refactored this to a single ICONS dictionary mapping lowercase currency codes to mdi:currency-* icon names. The icon property now uses this mapping and falls back to the USD icon if the unit is missing or unrecognized.\n\nThe second patch also added explicit error handling during platform setup. setup_platform now imports ForbiddenError and UnauthorizedError from monzo.errors and wraps initialization of MonzoData in a try/except block. If either of these exceptions is raised (e.g., invalid or unauthorized access token), the platform logs an error ('Monzo failed to initialise') and returns False, preventing a broken platform from being added. The Monzo sensor file was added to .coveragerc's omit list because it's an integration component.\n\nOverall, the incident here was not a bug fix but an integration feature: defining a robust, throttled, and validated sensor platform for Monzo that gracefully handles authentication failures, uses clear configuration semantics, and maps currency codes to appropriate UI icons.",
        "semantic_memory": "When integrating an external financial or web service into a home automation platform, several patterns from this change are broadly applicable:\n\n1. **Local imports for external dependencies**: External libraries (like the monzo Python client) should be imported within the functions or classes that use them, not at module import time. This keeps the core system importable even if optional dependencies are missing and fits well with plugin-style architectures.\n\n2. **Use a data wrapper object for API interaction**: Encapsulate API calls and caching in a dedicated data class (e.g., MonzoData) that is shared across multiple sensor entities. This avoids redundant HTTP calls and centralizes error handling and throttling logic.\n\n3. **Throttle external API calls**: Apply throttling (e.g., via a decorator like Throttle) to the API update method instead of each entity's update. This protects against rate limits and reduces load on the external service, especially when multiple entities depend on the same upstream data.\n\n4. **Config validation with sensible defaults**: Use a schema validation library (such as voluptuous) to define clear configuration contracts. Provide defaults for optional fields (e.g., default monitored_variables to ['balance']) and allow optional parameters like account_id while deriving reasonable defaults from the API when not provided.\n\n5. **Graceful handling of authentication/authorization errors**: During integration setup, catch authentication-related exceptions (e.g., ForbiddenError, UnauthorizedError) raised by the client library. If initialization fails, log a specific, actionable error message and abort platform setup rather than letting the platform partially initialize and fail later in a less obvious way.\n\n6. **Structured mapping instead of conditionals**: Replace repetitive if/elif chains with dictionary-driven mappings (e.g., mapping currency codes to mdi icon strings). This simplifies maintenance, makes it easier to extend to new values, and centralizes the mapping logic.\n\n7. **UI semantics aligned with data**: When representing financial data, associate the unit (currency code) with both the numeric state and the icon selection. This ensures the UI conveys the correct context (e.g., showing a GBP icon for a GBP balance) and avoids hard-coded assumptions about default currencies.\n\nThese practices are generalizable to any plugin-based system that integrates external APIs, especially those with authentication concerns and rate limits.",
        "procedural_memory": [
            "Step-by-step instructions on how to design and implement a new external-service sensor integration in a Home Assistantâ€“like platform:",
            "Step 1: Define the external dependency and requirements.\n- Identify the Python client/library you will use (e.g., monzo==0.5.3).\n- Add it to the component's REQUIREMENTS list.\n- Update the global requirements_all.txt (or equivalent) with the pinned version and a comment indicating which component uses it.",
            "Step 2: Structure imports to keep the core system robust.\n- Avoid importing the external library at module import time.\n- Perform `from external_lib import X` inside the functions or class initializers that need it (e.g., inside setup_platform or the data wrapper's __init__).\n- This ensures the module can be imported even if the optional dependency is missing, and loading of the integration is controlled by the platform loader.",
            "Step 3: Define configuration schema with validation and defaults.\n- Use a validation library like voluptuous to build a PLATFORM_SCHEMA.\n- Mark critical parameters (e.g., access_token) as Required.\n- Make other configuration values Optional with sensible defaults (e.g., default monitored_variables to a common case like ['balance']).\n- Use enums or membership checks (vol.In) to restrict monitored_variables to supported metrics.",
            "Step 4: Implement a data wrapper class for API access.\n- Create a class (e.g., MonzoData) responsible for all calls to the external API.\n- Initialize it with necessary credentials and optional parameters (like account_id).\n- If optional parameters are omitted, derive defaults from the API (e.g., use the first account returned by get_first_account()).\n- Store the latest response (e.g., self.balance) as an attribute.",
            "Step 5: Throttle API calls at the data layer.\n- Use a throttling decorator (such as homeassistant.util.Throttle) on the data wrapper's update() method.\n- Choose a reasonable interval (e.g., 10 minutes) based on service rate limits and expected data volatility.\n- In each sensor entity's update(), call data.update() instead of calling the external API directly. This ensures multiple entities share a single throttled data source.",
            "Step 6: Implement sensor entities that map data to UI.\n- Create an Entity subclass (e.g., MonzoSensor) that takes the shared data object, a metric type, and a base name.\n- In update(), read from the data object's cached response and map fields to state and unit_of_measurement based on the sensor type.\n- Provide a friendly name (e.g., combining the client name and a human-readable metric label).",
            "Step 7: Map units to icons using a dictionary.\n- Define a single ICONS dict mapping normalized unit keys (like currency codes) to icon identifiers (e.g., mdi:currency-gbp).\n- In the icon property, look up the icon based on the unit_of_measurement (after normalizing to lowercase), and fall back to a default if not found.\n- This avoids long chains of conditionals and makes it easy to add new unit/icon pairs.",
            "Step 8: Add robust authentication error handling during setup.\n- Inspect the external library to understand which exceptions are raised for invalid credentials or permission issues (e.g., ForbiddenError, UnauthorizedError).\n- In setup_platform, wrap initialization of the data wrapper (e.g., MonzoData) in a try/except block that catches these specific exceptions.\n- On failure, log a clear error message indicating what went wrong and return False or equivalent to abort platform setup cleanly.",
            "Step 9: Integrate with test coverage configuration.\n- If your project excludes integration components from unit test coverage metrics, add the new component file to the coverage configuration (e.g., .coveragerc omit list).\n- This keeps coverage reporting consistent with existing components.",
            "Step 10: Verify and document the integration.\n- Run the project's test suite (e.g., tox) to ensure nothing is broken.\n- Add or update documentation to show example configuration (including required access tokens and optional account_id) and list the available monitored_variables.\n- Optionally test invalid tokens or revoked access to ensure your error handling behaves as expected and produces clear logs."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Implementation and hardening of a Home Assistant integration for KEBA KeContact / BMW wallbox charging stations. The component was iteratively refactored from a custom UDP asyncio protocol into a dedicated PyPI library (keba-kecontact), added robust polling (including a short fast-polling window after control actions), configuration-driven failsafe management, stable unique_ids based on wallbox serial numbers, Home Assistant–style services (authorize, deauthorize, set_current, set_energy, enable/disable, set_failsafe), and correct handling when no charging station is reachable (setup fails with an error).",
        "keywords": [
            "homeassistant.components.keba",
            "KEBA KeContact",
            "BMW Wallbox",
            "EVSE integration",
            "UDP device integration",
            "asyncio DatagramProtocol",
            "keba-kecontact",
            "Home Assistant platform",
            "binary_sensor",
            "sensor",
            "lock",
            "failsafe",
            "fast polling",
            "refresh_interval",
            "unique_id",
            "device_class",
            "requirements_all.txt",
            "manifest.json",
            "integration setup failure handling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request implements a new Home Assistant integration for KEBA KeContact-based charging stations (e.g., KEBA P20/P30, BMW Wallbox) and iteratively improves its robustness and code quality.\n\nInitially, the integration directly implemented KEBA’s UDP protocol via an asyncio.DatagramProtocol subclass (KebaProtocol) inside Home Assistant. It opened a UDP endpoint, periodically requested reports (report 1/2/3), parsed raw JSON responses, scaled values, and stored them in a local data dict. Binary sensors, regular sensors, and a lock entity subscribed to this data store via update listeners. Services were exposed for starting/stopping charging, setting failsafe behavior, current limits, and energy limits.\n\nAs the PR evolved, several key issues and improvements were addressed:\n\n1. **Protocol extraction to external library**: To reduce protocol complexity inside Home Assistant and improve reuse/testability, the low-level UDP I/O and data parsing logic was moved into a separate PyPI package, `keba-kecontact`. A new class `KebaHandler` now subclasses `KebaKeContact` and focuses on Home Assistant integration (callbacks, polling strategy, entity updates) while relying on the library for communication and data normalization.\n\n2. **Configuration and naming cleanup**: Configuration keys (rfid, failsafe flags, timers, fallback and persist options, refresh interval) were turned into named constants (CONF_RFID, CONF_FS, CONF_FS_TIMEOUT, etc.) and validated through Home Assistant’s `voluptuous` schema. Several earlier typos and ad-hoc names (e.g., `failsafe_save` vs `failsafe_persist`) were fixed, aligning with HA best practices and making the config less error-prone.\n\n3. **Service API redesign**: The service mapping was cleaned up and normalized: `authorize`/`deauthorize` now map to RFID-based start/stop; `enable`/`disable` map to `ena 1/0` (overall EV enable), `set_current` and `set_energy` accept parameters and validate them; `set_failsafe` takes dedicated fields for timeout, fallback current, and persistence. Service handlers were unified to call methods on KebaHandler using a service map and passing `call.data` directly.\n\n4. **Fast polling and refresh behavior**: To provide timely UI feedback after control actions, the integration implements a hybrid polling strategy. There is a base `refresh_interval` (min clamped to 5 seconds) for normal operation, and a short fast-polling window (2-second interval) after certain state-changing actions (set_energy, enable/disable EV, start/stop charging, set_failsafe). This is implemented by an internal counter (`_fast_polling_count`) and a periodic task (`_periodic_request`) that reschedules itself on the event loop.\n\n5. **Failsafe configuration and safety**: Failsafe behavior (internal to the charger) can be configured via YAML and the `set_failsafe` service. On startup, the integration computes the effective failsafe parameters based on the config (or disables failsafe) and calls `set_failsafe` on the device. Earlier, failsafe commands were sent as raw UDP strings; now they are routed through the library and validated, with errors logged if parameters are invalid.\n\n6. **Entity modeling and attributes**:\n   - Binary sensors: Online status, plug state, charging state, and failsafe state are represented as binary sensors with proper Home Assistant device classes (`connectivity`, `plug`, `power`, `safety`) and normalized attribute names (snake_case like `plugged_on_wallbox`, `failsafe_timeout`, `fallback_current`).\n   - Sensors: Core metrics such as max current, energy target, current power, session energy, and total energy are exposed as sensors with appropriate units and icons. Additional electrical details (voltages U1/U2/U3, currents I1/I2/I3, power factor) are exposed as attributes in normalized form.\n   - Lock: An authentication lock entity reflects whether the wallbox requires authorization (`Authreq`) and maps `lock` to stopping (deauthorization) and `unlock` to authorization of the configured RFID. To better fit HA’s model, lock/unlock are implemented as async methods.\n\n   All entities now have stable `unique_id` values based on the wallbox serial number (via `keba.device_name` formatted as `keba_wallbox_<Serial>` plus a suffix). This ensures consistent entity IDs across restarts and configurations.\n\n7. **Setup robustness and error handling**: The integration’s setup now explicitly waits for the initial device communication: `async_setup` calls `keba.setup()`, and that method requests initial data and checks for a `Serial` value. If the serial cannot be loaded (i.e., the charging station is unreachable or not responding), `async_setup` logs an error (`Could not find a charging station at <host>`) and returns `False`, causing the integration to fail cleanly instead of silently misbehaving or leaving entities in an undefined state.\n\n8. **Home Assistant conventions, style, and dependencies**: The code was updated to respect linting tools (`flake8`, `pylint`) and `black` formatting. Binary sensor device classes, attribute naming, and service documentation in `services.yaml` were brought in line with HA conventions. The integration’s `manifest.json` pins the `keba-kecontact` dependency (eventually to `0.2.0`), and `requirements_all.txt` is updated accordingly. The integration is excluded from coverage in `.coveragerc` while initially untested.\n\nOverall, the PR started with a straightforward but protocol-heavy implementation and evolved into a robust, maintainable integration that uses a dedicated protocol library, adheres to Home Assistant idioms, includes better error handling, and provides a richer set of entities and services for KEBA-based charging stations.",
        "semantic_memory": "This work provides generalizable lessons for implementing and hardening device integrations in Home Assistant (or similar event-driven platforms):\n\n1. **Separate protocol logic from platform integration**: Implementing a vendor protocol directly inside the integration (e.g., a DatagramProtocol subclass) tightly couples network I/O, parsing, and platform integration. Extracting protocol and I/O logic into a dedicated library (`keba-kecontact`) simplifies the HA integration code, makes it easier to test communication separately, and allows other projects to reuse the protocol implementation.\n\n2. **Use configuration schemas and constants for clarity and safety**: Defining configuration keys as module-level constants (CONF_*) and validating them via `voluptuous` helps avoid typos, aligns different parts of the code (schema, services, internal methods), and makes it easier to refactor and document configuration. This is especially important for safety-critical options like failsafe timeouts and fallback currents.\n\n3. **Stable identifiers should come from real device identity**: For long-lived entities, `unique_id` should be derived from a stable, inherent device identifier (e.g., serial number), not from ephemeral parameters such as host/IP or generic names. This ensures that entity IDs remain stable across restarts, IP changes, and config tweaks.\n\n4. **Design polling and event patterns around user experience and device behavior**: A single fixed polling interval is often a trade-off: too slow for responsive feedback, too fast for normal operation. Introducing a short-term fast-polling window after actions that change state (start/stop charging, enable/disable, set energy/failsafe) yields snappy UI updates while keeping steady-state load low. This pattern is broadly applicable to any device where immediate feedback is desirable after commands but continuous high-frequency polling is not.\n\n5. **Explicitly fail setup when critical dependencies are unavailable**: An integration that silently initializes even when it cannot talk to the device tends to surface hard-to-diagnose issues later. By performing an initial probe (e.g., request data, read a serial) and returning `False` from `async_setup` if it fails, the integration fails fast and clearly, which is more robust and user-friendly.\n\n6. **Normalize attribute names and use proper device classes**: Using snake_case keys for attributes and standardized device classes (e.g., `DEVICE_CLASS_POWER`, `DEVICE_CLASS_CONNECTIVITY`, etc.) makes the integration more consistent with the rest of the platform and improves the user’s understanding in the UI. It also simplifies templating, automation, and documentation.\n\n7. **Use a service map for dispatching**: Mapping service names to method names in a `_SERVICE_MAP` dict and then resolving functions dynamically (`getattr(keba, function_name)`) centralizes service routing. It avoids repetitive boilerplate and makes the service layer easier to evolve.\n\n8. **Leverage async patterns correctly in HA**: Using `async_setup`, `async_update`, and `async_*` entity methods avoids blocking the event loop. Long-running or repeated tasks (e.g., polling) should be scheduled using `loop.create_task` and should await I/O functions. Avoiding synchronous calls in this path is crucial for HA stability.\n\n9. **Version-pin external protocol packages**: When an integration depends on a third-party library implementing device protocols, pinning a specific version in the manifest and `requirements_all.txt` provides reproducibility and protects against breaking changes, especially for network protocols with safety implications.\n\n10. **Service requests as data-driven methods**: Taking a `call.data` dict, validating and extracting expected fields, and passing them into domain methods (e.g., `async_set_current`) encapsulates parameter handling and keeps service handlers simple. This pattern generalizes to many integrations offering parameterized services.\n\nThese practices apply broadly to integrating networked devices into asynchronous home automation systems: architecture (where to put protocol logic), configuration design, error handling, entity modeling, and performance tuning of polling and updates.",
        "procedural_memory": [
            "Step-by-step instructions on how to design, debug, and harden similar Home Assistant device integrations, particularly for networked hardware with custom protocols.",
            "Step 1: Start with a minimal, direct implementation to prove connectivity.\n- Implement a prototype using asyncio (e.g., DatagramProtocol for UDP) to send basic commands and parse responses.\n- Log raw messages and ensure you can obtain key data points (e.g., serial number, state reports) reliably.",
            "Step 2: Extract protocol logic into a dedicated library once stable.\n- Move all low-level I/O and protocol-specific parsing into a separate, testable Python package.\n- Expose a clean async API for operations (start/stop, set_current, set_energy, set_failsafe, request_data, etc.) and an event/callback mechanism for new data.\n- Pin a version of this package in your integration’s manifest and global requirements so you control upgrades.",
            "Step 3: Define configuration schema and constants.\n- Introduce CONF_* constants for all user-configurable options (host, rfid, failsafe options, refresh_interval, etc.).\n- Use `voluptuous` to validate types and reasonable ranges (e.g., positive ints, allowed current ranges, etc.).\n- Replace hard-coded strings with constants throughout the integration to avoid divergence between schema, code, and docs.",
            "Step 4: Implement a handler that bridges the protocol library and Home Assistant.\n- Subclass your protocol class (like KebaKeContact) into a HA-specific handler (e.g., KebaHandler) that:\n  - Stores `hass`, device identification, and config.\n  - Hooks the protocol’s callback into a `hass_callback` that notifies registered entity listeners.\n  - Provides async wrapper methods (`async_set_energy`, `async_set_current`, `async_start`, `async_stop`, etc.) that call the underlying library.\n- Add a method (`add_update_listener`) that entities can use to register callback functions which call `async_schedule_update_ha_state(True)`. This ensures entities update whenever new data arrives.",
            "Step 5: Implement robust setup and device discovery.\n- In `async_setup`, create your handler and immediately call a `setup()` method on it that:\n  - Initializes the protocol library (e.g., opens the UDP socket).\n  - Requests initial data from the device.\n  - Extracts a stable identifier (such as `Serial`) and stores it for building `unique_id`s.\n- If the serial or other critical data cannot be retrieved, log an error and return False from `async_setup` so HA marks the integration as failed instead of loading broken entities.",
            "Step 6: Design a suitable polling strategy.\n- Implement a periodic task (e.g., `_periodic_request`) that calls `request_data()` and then sleeps.\n- Use a configurable `refresh_interval` for normal operation, but enforce a minimum (e.g., 5 seconds) to avoid hammering devices.\n- Implement a fast-polling window: after certain state-changing operations (set_energy, start/stop, enable/disable, set_failsafe), reset a counter and temporarily switch to a shorter delay (e.g., 2 seconds) for several cycles to quickly reflect the new state in the UI.",
            "Step 7: Model entities and attributes properly.\n- Create entity classes (BinarySensorDevice, Entity, LockDevice) that:\n  - Do not poll (`should_poll` returns False) and rely on update listeners.\n  - Use `unique_id` constructed from a stable device name (e.g., `keba_wallbox_<Serial>`) plus a suffix describing the entity.\n  - Use descriptive, human-readable `name` values.\n- Use Home Assistant device classes where appropriate (e.g., `DEVICE_CLASS_CONNECTIVITY`, `DEVICE_CLASS_PLUG`, `DEVICE_CLASS_POWER`, `DEVICE_CLASS_SAFETY`, `DEVICE_CLASS_POWER` for sensors).\n- Use snake_case attribute keys (`max_charging_rate`, `failsafe_timeout`, `voltage_u1`, `current_i1`, etc.) to match HA conventions and simplify automations.",
            "Step 8: Expose services and map them to handler methods.\n- Define services in `services.yaml` with clear descriptions and fields (energy, current, failsafe_timeout, failsafe_fallback, failsafe_persist, etc.).\n- In `__init__.py`, create a `_SERVICE_MAP` from service names to handler method names.\n- Implement a generic `execute_service(call)` that looks up the method with `getattr(handler, method_name)` and awaits it with `call.data` as an argument.\n- Validate input where necessary (e.g., current/energy must be numeric and within safety limits), and log meaningful warnings when invalid values are encountered.",
            "Step 9: Improve logging and error messages.\n- Use different log levels appropriately: info/debug for regular events (polling), warning for unexpected but non-fatal issues (invalid parameter values), and error when the integration cannot function (no device reachable).\n- Ensure log messages contain enough context (host, parameter values) to help users troubleshoot configuration issues.",
            "Step 10: Conform to platform style, linting, and testing.\n- Apply standard formatters (like `black`) and linters (`flake8`, `pylint`) and fix all reported issues.\n- Normalize import order, line length, and docstrings.\n- Add the integration to `requirements_all.txt` and keep the `manifest.json` in sync with the pinned version of the protocol library.\n- If initially untested, explicitly omit the component from coverage in `.coveragerc` and plan tests later.",
            "Step 11: When integrating new hardware, always consider failure modes.\n- Decide what happens if the device goes offline after startup (e.g., you may mark `Online` sensor false while keeping entities, or attempt reconnection within the protocol library).\n- For safety-critical functions like EV charging, make conservative choices in failsafe modes and log clearly when configuration values are out-of-range or corrected.\n- Reflect key safety statuses in binary sensors and lock entities, not just in logs, so automations can respond appropriately."
        ]
    }
}
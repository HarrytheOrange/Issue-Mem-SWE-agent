{
    "search_index": {
        "description_for_embedding": "Home Assistant ISY994 integration was broken by ISY firmware 5.0.10 due to changes in uom usage. The fix is a large refactor: remove global state, store ISY nodes/programs/weather in hass.data, centralize node categorization using node_def_id, Insteon type, and uom heuristics, replace hidden_string with ignore_string, improve host parsing, fix fan and cover/lock/switch program entities, and add a climate import toggle and better weather sensor naming.",
        "keywords": [
            "isy994",
            "Home Assistant",
            "firmware 5.0.10",
            "uom deprecation",
            "node_def_id",
            "hass.data",
            "global state removal",
            "binary_sensor",
            "sensor",
            "switch",
            "light",
            "lock",
            "fan",
            "cover",
            "weather",
            "climate",
            "ignore_string",
            "hidden_string removal",
            "SUPPORTED_FEATURES",
            "fan speed",
            "program entities",
            "NodeDefs",
            "integration refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The ISY994 integration in Home Assistant broke when users upgraded the ISY firmware to 5.0.10. In that firmware, Universal Devices deprecated the traditional uom values as the primary way to identify device types and encouraged developers to use NodeDefs instead. The existing Home Assistant isy994 component relied heavily on uom and scattered, domain-specific filtering logic, as well as module-level globals for the ISY connection and node lists. This caused incorrect or missing entity creation, especially on newer firmware and mixed device families.\n\nTo fix this, the PR performed a comprehensive refactor:\n\n1. **State management & architecture**\n   - Removed all global variables like `ISY`, `SENSOR_NODES`, `NODES`, `GROUPS`, `WEATHER_NODES`, and `PROGRAMS` from `components/isy994.py`.\n   - Introduced centralized storage in `hass.data` using three keys:\n     - `ISY994_NODES`: a dict mapping domain -> list of ISY nodes.\n     - `ISY994_PROGRAMS`: a dict mapping domain -> list of `(name, status_node, actions_node)` tuples for program-based entities.\n     - `ISY994_WEATHER`: a list of `WeatherNode(status, name, uom)` objects.\n   - Each platform (`binary_sensor`, `sensor`, `switch`, `light`, `lock`, `fan`, `cover`) now reads domain-specific nodes and programs from `hass.data` and no longer maintains its own filtering logic or accesses globals.\n\n2. **Centralized node categorization**\n   - Implemented `NODE_FILTERS` and helper functions in `isy994.py` to assign ISY nodes to Home Assistant domains:\n     - `_check_for_node_def(hass, node, single_domain=None)`: uses `node.node_def_id` (5.x firmware) to classify devices; the most reliable method.\n     - `_check_for_insteon_type(hass, node, single_domain=None)`: uses `node.type` prefix to classify Insteon devices across firmware versions.\n     - `_check_for_uom_id(hass, node, ...)`: uses numeric uom IDs for older firmware that represent measurement types.\n     - `_check_for_states_in_uom(hass, node, ...)`: uses lists of human-readable state strings for uom in newer firmware.\n   - `_categorize_nodes(hass, isy.nodes, ignore_identifier, sensor_identifier)` iterates over all ISY nodes, applies ignore/sensor rules, and then classifies nodes into domains using the above helpers, filling `hass.data[ISY994_NODES]`.\n   - Binary vs numeric sensors: `_is_sensor_a_binary_sensor` determines if a sensor node qualifies as a `binary_sensor` using NodeDefs, Insteon type, and binary uom heuristics. Sensor nodes explicitly tagged by `sensor_string` are first checked with this helper; if not binary, they are treated as regular `sensor`s.\n   - Scenes (`PyISY.Nodes.Group`) are categorized as `switch` entities via `SCENE_DOMAIN = 'switch'`.\n\n3. **Program-based entities cleanup**\n   - The original platforms duplicated logic and error handling for programs and directly accessed `ISY.programs`. This refactor moved all program discovery, structure validation, and error handling into `_categorize_programs(hass, isy.programs)` in the component.\n   - Only selected domains (`SUPPORTED_PROGRAM_DOMAINS = ['binary_sensor', 'lock', 'fan', 'cover', 'switch']`) support program-based entities.\n   - Programs are expected to reside under `My Programs/HA.<domain>/<EntityName>/`. For each folder representing an entity, the code validates:\n     - `entity_folder[KEY_STATUS]` exists and has `dtype == 'program'`.\n     - For non-binary_sensor domains, `entity_folder[KEY_ACTIONS]` exists and has `dtype == 'program'`.\n   - Invalid or unexpected structures log a clear warning: \"Program entity '%s' not loaded due to invalid folder structure.\" and are skipped.\n   - Valid entries are stored as `(name, status, actions)` tuples in `hass.data[ISY994_PROGRAMS][domain]`.\n   - Platforms now simply iterate `for name, status, actions in hass.data[ISY994_PROGRAMS][DOMAIN]` and construct `*Program` entities without their own try/except logic.\n\n4. **Configuration changes**\n   - **Removed** `hidden_string` option and related logic. Previously, matching this string in node name/path both modified the name and controlled UI hiding. Hiding is now expected to be done via Home Assistant `customize`.\n   - **Added** `ignore_string` (default `{IGNORE ME}`): nodes whose name or path contains this string are completely ignored and no Home Assistant entities are created.\n   - **Added** `enable_climate` (default `True`): controls whether ISY climate/weather data is imported as Home Assistant sensors. When `False`, even if the ISY has \"Weather Information\" enabled, climate nodes are not imported.\n   - Existing `sensor_string` remains and is used to force certain nodes into the `sensor` domain (subject to binary sensor detection).\n\n5. **Weather / climate handling**\n   - `WEATHER_NODES` global is replaced with `hass.data[ISY994_WEATHER]`, a list of `WeatherNode(status, name, uom)` entries.\n   - `_categorize_weather(hass, isy.climate)` introspects `isy.climate` attributes, pairing each attribute with its corresponding `*_units` attribute and building `WeatherNode`s.\n   - Weather sensor names have underscores replaced with spaces (e.g. `dew_point` becomes `dew point`) for better default display names, without changing entity IDs.\n   - A crash in the sensor platform when climate nodes were present was fixed by aligning `ISYSensorDevice` and `ISYWeatherDevice` with the new `ISYDevice` base and data structures.\n\n6. **Platform-level fixes and cleanups**\n   - **Binary sensors**: updated to use `ISY994_NODES` and `ISY994_PROGRAMS`. A single physical device with multiple ISY nodes (e.g., tamper, battery, heartbeat) is grouped properly. Program entities are constructed from pre-validated `(name, status, None)` tuples.\n   - **Covers**: replaced unit-based filtering with domain lists from `ISY994_NODES`. Extended `VALUE_TO_STATE` mapping to include states like `stopped`, `STATE_CLOSING`, `STATE_OPENING`. Program entities use pre-validated `status` and `actions` and log warnings at the component level.\n   - **Fans**:\n     - Removed ISY-specific medium speed string (`med`) logic by relying on numeric values and a consistent `VALUE_TO_STATE`/`STATE_TO_VALUE` mapping.\n     - Implemented `supported_features` to return `SUPPORT_SET_SPEED`, properly declaring fan speed support.\n     - Fixed `is_on` to correctly return a boolean (`self.value != 0`) and removed incorrect attempts to set `self.speed` directly in the program entity.\n     - `ISYFanProgram` now only issues `runThen()` and `runElse()` in `turn_off`/`turn_on` and reports no extra supported features.\n   - **Lights**: simplified setup to just construct `ISYLightDevice` for each node assigned to the `light` domain by the component. Dimmable detection is handled centrally via the NodeDef/uom logic.\n   - **Locks** and **switches**: converted to the new `hass.data`-based node/program lists; removed manual program validation and added centralized warnings. Switches rely on `bool(self.value)` for `is_on` instead of mapping to HA states.\n   - **Base class (`ISYDevice`)**:\n     - Now only handles name, unique ID, event subscriptions, availability, and attribute exposure.\n     - `name` simply uses `_name` or `self._node.name` without hidden-string filtering or underscore replacement. Underscore replacement is now handled where desired (e.g., climate node names).\n     - Removed unused methods: `hidden`, `unit_of_measurement`, `_attr_filter`, `update`, and the `_domain` attribute, as domain is implied by platform.\n     - Type hints tightened (e.g., `value` returns `int`).\n   - All platforms updated to use `super().__init__(node)` instead of explicitly calling their base class constructors.\n\n7. **Miscellaneous**\n   - Host parsing now uses `urllib.parse.urlparse` correctly. The `host` config parameter (e.g., `http://192.168.0.6:80`) is parsed into `host.hostname` and `port` with sensible defaults (80 for http, 443 for https), avoiding brittle string replacements.\n   - Auto-update lifecycle: the `setup` function now registers a stop callback that sets `isy.auto_update = False` on `EVENT_HOMEASSISTANT_STOP`; on successful setup, `isy.auto_update = True` is enabled.\n   - Replaced string concatenations with `str.format` where appropriate and fixed a bug that used `is` instead of `==` when comparing `dtype` with `KEY_FOLDER`.\n\nIn summary, this incident was about restoring compatibility with ISY 5.0.10 and cleaning up a historically messy integration. The solution centralized node and program classification, replaced globals with `hass.data`, introduced more robust detection heuristics based on new firmware capabilities, fixed several platform-level bugs (especially fans, programs, and weather), and modernized the overall structure of the ISY994 integration.",
        "semantic_memory": "This fix illustrates several generalizable patterns and best practices for maintaining integrations with external device ecosystems:\n\n1. **Avoid module-level global state in Home Assistant integrations**\n   - Storing shared state in global variables (`ISY`, `NODES`, `PROGRAMS`) makes it hard to reason about lifecycle, leads to hidden coupling between platforms, and complicates testing.\n   - Instead, use the host framework's dependency injection or shared storage mechanism (in Home Assistant, `hass.data`) to store shared objects and classification results. This centralizes state and makes it easier to extend and debug.\n\n2. **Centralize cross-domain classification logic**\n   - When multiple submodules/platforms need to classify entities (e.g., nodes into `binary_sensor`, `sensor`, `switch`, etc.), duplicated filtering logic is brittle. Any change must be mirrored across all domains, leading to drift and subtle bugs (e.g., a node appearing in multiple domains or in none).\n   - A better approach is to centralize classification in a core component that uses a well-defined set of heuristics, then store the results in a shared structure. Platforms merely consume these prepared lists. This makes behavior consistent and maintainable.\n\n3. **Design for evolving upstream APIs and multiple firmware versions**\n   - External systems evolve: ISY 5.x introduced `node_def_id` and changed the semantics of `uom`. A robust integration supports both old and new interfaces.\n   - Abstract detection heuristics into layered strategies with clear precedence:\n     - Use the most precise, explicit signals first (`node_def_id`).\n     - Fallback to structured type identifiers (`node.type` for Insteon).\n     - Finally, use heuristic matches (numeric uom IDs or lists of states).\n   - This layered design minimizes breakage when upstream semantics change and provides an easy place to add new detection paths.\n\n4. **Separate concerns between discovery/validation and entity instantiation**\n   - Program-based entities originally re-validated their structure and handled errors in each platform, leading to noise and inconsistencies.\n   - A better pattern: perform all validation in one place during discovery, then pass clean, validated tuples (or objects) to the platforms. Platforms are then thin and free from repeated try/except logic.\n   - Centralized validation also enables more informative and consistent logging when external structures (like program folders) are misconfigured.\n\n5. **Use configuration options for behavior that users may want to disable entirely**\n   - Not all data from an external system is useful in another context (e.g., ISY climate vs dedicated weather integrations). Instead of forcing users to hide entities post-creation, offer a config toggle (`enable_climate`) to prevent import entirely.\n   - Similarly, `ignore_string` allows users to avoid creating entities for certain nodes. This is better than a `hidden_string` that only affects UI visibility but still creates entities and consumes resources.\n\n6. **Treat naming/labeling separately from behavior or identity**\n   - Overloading a name substring both to drive behavior (hiding) and to form the entity name made the logic fragile. Removing name-based side effects from the core `ISYDevice.name` and handling user-friendly labels elsewhere (e.g., replacing underscores with spaces in climate names) results in cleaner semantics.\n\n7. **Use clear type checks and explicit attribute presence checks**\n   - Relying on exceptions like `AttributeError` for control flow can hide real errors and make intent unclear. Explicitly using `hasattr(node, 'uom')` or `hasattr(node, 'node_def_id')` improves readability and robustness.\n   - Also, using `==` instead of `is` for string or value comparison avoids subtle bugs due to Python's object identity semantics.\n\n8. **Declare capabilities accurately**\n   - Ensuring entities correctly implement fields like `supported_features` is important. For example, the fan entity should declare `SUPPORT_SET_SPEED` if it implements `set_speed`. This improves compatibility with frontends and automations.\n\n9. **Leverage framework lifecycle hooks for resource management**\n   - For long-lived connections or auto-update loops (e.g., `isy.auto_update`), register callbacks with the host application's lifecycle (e.g., `EVENT_HOMEASSISTANT_STOP`) to cleanly shut down instead of relying on globals or ad hoc mechanisms.\n\n10. **Refactoring as an opportunity to fix historical issues**\n    - When forced to update due to an upstream breaking change, it's often productive to also resolve existing technical debt in the module (like poor host parsing, inconsistent naming, and unused methods). Doing so can leave the integration in a markedly better state, making future adaptations easier.\n\nOverall, the key ideas are: share state via well-defined mechanisms, centralize classification and validation logic, design for evolving upstream APIs, avoid name-based behavioral hacks, and ensure entities accurately describe their capabilities.",
        "procedural_memory": [
            "When an external device integration breaks after a firmware or API change (as with ISY994 firmware 5.0.10), diagnose and fix it by centralizing classification logic, removing globals, and leveraging new upstream capabilities like NodeDefs. Follow these steps:",
            "Step 1: Identify symptoms and scope of breakage\n- Observe what changed after the firmware/API update: missing entities, wrong domains, crashes, or logs complaining about unknown uom values or node types.\n- Check the upstream release notes (e.g., ISY firmware 5.0.10) for breaking changes (deprecation of uom semantics, introduction of NodeDefs, new device families, etc.).\n- Reproduce the problem on a test environment if possible, with a simplified configuration.",
            "Step 2: Inspect existing discovery and classification logic\n- Locate where your integration currently determines entity types (e.g., per-domain `setup_platform` functions filtering nodes based on uom or type).\n- Look for duplicated logic across domains (e.g., each of `binary_sensor`, `sensor`, `switch`, etc. filtering `ISY.NODES` independently).\n- Identify any global state (module-level `NODES`, `PROGRAMS`, or a global controller instance) that is shared implicitly between domains.",
            "Step 3: Migrate shared state into a central, framework-aligned store\n- For Home Assistant, replace module-level globals with `hass.data` keys: e.g., `hass.data[INTEGRATION_NODES]`, `hass.data[INTEGRATION_PROGRAMS]`, and any other shared structures.\n- Initialize these structures at the start of the integration's `setup` or `async_setup` function.\n- Ensure each platform reads data from `hass.data` rather than from globals or its own independent discovery logic.",
            "Step 4: Centralize node classification heuristics\n- Implement a set of helper functions in the core integration module that can classify a node into a domain using multiple strategies in priority order:\n  - First, use precise metadata exposed by the new firmware/API (like `node_def_id` or similar) to match nodes to known categories.\n  - Second, use type identifiers (like Insteon `node.type` prefixes) that are stable across firmware versions.\n  - Third, use heuristic matching on fields like uom IDs or lists of possible state strings, while being aware of their limitations.\n- Encode these rules in a single categorization function that iterates over all nodes and populates a shared mapping: e.g., for Home Assistant, `hass.data[INTEGRATION_NODES][domain].append(node)`.",
            "Step 5: Implement domain-specific nuance centrally\n- If certain domains have special logic (e.g., differentiating `binary_sensor` vs `sensor` based on binary vs numeric uom), implement this in the shared categorization layer, not per-platform.\n- Similarly, handle scenes, groups, or other composite objects in one place (e.g., classifying scenes as switches).",
            "Step 6: Move program or rule-based entity handling to the component\n- If your integration supports entities based on program/automation objects in the device (like ISY programs), centralize their discovery and validation.\n- Define an expected folder or hierarchy convention, then write a single function to:\n  - Traverse the program tree.\n  - Validate the presence and type of required subobjects (e.g., status and actions programs).\n  - Log meaningful warnings for misconfigured structures.\n  - Store pre-validated tuples or objects in `hass.data` (e.g., `(name, status_node, actions_node)`).\n- Remove per-platform try/except logic for program discovery; platforms should just consume the validated tuples.",
            "Step 7: Update each platform to use the new shared structures\n- In each domain module (binary_sensor, sensor, switch, light, etc.), replace direct access to the device controller or global node lists with reads from `hass.data[INTEGRATION_NODES][DOMAIN]` and `hass.data[INTEGRATION_PROGRAMS][DOMAIN]`.\n- Simplify the platform `setup_platform` / `async_setup_entry` to:\n  - Instantiate entities from the prepared lists.\n  - Avoid reapplying complex filtering or classification.\n- Update entity base classes to inherit from a common integration base that manages node references, event subscriptions, and attributes.",
            "Step 8: Clean up configuration semantics\n- Remove configuration flags that overload entity naming or behavior (like a \"hidden\" string embedded in entity names to control UI visibility).\n- Introduce explicit configuration options for behaviors users may want to disable entirely, such as:\n  - A string that causes nodes to be ignored at import time (e.g., `ignore_string`).\n  - A boolean that controls whether certain data categories (e.g., climate or weather) should be imported (`enable_climate`).\n- Update documentation and default values to reflect the intended usage and to minimize surprises.",
            "Step 9: Fix platform-specific issues discovered during refactor\n- While refactoring, look for and correct existing bugs:\n  - Incorrect capability declarations (e.g., missing `supported_features` flags).\n  - Methods that attempt to write to read-only properties (such as directly setting `speed` on a program-based fan entity).\n  - Logical errors (using `is` instead of `==` for value comparison).\n  - Fragile parsing code (e.g., host/URL parsing done via `replace` instead of using `urlparse`).\n- Adjust entities to return the correct types for core properties (`bool` for `is_on`, `int` for value/status, etc.).",
            "Step 10: Tie into application lifecycle for cleanup\n- If your integration uses auto-updates or persistent connections, register a stop or teardown callback with the host application so that you can disable auto-updates and close connections cleanly on shutdown.\n- For Home Assistant, use `hass.bus.listen_once(EVENT_HOMEASSISTANT_STOP, stop_callback)` and in `stop_callback` turn off `auto_update` or close the client.",
            "Step 11: Test across firmware versions and device types\n- Confirm that the integration works with both older and newer firmware:\n  - Validate that `node_def_id`-based classification works on new versions.\n  - Ensure fallback heuristics (uom ID, states, type) still correctly classify devices on older versions.\n- Test with multiple device families (Insteon, Z-Wave, node servers, etc.) and special cases like weather/climate modules.\n- Verify that ignored nodes are not imported, climate nodes respect the `enable_climate` flag, and names/IDs remain stable so that existing automations aren't broken.",
            "Step 12: Log clearly and document expectations\n- Provide clear log messages when entities cannot be created due to misconfiguration (e.g., invalid program folder structure).\n- Document folder and naming conventions for program-based entities and configuration options (`ignore_string`, `enable_climate`, `sensor_string`).\n- Encourage users to test on their setups and report edge cases, especially when changes affect core discovery logic across many device types."
        ]
    }
}
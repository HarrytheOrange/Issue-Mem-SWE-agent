{
    "search_index": {
        "description_for_embedding": "Home Assistant Onkyo media_player integration mis-handled volume for newer receivers that report volume on a 0–200 scale. The code assumed a max of 80, causing incorrect normalization and set_volume handling. Fix updates SUPPORTED_MAX_VOLUME and all volume conversion logic to use 200 by default, while allowing older 0–80 receivers to specify max_volume=80 in configuration.",
        "keywords": [
            "Home Assistant",
            "onkyo",
            "media_player",
            "volume scaling",
            "max_volume",
            "SUPPORTED_MAX_VOLUME",
            "normalized volume 0..1",
            "device capability mismatch",
            "backwards compatibility",
            "configuration override"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant integration for Onkyo receivers assumed that all devices used a volume range of 1–80. Newer Onkyo receivers (e.g., TX-RZ830), however, represent volume from 0–100 in 0.5 increments and report this to Home Assistant as 0–200. Because the integration normalized volume to a 0..1 float by hardcoding 80 as the maximum (both when reading and when setting volume), newer receivers appeared with incorrect volume levels: the normalized values were off and the device could never reach what Home Assistant thought was 'max' volume.\n\nThe developer addressed this by:\n- Changing SUPPORTED_MAX_VOLUME from 80 to 200 in homeassistant/components/onkyo/media_player.py.\n- Updating the main-zone volume read path to divide the raw volume by 200.0 instead of 80.0.\n- Updating the main-zone set_volume_level to already respect self._max_volume (which now defaults to 200), leaving the logic but correcting the assumed max.\n- Updating the zone volume set_volume_level method to multiply the normalized volume by 200 instead of 80 and fixing its docstring to refer to 1–200.\n- Cleaning up type hints for KNOWN_HOSTS and addressing pydocstyle issues in the docstring formatting.\n\nAs a result, newer receivers that report 0–200 now map correctly to Home Assistant’s 0..1 volume range. Older receivers that truly max out at 80 can retain correct behavior by explicitly setting max_volume: 80 in their configuration, acknowledging a minor behavioral change where the default max is now tuned for newer devices.",
        "semantic_memory": "This fix illustrates a common integration issue: hardcoded assumptions about device capability ranges (here, volume max) break when hardware generations change protocols or scaling. The general pattern is:\n\n- External devices often represent quantities (volume, brightness, temperature) on arbitrary integer scales, while the application normalizes them to a canonical range (e.g., 0..1). If the integration assumes a fixed mapping (like 0–80) and the hardware moves to 0–200, the normalized values become incorrect and control feels wrong or capped.\n- To support multiple hardware generations, it is better to:\n  - Use a configurable or discoverable max/min value instead of hardcoding constants.\n  - Apply the same scaling logic consistently in both directions: when reading state from the device and when sending commands.\n  - Document the behavior and provide configuration escape hatches for legacy devices.\n- Even small numeric changes (80 → 200) can be effectively breaking changes, so they should be explicitly communicated and mitigated—here, by allowing old receivers to set max_volume=80.\n- When updating numerical assumptions in code, update all related docstrings, comments, and secondary paths (like zone-specific commands) to avoid subtle inconsistencies.\n\nIn general, whenever an integration maps device-specific ranges to application-level abstractions, it should be designed for variability (configuration, discovery, or per-device metadata) rather than encoding a single historical device’s characteristics.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of range mismatch.\n- Look for reports that a device (volume, brightness, etc.) never reaches 100% or jumps in unexpected increments.\n- Compare the device’s displayed/expected values with what the application (e.g., UI sliders, logs, state attributes) shows.\n- Check if the normalized value in the app (0..1) corresponds correctly to the device’s actual behavior.",
            "Step 2: Inspect integration code for hardcoded ranges.\n- Locate the integration/module for the affected device (e.g., homeassistant/components/onkyo/media_player.py).\n- Search for constants like MAX_VOLUME, SUPPORTED_MAX_VOLUME, or similar numeric limits.\n- Look for math that maps between raw device units and normalized units: divisions or multiplications by fixed numbers (e.g., `/ 80.0`, `* 80`).",
            "Step 3: Verify the device’s actual range and protocol behavior.\n- Check the device’s documentation or protocol specs for the valid numeric range and step size (e.g., Onkyo newer models: volume 0–200 representing 0–100 in 0.5 increments).\n- If possible, log or print the raw values returned by the device library/API to confirm real-world behavior.\n- Confirm whether different device generations use different ranges (e.g., older 0–80 vs newer 0–200).",
            "Step 4: Generalize or adjust the range handling.\n- If a single new range applies to most devices, update the global constant (e.g., SUPPORTED_MAX_VOLUME = 200 instead of 80).\n- Ensure any normalization uses this value consistently: state reading should do `normalized = raw / max_range`, and setting should do `raw = int(normalized * max_range)`.\n- If there are multiple possible ranges (old vs new hardware), introduce configuration or detection:\n  - Add a config option (e.g., max_volume) and default it to the most common or safest value.\n  - Allow users of legacy devices to override the default (e.g., set max_volume: 80 in configuration).",
            "Step 5: Update all code paths and documentation.\n- Find all occurrences of the old range in code and docstrings (search for the numeric literal, e.g., 80).\n- Update main zone and any additional zones or modes (e.g., secondary zones in receivers) to use the same scaling logic and updated range.\n- Revise docstrings and comments to reflect the new range and behavior, ensuring they describe the correct normalization logic.",
            "Step 6: Test with representative devices.\n- If possible, test with both a newer device (expected to use the new range) and an older one (with explicit configuration override).\n- Confirm that:\n  - Setting volume to 1.0 results in the maximum safe raw value for that device.\n  - Reading back raw values from the device yields correct normalized values.\n- Use automated tests where available to cover the conversion functions and avoid regressions.",
            "Step 7: Communicate breaking or behavior-changing aspects.\n- Note in issue/PR description if the change might alter behavior for existing users (e.g., older devices now assume a higher max unless configured).\n- Provide clear configuration examples showing how to restore legacy behavior (e.g., add `max_volume: 80` for old Onkyo receivers).\n- Update user-facing documentation to describe the new default scaling and the override option.",
            "Step 8: Clean up and conform to project standards.\n- Ensure type hints and structures (like KNOWN_HOSTS) follow current style (e.g., `KNOWN_HOSTS: List[str] = []`).\n- Fix any linting or style issues (e.g., pydocstyle for docstring formatting and whitespace).\n- Re-run the project’s test/lint suite (e.g., `tox`) before submitting the fix."
        ]
    }
}
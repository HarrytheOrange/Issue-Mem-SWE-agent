{
    "search_index": {
        "description_for_embedding": "Home Assistant hangouts component: Google Hangouts authentication via the hangups library was failing or unreliable. The underlying hangups library added a manual OAuth login flow (authorization code). This PR exposes a new optional 'authorization_code' field in the config flow, extends the credentials wrapper to carry this code, and passes a manual_login flag into hangups.get_auth, enabling successful manual authentication while keeping the existing username/password and 2FA flow intact. Tests were added for the new path.",
        "keywords": [
            "homeassistant",
            "hangouts",
            "hangups",
            "google hangouts",
            "authentication failure",
            "manual authentication",
            "authorization code",
            "OAuth",
            "config_flow",
            "CredentialsPrompt",
            "async_add_executor_job",
            "Google2FAError",
            "GoogleAuthError"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The Home Assistant Google Hangouts integration relied on the hangups library for authentication. Users reported that authentication was failing even when providing correct credentials. The hangups library had introduced a manual OAuth login method where users obtain an authorization code in a browser and feed it back to the client. The integration did not expose this capability, so users had no way to use the more reliable manual flow.\n\nTo fix this, the PR updated the hangouts integration as follows:\n\n1. **Config flow changes**:\n   - Added a new constant `CONF_AUTH_CODE = 'authorization_code'` in `homeassistant/components/hangouts/const.py`.\n   - Extended the config flow schema in `config_flow.py` to accept an optional `authorization_code` field:\n     ```python\n     data_schema=vol.Schema({\n         vol.Required(CONF_EMAIL): str,\n         vol.Required(CONF_PASSWORD): str,\n         vol.Optional(CONF_AUTH_CODE): str,\n     })\n     ```\n   - In `async_step_user`, the handler now reads:\n     ```python\n     user_email = user_input[CONF_EMAIL]\n     user_password = user_input[CONF_PASSWORD]\n     user_auth_code = user_input.get(CONF_AUTH_CODE)\n     manual_login = user_auth_code is not None\n     ```\n   - It constructs credentials with the auth code:\n     ```python\n     self._credentials = HangoutsCredentials(user_email,\n                                             user_password,\n                                             user_pin,\n                                             user_auth_code)\n     ```\n   - And calls `hangups.get_auth` through `async_add_executor_job` with a `manual_login` flag using `functools.partial`:\n     ```python\n     await self.hass.async_add_executor_job(\n         functools.partial(get_auth,\n                           self._credentials,\n                           self._refresh_token,\n                           manual_login=manual_login)\n     )\n     ```\n   - Existing exception handling for `GoogleAuthError` and `Google2FAError` is reused, so manual auth failures surface via the same error paths.\n\n2. **Credentials wrapper changes**:\n   - `HangoutsCredentials` in `hangups_utils.py` was extended to carry an optional authorization code:\n     ```python\n     def __init__(self, email, password, pin=None, auth_code=None):\n         self._email = email\n         self._password = password\n         self._pin = pin\n         self._auth_code = auth_code\n     ```\n   - New methods were added to satisfy the hangups manual auth API:\n     ```python\n     def get_authorization_code(self):\n         return self._auth_code\n\n     def set_authorization_code(self, code):\n         self._auth_code = code\n     ```\n   - Existing methods `get_email`, `get_password`, `get_verification_code`, and their setters remain intact for the non‑manual and 2FA flows.\n\n3. **Strings and translations**:\n   - The strings for the config UI were updated in `strings.json` and `.translations/en.json` to document the new field:\n     - Key `authorization_code` is labeled \"Authorization Code (required for manual authentication)\".\n   - This clarifies for users that the field is part of a manual login option.\n\n4. **Library version & requirements**:\n   - The component-level `REQUIREMENTS` in `homeassistant/components/hangouts/__init__.py` was bumped from `hangups==0.4.6` to `hangups==0.4.9` to ensure the manual auth API is available.\n   - `requirements_all.txt` and `requirements_test_all.txt` were toggled between 0.4.6 and 0.4.9 over multiple commits; the intent of the PR is to align them with `0.4.9` so that the new manual authentication API from hangups is present. (There is a minor rebase/merge artifact where the final diff temporarily shows 0.4.6—this would need resolution before merge.)\n\n5. **Tests**:\n   - `tests/components/hangouts/test_config_flow.py` gained `test_flow_works_with_authcode`:\n     ```python\n     async def test_flow_works_with_authcode(hass, aioclient_mock):\n         flow = config_flow.HangoutsFlowHandler()\n         flow.hass = hass\n\n         with patch('hangups.get_auth'):\n             result = await flow.async_step_user(\n                 {\n                     'email': 'test@test.com',\n                     'password': '1232456',\n                     'authorization_code': 'c29tZXJhbmRvbXN0cmluZw=='\n                 }\n             )\n         assert result['type'] == data_entry_flow.RESULT_TYPE_CREATE_ENTRY\n         assert result['title'] == 'test@test.com'\n     ```\n   - This verifies that providing an authorization code through the config flow results in a successful configuration entry when `hangups.get_auth` does not raise.\n\nAs a result, users who previously could not log into Google Hangouts through Home Assistant now have a robust alternative: they can perform the manual OAuth login described by hangups, paste the resulting authorization code into the Home Assistant config flow, and complete authentication successfully. The legacy username/password (and 2FA) path continues to work for those for whom it still functions.",
        "semantic_memory": "This fix illustrates several generalizable patterns for integrating third-party authentication flows into an application:\n\n1. **Expose library-level auth options through your configuration UX**:\n   When a third-party library (like hangups) adds a new authentication mechanism (e.g., manual OAuth with an authorization code), the application should expose that mechanism to users who depend on it. This typically requires:\n   - Extending configuration schemas to add new optional fields.\n   - Updating UI strings/translations to clearly signal how and when the new option is used.\n   - Routing conditional logic based on the presence/absence of those fields.\n\n2. **Use thin adapter objects to implement external interfaces**:\n   The hangups library expects a `CredentialsPrompt` with specific methods. Implementing a thin wrapper (`HangoutsCredentials`) that simply stores fields and exposes `get_*` and `set_*` methods allows the application to evolve alongside the library. When the library adds a new concept (authorization code), you only need to update the adapter to satisfy the new interface, rather than changing business logic everywhere.\n\n3. **Keep backward compatibility via optional configuration**:\n   Instead of replacing the old flow, the PR makes the authorization code optional and derives behavior from its presence. This pattern reduces migration friction:\n   - Users relying on the old behavior are unaffected.\n   - Users who need the new behavior can opt in.\n   Using `.get()` on `user_input` and `vol.Optional` in the schema is a clean way to achieve this.\n\n4. **Run blocking library calls in executors from async environments**:\n   In async frameworks (like Home Assistant's core), CPU or I/O-bound synchronous functions (e.g., `hangups.get_auth`) must not run in the main event loop. The pattern here uses `hass.async_add_executor_job` with `functools.partial` to pass extra parameters safely. This is a reusable pattern for any third-party blocking call.\n\n5. **Preserve error handling and domain-specific exceptions**:\n   New flows should reuse the same exception handling framework (here, `GoogleAuthError` and `Google2FAError`) so that downstream consumers don't need to be aware of which auth path was chosen. This encourages a cohesive error surface independent of underlying auth mechanisms.\n\n6. **Align dependency versions with features used**:\n   When relying on new library APIs, the component's declared requirements must guarantee a sufficiently new version. Accidentally mismatching per-component requirements vs project-wide requirements_all/test_all can cause subtle CI or runtime failures. Ensuring those files agree is part of robust dependency management.\n\n7. **Add focused tests for each configuration path**:\n   New authentication options should be covered by unit tests that:\n   - Simulate user input for the new fields.\n   - Patch out actual network calls or external login processes.\n   - Assert that the configuration entry is created or that errors are propagated as expected.\n   This guards against regressions in the config flow logic as the integration evolves.",
        "procedural_memory": [
            "To diagnose and fix similar issues where an integration’s authentication is failing and the underlying library offers additional auth mechanisms:",
            "Step 1: **Confirm the failure mode and library capabilities**\n- Reproduce the authentication failure using existing config (username/password, 2FA, etc.).\n- Check the underlying library’s documentation and changelog to see if it has introduced alternative auth flows (e.g., manual OAuth, device code, browser-based login).\n- Identify the exact API methods (and classes) required to use the new flow.",
            "Step 2: **Ensure the library version supports the desired flow**\n- Determine the minimum library version that includes the new authentication API.\n- Update the component/module’s dependency declaration to that version (e.g., `REQUIREMENTS` or `pyproject.toml`/`requirements.txt`).\n- Update any project-wide requirements files (e.g., `requirements_all.txt`, `requirements_test_all.txt`) to the same version to avoid mismatches.\n- Run dependency generation scripts if the project requires them (e.g., `script/gen_requirements_all.py`).",
            "Step 3: **Extend your credentials/adapter class to support new fields**\n- Locate your adapter class that implements the library’s credential interface (e.g., `CredentialsPrompt`).\n- Add new attributes in the constructor for any extra data the library needs (e.g., `auth_code`).\n- Implement any new methods required by the library (e.g., `get_authorization_code`, `set_authorization_code`).\n- Keep existing methods intact for backward compatibility.",
            "Step 4: **Modify the configuration flow or UI schema**\n- Add new optional fields for the additional auth data (e.g., `authorization_code`) to your config schema.\n  - In Home Assistant, this means adding `vol.Optional(CONF_AUTH_CODE): str` to the `data_schema`.\n- Add or update constants in your domain’s `const.py` (e.g., `CONF_AUTH_CODE = 'authorization_code'`).\n- Update user-facing strings and translations to clearly explain the new field (e.g., “Authorization Code (required for manual authentication)”).",
            "Step 5: **Wire the configuration input into the auth call**\n- In your config flow handler or setup function:\n  - Extract the new field using `.get()` so it remains optional: `auth_code = user_input.get(CONF_AUTH_CODE)`.\n  - Derive a control flag (e.g., `manual_login = auth_code is not None`).\n  - Instantiate your credentials object with the new parameter (email, password, 2FA pin, auth code, etc.).\n- When calling the library’s auth function:\n  - If it is blocking, wrap it with an executor job or equivalent (`async_add_executor_job`, `run_in_executor`, etc.).\n  - Use `functools.partial` (or similar) to pass additional keyword arguments like `manual_login=manual_login` cleanly.\n- Maintain existing try/except blocks for domain-specific auth exceptions so the rest of the system doesn’t need to know about the internal auth mode.",
            "Step 6: **Test all relevant auth paths**\n- Add unit tests for:\n  - The original auth flow (username/password, with and without 2FA).\n  - The new manual auth flow, e.g. with an authorization code provided.\n- In tests:\n  - Instantiate the config flow handler and assign any required attributes (like `flow.hass`).\n  - Patch the library’s `get_auth` (or equivalent) to avoid real network or browser interactions and to simulate success or failure.\n  - Call the config step with the appropriate input and assert that:\n    - Successful flows create a configuration entry (`RESULT_TYPE_CREATE_ENTRY`).\n    - Failed flows populate the correct errors in the response.\n- Run the full test suite and ensure new tests pass consistently.",
            "Step 7: **Verify UX and documentation**\n- Confirm that the configuration UI displays the new field and explanatory text correctly.\n- Ensure that the field is treated as optional (or required only in the context of the new flow) and does not break existing configurations.\n- Update user documentation to teach users how to perform the manual login steps (e.g., follow the underlying library’s manual login guide, copy the authorization code, paste it into the configuration).",
            "Step 8: **Review for consistency and cleanup**\n- Check for any rebase or merge artifacts (e.g., conflicting requirement versions, duplicate translation keys) and resolve them.\n- Remove dead or unused code related to previous auth attempts if it is no longer needed.\n- Make sure passwords or tokens are not inadvertently persisted beyond what the application design intends (e.g., only refresh tokens stored, not raw passwords)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Added first-class support for parameterized sensor instances in StackStorm by introducing SensorInstance and SensorExecution models, persistence layer, REST APIs, controllers, and pack-based registration. Fixed multiple integration bugs such as incorrect attribute mappings, wrong controller models, missing loader support for new content type 'sensorinstances', and typos in module names and content_type identifiers.",
        "keywords": [
            "StackStorm",
            "sensor",
            "SensorType",
            "SensorInstance",
            "SensorExecution",
            "multiple sensors with different configs",
            "DB models",
            "MongoDBAccess",
            "persistence layer",
            "CUD publisher",
            "REST API",
            "controllers",
            "sensorinstancesregistrar",
            "content loader",
            "pack registration",
            "st2ctl reload",
            "fixtures",
            "CleanDbTestCase",
            "parameters_schema",
            "content_type typo",
            "module import typo"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request extended StackStorm's sensor subsystem to support running multiple instances of the same sensor type with different configurations. Previously, only SensorType existed, making it hard to have multiple logically separate sensor processes with distinct parameters and credentials.\n\nThe change introduced two new MongoDB-backed models: SensorInstanceDB (a parameterized instantiation of a SensorType) and SensorExecutionDB (a runtime record of a SensorInstance running on a specific sensor node). Corresponding persistence wrappers (SensorInstance, SensorExecution) and a new CUD publisher (SensorInstanceCUDPublisher) were created.\n\nOn the API side, SensorInstanceAPI and SensorExecutionAPI were added along with JSON schemas. The existing SensorTypeAPI was extended with a `parameters_schema` field to declare allowed input parameters. Utility functions in `sensor_type_utils` were extended to translate between API and DB models for all three types (SensorType, SensorInstance, SensorExecution). Initially, there was a bug in `to_sensor_instance_db_model`: it called `getattr(sensor_instance_api_model, '')`, which was quickly fixed to `getattr(..., 'parameters_schema', {})`.\n\nNew controllers were wired into the v1 API root: `/v1/sensorinstances` (SensorInstanceController, a ContentPackResourceController) and `/v1/sensorexecutions` (SensorExecutionController, ResourceController). Early versions mistakenly had SensorExecutionController using SensorInstanceAPI/Access and missing filter support; this was corrected to use SensorExecutionAPI/SensorExecution with filters on `sensor_node`, `sensor_instance`, and `status`.\n\nTests were added for the new DB models and persistence logic (CRUD on SensorType, SensorInstance, SensorExecution) and for the new endpoints. The functional tests load fixtures via FixturesLoader; to support the new resource types, FixturesLoader was extended so that:\n- `sensorinstances` and `sensorexecutions` are valid fixture types.\n- Appropriate API, DB, and persistence classes are mapped for them.\n- Optional `fixtures_dict` arguments default to `None` instead of `{}` to avoid mutable default pitfalls.\n\nTo allow sensor instances to be declared in packs, a new registrar `SensorInstancesRegistrar` was implemented under `st2reactor.bootstrap.sensorinstancesregistrar`. It discovers `sensorinstances/` folders in packs, loads YAML metadata, normalizes/validates the `pack` field, maps YAML -> SensorInstanceAPI -> SensorInstanceDB, and upserts into the DB (updating existing instances with the same pack+name). The registrar is exposed via `register_sensor_instances` which can operate over all packs or a single pack.\n\nMultiple integration bugs were uncovered and fixed while wiring this:\n- `bootstrap.register_sensor_instances()` initially imported `st2reactor.bootstrap.sensorsinstancesregistrar` (typo) instead of `sensorinstancesregistrar`.\n- In `SensorInstancesRegistrar.register_sensor_instances_from_pack`, the content_type was misspelled as `sensorinstnaces`; this caused the registrar to find no sensorinstances when registering a single pack and was fixed to `sensorinstances`.\n- The global content loader `ContentPackLoader` originally only knew about `sensors`, `actions`, `rules`, `aliases`, `policies`. It was extended to treat `sensorinstances` as a valid content type and delegate to `_get_sensorinstances`, which returns the `sensorinstances/` folder.\n- The CLI tool `st2ctl` and the `contrib/packs/actions/load.yaml` action were updated to add a `--register-sensorinstances` flag and to include sensorinstances in the default reload pipeline. Help strings were updated accordingly.\n\nAs features matured, tests had to be updated: a new fixture pack (`pack_with_sensor_instances`) added a parameterized sensor and its instances, which increased the total sensor/trigger counts. The existing `test_sensor_and_rule_registration` assertions that expected only two sensors and two trigger types were generalized into helper methods that locate sensors and trigger types by name, so they remain robust as fixture counts grow. A dedicated `SensorInstanceRegistrationTestCase` using `CleanDbTestCase` verifies both multi-pack and single-pack registration of sensor instances and validates relationships: the ParameterizedSensor exists, two SensorInstances exist in the `pack_with_sensor_instances` pack, and their `sensor_type` references are correct.\n\nOverall, the PR lays the groundwork for multi-instance, parameterized sensors in StackStorm, with full DB persistence, API surface, pack-based registration, and a battery of tests, while iteratively fixing wiring typos and translation bugs discovered by those tests.",
        "semantic_memory": "This work illustrates a general pattern of introducing a new resource type into a distributed automation platform and ensuring it is fully integrated across persistence, API, content loading, and CLI tooling.\n\nKey conceptual takeaways:\n\n1. **Instance vs. Type modeling**: When a system previously modeled only 'types' (e.g., SensorType), adding 'instances' (SensorInstance) allows for multiple concrete deployments of the same type with different configuration, credentials, or runtime behaviors. This is especially important for event sources (sensors, listeners) where users may want separate, independently controlled processes.\n\n2. **Runtime execution records**: Separate from configuration instances, designing a lightweight execution model (SensorExecution) allows capturing per-node runtime state: where an instance is running, its status, and possibly other diagnostics. This pattern mirrors 'Execution' entities for actions or workflows and is useful for monitoring and orchestration.\n\n3. **Consistency across layers**: Adding a new core concept requires consistent handling in several layers:\n   - DB models and access objects (MongoDBAccess) with appropriate fields and indexes (e.g., pack+name identity, references to other models via string refs).\n   - Persistence facade classes (e.g., SensorInstance, SensorExecution) often with CUD publishers for messaging.\n   - API models (BaseAPI derivatives) and schemas for validation, including complex schema fields like `parameters_schema` and `parameters` that use JSON Schema constructs. Utility functions (like `sensor_type_utils`) centralize the API<->DB translation.\n   - Web controllers that expose CRUD endpoints and filter options (`name`, `pack`, `sensor_type`, `sensor_node`, `status`) while reusing generic base controllers when possible.\n   - Content loaders and registrars that know how to discover and register the new content type from pack directories, unify behavior with existing content types, and enforce invariants (like `pack` field consistency).\n   - CLI tooling and default reload flows that include the new resource type so operational workflows stay coherent.\n\n4. **Error patterns when wiring new content types**:\n   - **Typos in content_type names** (`sensorinstnaces` vs `sensorinstances`) and module imports (`sensorsinstancesregistrar` vs `sensorinstancesregistrar`) are common and can silently break discovery or registration. Tests that exercise single-pack and multi-pack registration catch these issues.\n   - **Wrong model/access in controllers**: Copy-paste errors where a controller uses the wrong API model or persistence access class result in confusing runtime behavior and must be caught by functional tests hitting the endpoints.\n   - **API/DB translation bugs**: Using incorrect attribute names (e.g., `getattr(..., '')`) leads to missing fields or schema mismatches. Centralizing translation logic and testing it with realistic fixtures mitigates this.\n\n5. **Fixtures and test evolution**: Test fixtures act as a canonical source of truth for pack content; when adding new content types, existing tests may break because counts change. It's better to assert on specific properties (e.g., \"a sensor named X exists with poll_interval Y\") than on rigid list lengths or positions, especially in systems where new built-in content may be added over time.\n\n6. **Pack-based registration as a pattern**: The pattern for registering a new resource type from packs is reusable:\n   - Extend the content loader with a new content_type and folder mapping.\n   - Implement a registrar that: (a) loads YAML metadata, (b) injects/validates the `pack` field, (c) translates to API and DB models, (d) upserts based on a natural key (pack+name), and (e) logs failures gracefully.\n   - Integrate this registrar into both a top-level bootstrap function and the CLI so operators can consistently reload content.\n\n7. **Strong tests for integration**: Unit tests for DB CRUD and API schemas must be complemented with functional tests that:\n   - Call real HTTP endpoints for the new controllers.\n   - Use FixturesLoader to populate realistic data in the database.\n   - Verify filtering behaviors (by type, by node, by status) and reference resolution (using `get_reference().ref`).\n   Using CleanDbTestCase or equivalent ensures tests don't interfere with each other by sharing state.\n\nThese patterns apply beyond StackStorm sensors: any system that needs to support multiple parameterized instances of a plugin or service type can follow a similar approach: define instance and execution models, create consistent API layers, and integrate with any content/pack or plugin-registration mechanisms present in the system.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues involving adding a new resource type (like SensorInstance) to a system with DB models, APIs, and pack-based registration.",
            "Step 1: Model the new concepts in the data layer.\n- Identify whether you need just a configuration-time instance model, a runtime execution model, or both (e.g., SensorInstanceDB and SensorExecutionDB).\n- Define DB models with required fields, including references to existing models via string refs (e.g., `sensor_type` as a reference to SensorType, `sensor_instance` as a reference to SensorInstance).\n- Add new MongoDBAccess instances and include them in any global MODELS or registry lists.\n- Write basic CRUD unit tests to ensure the models can be created, updated, and deleted without errors.",
            "Step 2: Add persistence facades and publishers.\n- Create persistence classes for the new models (e.g., SensorInstance, SensorExecution) that wrap the DB access layer.\n- For content-pack resources, subclass the appropriate base (e.g., ContentPackResource); for runtime-only data, use a simpler Access base.\n- Add CUD publishers if the system needs to broadcast create/update/delete events (e.g., SensorInstanceCUDPublisher, SENSOR_INSTANCE_CUD_XCHG).\n- Wire these publishers into the persistence classes’ `_get_publisher` methods.\n- Verify that CUD events are emitted as expected, mocking the underlying message publishers in tests.",
            "Step 3: Extend API models and conversion utilities.\n- Create API models for the new resource types (e.g., SensorInstanceAPI, SensorExecutionAPI) with JSON schemas describing all fields, including nested `parameters` or `parameters_schema`.\n- In the conversion utility module (e.g., `sensor_type_utils`), add functions to translate API models to DB models and vice versa.\n- Be careful with `getattr` defaults: always specify the correct attribute name and sensible default values, and avoid typos like `getattr(obj, '')`.\n- Update existing API models (e.g., SensorTypeAPI) to include new fields such as `parameters_schema` if necessary.\n- Add or update unit tests to validate schema correctness and API<->DB translation, including edge cases like missing optional fields or minimum poll intervals.",
            "Step 4: Implement and wire API controllers.\n- Add new controllers for the resource type under your API package (e.g., SensorInstanceController, SensorExecutionController), using appropriate base classes like ContentPackResourceController or ResourceController.\n- Set the `model`, `access`, `supported_filters`, and `options` attributes correctly.\n- Ensure `supported_filters` map query parameters to the actual DB field names (e.g., `type` -> `sensor_type`, `sensor_node` -> `sensor_node`).\n- Register controllers in the root API controller so routes like `/v1/sensorinstances` and `/v1/sensorexecutions` are accessible.\n- Write functional tests that hit these endpoints, asserting status codes, payload shape, and filter behavior.\n- Watch for copy-paste mistakes where controllers reference the wrong model or access class and fix them promptly.",
            "Step 5: Integrate new content types into the content loader and registrars.\n- Extend the central content loader's `ALLOWED_CONTENT_TYPES` to include the new type (e.g., `sensorinstances`).\n- Implement helper methods such as `_get_sensorinstances` that map the content type to a folder (`sensorinstances/`) under each pack.\n- Implement a registrar (e.g., SensorInstancesRegistrar) that:\n  - Discovers the `sensorinstances` directories in packs and lists YAML files.\n  - Uses a meta loader to parse YAML into dicts.\n  - Ensures `pack` is set correctly (inject from folder name if missing; validate if present).\n  - Constructs API and DB models and upserts based on a natural key (pack+name), updating existing records when needed.\n  - Handles exceptions gracefully, logging failures but continuing with other files where appropriate.\n- Provide both multi-pack (`register_x_from_packs(base_dirs)`) and single-pack (`register_x_from_pack(pack_dir)`) registration methods.\n- Fix any typos in content_type strings (e.g., `sensorinstnaces` -> `sensorinstances`) discovered during testing.",
            "Step 6: Hook the new registration into bootstrap and CLI workflows.\n- Update the bootstrap module to add a configuration flag for your new resource type (e.g., `cfg.BoolOpt('sensorinstances', ...)`).\n- Implement a `register_sensor_instances()` function that logs start/end, imports the registrar lazily (to avoid hard dependencies), and calls it with the configured pack directory if any.\n- Integrate this function into the overall `register_content()` pipeline so that `--register-all` or specific flags perform the new registration.\n- Update CLI tools (e.g., `st2ctl`) to:\n  - Include new flags like `--register-sensorinstances` in allowed arguments and usage help.\n  - Add the new flag to the default registration flags so reloads behave consistently.\n- Update any higher-level actions (like `packs.load`) that orchestrate content reloads to include the new content type in their default `register` argument.",
            "Step 7: Extend FixturesLoader and tests to support new fixtures.\n- Modify FixturesLoader to recognize the new fixture categories (e.g., `'sensorinstances'`, `'sensorexecutions'`) in ALLOWED_DB_FIXTURES and to map them to the correct API/DB/persistence classes.\n- Avoid using mutable defaults for function arguments (e.g., use `fixtures_dict=None` and set `fixtures_dict = {}` inside) to prevent cross-test contamination.\n- Create YAML fixtures for your new resource types under test pack directories.\n- In functional tests, use FixturesLoader to load sensors, sensorinstances, and sensorexecutions into the DB and assert that endpoints return the expected counts and data.\n- If adding new fixtures changes counts that existing tests assert on, refactor those tests to look up resources by name and properties instead of indexes/lengths when appropriate.",
            "Step 8: Debug common integration failures.\n- If registration of a new resource type silently results in zero items:\n  - Verify the content loader supports your content_type and returns the expected folder.\n  - Check for typos in content_type strings passed to the loader or registrar.\n  - Ensure the registrar is actually being called from bootstrap/CLI with correct arguments.\n- If API endpoints return 404 or wrong data:\n  - Confirm the controller is registered in the root controller with the expected route name.\n  - Verify the controller `model` and `access` attributes reference the correct classes.\n- If translation errors occur (missing fields, wrong defaults):\n  - Inspect the conversion utilities for incorrect attribute names or missing properties.\n  - Add targeted unit tests for the problematic translation.\n- If tests fail due to unexpected extra records (e.g., sensor counts):\n  - Check for new fixtures or new built-in content introduced by your changes.\n  - Update tests to assert on the presence of specific items instead of exact counts, or adjust counts accordingly if they are meant to be precise.",
            "Step 9: Enforce referential consistency and validation.\n- Ensure that instance models reference valid types (e.g., SensorInstance.sensor_type refers to an existing SensorType). While this PR leaves detailed validation as a TODO, in a mature system you should:\n  - In the registrar, lookup the referenced type and fail-fast or log an error if it doesn’t exist.\n  - Optionally enforce database-level constraints or application-level checks to prevent orphaned instances.\n- When designing execution models, ensure they link back to instance models and include any necessary runtime metadata to make debugging easier (e.g., node name, status, timestamps)."
        ]
    }
}
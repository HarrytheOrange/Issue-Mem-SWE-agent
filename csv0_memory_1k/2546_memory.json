{
    "search_index": {
        "description_for_embedding": "Legacy CI packaging for the new st2stream service was failing because the service lacked old-style Debian/RPM metadata and Makefile targets. The fix added a component Makefile, Debian packaging files, RPM spec files, updated config installation paths, and wired stream logging into the production config so legacy packaging pipelines could build successfully.",
        "keywords": [
            "st2stream",
            "StackStorm",
            "packaging",
            "Debian",
            "RPM",
            "spec file",
            "Makefile",
            "CI build failure",
            "legacy packaging",
            "stream service",
            "logging config",
            "st2.prod.conf"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a new service (st2stream, the Stream API) was introduced into a codebase that still relied on an older packaging pipeline for CI (legacy Debian and RPM builds driven by per-component Makefiles and spec files). The st2stream component had no old-style packaging metadata or Makefile, so CI and packaging workflows that expected these artifacts failed.\n\nTo remedy this, the developer added a classic per-component Makefile under st2stream/ that supports building RPMs and Debian packages, including targets like `rpm`, `rhel-rpm`, `deb`, `wheelhouse`, and `bdist_wheel`. The Makefile includes logic to populate the Python package version, fixate requirements, generate a Debian changelog entry, and install configuration files during packaging. The initial Makefile’s post_install logic incorrectly used `logging.api.conf` and `syslog.api.conf`; this was later corrected to `logging.stream.conf` and `syslog.stream.conf` so that stream-specific configuration is installed under `/etc/st2/`.\n\nThe PR also added a complete Debian packaging skeleton for st2stream under `st2stream/packaging/debian/` (control, changelog, postinst, install, rules, etc.), and RPM spec files under `st2stream/packaging/rpm/`. The RPM metadata initially used filenames `st2api.spec` and `st2api-rhel6.spec`, which would be misleading or incorrect for the stream component. A subsequent patch renamed these files to `st2stream.spec` and `st2stream-rhel6.spec` while keeping their content, ensuring naming consistency and preventing confusion.\n\nFinally, the production configuration `conf/st2.prod.conf` was updated to include a `[stream]` section referencing `/etc/st2stream/logging.conf`. This ensures that the deployed system knows where to find the st2stream logging configuration and that the packaging-installed config is actually used at runtime.\n\nOverall, the fix reintroduced and aligned the necessary old-style packaging metadata and configuration wiring for the st2stream service so that legacy CI and deployment flows continue to function until the new packaging system can fully replace them.",
        "semantic_memory": "This fix illustrates key patterns when integrating a new service into an existing ecosystem that still depends on legacy build and packaging pipelines.\n\n1. **Backward compatibility with legacy packaging**: Even if a project is migrating to a modern packaging process (e.g., wheels, container images, or a central build system), existing CI/CD pipelines and deployment environments may still depend on older mechanisms (Debian `debian/` directories, RPM spec files, per-component Makefiles). When introducing a new component, you often must add corresponding legacy packaging artifacts to avoid breaking established workflows.\n\n2. **Consistency of naming and configuration paths**: Component-specific resources (like config files and logging configs) must be named consistently with the component (e.g., `logging.stream.conf` for `st2stream`, not `logging.api.conf`) and installed under predictable paths. Misaligned names or paths can cause runtime misconfigurations that are hard to trace back to packaging scripts.\n\n3. **Tight coupling between packaging and runtime configuration**: Packaging scripts (Makefiles, spec files, postinst scripts) don't just bundle code—they also install and potentially mutate configuration files (e.g., changing log directories from `logs` to `/var/log/st2`). Any new service should have its configuration install logic wired similarly to existing components so that logging, paths, and environment expectations are consistent across the system.\n\n4. **Evolving file names without changing semantics**: When files are misnamed (e.g., `st2api.spec` used for the stream service), renaming them to align with the actual component is important for maintainability, even if the content is identical. This reduces confusion and helps future developers quickly locate the correct packaging metadata for each service.\n\n5. **Mirroring patterns from existing components**: The simplest and most reliable way to add packaging for a new service is to clone the patterns used by similar services (e.g., st2api, st2sensorcontainer) and adjust names, requirements, and config targets. This ensures consistent behavior and reduces the likelihood of missing necessary steps that CI expects.",
        "procedural_memory": [
            "Step-by-step approach to diagnose and fix missing legacy packaging for a new service in a monorepo:",
            "Step 1: Inspect CI failure logs. Look for errors indicating missing Makefile targets, missing Debian `debian/` directory, missing RPM spec files, or failed `dpkg-buildpackage`/`rpmbuild` commands for the new service (e.g., `st2stream`).",
            "Step 2: Confirm the new service’s layout. Verify that the service has a proper Python package/module, entrypoints (bin scripts), and config files (`conf/`), but lacks packaging metadata (no `packaging/debian/` or `packaging/rpm/`, no per-component Makefile).",
            "Step 3: Identify an existing, similar component. Choose a reference service (e.g., st2api or another API-like component) that already builds correctly with the current CI tooling. Use its Makefile and packaging metadata as a template.",
            "Step 4: Create a per-component Makefile for the new service. Include targets for cleaning, linting, and packaging (e.g., `rpm`, `rhel-rpm`, `deb`, `wheelhouse`, `bdist_wheel`). Ensure it:\n- Defines the component name (`COMPONENTS := <service_name>`).\n- Calls any shared scripts to populate version information.\n- Fixates or processes requirements as other components do.\n- Installs config files into the correct destination paths in `DESTDIR`.\n- Generates a Debian changelog entry when building on Debian/Ubuntu.",
            "Step 5: Add Debian packaging metadata. Under `packaging/debian/` for the new service, add:\n- `control` with the correct package name, description, and dependencies.\n- `changelog`, `compat`, `rules`, and any required `README.*` templates.\n- `install` defining how to place the Python package, configs, and binaries into the filesystem.\n- `postinst` and other maintainer scripts if runtime tweaks (e.g., rewriting log paths) are necessary.",
            "Step 6: Add RPM spec files. Under `packaging/rpm/`, create spec files for the service:\n- Name them consistently with the component (`<service>.spec`, `<service>-rhel6.spec` etc.).\n- Set `Name`, `Summary`, `Version`, `Release`, and `Requires` appropriately.\n- In `%build` and `%install` sections, follow the patterns used by existing services: adjust config paths (e.g., change `logs` to `/var/log/<app>`), create directories, copy the Python package into `%{python2_sitelib}`, copy config files, and install binaries into `/usr/bin`.",
            "Step 7: Wire logging and configuration into the main config. Update the main production config (e.g., `st2.prod.conf`) to add a section for the new service (e.g., `[stream]`) and point its logging directive to the correct path installed by packaging (e.g., `/etc/<service>/logging.conf` or `/etc/st2/logging.<service>.conf`).",
            "Step 8: Align config file names. Ensure that the Makefile and packaging scripts use component-specific naming for logging and syslog configs (e.g., `logging.stream.conf`, `syslog.stream.conf`), not reused names from another service. Update any sed/patch commands that rely on those file names.",
            "Step 9: Build packages locally. On a Debian-based system, run the new service’s Makefile `deb` or `install` target and verify that `dpkg-buildpackage` completes and produces `.deb` files. On an RPM-based system, run `rpm`/`rhel-rpm` to ensure `rpmbuild` succeeds and produces `.rpm` files.",
            "Step 10: Install and smoke-test the packages. Install the generated Debian/RPM package in a test environment. Confirm that:\n- Python modules are installed in the expected site-packages directory.\n- Config files exist under `/etc/<service>` or `/etc/st2/` with correct names.\n- Log paths in configs use the central log directory (e.g., `/var/log/st2`).\n- The service starts successfully and uses the expected logging configuration.",
            "Step 11: Update CI/CD configuration if needed. If there is a separate CI repo or build configuration (such as `st2cd`), ensure it is updated to include the new service’s packaging artifacts or build steps.",
            "Step 12: Clean up and deprecate legacy paths over time. Once the new packaging or deployment system is fully in place, plan a migration to remove or deprecate the old Makefiles and packaging metadata, but only after verifying that no CI or deployment flows still depend on them."
        ]
    }
}
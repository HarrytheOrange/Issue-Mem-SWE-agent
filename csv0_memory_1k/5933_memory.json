{
    "search_index": {
        "description_for_embedding": "Home Assistant Z-Wave refactor: renamed the per-entity configuration section from `customize` to `device_config` and rewired how configuration is validated and accessed. Initial change broke Z-Wave because the voluptuous schema expected the wrong data shape (list vs dict and required `entity_id`), causing configuration validation errors and Z-Wave startup failures. The fix introduces a proper `device_config` dict schema, stores it in `hass.data` for use by platforms (e.g., light.zwave), and relaxes the schema so `entity_id` is not required inside each entry.",
        "keywords": [
            "Home Assistant",
            "Z-Wave",
            "zwave",
            "device_config",
            "customize",
            "configuration schema",
            "voluptuous",
            "validation error",
            "Invalid config for [zwave]",
            "dict vs list",
            "hass.data",
            "regression",
            "breaking change",
            "light.zwave"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This incident arose during a refactor of Home Assistant's Z-Wave configuration. The goal was to rename the Z-Wave-specific configuration section from `customize` to `device_config` to avoid confusion with the global `customize` mechanism and to better support a future configuration panel.\n\nPreviously, Z-Wave per-entity options were configured as:\n\n  zwave:\n    customize:\n      switch.bla_die_bla_0_1:\n        ignored: true\n\nThe PR changed this to:\n\n  zwave:\n    device_config:\n      switch.bla_die_bla_0_1:\n        ignored: true\n\nThe first patch attempted to implement this by:\n- Removing the dependency on `homeassistant.helpers.customize` in the Z-Wave component.\n- Introducing `CONF_DEVICE_CONFIG` and a `_DEVICE_CONFIG_SCHEMA_ENTRY` voluptuous schema.\n- Changing the configuration schema to define:\n    vol.Optional(CONF_DEVICE_CONFIG, default={}): _DEVICE_CONFIG_SCHEMA_ENTRY\n- Switching runtime lookup from `customize.get_overrides(...)` to directly indexing the config: `config[DOMAIN][CONF_DEVICE_CONFIG].get(name)`.\n\nHowever, this introduced multiple problems:\n1. **Schema shape mismatch:**\n   - The old `customize` mechanism accepted both dict and list forms (and had its own validation via `customize.CUSTOMIZE_SCHEMA`).\n   - The new schema made `device_config` map directly to a single `_DEVICE_CONFIG_SCHEMA_ENTRY` instead of a dict-of-entries keyed by entity_id.\n   - Users commonly had either a mapping like `device_config: { entity_id: {..} }` or a list-like form from previous patterns. With the new schema, configurations were rejected with errors such as:\n\n     \"Invalid config for [zwave]: [sensor.aeotec_...] is an invalid option for [zwave]. Check: zwave->zwave->device_config->sensor.aeotec_...\"\n\n   - Another user had a list of configs including wildcards; the validator expected a dictionary but got a list, resulting in:\n\n     \"expected a dictionary for dictionary value @ data['zwave']['device_config']. Got [OrderedDict([...]), ...]\"\n\n   - In practice this meant that any non-empty `device_config` broke Z-Wave initialization.\n\n2. **Runtime access pattern:**\n   - Initially the code still read directly from `config[DOMAIN][CONF_DEVICE_CONFIG]` in the Z-Wave `value_added` callback, and light.zwave still used the old `customize.get_overrides` helper.\n   - This created inconsistent access patterns and made later evolution (e.g., config panel) harder.\n\nUsers reported that after the upgrade Z-Wave completely stopped working when `device_config` was present. Even when `device_config` was removed, some setups still showed missing devices, increasing confusion.\n\nThe subsequent patches fixed this refactor:\n\nPatch 2:\n- Introduced `DATA_DEVICE_CONFIG = 'zwave_device_config'` and stored the final resolved Z-Wave device config in `hass.data[DATA_DEVICE_CONFIG] = config[DOMAIN][CONF_DEVICE_CONFIG]` during setup.\n- Updated `value_added` to use this shared store:\n\n  name = \"{}.{}\".format(component, object_id(value))\n  node_config = hass.data[DATA_DEVICE_CONFIG].get(name)\n\n- Updated `light.zwave` to also use `hass.data[zwave.DATA_DEVICE_CONFIG].get(name)` instead of `customize.get_overrides(...)`, ensuring all Z-Wave platforms pull configuration from the same source.\n\nPatch 3:\n- Relaxed the `_DEVICE_CONFIG_SCHEMA_ENTRY` by removing `vol.Required(CONF_ENTITY_ID)` from the schema. Since `device_config` entries are keyed by entity ID in the config dict, requiring an inner `entity_id` key was unnecessary and conflicted with how users wrote their configs.\n\nAfter these changes:\n- The `device_config` section is a dict mapping entity_id -> options dict.\n- Each options dict can contain `polling_intensity`, `ignored`, `refresh_value`, and `delay`, all optional.\n- The schema no longer expects a list or an inner `entity_id` field, eliminating the earlier validation errors.\n- All Z-Wave components (core and light platform) consistently access configuration via `hass.data[zwave.DATA_DEVICE_CONFIG]`.\n\nThe root cause of the regression was a misdesigned configuration schema and partial migration away from the `customize` helper: the new key name was introduced without mirroring the old data shape and access patterns, causing validation errors and runtime breakage. The fix aligned the schema with actual usage (dict keyed by entity_id), centralized storage in `hass.data`, and updated all consumers to use the new mechanism.",
        "semantic_memory": "Generalizable lessons from this fix:\n\n1. **Preserve or clearly migrate configuration data shapes when renaming keys.**\n   When refactoring configuration (e.g., renaming `customize` to `device_config`), it is not enough to change the key name. The value's structure (dict vs list, nested keys, required fields) and semantics must either remain compatible or be carefully migrated. If users previously provided `component: { entity_id: {options...} }`, the new key should expect the same shape unless a breaking migration is explicitly implemented and documented.\n\n2. **Schema validation must accurately reflect runtime expectations.**\n   Voluptuous (or any config validator) should describe the structure the code actually uses. In this case, the code expected `device_config` to be a mapping of entity IDs to option dicts, but the initial schema treated it as a single entry schema. This mismatch caused validation errors before the code even ran. Always design schema definitions with the final access pattern in mind (e.g., `vol.Schema({ str: entry_schema })` for dicts).\n\n3. **Avoid duplicating identifier fields inside keyed mappings.**\n   If configuration is keyed by a unique identifier (like an entity_id in a dict), do not require that same key to appear redundantly inside each value. It complicates the schema, invites inconsistencies, and creates friction. In this case, requiring `CONF_ENTITY_ID` inside each `_DEVICE_CONFIG_SCHEMA_ENTRY` was unnecessary and was eventually removed.\n\n4. **Centralize shared configuration in a common data store.**\n   Multiple platforms (e.g., `zwave` core component and `light.zwave`) needed access to the same per-entity options. Storing this config under `hass.data[CONST]` allowed all components to read a consistent view. This is a general pattern: use a shared application-level registry or store for component-wide configuration instead of recomputing or re-reading from raw config in each platform.\n\n5. **Remove or update tests alongside behavior changes.**\n   The original tests for `customize` behavior were deleted when the feature moved to `device_config`. However, there was no equivalent test suite validating the new configuration schema and shapes. When refactoring, ensure you either adapt existing tests to the new behavior or recreate coverage. This would have caught the dict-vs-entry schema bug before users encountered it.\n\n6. **Keep migration paths explicit and communicate breaking changes.**\n   Changing a frequently used configuration section is a breaking change. It should come with a clear migration path and explicit validation errors explaining how to update configs (e.g., deprecating old keys, providing warnings, and documentation). Silent schema changes that cause generic 'Invalid config' errors increase user frustration.\n\n7. **Be careful when removing helper abstractions.**\n   Replacing a common helper (`customize.get_overrides`) with direct config access needs coordinated updates across all call sites. Missing one (e.g., in `light.zwave`) can lead to inconsistent behavior. A good pattern is to introduce a new helper (`get_zwave_device_config`) and migrate all call sites through that abstraction before changing underlying storage.\n\nThese principles apply across systems: whenever you modify configuration schemas or shared component state, design schemas to match actual use, centralize state, and ensure tests cover the new behavior.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and capture the exact configuration error.\n- Run the application's configuration check or startup command (e.g., `hass --script check_config`).\n- Capture the full error message, especially the path (`zwave->zwave->device_config->...`) and the 'expected X, got Y' portion.\n- Ask users to share the relevant config snippet around the failing key (e.g., their `zwave:` block) to compare against expectations.",
            "Step 2: Compare the current schema to the actual config shape.\n- Locate the configuration schema definition (e.g., voluptuous schema in the component).\n- Identify how the key is defined: Is it a simple entry schema, a list, or a dict mapping?\n  - For example, is it `vol.Optional('device_config', default={}): entry_schema` or `vol.Schema({ str: entry_schema })`?\n- Compare this to the config users actually write:\n  - Are they providing a dict keyed by entity IDs?\n  - Are they providing a list of objects with `entity_id` fields?\n- Note any mismatches (dict vs list, missing nested dicts, required fields not present in real configs).",
            "Step 3: Align the schema with the intended/used structure.\n- Decide on the canonical data shape you want to support (e.g., `device_config` as a dict mapping entity_id -> options dict).\n- Update the schema accordingly:\n  - For dict-of-entries: something like\n    `vol.Optional(CONF_DEVICE_CONFIG, default={}): { cv.string: _ENTRY_SCHEMA }`\n    or a custom validator that matches that pattern.\n  - Avoid requiring redundant fields (e.g., don't require `entity_id` inside each value if the dict keys are the entity IDs).\n- If you are deprecating an old shape (like list-form), consider:\n  - Supporting both shapes temporarily and normalizing internally, or\n  - Providing a clear error message guiding users to the new shape.",
            "Step 4: Normalize and centralize configuration at setup time.\n- During component setup, read the validated config and normalize it into a standard internal representation.\n  - Example: `hass.data[DATA_DEVICE_CONFIG] = config[DOMAIN][CONF_DEVICE_CONFIG]`.\n- Ensure that all parts of the component and any associated platforms use this shared representation instead of re-parsing the raw configuration.\n  - Replace calls like `customize.get_overrides(...)` or `config[DOMAIN][CONF_DEVICE_CONFIG]` with `hass.data[DATA_DEVICE_CONFIG]` or an equivalent helper.",
            "Step 5: Update all call sites to the new mechanism.\n- Search for all usages of the old configuration key or helper (e.g., `CONF_CUSTOMIZE`, `customize.get_overrides`, or direct `config[DOMAIN][...]` references).\n- Update them to use the new key (`CONF_DEVICE_CONFIG`) and the centralized store (`hass.data[DATA_DEVICE_CONFIG]`).\n- Ensure platform modules (e.g., `light.zwave`, `sensor.zwave`) are updated alongside the core component.\n- If necessary, introduce a small helper function like `get_device_config(hass, entity_id)` to encapsulate the new access pattern.",
            "Step 6: Adjust tests or add new ones.\n- If old tests only cover the deprecated shape (e.g., customize lists), either adapt them to cover the new `device_config` shape or add new tests.\n- Add unit tests that:\n  - Validate that common config examples pass the schema.\n  - Validate that incorrect shapes result in clear validation errors.\n  - Confirm that `hass.data[DATA_DEVICE_CONFIG]` is populated as expected and accessible from platform code.\n- Run the full test suite to catch regressions.",
            "Step 7: Verify end-to-end behavior with user-like configs.\n- Create or reuse a sample configuration mirroring what users reported, including edge cases like multiple entries, wildcards (if supported), or missing optional fields.\n- Run the config check and application startup with this config:\n  - Confirm that validation passes.\n  - Confirm that the component initializes without errors and devices show up as expected.\n- If the feature is a breaking change (e.g., old key removed), ensure docs are updated and, where possible, add deprecation warnings.",
            "Step 8: Communicate migration guidance.\n- Document the new configuration key and shape (e.g., `zwave.device_config: { <entity_id>: {ignored: true, ...} }`).\n- If an old key is removed (`customize` -> `device_config`), provide a clear migration note:\n  - \"Rename `zwave: customize:` to `zwave: device_config:` and remove inner `entity_id` fields, using entity IDs as keys instead.\"\n- For future changes, consider implementing a compatibility layer that maps old config formats to the new internal representation while emitting deprecation warnings instead of hard failures."
        ]
    }
}
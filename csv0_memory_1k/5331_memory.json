{
    "search_index": {
        "description_for_embedding": "Fix unhandled asyncio.CancelledError in Home Assistant camera image proxy after aiohttp upgrade by wrapping async_camera_image in try/except and treating client disconnects as normal, plus standardize debug log messages from 'browser' to 'frontend' across camera streaming implementations (ffmpeg, mjpeg, synology).",
        "keywords": [
            "camera image proxy",
            "asyncio.CancelledError",
            "aiohttp 1.1.6",
            "Home Assistant camera",
            "async_camera_image",
            "mjpeg stream",
            "ffmpeg camera",
            "synology camera",
            "client disconnect",
            "unhandled exception",
            "http stream",
            "frontend log message"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant's camera image proxy and streaming endpoints started throwing errors after upgrading to aiohttp 1.1.6. The issue appeared when clients (browsers/frontends) closed the camera stream or cancelled image requests. The coroutine camera.async_camera_image() and related streaming coroutines could raise asyncio.CancelledError when the HTTP request was cancelled by the client. For some camera endpoints (especially the image proxy handler), this exception was not caught, resulting in noisy error logs and potentially unclean request handling. Existing streaming handlers (ffmpeg, mjpeg, synology) already had try/except asyncio.CancelledError blocks, but the log message wording referenced 'browser' instead of 'frontend'. The fix added a try/except asyncio.CancelledError around the async_camera_image() call in CameraImageView.handle(). If a CancelledError occurs, the code logs a debug message ('Close stream by frontend.') and lets the request end gracefully without treating it as an error. When the image is successfully retrieved, the handler now explicitly checks for None and returns HTTP 500 if no image is available, otherwise returning the image bytes in the response body. Additionally, all existing camera streaming handlers (ffmpeg, mjpeg, synology) had their debug messages updated from 'Close stream by browser.' to 'Close stream by frontend.' to reflect that the disconnection may come from any frontend, not necessarily a traditional browser.",
        "semantic_memory": "When building async HTTP endpoints (especially long-lived or streaming ones) with asyncio-based frameworks like aiohttp, client disconnects are represented by asyncio.CancelledError being raised inside coroutines that are awaiting I/O or long-running tasks. This is a normal control-flow signal and should generally not be treated as a failure. Best practice is to wrap the main request-handling logic in try/except asyncio.CancelledError, log at debug level if desired, and perform any needed cleanup in a finally block. Failing to handle CancelledError can lead to noisy stack traces and misleading error logs after upgrades of async libraries that propagate cancellation more strictly. For camera or media streaming endpoints, it is especially important to treat cancelled requests as routine, because users frequently navigate away, close tabs, or switch views, causing cancellations. Additionally, HTTP handlers that fetch resources asynchronously should explicitly handle 'no data' (e.g., None image) and return a clear HTTP status (such as 500 or 404) rather than silently succeeding with an empty body. Consistent log messaging (e.g., using 'frontend' rather than 'browser') improves observability for multi-client environments and avoids assumptions about client types. Overall, the pattern is: catch cancellation, clean up, and log minimally; validate returned data and respond with appropriate status codes.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and identify the symptom. Enable debug logs for your async HTTP framework (e.g., aiohttp) and your camera/stream handlers. Trigger the problematic behavior by starting a stream or image request from the frontend and then cancelling it (closing tab, navigating away, or programmatically aborting the request). Look for stack traces or error logs mentioning asyncio.CancelledError.",
            "Step 2: Locate affected handlers. Identify which request handlers or coroutines are involved in serving the resource (e.g., camera image or MJPEG stream). In this case, handlers like CameraImageView.handle() and camera streaming endpoints (ffmpeg, mjpeg, synology) were responsible.",
            "Step 3: Check for unhandled asyncio.CancelledError. Inspect the relevant coroutines to see whether they wrap their core logic in try/except asyncio.CancelledError. Pay particular attention to any await/ yield from calls that perform I/O or long-running work (e.g., async_camera_image(), streaming loops). If there is no cancellation handling, the exception will propagate and appear as an error in logs.",
            "Step 4: Add cancellation handling. Wrap the main body of the handler in a try/except asyncio.CancelledError block. Inside the except block, log at debug level that the stream or request was closed by the frontend (or client) and avoid treating it as an error. Example pattern:\n\ntry:\n    image = await camera.async_camera_image()\n    if image is None:\n        return web.Response(status=500)\n    return web.Response(body=image)\nexcept asyncio.CancelledError:\n    _LOGGER.debug(\"Close stream by frontend.\")\n    # Optionally perform cleanup; then let the request finish.\n",
            "Step 5: Ensure proper cleanup in finally. For streaming endpoints that maintain open connections or allocate resources (e.g., response objects, encoder processes), use a finally block to close or release resources if the response was not None. This ensures resource cleanup happens both on normal completion and on cancellation.",
            "Step 6: Handle 'no data' cases explicitly. If the asynchronous function that fetches data (e.g., async_camera_image()) can return None, decide on an appropriate HTTP status code (such as 500 for internal errors or 404 if the resource is missing) and return that explicitly instead of a successful 200 with an empty body.",
            "Step 7: Normalize log messages. Review related handlers (e.g., ffmpeg, mjpeg, vendor-specific camera integrations) and standardize their debug messages for cancellations, e.g., changing 'Close stream by browser.' to 'Close stream by frontend.' for consistency and clarity across the codebase.",
            "Step 8: Retest after changes. Repeat the cancellation scenarios: open camera streams/views, then close or navigate away. Confirm that asyncio.CancelledError no longer appears as an unhandled error, the logs show only debug-level messages for normal disconnects, and resources are cleaned up correctly.",
            "Step 9: Monitor after deployment. After deploying the fix, monitor logs over time to ensure there are no residual unhandled CancelledError traces and that the chosen HTTP status codes for error cases (like None image) correctly reflect real problems rather than normal user behavior."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Snapcast media_player integration updated for Snapcast 0.11.1 / python-snapcast 2.x: migration to async API, split into group and client entities, added group volume control, and introduced snapcast_snapshot/snapcast_restore services that delegate to the library’s snapshot/restore. Fixed CI import/pylint issues related to package layout.",
        "keywords": [
            "snapcast",
            "homeassistant.components.media_player.snapcast",
            "async_setup_platform",
            "python-snapcast 2.x",
            "group and client entities",
            "snapshot restore services",
            "snapcast_snapshot",
            "snapcast_restore",
            "media_player services.yaml",
            "pylint import error",
            "package __init__.py",
            "Home Assistant async media player"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The issue was to update Home Assistant’s Snapcast media_player platform to support Snapcast server 0.11.1, which came with a breaking API change in the python-snapcast library. The old integration was synchronous, assumed a single type of Snapcast entity, and used the pre-2.x API. The fix upgraded the dependency from snapcast==1.2.2 to snapcast==2.0.6 and rewrote the integration around the new async control API.\n\nThe platform setup was converted from setup_platform to async_setup_platform, using snapcast.control.create_server(hass.loop, host, port) instead of directly constructing a Snapserver. Error handling around socket.gaierror logs connection failures and aborts setup cleanly. The component now treats Snapcast groups and clients as separate logical entities: SnapcastGroupDevice models a Snapcast group (stream selection and group volume), and SnapcastClientDevice models a client (connection status and per-client volume).\n\nCapabilities and entity model changed:\n- Clients: SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET, state is STATE_ON/STATE_OFF based on connection. Entity ids use a stable identifier-based prefix CLIENT_PREFIX = 'snapcast_client_' + client.identifier, and the friendly name attribute exposes the human-readable client name plus a suffix.\n- Groups: SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET | SUPPORT_SELECT_SOURCE, state mirrors stream_status ('idle', 'playing', etc.), and entity ids use GROUP_PREFIX = 'snapcast_group_' + group.identifier. Group volume and mute are exposed via volume_level and is_volume_muted, backed by new group.volume / group.muted properties.\n\nAll control methods were converted to async_* coroutines that call the new library methods and schedule state updates correctly for Home Assistant’s event loop:\n- async_select_source, async_mute_volume, async_set_volume_level for groups call set_stream/set_muted/set_volume and then schedule async_update_ha_state() via hass.async_add_job.\n- async_mute_volume and async_set_volume_level for clients call client.set_muted and client.set_volume, likewise scheduling state updates.\n\nThe PR also introduced two new Snapcast-specific services, snapcast_snapshot and snapcast_restore, defined in media_player/services.yaml and registered under the snapcast domain. Initially, snapshot/restore were implemented by manually storing and replaying attributes (source, volume, mute) in hass.data[DOMAIN]. Later, this was refactored to delegate to python-snapcast’s built-in snapshot/restore support:\n- SnapcastGroupDevice.snapshot() and SnapcastClientDevice.snapshot() call self._group.snapshot() / self._client.snapshot().\n- async_restore() on both yield from self._group.restore() / self._client.restore().\nThe service handler _handle_service uses the entity_id list from the service data, filters hass.data[DOMAIN] for matching devices, and calls snapshot() or async_restore() on each, depending on the service (SERVICE_SNAPSHOT or SERVICE_RESTORE). hass.data[DOMAIN] now stores the list of all Snapcast devices (groups + clients) instead of a per-entity snapshot state dict.\n\nEntity naming was adjusted to avoid problems when users renamed clients in the Snapcast app: entity_id is now derived from the internal Snapcast identifier, while a user-friendly name is exposed via the friendly_name attribute. This resolved issues where volume control stopped working until Home Assistant was restarted when the client name changed.\n\nThere was a persistent CI failure where pylint complained about missing imports for snapcast modules, even though the package was installed and importable locally. This turned out to be a bug related to Python 2/pylint handling of packages without proper top-level package entries. The resolution (discussed in the PR) was to ensure the top-level snapcast package directory is treated as a proper Python package (with __init__.py and listed in setup.py’s packages). Once the packaging issue was corrected in the python-snapcast library, the Home Assistant PR’s Travis run succeeded.\n\nFinally, additional cleanups were made: the REQUIREMENTS and requirements_all.txt entries were kept in sync through library version bumps (2.0.0 → 2.0.1 → 2.0.2 → 2.0.5 → 2.0.6), unnecessary imports and state snapshot logic were removed, and async state updates were made to comply with Home Assistant’s async patterns. After review comments were addressed and tests passed, the PR was cleared for merge.",
        "semantic_memory": "Several general patterns emerge from this fix:\n\n1. **Adapting to an upstream async API change**\nWhen an underlying library moves from a synchronous to an asynchronous model, integrations should:\n- Switch to async setup (e.g., async_setup_platform) and async control methods (async_* handlers) in frameworks that support it.\n- Use the library’s event-loop aware factory functions (e.g., create_server(loop, host, port)) instead of direct constructors.\n- Reflect the library’s logical model (e.g., separate group and client entities) to better match real-world behavior and allow more granular control.\n\n2. **Stable entity identifiers vs. user-friendly names**\nEntity IDs should be derived from stable, internal identifiers (like a Snapcast client identifier) instead of mutable display names set by users. Friendly names can still be shown through separate attributes. This prevents breakage when users rename entities in external apps.\n\n3. **Delegating advanced behavior to the domain library**\nFunctionality like snapshot/restore of state is best implemented in the domain library when it depends on protocol details. A Home Assistant integration should prefer calling library methods (client.snapshot()/restore()) instead of reimplementing state management by manually reading/writing attributes and issuing multiple individual set_* commands. This reduces duplication and keeps the integration thinner and more robust when the library evolves.\n\n4. **Service handling and device lookup in Home Assistant**\nFor platform-specific services that act on media_player entities, a common pattern is:\n- Define services in services.yaml and load them via load_yaml_config_file.\n- Store the created device objects in hass.data[DOMAIN].\n- Implement a generic service handler that filters that list by entity_id and calls methods on the device objects. This decouples service logic from the core and allows flexible operations over multiple entities.\n\n5. **Correct async state update patterns in HA**\nInside async methods that perform I/O and then need to update Home Assistant state, it is better to schedule async_update_ha_state() using hass.async_add_job(self.async_update_ha_state()) instead of awaiting it directly in the coroutine that performs network I/O. This avoids nesting event-loop tasks improperly and is aligned with Home Assistant’s asynchronous architecture.\n\n6. **CI linting and packaging issues**\nCI/lint failures about missing imports can stem from packaging/layout problems, particularly in mixed Python 2/3 environments:\n- Python 2 and pylint can fail to import packages if directories lack __init__.py or if the package directories are not listed in setup.py’s packages.\n- If imports work locally but fail in CI, it’s important to verify the package’s installation metadata and how it’s structured in the environment used by CI.\n\n7. **Expressing capabilities accurately**\nSplitting entities into group and client objects allowed the integration to advertise capabilities (supported_features) more accurately. Groups expose source selection and group volume; clients expose only volume and mute. This provides a better UX and avoids exposing controls that don’t map to a real operation.\n\nOverall, the fix exemplifies a best-practice migration of an integration to a new async and more structured upstream API, while aligning with the host framework’s async patterns and improving robustness (stable IDs, better service handling).",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Understand the upstream breaking changes\n- Read the upstream library’s release notes and changelog (e.g., python-snapcast moving to 2.x, changing to async APIs and introducing group vs client models).\n- Identify all usages of the old library in your integration: construction methods, method names, synchronous vs asynchronous behavior, and object model.\n",
            "Step 2: Update dependency versions consistently\n- Update the integration’s REQUIREMENTS to the new library version (e.g., REQUIREMENTS = ['snapcast==2.0.6']).\n- Update any centralized requirements list (e.g., requirements_all.txt) to the same version.\n- Run any repository scripts that regenerate requirements files if needed.\n",
            "Step 3: Migrate to async setup and control methods\n- Replace setup_platform with async_setup_platform when the upstream library is async.\n- Use the library’s async factory functions (e.g., create_server(hass.loop, host, port)) to create connections.\n- Convert device control methods to async_* coroutines (async_mute_volume, async_set_volume_level, async_select_source, etc.) and use yield from or await when calling library methods.\n- Use should_poll = False and, where possible, rely on callbacks from the library (e.g., set_callback(self.schedule_update_ha_state)) to avoid polling.\n",
            "Step 4: Reflect the new domain model in entities\n- If the underlying system distinguishes between types (e.g., groups vs clients), create separate entity classes in the integration (SnapcastGroupDevice, SnapcastClientDevice).\n- Assign appropriate supported_features for each entity type based on the operations the hardware/API actually support.\n- Implement properties for state, volume, mute, and source that map cleanly onto the library’s attributes.\n",
            "Step 5: Design stable entity identifiers and user-facing names\n- Construct entity_id-like names from stable identifiers (e.g., 'snapcast_client_' + client.identifier) instead of display names that can be changed externally.\n- Expose friendly_name attributes for the UI using human-readable names (e.g., client.friendly_name + ' Snapcast Client').\n- This prevents breakage when a user renames devices in an external app and avoids the need for Home Assistant restarts to rebind entities.\n",
            "Step 6: Implement platform-specific services cleanly\n- Declare new services in the platform’s services.yaml with descriptions and entity_id fields (e.g., snapcast_snapshot, snapcast_restore).\n- In async_setup_platform, load descriptions via load_yaml_config_file and register services with hass.services.async_register.\n- Maintain a list of device objects in hass.data[DOMAIN].\n- Implement a single service handler that:\n  - Reads entity_ids from service.data.\n  - Filters hass.data[DOMAIN] to the devices whose device.entity_id matches.\n  - Calls the appropriate method (device.snapshot() or yield from device.async_restore()) depending on service.service.\n",
            "Step 7: Delegate complex features to the domain library\n- Before manually implementing state snapshot/restore, check if the underlying library offers these operations.\n- If it does (e.g., client.snapshot()/restore()), use these methods instead of storing attributes in hass.data and calling multiple low-level operations.\n- This keeps the integration thin and resilient to library changes.\n",
            "Step 8: Update state correctly in async context\n- After calling any async library control method, schedule a state update using hass.async_add_job(self.async_update_ha_state()).\n- Avoid awaiting async_update_ha_state() directly inside the same coroutine that performs I/O, to not block or nest event-loop tasks incorrectly.\n",
            "Step 9: Debug CI/lint import issues\n- If imports work locally but fail in CI (e.g., pylint cannot import a package):\n  - Verify that the package has proper __init__.py files for all directories that should be treated as packages.\n  - Ensure those packages are listed in setup.py’s packages argument so they are installed correctly.\n  - Consider Python 2 vs 3 differences: some tools (e.g., pylint running under Python 2) will not recognize namespace packages that lack __init__.py.\n- After adjusting packaging, rerun CI and confirm pylint/import issues are resolved.\n",
            "Step 10: Test and iterate\n- Run the full test suite (tox, pytest) to ensure no regressions.\n- Perform manual integration testing against a real Snapcast server to verify:\n  - Group and client entities are created and named as expected.\n  - Volume, mute, and source selection work for both groups and clients.\n  - Renaming clients in the Snapcast app does not break control.\n  - snapcast_snapshot and snapcast_restore services correctly save and restore state.\n- Address reviewer comments, especially around async patterns, naming, and service semantics, and refine the implementation accordingly."
        ]
    }
}
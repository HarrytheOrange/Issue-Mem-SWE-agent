{
    "search_index": {
        "description_for_embedding": "StackStorm ChatOps action aliases now support implicit key=value parameter parsing (with quotes and spaces) and mixing with existing template-based formats. The fix introduces a dedicated key=value parser using shlex, merges its results with the template parser (honoring defaults and overrides), and updates controllers to allow aliases without explicit formats.",
        "keywords": [
            "StackStorm",
            "ChatOps",
            "action alias",
            "alias parser",
            "key=value parameters",
            "implicit format",
            "command parsing",
            "shlex tokenization",
            "default parameter values",
            "quoted strings",
            "action_alias_utils.py",
            "aliasexecution.py",
            "parsing bug",
            "backwards compatible feature"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, StackStorm's ChatOps action alias mechanism only supported parameters extracted from explicitly defined format strings (e.g., 'list actions from {{pack}}'), and did not natively support commands where parameters are passed as key=value pairs (e.g., '!st2-sensors-list pack=examples limit=2'). Additionally, aliases without a 'formats' field were problematic, and there was uncertainty about mixing key=value parameters with template-based formats, as well as about handling default values, spaces, and quotes in parameter values.\n\nTo address this, the developer introduced a new KeyValueActionAliasFormatParser that parses 'key=value' pairs from the input parameter stream. Initially implemented with a regex, it was later improved to use Python's shlex.split for robust shell-like tokenization, correctly handling spaces and quoted strings (e.g., a=\"foo bar\", a='foo bar'). The parser walks through the tokens, splits on the first '=', and builds a dictionary of parameters.\n\nThe core ActionAliasFormatParser was updated so that get_extracted_param_value() first uses the key=value parser to get parameters from the raw stream and then runs the existing template-based parser. The resulting dictionaries are merged, where values extracted from the format templates overwrite any conflicting key=value entries, preserving explicit alias format behavior while allowing implicit overrides where appropriate. Tests were added to validate pure key=value parsing, mixing with free text, and parsing of quoted values.\n\nThe controller at st2api/controllers/exp/aliasexecution.py was updated to handle aliases that have no 'formats' defined: instead of assuming formats[0] exists, it now uses the first format if present or passes None to the parser. The ActionAliasAPI.to_model() method was also changed to default formats to [] when they are absent on the alias object, preventing attribute errors. Additional tests were written for mixed parsing with default parameter values (e.g., a=None, b=10, c=foo) to ensure that defaults are respected and only overridden when explicitly provided in the parameter stream. Together, these changes provide out-of-the-box ChatOps usability for actions via implicit key=value syntax and more robust, predictable parameter parsing.",
        "semantic_memory": "This fix illustrates several generalizable patterns for designing and evolving command and parameter parsers in automation systems:\n\n1. **Implicit vs. explicit syntax support**: Systems that initially rely on explicit formats (templates) can be made more user-friendly by adding an implicit, generic syntax (here, key=value) that works out of the box. This lowers configuration overhead while preserving compatibility with existing explicit formats.\n\n2. **Composable parsing strategies**: Instead of replacing a legacy parser, you can layer new parsers. The main ActionAliasFormatParser delegates part of its work to a dedicated KeyValueActionAliasFormatParser and then merges the results with its own template-based parsing. This encourages separation of concerns (key=value parsing vs. template parsing) and easier extensibility.\n\n3. **Tokenization with shlex vs. regex**: Shell-like input often includes quoting and spaces (e.g., a=\"foo bar\"). Using shlex.split is more robust than simple regexes for tokenizing such command lines. It automatically handles quotes and escaping, reducing edge-case bugs in parsing.\n\n4. **Deterministic precedence rules**: When multiple parsing mechanisms can define the same parameter (e.g., key=value vs. template extraction vs. defaults), you must define and implement a clear precedence order. Here, key=value parameters are read first, then overridden by template-based values, and finally influenced by default values defined in the templates.\n\n5. **Graceful handling of missing configuration**: Code that expects configuration like 'formats' should be defensive. Using defaults (e.g., formats = [] or alias_format = None) prevents crashes and enables new behavior (implicit parsing when no formats are given).\n\n6. **Testing for edge cases and mixed modes**: Changes to parsers should be backed by tests covering: no parameters, simple single parameters, multiple parameters, mixed free text and key=value pairs, quoted values, defaults, and mixed override behavior. This is critical for systems that interact with human input where small variations are common.\n\n7. **Backwards-compatible feature rollout**: Introducing new implicit behavior should not break existing explicit configurations. By layering parsers and using clear merging rules, you can add features without requiring users to modify existing aliases.",
        "procedural_memory": [
            "Step-by-step approach to diagnose and implement similar parsing enhancements or fixes:",
            "Step 1: Reproduce and characterize the problem.\n- Identify representative commands that fail or behave unexpectedly (e.g., alias without formats, or key=value syntax not working).\n- Write or extend unit tests that capture the current behavior and the desired new behavior. Include examples with defaults, mixed text, and quoted values.",
            "Step 2: Analyze the existing parsing architecture.\n- Locate the main parsing entry point (e.g., ActionAliasFormatParser) and understand how it processes input.\n- Determine where new syntax (e.g., key=value) should be introduced: as a separate parser, an extension of the existing parser, or a preprocessing step.",
            "Step 3: Introduce a dedicated parser for the new syntax.\n- Implement a small, focused parser (e.g., KeyValueActionAliasFormatParser) responsible only for the new syntax.\n- Use robust tokenization: for shell-like command strings, prefer shlex.split over regex so you can handle quotes and spaces correctly.\n- Ensure the parser gracefully handles invalid input (e.g., by catching ValueError from shlex and returning an empty dict).",
            "Step 4: Integrate parsers and define precedence rules.\n- Modify the main parser to call the new parser first (or at the appropriate stage) and collect its results.\n- Merge the results carefully: decide whether new syntax, template-based values, or default values should take precedence when keys overlap.\n- Implement this precedence explicitly in code (e.g., dict update order) so itâ€™s predictable and testable.",
            "Step 5: Handle missing configuration defensively.\n- Audit call sites that supply configuration like 'formats'. Replace direct indexing (formats[0]) with guarded logic: use the first format if present, otherwise allow None or an empty string.\n- In data models, default optional fields (e.g., formats) to safe values like [] using getattr or explicit defaults to avoid attribute errors.",
            "Step 6: Expand and refine test coverage.\n- Add tests for:\n  - Empty param streams (should return empty dict or only defaults).\n  - Simple and multiple key=value pairs.\n  - Mixed text and key=value pairs in arbitrary order.\n  - Quoted values with spaces and both single/double quotes.\n  - Mixed template-based parameters and key=value parameters, including default values and overrides.\n- Run the full test suite and confirm all new and existing tests pass.",
            "Step 7: Validate end-to-end behavior and document.\n- Test real ChatOps commands (or analogous command paths) to ensure the alias/command behavior matches expectations, especially when aliases lack explicit formats.\n- Document the new implicit syntax, mixing rules, and any edge-case behavior so that users understand how to structure their commands and what precedence rules apply."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "MongoDB queries were doing table scans due to missing indexes in multiple MongoEngine models (actions, triggers, policies, RBAC, etc.). The fix added appropriate meta.indexes entries for frequently queried fields and enabled MongoDB's --notablescan option in CI to fail tests when queries require a collection scan.",
        "keywords": [
            "MongoDB",
            "mongoengine",
            "missing index",
            "table scan",
            "--notablescan",
            "performance",
            "st2common models",
            "meta.indexes",
            "CI",
            "RuleEnforcementDB",
            "TriggerDB",
            "ActionDB",
            "RBAC",
            "query optimization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the team wanted to speed up tests and uncover MongoDB queries that were performing full collection scans. They ran MongoDB with the --notablescan flag, which causes any query that would require a table scan to fail. This quickly exposed several missing indexes across the codebase.\n\nThe failures involved various models in the st2common package, such as ActionDB, ActionAliasDB, PolicyDB, TriggerDB, ActionExecutionDB, LiveActionDB, RBAC-related DBs (RoleDB, UserRoleAssignmentDB, PermissionGrantDB), KeyValuePairDB, SensorTypeDB, RuleDB, RuleEnforcementDB, and even a FakeModelDB used in tests. Queries on fields like name, pack, ref, enabled, resource_ref, trigger_instance.id, context.trigger_instance.id, user, role, resource_uid, timestamps, and others were not backed by indexes, leading to disallowed table scans under --notablescan.\n\nThe developer added or expanded each model's meta.indexes definition to include indexes for those frequently queried fields and typical query patterns, for example:\n- ActionDB: indexes on name, pack, ref.\n- ActionAliasDB: index on name.\n- PolicyDB: indexes on name and resource_ref.\n- TriggerDB: indexes on name, type, parameters.\n- ActionExecutionDB: index on trigger_instance.id.\n- LiveActionDB: indexes on context and context.trigger_instance.id.\n- RBAC models (RoleDB, UserRoleAssignmentDB, PermissionGrantDB): indexes on name, system, permission_grants, user, role, is_remote, resource_uid.\n- RuleDB: index on enabled.\n- RuleEnforcementDB: indexes on trigger_instance_id, execution_id, rule.id, rule.ref, enforced_at, -enforced_at, and compound (-enforced_at, rule.ref).\n- KeyValuePairDB: index on name.\n- SensorTypeDB: index on enabled.\n- FakeModelDB in tests: indexes on index, category, timestamp, and context.user.\n\nThere was also a confusing stack trace around querying TriggerDB (AttributeError: 'NoneType' object has no attribute 'find'), which appeared while running with --notablescan. After adding the appropriate indexes on TriggerDB (name, type, parameters) and other related models, all missing-index issues were resolved.\n\nAdditionally, the RuleEnforcementDB class was refactored: an attempt was made to use stormbase.UIDFieldMixin for uid handling, but the code ultimately reverted to a simpler approach where RuleEnforcementDB does not inherit from UIDFieldMixin and instead exposes a custom get_uid() that builds a UID from the resource type and the document id. The meta.indexes for RuleEnforcementDB were still expanded independently.\n\nFinally, the CI configuration was updated (.circle/install-and-run-mongodb.sh) to always start MongoDB with --notablescan in CircleCI. This ensures that any new queries introduced in the future that require a table scan will cause tests to fail, catching missing indexes early.",
        "semantic_memory": "This case illustrates best practices for MongoDB + ODM (MongoEngine) schema design and CI validation:\n\n1. **Indexes must match real query patterns.**\n   When using MongoEngine (or any ODM), it's not enough to define collections and fields; you must explicitly define indexes in the model meta.indexes for fields that are used in filters, sorts, and common lookups. This includes:\n   - Simple equality filters (e.g., resource_ref, user, role, enabled, name).\n   - Embedded or nested fields (e.g., context.trigger_instance.id, runner.name, rule.ref).\n   - Time-based sorting and range queries (e.g., enforced_at, start_timestamp, end_timestamp).\n   - Compound indexes that align with multi-field queries and sort orders (e.g., -enforced_at, rule.ref or -start_timestamp, action.ref, status).\n\n2. **Use --notablescan as a guardrail.**\n   Running MongoDB with --notablescan in dev/CI is a powerful way to detect missing indexes and badly designed queries early. Under this mode, any query that would cause a collection scan is rejected, turning potential performance regressions into test failures rather than production incidents.\n\n3. **Keep DB model index definitions in sync with application logic.**\n   As the code evolves and new queries are added (e.g., filtering by new fields, new RBAC features, new workflows), meta.indexes should be updated accordingly. The test suite, especially under --notablescan, acts as a feedback mechanism when model definitions fall behind changes in query logic.\n\n4. **Consider index granularity for RBAC and configuration data.**\n   RBAC models (roles, user-role assignments, permission grants) and configuration/kv models often become hot paths for authorization checks and settings lookups. They need appropriate indexes on identity keys (user, role, resource_uid, system flags) to avoid severe performance issues.\n\n5. **UID handling and logging consistency.**\n   When a resource type doesn't easily fit into a generic UID mixin, you can still keep logging uniform by defining a simple get_uid method that composes a stable resource-specific identifier, even if it uses the primary key (id). This allows external subsystems (e.g., RBAC resolvers) to log objects consistently without forcing them into a specific inheritance structure.\n\nOverall, the pattern is: explicitly index any field (including nested fields) used in frequent filters/sorts, validate via --notablescan in CI, and keep schema and query behavior aligned.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Detect table scans and missing indexes.\n- Enable MongoDB's --notablescan option in a development or CI environment.\n- Run the test suite or the workload that exercises typical queries.\n- Observe failures: queries that would require a collection scan will fail with errors instead of silently degrading performance.",
            "Step 2: Identify the offending queries and fields.\n- Inspect stack traces and logs where queries fail under --notablescan.\n- Look at the MongoEngine (or ODM) model being queried and the filter conditions used (e.g., Trigger.query(type=trigger_type), ActionExecution.query(trigger_instance__id=...).\n- Note which fields (including nested/embedded fields) appear in query filters, sorts, or compound conditions.",
            "Step 3: Map queries to model indexes.\n- Open the corresponding model class and its meta configuration (e.g., meta = {'indexes': [...]} in MongoEngine).\n- Check whether the queried fields have appropriate indexes:\n  - Single-field indexes for simple equality or sort operations.\n  - Compound indexes for multi-field filters or sort patterns (especially when sorting by a timestamp and filtering by another field).\n  - Support for nested fields (e.g., 'context.trigger_instance.id', 'rule.ref').",
            "Step 4: Define or update indexes in model metadata.\n- Add missing index definitions to meta.indexes for the model. Examples in MongoEngine:\n  - {'fields': ['name']}\n  - {'fields': ['pack']}\n  - {'fields': ['resource_ref']}\n  - {'fields': ['trigger_instance.id']}\n  - {'fields': ['context.trigger_instance.id']}\n  - {'fields': ['-enforced_at', 'rule.ref']}\n- For frequently filtered boolean or status fields, add indexes like {'fields': ['enabled']} or {'fields': ['status']}.\n- For time-based queries, consider both ascending and descending indexes if both directions are needed frequently.\n- When using reusable mixins (e.g., UIDFieldMixin, TagsMixin), make sure to include their get_indexes()/get_indices() contributions in the meta.indexes list.",
            "Step 5: Apply schema changes and re-run tests.\n- Ensure your migration or ODM initialization creates the new indexes (MongoEngine will typically do this on first use or via an index-building routine).\n- Restart MongoDB if needed and re-run the test suite under --notablescan.\n- Confirm that previously failing queries now succeed and that no new notablescan-related failures appear.",
            "Step 6: Integrate notablescan (or equivalent checks) into CI.\n- Modify your CI environment startup script to launch MongoDB with --notablescan (as done in .circle/install-and-run-mongodb.sh):\n  - mongod --nojournal ... --notablescan --dbpath ... --bind_ip 127.0.0.1\n- Document this behavior so developers understand that missing indexes will manifest as test failures.",
            "Step 7: Maintain alignment between models and queries.\n- When adding new features or changing query patterns, proactively update meta.indexes in the relevant models.\n- Add or adjust tests to cover new query paths so that --notablescan will detect missing indexes as part of normal CI.\n- Periodically review slow query logs or use explain() on critical queries in staging/production to confirm they use the intended indexes.",
            "Step 8: Handle UID and logging consistency (if applicable).\n- If your logging or RBAC systems expect a get_uid() method but the model doesn't naturally use an existing UID mixin, implement a simple get_uid() that returns a consistent identifier (e.g., f\"{RESOURCE_TYPE}:{id}\").\n- Only introduce UID mixins if they fit the resource semantics; otherwise, keep a custom method and focus on indexes separately."
        ]
    }
}
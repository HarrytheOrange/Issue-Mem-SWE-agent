{
    "search_index": {
        "description_for_embedding": "Introduced reusable configuration validators in Home Assistant to ensure entity IDs belong to a specific domain (single and list variants). Added helpers `entities_domain(domain)` and `entity_domain(domain)` in config_validation, with comprehensive tests, and applied `entity_domain('camera')` to the image_processing platform's source schema to guarantee only camera entities are used.",
        "keywords": [
            "Home Assistant",
            "config_validation",
            "voluptuous",
            "entity_id",
            "entity_domain",
            "entities_domain",
            "split_entity_id",
            "image_processing",
            "camera",
            "schema validation",
            "domain-specific entity validation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the developer needed a consistent way to validate that configuration entries referencing entities belong to the correct Home Assistant domain (e.g., ensuring a camera entity is used where a camera is required). Previously, there was a generic `entity_id` and `entity_ids` validator, but nothing to enforce that the entity belonged to a particular domain, which was especially relevant for upcoming group platforms and the image_processing integration.\n\nTo solve this, the developer added two new validators in `homeassistant/helpers/config_validation.py`:\n- `entities_domain(domain)`: a factory function returning a validator that accepts a single string or a sequence of strings, normalizes them using the existing `entity_ids()` helper, then checks via `split_entity_id()` that each entity's domain matches the required domain. If any entity is not in the domain, it raises a detailed `vol.Invalid` error that includes the offending entity ID and the expected domain.\n- `entity_domain(domain)`: a single-entity validator built on top of `entities_domain(domain)`. It calls the list validator and returns only the first (and expected single) normalized entity ID, ensuring consistent behavior between single and multiple entity validation.\n\nThe tests in `tests/helpers/test_config_validation.py` were expanded to cover both validators. For `entities_domain`, tests verify that invalid inputs (None, empty strings, invalid entity IDs, entities from the wrong domain, or malformed IDs) raise `vol.MultipleInvalid`, and that valid inputs (case-insensitive domains, mixed list and CSV-like string formats) are normalized and accepted. For `entity_domain`, tests confirm that an invalid or wrong-domain entity is rejected and that a valid entity (even with uppercase domain) is normalized correctly.\n\nFinally, the image_processing platform (`homeassistant/components/image_processing/__init__.py`) was updated: the `SOURCE_SCHEMA` now uses `cv.entity_domain('camera')` instead of the generic `cv.entity_id` for `CONF_ENTITY_ID`. This guarantees that any configured `source` for image processing refers specifically to a camera entity, not just any entity id. This change improves validation and error reporting for users and sets a pattern for other platforms that require domain-specific entity references.",
        "semantic_memory": "This work captures a reusable pattern for domain-constrained entity validation in configuration schemas.\n\nKey concepts and generalizable lessons:\n\n1. **Factory-based validators for domain constraints**: Instead of repeatedly hand-writing checks in each component, create validator factory functions (like `entities_domain(domain)` and `entity_domain(domain)`) that encapsulate the logic for validating that entity IDs belong to a specific domain. This improves consistency and reduces duplication.\n\n2. **Build on existing validators and utilities**: The new validators reuse `entity_ids()` to normalize inputs and `split_entity_id()` to extract the domain. Leveraging existing helpers ensures consistent handling of formats (e.g., CSV strings vs lists, case normalization) and centralizes parsing logic.\n\n3. **Single vs multiple value validators**: Often you need a validator for a list of items and a validator for a single item that follow the same rules. Implement the list validator as the core, then define the single-item validator as a thin wrapper (`entity_domain`) around the list validator, returning only the first element. This avoids divergence in behavior between single and multiple input variants.\n\n4. **Descriptive validation errors**: When rejecting invalid configuration, error messages should contain both the problematic value and the expected constraint (e.g., \"Entity ID 'cover.demo' does not belong to domain 'sensor'\"). This improves debuggability for users and developers.\n\n5. **Use validation at schema-level to enforce semantics**: Rather than checking domains later at runtime, enforce domain correctness in the configuration schema itself. This surfaces configuration problems early and avoids harder-to-debug runtime failures.\n\n6. **Comprehensive tests for both valid and invalid cases**: Tests should cover: non-allowed types (e.g., None, empty strings), malformed entity IDs, wrong domains, and valid entities with different casing or formats. This ensures the validator remains robust to future changes.\n\nOverall, the pattern is: when a configuration option references an entity that must belong to a specific domain, provide a dedicated validator factory and apply it within platform schemas instead of using generic entity ID validators.",
        "procedural_memory": [
            "When you need to ensure that configuration entity IDs belong to a specific domain in Home Assistant, create or reuse domain-specific validator helpers and wire them into the component's schema.",
            "Step 1: Identify where domain-specific entity constraints are needed.\n- Look for config options like `source`, `target`, or `entity_id` that semantically must be a given domain (e.g., 'camera', 'sensor', 'light').\n- Confirm that current schemas might be using a generic `entity_id`/`entity_ids` validator that does not enforce the domain.",
            "Step 2: Implement a list-based domain validator (if not already available).\n- In `helpers/config_validation.py`, define a factory function `entities_domain(domain: str)`.\n- Inside, define a nested `validate(values)` function that:\n  - Calls `values = entity_ids(values)` to normalize single strings vs lists and to validate entity ID format.\n  - Iterates over each `ent_id` in `values`, uses `split_entity_id(ent_id)[0]` to get the domain, and compares it to the required `domain`.\n  - If any domain does not match, raises `vol.Invalid` with a detailed message including the offending entity ID and expected domain, e.g. `\"Entity ID '{}' does not belong to domain '{}'\"`.\n  - Returns the normalized list of entity IDs on success.\n- Return `validate` from `entities_domain(domain)`.",
            "Step 3: Implement a single-entity domain validator wrapper.\n- Define `entity_domain(domain: str)` in the same module.\n- Inside, define `validate(value)` that:\n  - Creates the list validator: `ent_domain = entities_domain(domain)`.\n  - Calls `ent_domain(value)` and returns the first element from the resulting list.\n- This reuses the same normalization and domain-checking logic for single values.",
            "Step 4: Integrate the validators into component schemas.\n- Locate the relevant platform schema (e.g., `components/image_processing/__init__.py`).\n- Replace generic validators like `cv.entity_id` with domain-specific ones, e.g. `cv.entity_domain('camera')` for `CONF_ENTITY_ID` if it must be a camera.\n- Ensure you do this consistently across all options requiring domain-constrained entities.",
            "Step 5: Add unit tests for both validators.\n- In `tests/helpers/test_config_validation.py`, add tests for `entity_domain`:\n  - Use `vol.Schema(cv.entity_domain('sensor'))`.\n  - Assert that invalid entity IDs or entities in the wrong domain raise `vol.MultipleInvalid`.\n  - Assert that valid IDs (even with different casing, like `sensor.LIGHT`) are normalized (e.g., to `sensor.light`).\n- Add tests for `entities_domain`:\n  - Use `vol.Schema(cv.entities_domain('sensor'))`.\n  - Verify that `None`, empty strings, malformed IDs, and mixed-domain lists raise `vol.MultipleInvalid`.\n  - Verify that valid CSV strings and lists are normalized into lists of lowercased, correct-domain entity IDs.",
            "Step 6: Run the test suite and adjust as needed.\n- Run the relevant test subset or full `tox` suite to ensure tests pass.\n- If failures appear, refine error messages, domain checks, or normalization logic without breaking existing behaviors.",
            "Step 7: Apply this pattern to new or existing components.\n- For any new group or platform PR requiring domain-restricted entities, use `entity_domain(domain)` or `entities_domain(domain)` instead of custom inline checks.\n- This keeps configuration handling consistent and makes future maintenance and refactoring easier."
        ]
    }
}
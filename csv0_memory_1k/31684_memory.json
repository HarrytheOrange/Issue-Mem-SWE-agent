{
    "search_index": {
        "description_for_embedding": "Home Assistant PR adding a new Ubiquiti airCube router integration using the modern config entry and device_tracker ScannerEntity architecture instead of the legacy DeviceScanner platform. Implements a JSON-RPC client to the /ubus API, manages session IDs, handles dual-band Wi-Fi client lists, adds config flow + options flow (including consider_home detection time), and provides robust error handling (login failure, SSL errors, timeouts, cannot connect).",
        "keywords": [
            "Home Assistant",
            "Ubiquiti airCube",
            "device_tracker",
            "router presence detection",
            "config_entry",
            "ScannerEntity",
            "JSON-RPC",
            "ubus",
            "config_flow",
            "options_flow",
            "detection_time",
            "CannotConnect",
            "LoginError",
            "SSLError",
            "ConnectionTimeout",
            "router integration pattern"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR introduces a new Home Assistant integration for Ubiquiti airCube routers that tracks connected devices via the router's /ubus JSON-RPC API. The initial implementation used the legacy device_tracker interface (DeviceScanner, get_scanner, YAML-only config), which was flagged by a reviewer asking to follow the new device tracker implementation as in the UniFi or MikroTik integrations. In response, the author rewrote the integration around config entries, a router abstraction, and ScannerEntity-based device trackers. The final code defines an aircube domain with CONFIG_SCHEMA that supports import from YAML, but primary configuration is via config_flow. The config flow validates host/credentials by calling _get_session_id against the router's /ubus 'session login' endpoint, mapping common failure modes to structured Home Assistant errors (CannotConnect, ConnectionTimeout, LoginError, SSLError) and to localized error messages. A separate options flow allows the user to configure the 'consider home' interval (detection_time) in seconds. The AirCubeRouter class encapsulates router-level concerns (host, URL, credentials, verifying SSL, detection time) and uses an AirCubeData object to talk to the router API. AirCubeData uses requests to perform JSON-RPC calls, fetches router metadata (hostname, model, firmware version, serial/MAC), and builds a dictionary of Device instances representing connected clients. Devices are discovered from the 'ubnt stats' JSON response: both 2.4 GHz (wlan0) and, when present, 5 GHz (wlan1) assoclist entries are merged into a single list. Each Device tracks its MAC address, raw params, derived attributes (e.g., mac-address) and a last_seen timestamp updated whenever it's observed in the latest scan. The integration’s device_tracker module sets up ScannerEntity instances per Device. On setup, it also consults the entity registry to restore previously known clients that are no longer active but still should exist as entities, re-adding them to the Device map. DeviceTracker entities report is_connected based on whether now() - last_seen is less than the configured detection_time. They subscribe to a per-router dispatcher signal (aircube-update-{host}) and update their state whenever the router performs an API poll. The __init__ module registers the router in the device registry (using its serial as an identifier, plus model, firmware, and manufacturer) when the config entry is set up, and handles unloading device_tracker entities on unconfigure. The manifest is updated to mark the integration as config_flow-capable, codeowners, and the integration is registered in generated/config_flows.py, plus translations and strings for the UI are added. Overall, the PR resolves the reviewer’s request by replacing legacy device tracker patterns with Home Assistant’s newer config-entry-based, async/dispatcher-driven architecture and adds robust login/connection error handling around the airCube’s JSON-RPC API.",
        "semantic_memory": "The PR illustrates a modern pattern for implementing router-based device trackers in Home Assistant, especially when migrating away from legacy DeviceScanner platforms:\n\n1. **Config entries instead of YAML-only setup**: New integrations should use config_entries with config_flow and options_flow. YAML configuration is supported via async_setup only as an import mechanism, not as the primary configuration interface.\n\n2. **Router abstraction layer**: Encapsulate all router-specific API logic in a dedicated Router class and a data helper (here, AirCubeRouter and AirCubeData). This separation allows:\n   - Centralized connection handling and login/session logic.\n   - A single place to manage API calls and raw data structures.\n   - A clear interface for device_tracker entities to read from (e.g., router.api.devices, router.available).\n\n3. **Device model for clients**: Represent each connected network client as a Device object that persists state over time (MAC address, raw params, last_seen, and derived attributes). This pattern makes it straightforward to reason about presence and attributes independent of the underlying API.\n\n4. **`ScannerEntity` and dispatcher-based updates**: Instead of DeviceScanner.scan_devices, the newer architecture uses ScannerEntity entities per client and a dispatcher signal to push updates. The Router schedules periodic or on-demand updates (request_update/async_update), and the entities subscribe to a router-specific signal to refresh their state when data changes. This fits well into Home Assistant’s entity/component model and minimizes polling logic in entities.\n\n5. **Consider-home logic in the integration**: For presence detection, the integration computes is_connected based on last_seen and a configurable detection_time. This logic lives in the entity/device model rather than in generic code, allowing each integration to tune behavior for its API semantics.\n\n6. **Robust API and authentication error handling**: The integration builds a small error taxonomy (LoginError, SSLError, ConnectionTimeout, CannotConnect) and maps exceptions from the requests library into these domain-specific errors. The config flow then maps them to user-facing errors. Using a dedicated error layer allows clean separation between transport-level issues and user input mistakes (e.g., wrong credentials vs unreachable host).\n\n7. **Session-based JSON-RPC handling**: For routers exposing a /ubus JSON-RPC API, define helper functions for JSON-RPC calls and session management (e.g., `_req_json_rpc` and `_get_session_id`). These helpers centralize the JSON-RPC envelope creation, error handling, and timeout/SSL behavior, making the rest of the code work with processed responses only.\n\n8. **Device registry integration**: For router integrations, register the router as a Device in the device registry (using serial number, model, firmware, manufacturer) and represent client devices with CONNECTION_NETWORK_MAC or similar identifiers. This enables rich device relationships in the UI and automations.\n\n9. **Entity registry–based restoration**: When initializing device_tracker entities, the integration can inspect the entity registry for entities belonging to its config entry and domain, and restore devices that are no longer active but were known previously. This ensures continuity of entity IDs and avoids losing entities on restart when no clients are currently connected.\n\n10. **Translation and user experience**: New integrations must provide `.translations` and `strings.json` to support localized config flows and options, and declare `config_flow: true` in manifest.json. This standardizes the user experience and keeps error messages and field labels in sync with the code.\n\nMore broadly, this PR demonstrates the best practice of aligning new functionality with the host framework’s most current patterns (config entries, async I/O, dispatcher-based updates) instead of relying on deprecated or legacy APIs. It also shows a generalizable approach for any router-like device: abstract the API, build a device model with last_seen and attributes, tie presence to that model, and use HA’s entity/config_entry mechanisms for lifecycle and UI.",
        "procedural_memory": [
            "Step-by-step instructions on how to design or migrate a router-based device tracker integration in Home Assistant using modern patterns:",
            "Step 1: Identify legacy patterns and target architecture",
            "  - Check if the existing or initial integration uses DeviceScanner, get_scanner, and YAML-only configuration via PLATFORM_SCHEMA in device_tracker.py. These are legacy patterns.",
            "  - Plan to replace them with a config_entry-based design: config_flow, options_flow, async_setup_entry, and ScannerEntity-based device trackers.",
            "",
            "Step 2: Define integration constants and manifest",
            "  - Create a const.py with DOMAIN, DEFAULT_* values, and any attribute keys used for devices (e.g., ATTR_MANUFACTURER, ATTR_MODEL, ATTR_FIRMWARE, CONF_DETECTION_TIME).",
            "  - Update manifest.json:\n    - Set \"domain\" and \"name\".\n    - Add \"config_flow\": true.\n    - Declare \"codeowners\".\n    - Keep \"requirements\" and \"dependencies\" accurate.",
            "  - Add the domain to generated/config_flows.py so the config flow is discoverable.",
            "",
            "Step 3: Implement the router API helper module",
            "  - Create a router.py that encapsulates all low-level API communication:\n    - Define helper functions for JSON-RPC (if applicable), e.g. `_req_json_rpc(url, session_id, rpcmethod, subsystem, method, verify_ssl, **params)`.\n    - Implement `_get_session_id(url, username, password, verify_ssl)` to log in and obtain a session token; raise distinct exceptions for login failures vs connection/SSL issues.\n    - Implement `get_api(...)` that verifies both authentication and basic API functionality (e.g., calling 'ubnt stats'), re-authenticating if necessary.",
            "  - Map requests exceptions to domain-specific errors:\n    - ConnectionTimeout for timeouts (ConnectTimeout, socket.timeout).\n    - SSLError for SSL handshake/cert errors.\n    - CannotConnect for network/connection errors.\n    - LoginError for invalid credentials or unsuccessful authentication.",
            "",
            "Step 4: Create Device and data model classes",
            "  - Define a Device class representing a client (network device):\n    - Store MAC address, raw params, last_seen timestamp, and derived attributes.\n    - Provide .name (fallback to MAC or friendly name if available), .mac, .last_seen, .attrs.\n    - Implement an update(params=None, active=False) method that updates params and sets last_seen when active=True.",
            "  - Define AirCubeData (or similar) that talks to the API:\n    - Store config_entry, host, credentials, verify_ssl, available flag, router metadata (hostname, model, firmware, serial_number).\n    - Provide methods:\n      - connect_to_router(): call get_api() and set available flag.\n      - command(): perform a stats request via get_api(); raise CannotConnect if not available.\n      - get_router_details(): populate router metadata from the stats response.\n      - get_list_from_interface(): extract client MACs from the API response; handle multiple radios (wlan0, wlan1) as needed.\n      - restore_device(mac): reconstruct a Device object from prior state.\n      - update_devices(): fetch current clients and update or create Device instances, marking them as active.",
            "",
            "Step 5: Build the Router wrapper object",
            "  - Implement a Router class (e.g., AirCubeRouter) that wraps AirCubeData and integrates it with Home Assistant:\n    - Expose properties like host, url, username, password, verify_ssl, hostname, model, firmware, serial_num, available.\n    - Implement option_detection_time returning a timedelta constructed from CONF_DETECTION_TIME in config_entry options.\n    - Define a signal_update property returning a unique dispatcher signal string, e.g., f\"aircube-update-{self.host}\".",
            "  - Provide lifecycle methods:\n    - async_add_options(): set default options in config_entry (e.g., detection_time) if not already set.\n    - async_update(): call into AirCubeData.update in an executor and dispatch the update signal to entities.\n    - request_update(): ensure only one update runs at a time by tracking self.progress (a task).",
            "  - Implement async_setup():\n    - Validate connectivity via get_api.\n    - Instantiate AirCubeData, add default options, populate router details, and fetch initial device state.\n    - Forward the config entry to the device_tracker platform with async_forward_entry_setup.",
            "",
            "Step 6: Implement config_flow and options_flow",
            "  - Create config_flow.py with a ConfigFlow subclass:\n    - In async_step_user:\n      - Prevent duplicate configuration by checking existing entries with the same host or name.\n      - Validate credentials by calling _get_session_id() (in an executor) to the router; catch LoginError, CannotConnect, ConnectionTimeout, SSLError.\n      - Map errors to appropriate keys in the `errors` dict to surface to the UI (base vs specific fields like username/password).\n      - On success, create the config entry with title=user_input[CONF_NAME].\n    - In async_step_import, normalize YAML config (e.g., convert detection_time from timedelta to seconds) and delegate to async_step_user.",
            "  - Implement an OptionsFlow:\n    - Provide async_step_init redirecting to async_step_device_tracker.\n    - In async_step_device_tracker, offer a form to adjust detection_time, defaulting to the current option or a constant like DEFAULT_DETECTION_TIME.\n    - On submit, store options with async_create_entry.",
            "",
            "Step 7: Wire up the integration entry point",
            "  - In __init__.py:\n    - Define a CONFIG_SCHEMA for optional YAML-based configuration (e.g., host, username, password, verify_ssl, detection_time), wrapped in an AIRCUBE_SCHEMA and ensure_list.\n    - In async_setup, loop over any YAML entries and initiate config flows via hass.config_entries.flow.async_init with SOURCE_IMPORT.\n    - In async_setup_entry:\n      - Instantiate the Router and run router.async_setup(); abort on failure.\n      - Store the router in hass.data[DOMAIN][entry_id].\n      - Register the router as a device in the device registry using async_get_registry and async_get_or_create, with identifier (DOMAIN, serial_num) and appropriate manufacturer, model, name, and sw_version.\n    - In async_unload_entry, forward unload to the device_tracker platform and remove the router from hass.data.",
            "",
            "Step 8: Implement device_tracker platform with ScannerEntity",
            "  - In device_tracker.py, implement async_setup_entry(hass, config_entry, async_add_entities):\n    - Retrieve the router from hass.data[DOMAIN][entry_id].\n    - Obtain the entity registry to restore previously known client entities.\n    - For each entity belonging to this config_entry and the device_tracker domain:\n      - If its unique_id corresponds to a client MAC that is not currently in router.api.devices but is present in router.api.all_devices, call router.api.restore_device(unique_id) to recreate the Device.\n    - Define a callback update_router() that calls an update_items(router, async_add_entities, tracked) helper.\n    - Register update_router with async_dispatcher_connect on router.signal_update.\n    - Call update_router() once immediately to create initial entities.",
            "  - Implement update_items(router, async_add_entities, tracked):\n    - Iterate over router.api.devices and create AirCubeRouterTracker (or similar) entities for any MAC not yet in tracked.\n    - Add new entities via async_add_entities.",
            "",
            "Step 9: Implement the ScannerEntity subclass",
            "  - In the entity class (AirCubeRouterTracker):\n    - Store references to the Device and Router objects.\n    - Implement properties:\n      - is_connected: return True if device.last_seen is not None and (now - last_seen) < router.option_detection_time.\n      - source_type: return SOURCE_TYPE_ROUTER.\n      - name: return device.name.\n      - unique_id: return device.mac.\n      - available: delegate to router.available.\n      - device_state_attributes: return device.attrs when is_connected, or None otherwise.\n      - device_info: return a dict with connections {(CONNECTION_NETWORK_MAC, mac)}, identifiers {(DOMAIN, mac)}, and name.",
            "  - Implement async_added_to_hass: log debug info and subscribe to router.signal_update via async_dispatcher_connect, storing the unsubscribe function.",
            "  - Implement async_update: call router.request_update() to trigger an API refresh; the dispatcher will then cause async_write_ha_state to be called from the subscribed callback.",
            "  - Implement will_remove_from_hass: call the stored unsubscribe function to clean up dispatcher subscriptions.",
            "",
            "Step 10: Add translations and UI strings",
            "  - Provide .translations/en.json and strings.json containing:\n    - Config flow titles, field labels (name, host, username, password, verify_ssl), and errors (cannot_connect, timeout, wrong_credentials, ssl_error, name_exists, already_configured).\n    - Options step for device_tracker containing detection_time label.\n  - Keep translation keys consistent with error codes returned from config_flow.",
            "",
            "Step 11: Test end-to-end behavior",
            "  - Validate that adding the integration via the UI prompts for host, username, password, and SSL usage; invalid credentials or unreachable host map to correct error messages.\n  - Confirm that the router is added to the device registry with the correct metadata (hostname, model, firmware, serial).\n  - Verify that connected clients appear as device_tracker entities with MAC-based unique IDs and correct is_connected logic based on detection_time.\n  - Restart Home Assistant and ensure previously known device_tracker entities are restored even if clients are currently not connected.\n  - Test behavior under connection/SSL failures to confirm graceful error handling and reconnection behavior.",
            "",
            "Following these steps will let a developer implement or migrate a router-based device tracker integration that conforms to Home Assistant’s modern architecture, provides better UX via config flows and options, and has robust, debuggable handling of API and connectivity issues."
        ]
    }
}
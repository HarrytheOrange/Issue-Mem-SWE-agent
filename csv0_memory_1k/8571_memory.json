{
    "search_index": {
        "description_for_embedding": "Home Assistant ubus device_tracker bug where only the first tracker instance updated because of decorator ordering between a custom _refresh_on_access_denied wrapper and the Throttle(MIN_TIME_BETWEEN_SCANS) decorator. Changing the decorator order to apply the access-denied refresh wrapper before throttling restored correct behavior for multiple tracker instances.",
        "keywords": [
            "homeassistant",
            "device_tracker",
            "ubus",
            "decorator order",
            "Throttle",
            "MIN_TIME_BETWEEN_SCANS",
            "multiple instances",
            "only first instance works",
            "access denied",
            "_refresh_on_acccess_denied",
            "stateful decorator",
            "shared throttling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant ubus device_tracker integration, a regression occurred after introducing a _refresh_on_acccess_denied decorator that refreshes the router session when an access-denied error is encountered. The method `_update_info` was decorated as:\n\n@Throttle(MIN_TIME_BETWEEN_SCANS)\n@_refresh_on_acccess_denied\n\ndef _update_info(...)\n\nAfter this change, when multiple ubus device_tracker instances were configured, only the first initialized tracker would actively update. Subsequent instances appeared inert.\n\nThe root cause was an interaction between the order of decorators and the throttling behavior. With Throttle as the outermost decorator, its shared state (e.g., last call time, cached result) affected all instances of the tracker method at the class level, effectively throttling calls for all instances based on the first one. Combined with the access-refresh logic, this resulted in only the first tracker instance actually making ubus update calls while others were suppressed.\n\nThe fix was to reverse the decorator order so that `_refresh_on_acccess_denied` wraps `_update_info` first and `Throttle(MIN_TIME_BETWEEN_SCANS)` is applied afterward:\n\n@_refresh_on_acccess_denied\n@Throttle(MIN_TIME_BETWEEN_SCANS)\n\ndef _update_info(...)\n\nThis change made the multiple ubus trackers function correctly again; each instance could update as expected while still benefiting from throttling and session-refresh behavior.",
        "semantic_memory": "Decorator order in Python is semantically important, especially when decorators are stateful (e.g., throttling, caching) or modify control flow (e.g., retry, error handling, session refresh). The decorator closest to the function is applied first and the topmost decorator is the outermost wrapper. When such decorators are applied at class definition time, their state often becomes shared across all instances that use the method, because the wrapped function object is stored on the class.\n\nIf a throttling or caching decorator is outermost, it can unintentionally share timing or cache state across multiple instances, causing only the first instance to execute fully while subsequent instances are throttled or receive stale results. When combined with a decorator that handles errors or refreshes sessions, the sequence in which errors are handled, sessions are refreshed, and calls are throttled can change drastically depending on the order of decorators.\n\nGeneralizable insights:\n- Stateful decorators (throttle, cache, rate limit) applied at class level may share state across instances; careful design or per-instance wrapping is needed.\n- The order of decorators controls the order in which logic is applied and can alter behavior in subtle ways, especially where error handling, retries, or side effects are involved.\n- Bugs where \"only the first instance works\" are often caused by shared global/class-level state, including in decorators, singletons, or module-level caches.",
        "procedural_memory": [
            "When multiple instances of a component or class stop working correctly and only the first instance behaves as expected, suspect shared state or shared rate-limiting/caching logic (e.g., in decorators).",
            "Step 1: Identify decorated methods involved in the failing behavior.\n- Look for @decorator syntax on methods used by multiple instances.\n- Check especially for rate limiting, throttling, caching, or retry decorators.",
            "Step 2: Inspect decorator implementation for statefulness.\n- Determine if the decorator keeps state (e.g., last_call_time, cached results) in closures, attributes on the wrapper, or class-level variables.\n- Verify whether this state is per-wrapper (i.e., per class method) and thus shared by all instances.",
            "Step 3: Reason about decorator order.\n- Remember that:\n  - @A\n  - @B\n  - def f(...):\n  -   ...\n  translates to f = A(B(f)), so A is the outermost wrapper and B is applied closer to the function.\n- Map how each decorator’s logic executes: outermost runs first on call, innermost runs last before the original function.",
            "Step 4: Consider how shared state affects multiple instances.\n- If a Throttle or cache decorator is outermost on a method defined at the class level, all instances will share the same throttling or cache state.\n- Ask: is it acceptable that instances share a global throttle/cache? If not, you must change the design or decorator order.",
            "Step 5: Experiment by changing decorator order.\n- Swap the order of decorators to change which logic is outermost.\n- For example, move error-handling/session-refresh decorators above or below throttling/caching decorators and re-run tests.\n- In this case, moving `_refresh_on_acccess_denied` above `@Throttle(MIN_TIME_BETWEEN_SCANS)` ensured access-denied refresh logic wrapped the function before throttling was applied.",
            "Step 6: Add targeted tests for multiple instances.\n- Create tests that instantiate multiple copies of the class and call the decorated method on each.\n- Assert that each instance updates independently and is not blocked by another instance’s throttling or cached state.",
            "Step 7: If decorator order is not sufficient, refactor to per-instance state.\n- Consider applying decorators in __init__ (wrapping bound methods), or modifying the decorator to store state on `self` (instance) instead of on the function wrapper.\n- Alternatively, parameterize the decorator to allow per-instance configuration or namespacing of state.",
            "Step 8: Document the design.\n- Clearly document the intended behavior of decorators in multi-instance scenarios and how the decorator order affects them.\n- Include comments in the code near the decorators indicating that the order is deliberate and required for correct multi-instance behavior."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Refactor Optuna tests to replace direct storage parametrization (`parametrize_storage` using InMemoryStorage/RDBStorage) with the unified `StorageSupplier` test helper and `STORAGE_MODES`. Tests now create studies inside a `StorageSupplier` context manager, improving consistency across storage backends and ensuring proper cleanup of storage resources.",
        "keywords": [
            "optuna",
            "pytest",
            "StorageSupplier",
            "STORAGE_MODES",
            "parametrize_storage",
            "storage backend tests",
            "InMemoryStorage",
            "RDBStorage",
            "resource cleanup",
            "test refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this PR, the Optuna project refactored several tests that previously used a custom `parametrize_storage` pattern to cover different storage implementations. Originally, tests in `tests/importance_tests/test_init.py`, `tests/trial_tests/test_frozen.py`, and `tests/trial_tests/test_trial.py` used `pytest.mark.parametrize` with concrete storage initializer callables, e.g. `storages.InMemoryStorage` and a lambda wrapping `storages.RDBStorage('sqlite:///:memory:')`. This approach duplicated logic and did not leverage the newly provided `StorageSupplier` helper, which centralizes storage configuration and cleanup for testing.\n\nThe refactor introduced imports from `optuna.testing.storage` (`STORAGE_MODES` and `StorageSupplier`) and replaced the old `parametrize_storage` markers with `@pytest.mark.parametrize('storage_mode', STORAGE_MODES)`. Inside each test, storage is now obtained via `with StorageSupplier(storage_mode) as storage:` and passed into `create_study(storage=storage, ...)`. This ensures that each test runs against all supported storage modes defined by the test utilities and that storage resources are properly cleaned up after each test.\n\nAlong the way, a test function name typo was fixed (`test_get_param_importancetarget_target_is_none_and_study_is_multi_obj` was renamed to `test_get_param_importance_target_is_none_and_study_is_multi_obj`). Some tests were restructured to merge nested context managers: for example, in `test_suggest_low_equals_high`, the patching of `distributions._get_single_value` and the `StorageSupplier` context were combined into a single `with` statement, simplifying the code. Similarly, `test_suggest_int_log` was refactored to patch the sampler's `sample_independent` method in the outer context and reuse that for assertions.\n\nFunctionally, the tests' assertions and behavior remain the same: they still verify parameter suggestion consistency, distribution checks, warning behavior, and importance evaluator behavior across multiple storage backends. The main change is infrastructural, improving maintainability, coverage consistency across storage types, and preventing potential resource leaks by centralizing storage lifecycle management through `StorageSupplier`.",
        "semantic_memory": "This change illustrates a general best practice in test infrastructure: centralize environment setup and backend parametrization in shared, well-defined utilities instead of duplicating that logic in each test. Specifically, for systems that support multiple backend implementations (such as different storage layers, database engines, or cache providers), it is beneficial to:\n\n1. Expose a canonical list of backend modes (here, `STORAGE_MODES`) in a common testing module.\n2. Provide a helper or fixture (here, `StorageSupplier`) that encapsulates backend setup, configuration, and teardown, ideally as a context manager or fixture.\n3. Parametrize tests by a logical mode identifier (like a string `storage_mode`) rather than by concrete factory callables scattered throughout the test suite.\n\nThis pattern yields several advantages:\n- **Consistency**: All tests exercise the same set of backends without each test having to know exact storage construction details.\n- **Maintainability**: Adding or modifying a backend is done in one place; all parametrized tests automatically pick it up.\n- **Resource Management**: A central helper can properly close connections, clean temporary files, and rollback transactions, reducing the risk of flaky tests due to leaked resources.\n- **Readability**: Tests focus on behavior (e.g., parameter suggestion, importance computation) rather than on the mechanics of setting up each backend.\n\nAdditionally, the refactor shows that nesting many `with` contexts (patching, storage lifecycles) can be simplified by combining them into a single `with` statement, which makes tests easier to read and less error-prone. Typos in test names were corrected, which is another small but important practice: descriptive, correct test names help future maintainers understand test intent.\n\nOverall, the lesson is to treat test infrastructure as first-class code: abstract repeated patterns (like backend setup), use parametrization at the level of logical modes rather than concrete classes, and ensure proper resource management via context managers or fixtures.",
        "procedural_memory": [
            "Use a unified storage/test backend helper instead of ad-hoc parametrization when you need to test code against multiple backends.",
            "Step 1: Identify duplicated backend parametrization logic.\n- Search the test suite for patterns like `pytest.mark.parametrize('storage_init_func', [...])` or repeated constructors of different backend classes (e.g., `InMemoryStorage`, `RDBStorage`).\n- Note where tests directly construct backends instead of using a shared helper or fixture.",
            "Step 2: Introduce or reuse a centralized backend abstraction.\n- If the project already provides a helper (e.g., `StorageSupplier` and `STORAGE_MODES` from `optuna.testing.storage`), prefer that over custom code.\n- If not available, create a testing utility module that exposes:\n  - A list of backend modes (e.g., `STORAGE_MODES = ['in_memory', 'sqlite', ...]`).\n  - A context manager or fixture (e.g., `StorageSupplier`) that, given a mode, sets up the corresponding backend and ensures cleanup.",
            "Step 3: Replace old parametrization with mode-based parametrization.\n- Remove the old `parametrize_storage` marker, such as:\n  - `parametrize_storage = pytest.mark.parametrize('storage_init_func', [...])`.\n- Change test decorators from `@parametrize_storage` to `@pytest.mark.parametrize('storage_mode', STORAGE_MODES)`.\n- Update test signatures from `def test_x(storage_init_func, ...)` to `def test_x(storage_mode: str, ...)`.",
            "Step 4: Use the backend supplier context manager in tests.\n- Inside each test that needs a storage/backend, wrap the core logic with the supplier:\n  - `with StorageSupplier(storage_mode) as storage:`\n  - Then pass `storage` into the API under test (e.g., `create_study(storage=storage, ...)`).\n- Ensure all interactions with the backend happen inside this `with` block so that cleanup occurs reliably at the end of the block.",
            "Step 5: Preserve test semantics while refactoring.\n- Move existing assertions and logic into the `StorageSupplier` context without changing their behavior.\n- Keep the structure of tests the same (e.g., still call `study.optimize`, still check warnings and raised exceptions) but ensure they now run for each storage mode.",
            "Step 6: Simplify nested context managers when possible.\n- Where tests previously nested `with patch.object(...):` inside `with StorageSupplier(...):`, consider combining them:\n  - `with patch.object(...), StorageSupplier(storage_mode) as storage:` if the order and lifetimes are compatible.\n- This reduces visual nesting and potential mistakes around where mocks or resources are active.",
            "Step 7: Run tests across all backends and verify coverage.\n- Execute the test suite and ensure that all parametrized tests now run successfully for every mode listed in `STORAGE_MODES`.\n- Check that failures or warnings are consistent across backends and that no unexpected resource leaks occur (e.g., hanging DBs, leftover files).",
            "Step 8: Clean up naming and docstrings for clarity.\n- Fix any typos in test function names (e.g., adding missing underscores, correcting words) to reflect what is actually being tested.\n- Optionally, update comments and docstrings to mention the use of `StorageSupplier` or the new backend abstraction, so future contributors understand the intended pattern."
        ]
    }
}
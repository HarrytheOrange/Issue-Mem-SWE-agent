{
    "search_index": {
        "description_for_embedding": "Fixes a JSON Schema bug where the `type` attribute of StackStorm action parameters accepted any string instead of only valid simple types. The schema for `action_params.json` was corrected to reference only `simpleTypes`, and a regression test was added to ensure registering an action with an invalid parameter type (e.g., `list` instead of `array`) raises a jsonschema.ValidationError.",
        "keywords": [
            "StackStorm",
            "action parameter type validation",
            "JSON Schema",
            "action_params.json",
            "jsonschema.ValidationError",
            "schema bug",
            "metadata validation",
            "invalid parameter type",
            "simpleTypes",
            "YAML action metadata"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, StackStorm's validation of the `type` attribute for action parameters was incorrect. The JSON Schema defined in `st2common/st2common/util/schema/action_params.json` used an `anyOf` clause that allowed either a reference to `simpleTypes` or a bare `string`. Because of this, any arbitrary string (e.g., `list`) was considered valid for the `parameters.<name>.type` field in action YAML metadata, instead of only the intended set of simple types (object, string, number, integer, array, null). \n\nThe issue was discovered after a user provided metadata with `type: \"list\"`, which should be invalid, but StackStorm accepted it. Investigation showed that the schema allowed this due to the overly permissive `\"type\": \"string\"` branch in the `anyOf`. The fix removed the second branch so that `type` now only uses `{ \"$ref\": \"#/definitions/simpleTypes\" }`, enforcing the allowed simple types.\n\nA regression test was added in `st2actions/tests/unit/test_actions_registrar.py` under `test_register_action_invalid_parameter_type_attribute`. It loads a new fixture `st2tests/st2tests/fixtures/generic/actions/action_invalid_param_type.yaml`, which defines a parameter with `type: \"list\"`. The test asserts that registering this action via `ActionsRegistrar._register_action` raises a `jsonschema.ValidationError` with a message indicating `'list' is not valid under any of the given schema`. Supporting validator methods (`_is_valid_pack` and `_get_runner_model`) are mocked to isolate the schema validation. The changelog was updated to document that action parameter `type` validation has been tightened to only accept valid types.",
        "semantic_memory": "This fix highlights a common pitfall when using JSON Schema to validate configuration or metadata: overly permissive schemas can silently accept invalid values. In this case, including a generic `\"type\": \"string\"` branch in an `anyOf` effectively disabled type enforcement for a field that should only allow a specific set of values.\n\nGeneralizable lessons:\n- When a field represents a constrained type (e.g., a small set of allowed type names), the schema should restrict it explicitly (via enums or references to a constrained definition) and avoid generic fallbacks like `type: string` unless truly necessary.\n- `anyOf`/`oneOf` can easily broaden a schema more than intended if one branch is too generic; always review the most permissive branch to ensure it doesn't swallow invalid cases.\n- For metadata-driven systems (like action definitions, workflows, or configuration files), validation bugs often surface only at runtime or when users supply novel inputs. Regression tests should be added specifically for edge cases that previously slipped through.\n- Adding a concrete fixture representing the invalid case (e.g., YAML with a wrong type name) and a unit test around the registration/validation path is an effective pattern to prevent the bug from reappearing.\n- Schema changes should be documented in changelogs because they can change what configurations are considered valid, potentially breaking previously accepted but incorrect definitions.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the validation behavior\n- Identify the field whose validation seems wrong (e.g., a `type` attribute in metadata).\n- Create a minimal fixture (YAML/JSON) that uses an obviously invalid value for that field (e.g., `type: \"list\"` when valid values are `array`, `string`, etc.).\n- Run the normal registration/validation path (e.g., an action registrar or config loader) and observe whether the invalid value is accepted or rejected.",
            "Step 2: Locate the relevant JSON Schema\n- Find the schema file used to validate the problematic metadata (e.g., `action_params.json`).\n- Search for the property definition corresponding to the field (`\"type\"` under the parameter schema).\n- Inspect its constraints (`type`, `anyOf`, `oneOf`, `$ref`, `enum`, etc.) to understand why the invalid value might be passing.",
            "Step 3: Identify overly permissive schema branches\n- Look for constructs like `anyOf` or `oneOf` where one branch is specific (e.g., `$ref` or `enum`) and another branch is generic (e.g., `{ \"type\": \"string\" }`).\n- Recognize that a generic branch may allow any string, defeating the purpose of the more specific branch.\n- Confirm by mentally or experimentally validating an invalid value against each branch.",
            "Step 4: Tighten the schema\n- Remove or narrow the overly broad branch. For example, change:\n  - `\"anyOf\": [ { \"$ref\": \"#/definitions/simpleTypes\" }, { \"type\": \"string\" } ]`\n  - To: `\"anyOf\": [ { \"$ref\": \"#/definitions/simpleTypes\" } ]` or just the reference if `anyOf` is no longer needed.\n- Alternatively, use `\"enum\": [\"object\", \"string\", \"number\", \"integer\", \"array\", \"null\"]` if you want direct explicitness instead of a referenced definition.",
            "Step 5: Add a regression test with fixtures\n- Create a dedicated fixture file that encodes the invalid case (e.g., YAML action with `parameters.param1.type: \"list\"`).\n- Write a unit test that:\n  - Loads the fixture through the same code path used in production (e.g., via a registrar or loader).\n  - Mocks unrelated dependencies (e.g., pack validation or runner lookup) to keep the test focused on schema validation.\n  - Asserts that a `jsonschema.ValidationError` (or relevant error) is raised.\n  - Optionally checks part of the error message to ensure the failure is due to the intended field.",
            "Step 6: Run the test suite and iterate\n- Run the affected tests (or the full suite) to ensure the new test fails with the old schema and passes with the updated schema.\n- Check that no existing tests break due to tighter validation, or adjust them if they were relying on previously invalid behavior.",
            "Step 7: Communicate and document the change\n- Add a changelog entry summarizing the schema fix and the now-enforced constraints on the field.\n- If this may affect existing users who had invalid but accepted values, note that those configurations will now fail validation and may need updates.",
            "Step 8: Generalize for future schema work\n- When designing new schema fields, prefer:\n  - `$ref` to constrained definitions or `enum` over generic `type: string` for known finite sets.\n  - Targeted use of `anyOf`/`oneOf` with each branch as constrained as possible.\n- Add tests for both valid and invalid edge cases, especially around fields that encode types, modes, or enums."
        ]
    }
}
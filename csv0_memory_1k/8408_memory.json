{
    "search_index": {
        "description_for_embedding": "Home Assistant Kodi media_player integration updated to support generic script sequences for turn_on_action and turn_off_action instead of a fixed list of Kodi power commands. Old turn_off_action enum values (quit, hibernate, suspend, reboot, shutdown) are automatically converted into equivalent script-based calls to media_player.kodi_call_method with a deprecation warning. Implementation uses SCRIPT_SCHEMA, script.Script, and passes entity_id into scripts via templates. Websocket System.OnQuit/Restart/Sleep events reset internal player state after scripted shutdown.",
        "keywords": [
            "Home Assistant",
            "media_player.kodi",
            "Kodi",
            "turn_on_action",
            "turn_off_action",
            "SCRIPT_SCHEMA",
            "script.Script",
            "kodi_call_method",
            "deprecation warning",
            "configuration migration",
            "websocket callbacks",
            "System.OnQuit",
            "entity_id template",
            "wake on lan via script"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant Kodi media_player platform was extended to allow fully customizable turn_on and turn_off behaviors using script-like action sequences instead of a fixed list of Kodi power actions.\n\nPreviously, the Kodi integration only exposed a single `turn_off_action` configuration option supporting a small enum: `quit`, `hibernate`, `suspend`, `reboot`, `shutdown`, or `None`. There was no corresponding `turn_on_action`, and users could not chain arbitrary Home Assistant services like Wake-on-LAN or notifications. With the introduction of `media_player.kodi_call_method` and better script infrastructure, the limited enum model had become unnecessarily restrictive.\n\nThe PR evolved through several iterations:\n- Initial attempt added explicit options for `turn_on_action` (including a special Wake-on-LAN option) and a script option for both turn_on and turn_off, plus extra config like MAC address and WOL broadcast. This coupled Kodi to the wake_on_lan component and required entity_ids for scripts.\n- Review feedback pointed out that a generic script syntax for both `turn_on_action` and `turn_off_action` would be cleaner, more powerful, and symmetrical, even if more verbose for users. The explicit WOL option and script entity name fields were removed in favor of generic script sequences.\n- Configuration schema was updated: `CONF_TURN_ON_ACTION` and `CONF_TURN_OFF_ACTION` now accept `cv.SCRIPT_SCHEMA` objects. For `CONF_TURN_OFF_ACTION`, the schema also temporarily accepts the old enum values so existing configurations do not break immediately.\n- A deprecation layer was added. The helper `_check_deprecated_turn_off(hass, turn_off_action)` detects when `turn_off_action` is one of the old enum strings. It maps that option to the appropriate Kodi JSON-RPC method using `DEPRECATED_TURN_OFF_ACTIONS` (e.g., `quit -> Application.Quit`, `hibernate -> System.Hibernate`). It then auto-builds a script config equivalent to:\n  - service: `media_player.kodi_call_method`\n  - data_template:\n      - `entity_id: '{{ entity_id }}'`\n      - `method: <mapped_method>`\n  This config is wrapped into a list (i.e., a minimal script sequence) and converted into a `script.Script` instance.\n- To allow templating of the entity_id even before the entity_id is known, the generated script uses `data_template` with `Template` objects. At runtime, when the script is run, the `entity_id` variable is passed via `async_run(variables={\"entity_id\": self.entity_id})`. This decouples the migration logic from the entity registry timing.\n- A clear deprecation warning is logged, including a YAML example of the equivalent new-style configuration, so users can copy/paste it into `configuration.yaml`. The warning explicitly states that the old action will cease to function in a future release.\n- Final `PLATFORM_SCHEMA` now looks like:\n  - `CONF_TURN_ON_ACTION`: optional, `cv.SCRIPT_SCHEMA` (a script sequence).\n  - `CONF_TURN_OFF_ACTION`: optional, `vol.Any(cv.SCRIPT_SCHEMA, vol.In(DEPRECATED_TURN_OFF_ACTIONS))`.\n- In the KodiDevice constructor, both `turn_on_action` and `turn_off_action` are converted into `script.Script` objects with appropriate names. For turn_off, `_check_deprecated_turn_off` is called first to handle legacy values and generate a script.\n- `supported_features` now adds `SUPPORT_TURN_ON` if a `turn_on_action` script is configured, and `SUPPORT_TURN_OFF` if a `turn_off_action` script is configured.\n- `async_turn_on` and `async_turn_off` were simplified: instead of branching on option strings, they now simply run the configured script if it exists, passing in `entity_id` as a variable. If no script is configured, a warning is logged.\n- Websocket callbacks for `System.OnQuit`, `System.OnRestart`, and `System.OnSleep` were restored and wired to `async_on_quit`, which resets internal player state (`_players`, `_properties`, `_item`, `_app_properties`) and triggers an HA state update, ensuring the entity reflects an 'off' style state after a scripted shutdown.\n\nThe overall result: users can now define arbitrary actions to turn Kodi on and off (e.g., send a Wake-on-LAN packet, toggle lights, send notifications, call specific Kodi JSON-RPC methods) via generic script sequences; existing configs using the old enum-based `turn_off_action` continue to work for now but emit clear, actionable deprecation warnings alongside an example of the new script-based configuration.",
        "semantic_memory": "This change illustrates several generalizable patterns for evolving configuration-driven integrations and power actions in a home automation system.\n\n1. **Transitioning from rigid enums to scriptable actions**\nInstead of exposing a closed set of actions via enumerated configuration values (e.g., `quit`, `hibernate`, `shutdown`), it's often better to expose a generic script or action sequence mechanism:\n- Use a schema like `SCRIPT_SCHEMA` to allow a list of service calls, delays, templates, etc.\n- This offers much greater flexibility (users can send WOL packets, toggle other entities, or call APIs directly) without increasing core complexity.\n- The core component simply executes scripts; all customized behavior lives in config.\n\n2. **Non-breaking migration with deprecation helpers**\nWhen replacing old configuration patterns:\n- Accept both the old and new formats in the validation schema temporarily.\n- Internally, detect the old format, convert it into an equivalent representation of the new format, and log a deprecation warning.\n- Include an explicit example (e.g., YAML snippet) of the new configuration in the warning so users have copy/paste-ready migration guidance.\n- Centralize the mapping logic in a helper (here, `DEPRECATED_TURN_OFF_ACTIONS` and `_check_deprecated_turn_off`) rather than scattering conditional branches throughout the code.\n\n3. **Decoupling migration logic from entity_id availability**\nEntity identifiers often are not finalized at validation/setup time. To avoid this dependency:\n- Use templated fields (e.g., `data_template` with `{{ entity_id }}`) in generated configs.\n- Wrap string templates in `Template` objects with the relevant `hass` context.\n- At execution time, call scripts with `variables={\"entity_id\": self.entity_id}` to substitute the correct id. This allows you to generate migration scripts without knowing the final entity_id at creation time.\n\n4. **Using script objects as first-class execution units**\nInstead of manually invoking services in component code:\n- Convert configuration data into `script.Script` instances once during setup.\n- Call `async_run()` on these scripts when actions are needed, optionally passing `variables` and callbacks.\n- Attach callbacks (e.g., `async_update_ha_state` or `async_on_quit`) to scripts to trigger follow-up state updates or cleanup after a script completes.\n- This reduces code duplication and aligns component behavior with the same mechanisms scripts use elsewhere.\n\n5. **Aligning supported_features with configured behavior**\nSupported feature flags should be dynamic based on whether functionality is actually configured:\n- If a `turn_on_action` exists, set `SUPPORT_TURN_ON`; otherwise, omit it.\n- If a `turn_off_action` exists, set `SUPPORT_TURN_OFF`.\nThis keeps the UI and service availability in sync with what the user has configured.\n\n6. **Leveraging event callbacks to keep state consistent**\nFor long-running or 24/7 services accessible via websockets:\n- Register event handlers (like Kodi's `System.OnQuit`, `OnRestart`, `OnSleep`) that clear cached state and trigger HA state updates when the underlying application exits or sleeps.\n- This keeps the entity's state accurate even when the shutdown is initiated via scripts or external controls.\n\nThese patterns apply broadly to any integration where you want to expose configurable on/off behavior, migrate users from simple toggles to extensible workflows, or maintain backward compatibility while evolving the config model.",
        "procedural_memory": [
            "Step-by-step approach to migrate an integration from fixed action enums to script-based turn_on/turn_off behaviors while maintaining backward compatibility.",
            "Step 1: Identify the existing config surface and target flexibility.\n- Enumerate the current configuration options (e.g., `turn_off_action` enum values like `quit`, `shutdown`).\n- Decide what new flexibility is desired (e.g., arbitrary sequences of Home Assistant services). Settle on a generic representation such as a script schema or action list.",
            "Step 2: Extend the configuration schema to accept scripts.\n- Introduce new config keys or reuse existing ones with widened schemas. For example:\n  - `vol.Optional(CONF_TURN_ON_ACTION, default=None): cv.SCRIPT_SCHEMA`\n  - `vol.Optional(CONF_TURN_OFF_ACTION): vol.Any(cv.SCRIPT_SCHEMA, vol.In(OLD_ACTION_MAPPING))`\n- This allows both script sequences and old enum values to be valid inputs during the transition period.",
            "Step 3: Create a mapping and conversion helper for legacy actions.\n- Define a mapping dict from old enum values to their underlying API actions, e.g.:\n  - `DEPRECATED_TURN_OFF_ACTIONS = {'quit': 'Application.Quit', 'shutdown': 'System.Shutdown', ...}`\n- Implement a helper like `_check_deprecated_turn_off(hass, turn_off_action)` that:\n  - Detects when `turn_off_action` is an old string value.\n  - Builds a script/action configuration equivalent to the old behavior (e.g., a call to `media_player.kodi_call_method` with the appropriate JSON-RPC method).\n  - Uses `data_template` with `Template` objects and a placeholder `{{ entity_id }}` so the script can be executed with a runtime `entity_id` variable.\n  - Logs a clear deprecation warning including an example YAML snippet of the equivalent new configuration.\n  - Returns the final script configuration (list of actions).",
            "Step 4: Convert configuration into script.Script objects at setup.\n- In the platform or entity initialization, after reading config:\n  - If a turn_on script is provided: `turn_on_action = script.Script(hass, turn_on_config, \"<friendly name>\", callback_after_completion)`.\n  - If a turn_off script or legacy option is provided: pass it through your checker (e.g., `_check_deprecated_turn_off(hass, value)`), then wrap the result in `script.Script`.\n- Store these `script.Script` objects on the entity (e.g., `self._turn_on_action`, `self._turn_off_action`).",
            "Step 5: Update supported_features based on configured scripts.\n- In `supported_features` or equivalent:\n  - Start with the base feature mask.\n  - If a `turn_on_action` script exists, OR in `SUPPORT_TURN_ON`.\n  - If a `turn_off_action` script exists, OR in `SUPPORT_TURN_OFF`.\n- This ensures that services like `media_player.turn_on` are only advertised when they actually do something.",
            "Step 6: Implement turn_on and turn_off to run scripts with variables.\n- In the entity's `async_turn_on` method:\n  - If `self._turn_on_action` is not None, call `yield from self._turn_on_action.async_run(variables={\"entity_id\": self.entity_id})`.\n  - Else, log a warning that no `turn_on_action` is configured.\n- Similarly, in `async_turn_off`:\n  - If `self._turn_off_action` is not None, call `yield from self._turn_off_action.async_run(variables={\"entity_id\": self.entity_id})`.\n  - Else, log a warning.\n- This pattern works both for user-defined scripts and auto-generated migration scripts that rely on `{{ entity_id }}`.",
            "Step 7: Wire up event callbacks to keep state consistent.\n- For integrations with websocket or push events, register handlers for shutdown-related events (e.g., `System.OnQuit`, `OnRestart`, `OnSleep`).\n- In the callback (e.g., `async_on_quit`):\n  - Reset or clear any internal state caches (`_players`, `_properties`, `_item`, `_app_properties`).\n  - Schedule an HA state update via `self.hass.async_add_job(self.async_update_ha_state())`.\n- Optionally hook script completion callbacks to these same state-resetting functions to handle shutdowns triggered via scripts.",
            "Step 8: Test migration behavior and deprecation messaging.\n- Create test configurations using both the old enum-style `turn_off_action` and new script-based definitions.\n- Confirm that:\n  - Old configs still work and result in correct behavior via the auto-generated scripts.\n  - Deprecation warnings include clear and correct YAML examples for users.\n  - New script configs (e.g., sequences including WOL, notifications, and Kodi method calls) execute correctly with the proper entity_id and side effects.\n- Run the automated test suite (e.g., `tox`) to ensure no regressions.",
            "Step 9: Document the new behavior and deprecation timeline.\n- Update component documentation to:\n  - Show examples of script-based `turn_on_action` and `turn_off_action` (e.g., Wake-on-LAN plus notification; Kodi Application.Quit; combined room shutdown scenes).\n  - Explain that old enum-based `turn_off_action` is deprecated, show the mapping, and provide a migration example.\n- Ensure release notes or a blog post calls out the deprecation and gives users time to migrate before removing legacy support."
        ]
    }
}
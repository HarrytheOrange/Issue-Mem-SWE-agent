{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant ISY994 fan platform where the fan entity's core state was incorrectly overwritten with the speed value. The fix restores proper semantics: `is_on` indicates power state, `speed` is derived from the underlying value via mapping, and commands no longer try to manually manage `state`/`speed`. Also updates default behavior so turning on without an explicit speed uses a high (255) value.",
        "keywords": [
            "Home Assistant",
            "ISY994",
            "fan platform",
            "entity state misuse",
            "state vs attributes",
            "speed attribute",
            "VALUE_TO_STATE",
            "STATE_TO_VALUE",
            "is_on property",
            "UI representation bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant ISY994 fan integration had a bug where the fan entity's `state` property was being overwritten with the current speed. Instead of representing the on/off state, the `state` field held values like low/medium/high. This conflicted with the expected entity model and caused incorrect behavior/representation in the frontend (e.g., issues like home-assistant-polymer#450).\n\nThe fix changed the implementation as follows:\n- `speed` is now derived directly from the raw device value using `VALUE_TO_STATE.get(self.value)` instead of returning `self.state`.\n- The fan entity no longer overrides `state`. Instead, it implements `is_on`, returning `self.value != 0` to indicate whether the fan is on.\n- Imports were cleaned up: `STATE_UNKNOWN` is no longer used and was removed.\n- `set_speed` was simplified: it now calls `self._node.on(val=STATE_TO_VALUE.get(speed, 255))` without trying to update `self.speed` or log debug errors on failure. The default value of `255` is used when no speed is provided, effectively treating a bare `turn_on` as a 'high' speed.\n- `turn_off` was also simplified to just call `self._node.off()` rather than attempting to manage `self.speed = self.state`.\n\nAs a result, the ISY994 fan entity now uses the Home Assistant fan model correctly: the on/off state is separated from the speed attribute, the UI can rely on proper semantics, and turning on without a specified speed defaults to a meaningful high speed instead of an 'off' or unknown state.",
        "semantic_memory": "This fix highlights an important design principle in entity/component models: core state fields (like `state` or boolean `is_on`) must preserve their documented semantics and should not be repurposed to carry other data such as 'speed', 'mode', or 'level'. Non-binary characteristics belong in dedicated attributes or properties (`speed`, `brightness`, `mode`, etc.), while the core state represents the primary lifecycle status (on/off, open/closed, etc.).\n\nOverwriting the main state with auxiliary values leads to:\n- Inconsistent behavior across platforms/components.\n- Frontend and API consumers misinterpreting the entity state (e.g., UI controls break or show wrong status).\n- Hard-to-debug issues where the underlying device state and the logical entity state diverge.\n\nAnother generalizable lesson: when offering high-level commands like `turn_on` that accept optional parameters (e.g., speed/brightness), define sensible defaults that match user expectations if the parameter is omitted (e.g., default to high speed or full brightness, not 'off'). Also, internal methods should avoid manually mutating properties like `state`/`speed` in response to commands; instead, state should flow from the device/driver back into the entity, and properties should be derived from that canonical source (such as `self.value`).",
        "procedural_memory": [
            "When debugging a component where the frontend shows incorrect or confusing entity states (e.g., a fan's state shows 'medium' instead of 'on'), check whether the integration is misusing the `state` property or mixing state with attributes.",
            "Step 1: Review the entity class implementation.",
            "Inspect properties like `state`, `is_on`, and any custom attributes (`speed`, `mode`, etc.). Ensure `state`/`is_on` reflect the primary binary/enum lifecycle, not secondary characteristics like speed.",
            "Step 2: Identify overloading or misuse of `state`.",
            "Search for code where `state` is overridden or manually assigned to values that are not valid canonical states (e.g., 'low', 'medium', 'high' for a fan instead of 'on'/'off'). Also check if a property like `speed` simply returns `self.state` instead of its own mapping.",
            "Step 3: Separate core state from attributes.",
            "Implement `is_on` (or correct `state`) based on the underlying device value (e.g., `self.value != 0` for a fan). Implement `speed` (or similar attributes) as separate properties derived from the same underlying value via mapping tables (e.g., `VALUE_TO_STATE.get(self.value)`). Do not redefine `state` to carry speed.",
            "Step 4: Use clear mapping tables for derived attributes.",
            "Define maps like `VALUE_TO_STATE` and `STATE_TO_VALUE` to translate between raw device values and logical attribute values (e.g., 0, 128, 255 â†” off, medium, high). Use these mappings in getters/setters rather than hardcoding values or abusing `state`.",
            "Step 5: Ensure commands do not manually mutate logical properties.",
            "In methods like `set_speed`, `turn_on`, and `turn_off`, call the underlying device API (e.g., `self._node.on(val=...)` or `self._node.off()`) and let the entity state be updated through normal state refresh mechanisms. Avoid statements like `self.speed = self.state` or manual state patching in these command methods.",
            "Step 6: Define sensible defaults for optional parameters.",
            "For commands that accept optional parameters (like `turn_on(speed=None)`), choose a reasonable default if the argument is omitted. For fans, defaulting to high speed (e.g., using a default value like 255 in `STATE_TO_VALUE.get(speed, 255)`) is often more intuitive than treating it as off or an error.",
            "Step 7: Clean up unused imports and error handling patterns.",
            "After aligning the state model, remove unused constants (e.g., `STATE_UNKNOWN` if no longer used). Simplify error handling to reflect how the platform actually propagates failures (e.g., log only where it adds value, and avoid redundant internal state churn that cannot be trusted if the command fails).",
            "Step 8: Test with the frontend and API clients.",
            "Verify that the UI now shows the correct on/off state and speed. Test `turn_on` with and without a specified speed, and `turn_off`, to ensure the UI and API report consistent and expected values. Confirm that no consumer relies on the old, incorrect behavior (document as a breaking change if necessary)."
        ]
    }
}
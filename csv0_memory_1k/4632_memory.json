{
    "search_index": {
        "description_for_embedding": "Home Assistant InfluxDB integration: add a configurable default measurement name for events that have no unit_of_measurement. Previously, such events used the full entity_id as the measurement name, leading to inconsistent measurement naming. The fix introduces an optional 'default_measurement' config that, when set, is used as the measurement name when unit_of_measurement is missing; otherwise, behavior falls back to the old entity_id-based naming.",
        "keywords": [
            "InfluxDB",
            "Home Assistant",
            "default_measurement",
            "unit_of_measurement",
            "measurement name",
            "time-series",
            "homeassistant.components.influxdb",
            "configuration option",
            "backwards compatibility"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant InfluxDB component, events are written to InfluxDB with a 'measurement' name. Originally, this measurement was taken from the entity's 'unit_of_measurement' attribute. If that attribute was missing or empty, the component would default the measurement name to the entity_id (e.g., 'sensor.living_room_temp'), resulting in a proliferation of entity-specific measurement names. This made querying and aggregating data across entities cumbersome and semantically odd, since the domain and object_id were already stored as tags.\n\nA user requested a way to have a consistent measurement name (e.g., 'state') for entities that lack a unit, while preserving the existing behavior for current users. To address this, the PR introduced a new optional configuration parameter, 'default_measurement', in the InfluxDB integration.\n\nImplementation details:\n- A new constant CONF_DEFAULT_MEASUREMENT = 'default_measurement' was added to homeassistant/components/influxdb.py.\n- The configuration schema was extended with `vol.Optional(CONF_DEFAULT_MEASUREMENT): cv.string`.\n- In setup(), the value `default_measurement = conf.get(CONF_DEFAULT_MEASUREMENT)` is read from config.\n- In the event listener, measurement is still first taken from `state.attributes.get('unit_of_measurement')`. If that is None or an empty string, the logic now checks if a default_measurement is configured:\n  - If default_measurement is set, use that string as the measurement name.\n  - If not set, fall back to the previous behavior and use `state.entity_id` as the measurement name to avoid a breaking change.\n\nA new test `test_event_listener_default_measurement` was added in tests/components/test_influxdb.py to verify that:\n- Given a config with `default_measurement: 'state'` and a blacklist that excludes 'fake.blacklisted', events with no unit_of_measurement use 'state' as the measurement name.\n- The measurement's tags still include domain='fake' and entity_id (just the object_id part) as before.\n- Blacklisted entities still do not result in write_points() being called, ensuring the new configuration did not break blacklisting behavior.\n\nThis change resolves the issue by allowing consistent and configurable measurement naming for InfluxDB points when the unit is absent, while keeping existing setups working unchanged if they do not specify default_measurement.",
        "semantic_memory": "When integrating with time-series databases like InfluxDB, the choice of measurement/metric names is important for queryability and data modeling. Using highly granular identifiers (like full entity IDs) as measurement names can fragment data and make cross-entity queries more difficult, especially if domain and entity identifiers are already stored separately as tags.\n\nA good pattern is:\n- Use a stable, semantic measurement name that describes the kind of data (e.g., 'state', 'temperature', 'power').\n- Store variable identifiers like domain, entity_id, or object_id as tags or labels, not as measurement names.\n- Allow users to override naming conventions via configuration rather than hardcoding behavior. This avoids breaking changes and gives flexibility for different data modeling preferences.\n\nFrom a software design standpoint, this PR illustrates several best practices:\n- Introduce new behavior via optional configuration flags to preserve backwards compatibility (e.g., 'default_measurement') rather than changing existing defaults abruptly.\n- Extend configuration schemas with validation (using voluptuous in this case) so that new options are type-checked (strings, ports, etc.).\n- Keep fallback logic explicit and predictable: if new config is absent, fall back to previous behavior.\n- Update tests to cover new configuration branches and ensure that related behavior (e.g., whitelists/blacklists) is not inadvertently broken by the change.\n- For telemetry and logging integrations, design naming and tagging in a way that suits typical query patternsâ€”favor consistent measurement names and leverage tags/labels for dimensions.\n\nThis generalizes to many systems that export metrics: you often want a configurable default metric name, or metric naming strategy, especially when certain attributes (like units) are missing or optional.",
        "procedural_memory": [
            "When diagnosing and improving measurement/metric naming in a time-series or monitoring integration, follow these steps:",
            "Step 1: Identify the symptom.\n- Look at the resulting data in the target system (e.g., InfluxDB). Are there many different measurement names per entity or per attribute? Are queries across entities awkward (e.g., you have to query dozens of measurements instead of one with tags)?\n- For this case, the symptom was that entities without unit_of_measurement produced measurement names equal to their entity_id, leading to inconsistent, entity-specific measurements.",
            "Step 2: Trace where measurement names are generated.\n- Locate the code that constructs the data point payload sent to the external system. For InfluxDB, this is typically where 'measurement', 'tags', 'time', and 'fields' are assembled.\n- Inspect the logic that chooses the measurement name (in this PR: `measurement = state.attributes.get('unit_of_measurement')` then fallback to `state.entity_id`).",
            "Step 3: Decide on a better naming strategy.\n- Determine a semantic, stable default measurement name that better reflects the data (e.g., 'state' for generic entity states).\n- Ensure that domain/object identifiers are already captured as tags or labels so that measurement names do not need to encode them.",
            "Step 4: Add a configuration option for flexibility.\n- Introduce a new configuration key (here: 'default_measurement') instead of hard-coding the new behavior.\n- Update the configuration schema/validation to accept the new option with the correct type (e.g., optional string).",
            "Step 5: Implement fallback logic that preserves existing behavior.\n- Read the new config value during setup (e.g., `default_measurement = conf.get(CONF_DEFAULT_MEASUREMENT)`).\n- In the measurement selection logic:\n  - First, use the primary attribute if present (e.g., unit_of_measurement).\n  - If missing/empty, check if the new config is set; if so, use that.\n  - If not set, fall back to the old behavior (e.g., using entity_id) to avoid breaking existing deployments.",
            "Step 6: Update or add tests for the new behavior.\n- Add tests that:\n  - Configure the integration with the new 'default_measurement' option.\n  - Trigger events that lack unit_of_measurement.\n  - Assert that the measurement name in the payload matches the configured default.\n  - Assert that existing behaviors such as blacklist/whitelist filtering still work.\n- Use mocks to verify that write calls (e.g., InfluxDBClient.write_points) are made with the expected body or not called when they should be blocked.",
            "Step 7: Verify backward compatibility and documentation.\n- Confirm that when 'default_measurement' is not set, the system behaves exactly as before.\n- Update documentation to show the new configuration option with an example (e.g., `default_measurement: 'state'`) and explain when it applies (events without unit_of_measurement).",
            "Step 8: Validate end-to-end in the target system.\n- After deployment, inspect the time-series database or monitoring system to ensure measurements now appear as intended (e.g., one 'state' measurement with tags for each entity) and that existing dashboards/queries still work."
        ]
    }
}
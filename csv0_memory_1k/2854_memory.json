{
    "search_index": {
        "description_for_embedding": "Adds support in napari's action manager for 'hold key to do X' shortcuts using generator-based actions and dedicated hold-shortcut bindings, updates tooltips and settings to distinguish press vs hold actions, and adjusts key-binding handling and tests to correctly execute generator actions on key press and release.",
        "keywords": [
            "napari",
            "action_manager",
            "keyboard shortcuts",
            "hold shortcut",
            "press vs hold",
            "generator function actions",
            "KeymapProvider",
            "key_bindings",
            "qt_viewer",
            "tooltips",
            "shortcuts settings"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The PR addressed how to support actions that are only active while a key is held down (e.g. 'hold Space to pan/zoom') within napari's centralized action manager and shortcut system. Previously, layer key bindings directly used generator functions for 'hold' behavior (code before yield on key press, after yield on key release), but this was not integrated with the action manager, shortcut editing UI, or tooltip generation.\n\nThe developer implemented a prototype where actions can have an alternate 'hold' implementation, typically expressed as a generator function:\n\n    def hold_action(layer):\n        # on key press\n        do_something()\n        yield\n        # on key release\n        undo_something()\n\nKey changes:\n- **ActionManager enhancements**:\n  - Added `self._hold_actions` and `self._hold_shortcuts` dictionaries to store hold-variant actions and their shortcuts.\n  - Extended `register_action(name, command, description, keymapprovider, alternate_hold=None)` to accept an `alternate_hold` callable, which must be a generator function (validated with `inspect.isgeneratorfunction`). The hold action is stored in `_hold_actions`.\n  - Added `bind_hold_shortcut(name, shortcut)` to bind hold-specific shortcuts and update both shortcut bindings and GUI elements.\n  - Updated `_update_shortcut_bindings` to bind press shortcuts to `action.command` and, when present, bind hold shortcuts to the associated hold action via the `KeymapProvider.bind_key` mechanism.\n  - Updated `_update_gui_elements` so that button tooltips show both normal and hold shortcuts, formatted like `(Ctrl-R or hold Space)` using `Shortcut(...).platform` and localized \"hold\" labels.\n  - Tightened `_validate_action_name` to enforce exactly one colon (`'package:name'`) in action names. This fixed a bug where shapes pan/zoom button tooltips were not updated correctly because an extra `napari:` prefix was being used.\n\n- **Layer-level helpers and decorators**:\n  - Updated `register_layer_action(keymapprovider, description, shortcuts=None)` in `layer_utils` so that if the decorated function is a generator, it is treated as a hold action. Specifically, it splits the function into `command` (non-generator) and `alternate_hold` (generator) for `ActionManager.register_action`. It also auto-binds default shortcuts when provided.\n  - Added `register_layer_alternate_hold_action(name, shortcuts=None)` to register a separate hold variant for an existing action. It stores the hold action under `'napari:' + name` in `_hold_actions` and binds hold shortcuts using `bind_hold_shortcut`.\n  - Exposed a `func.hold(shortcut)` helper on actions registered via `register_layer_action` to easily attach hold behavior to an existing action from layer modules.\n\n- **Usage in layers**:\n  - **Shapes layer**: Reworked the shapes pan/zoom and aspect-ratio key bindings. The hold-to-pan/zoom generator was moved to be attached to the `activate_shape_pan_zoom_mode` action using the new `.hold('Space')` mechanism. A separate `hold_to_lock_aspect_ratio` action was registered via `register_shapes_action` and given a default hold shortcut ('Shift').\n  - **Points layer**: The points pan/zoom hold behavior was similarly wired using `register_layer_alternate_hold_action('activate_points_pan_zoom_mode', 'Space')` instead of raw `Points.bind_key('Space')`.\n\n- **Global shortcut settings and UI**:\n  - In `utils/shortcuts.py`, added `default_hold_shortcuts` mapping, e.g. `'napari:hold_to_lock_aspect_ratio': ['Shift']`.\n  - In `settings/_shortcuts.py`, added a `hold_shortcuts` field to `ShortcutsSettings`, with appropriate title and description, so hold shortcuts can be stored alongside normal shortcuts.\n  - In the Qt preferences dialog (`_qt/dialogs/preferences_dialog.py`) and JSON schema form builder, registered a `hold_shortcuts` widget using the same `ShortcutsWidget` as for regular shortcuts to make hold shortcuts editable in the UI.\n  - In `QtViewer._bind_shortcuts`, added logic to read `get_settings().shortcuts.hold_shortcuts` and bind these via `action_manager.bind_hold_shortcut` similar to how normal shortcuts are bound.\n\n- **Key binding engine changes**:\n  - In `key_bindings.py`, the press/release handling for generator-based functions was tightened. On key press, generator actions are advanced once (`next(gen)`), without the previous assertion that forced a single-yield generator. On key release, `_key_release_generators` is checked; if a generator exists for that key, it's advanced once and an assertion ensures that the generator terminates (StopIteration) after the key release step. If it does, the generator is removed from `_key_release_generators`. If the generator yields more than once, an assertion message is raised indicating the extra yield.\n\n- **Testing adaptations**:\n  - `test_viewer.py::_get_all_keybinding_methods` now collects both normal action `command`s and any associated hold actions from `action_manager._hold_actions`, ensuring all bound methods are counted.\n  - The core test `test_add_layer` was updated to handle generator-based keybinding functions. For generator functions, it creates the generator, calls `next(gen)` to simulate key press and `next(gen)` again to simulate key release; it expects `StopIteration` after at most one press and one release (i.e. at most one yield), asserting otherwise. This verifies that hold actions follow the expected generator pattern.\n\nOverall, the PR built a coherent framework for 'hold' behaviors in napari: generator-based hold actions attached to the action manager, persisted and editable hold shortcuts, correct tooltip display for both press and hold shortcuts, and tests and keybinding internals updated to handle the press/release lifecycle of generator actions.",
        "semantic_memory": "This work demonstrates a general pattern for integrating 'press' vs 'hold' keyboard behaviors into an action/shortcut system using generator functions and explicit hold variants:\n\n1. **Generator-based hold actions**: A hold behavior is naturally represented as a generator function: code before the first `yield` runs on key press, and code after the `yield` runs on key release. This provides strong locality: both setup and teardown logic for a temporary mode live in one function, making it easy to reason about the state changes.\n\n2. **Dual action representation (press & hold)**: A single logical action (e.g. 'pan zoom mode') can have two variants:\n   - A normal 'press' action that toggles or switches mode when a key is pressed.\n   - A 'hold' variant that temporarily activates the mode for the key's duration and reverts on release.\n   An action manager can store these separately (e.g. `_actions` vs `_hold_actions`) but conceptually tie them to the same logical action name (`package:action_name`).\n\n3. **Separate bindings for press vs hold shortcuts**: The key mapping system benefits from treating press shortcuts and hold shortcuts as separate classes of bindings. This allows:\n   - Different default shortcuts for press and hold variants.\n   - Independent customization and persistence of both in user settings (`shortcuts` vs `hold_shortcuts`).\n   - Different UI affordances (e.g. tooltips that explicitly say \"hold X\" vs just \"X\").\n\n4. **Centralized registration and decorators**: Abstractions like `register_layer_action` and `register_layer_alternate_hold_action` encapsulate the logic of registering actions, assigning them names, binding shortcuts, and wiring them into the action manager. They can also auto-detect generator functions to categorize them as hold actions, letting layer authors write simple decorators rather than interact with the action manager directly.\n\n5. **Action names as stable identifiers**: Enforcing a consistent naming convention (`'package:name'` with exactly one colon) for actions is important. It ensures stable keys across bindings, tooltips, settings storage, and plugin overrides, and prevents subtle bugs where slightly mismatched names cause GUI elements not to update.\n\n6. **Tooltips as dynamic views of bindings**: Tooltips for UI elements (like mode buttons) should be derived from the action manager's current knowledge of bindings, not hard-coded. When both press and hold shortcuts exist, tooltips should combine them in a human-readable way (e.g. `(Ctrl+R or hold Space)`). This keeps the UI in sync with user-customizable shortcuts.\n\n7. **Testing generator-based input handlers**: When using generator functions to represent multi-phase interactions, tests must simulate the entire lifecycle (press and release) and assert on generator termination behavior. By enforcing that such generators yield at most once (press) and complete at or immediately after release, the system avoids leaking partial state or accumulating stale generators.\n\n8. **Configurable hold behavior**: Persisting hold shortcuts in the same configuration system as regular shortcuts (but in distinct fields) allows users to customize hold semantics without special-case logic. The UI can reuse existing shortcut editor widgets for hold actions, reducing implementation complexity.\n\nThese concepts can be applied to any GUI or interaction framework where there's a need to distinguish between 'tap' and 'hold' behaviors on the same key or button, while keeping configuration centralized, UI tooltips accurate, and interaction logic maintainable.",
        "procedural_memory": [
            "When adding or debugging 'hold key to perform action' behavior in an action/shortcut framework, follow these steps:",
            "Step 1: Model hold behavior with a generator function.",
            "Define the hold action as a generator where code executed on key press goes before the first `yield`, and code to revert the state on key release goes after the `yield`. For example:\n\n    def hold_pan_zoom(layer):\n        prev_mode = layer.mode\n        layer.mode = Mode.PAN_ZOOM  # key press\n        yield\n        layer.mode = prev_mode      # key release\n\nEnsure you have at most one `yield` (one press and one release phase) to avoid ambiguous state and leaks.",
            "Step 2: Extend the action registry to support hold variants.",
            "In your action manager or registry, introduce data structures to store hold actions and hold shortcuts separately from normal actions, e.g. `self._hold_actions: Dict[str, Callable]` and `self._hold_shortcuts: Dict[str, Set[str]]`.\n\nEnhance your `register_action` or equivalent API to accept an optional hold variant (e.g. `alternate_hold`) and validate it as a generator function. Store it under the same logical action name.\n\n    def register_action(name, command, description, keymapprovider, alternate_hold=None):\n        self._actions[name] = Action(command, description, keymapprovider)\n        if alternate_hold is not None:\n            assert isgeneratorfunction(alternate_hold)\n            self._hold_actions[name] = alternate_hold",
            "Step 3: Provide explicit APIs to bind hold shortcuts.",
            "Add a function like `bind_hold_shortcut(name, shortcut)` that associates hold shortcuts with a logical action name and updates both key bindings and GUI elements. For example:\n\n    def bind_hold_shortcut(self, name, shortcut):\n        self._validate_action_name(name)\n        self._hold_shortcuts[name].add(shortcut)\n        self._update_shortcut_bindings(name)\n        self._update_gui_elements(name)\n\nModify your binding logic so that press shortcuts bind the normal command, and hold shortcuts bind the hold generator:\n\n    def _update_shortcut_bindings(self, name):\n        action = self._actions[name]\n        for sc in self._shortcuts.get(name, []):\n            keymapprovider.bind_key(sc, overwrite=True)(action.command)\n        if name in self._hold_actions:\n            for sc in self._hold_shortcuts.get(name, []):\n                keymapprovider.bind_key(sc, overwrite=True)(self._hold_actions[name])",
            "Step 4: Integrate hold shortcuts into settings/configuration.",
            "Extend your settings model to store a mapping of hold shortcuts separate from normal shortcuts (e.g. `hold_shortcuts: Dict[str, List[str]]`). Provide sensible defaults in a module like `shortcuts.py` and register the new field in your preferences schema and Qt/GUI dialog.\n\nAt runtime (e.g. on application startup or preferences change), iterate over `settings.hold_shortcuts` and bind them through the action manager:\n\n    for action, shortcuts in settings.hold_shortcuts.items():\n        action_manager.unbind_shortcut(action)  # if needed\n        for sc in shortcuts:\n            action_manager.bind_hold_shortcut(action, sc)",
            "Step 5: Update UI tooltips to display both press and hold bindings.",
            "Modify UI components (e.g. toolbars, mode buttons) so that their tooltips are derived from the action managerâ€™s state. When generating tooltip text, combine normal shortcuts and hold shortcuts in a clear format, such as:\n\n    '(Ctrl+R or hold Space)'\n\nusing a function like `Shortcut(sc).platform` and localized labels for 'or' and 'hold'. This ensures that when users customize shortcuts, the UI updates automatically.",
            "Step 6: Ensure key press/release handling supports generator actions.",
            "In your key event engine, detect when a key is bound to a generator-based action. On key press, call `next(gen)` to execute the 'press' phase and store the generator in a map keyed by the physical key so you can resume it later.\n\nOn key release, look up the generator and call `next(gen)` again to trigger the 'release' phase, then expect a `StopIteration`. If the generator does not terminate, treat it as an error (e.g. via an assertion) so that developers are alerted to misuse (multiple yields).\n\nExample pattern:\n\n    def press_key(self, key_combo):\n        func = self._keymap[key]\n        if inspect.isgeneratorfunction(func):\n            gen = func()\n            self._key_release_generators[key] = gen\n            try:\n                next(gen)\n            except StopIteration:\n                del self._key_release_generators[key]\n\n    def release_key(self, key_combo):\n        gen = self._key_release_generators.get(key)\n        if not gen:\n            return\n        try:\n            next(gen)\n            assert False, 'Hold generator yielded more than once'\n        except StopIteration:\n            del self._key_release_generators[key]",
            "Step 7: Adjust tests to cover press+hold lifecycle.",
            "Update your tests that enumerate keybinding methods to include both normal and hold actions from the action registry. When testing individual keybinding functions:\n\n- If the function is not a generator, call it normally.\n- If it is a generator, simulate press and release by advancing the generator twice and asserting that it raises `StopIteration` afterward. This ensures that the generator has at most one yield and that both phases run without error.\n\nExample from a test:\n\n    if not isgeneratorfunction(func):\n        func(layer)\n    else:\n        gen = func(layer)\n        try:\n            next(gen)  # press\n            next(gen)  # release\n            assert False, 'More than one yield in hold action'\n        except StopIteration:\n            pass",
            "Step 8: Enforce consistent action naming.",
            "Guard against subtle naming bugs by validating action names. Require a stable `package:name` format and enforce it in a dedicated validator. This avoids mismatches between action names used when binding buttons, shortcuts, and configuration keys (which can otherwise cause UI elements like tooltips not to update)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix race condition in Optuna storage where trial state and values were updated in separate calls, causing inconsistent views across processes (e.g., RUNNING state with non-None values). Introduced a new atomic storage API set_trial_state_values(trial_id, state, values) and deprecated set_trial_state() and set_trial_values(). Updated all storage backends (RDB, Redis, in-memory, cached) and Study.tell() to use the atomic method and maintain temporal fields correctly.",
        "keywords": [
            "Optuna",
            "trial state",
            "trial values",
            "race condition",
            "atomic update",
            "set_trial_state_values",
            "set_trial_state",
            "set_trial_values",
            "Study.tell",
            "BaseStorage",
            "RDBStorage",
            "RedisStorage",
            "InMemoryStorage",
            "CachedStorage",
            "consistency",
            "concurrency bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, a concurrency bug in Optuna's trial storage interface was addressed. Previously, Study.tell() updated a trial's objective values and state with two separate calls:\n\n    if values is not None:\n        self._storage.set_trial_values(trial_id, values)\n    self._storage.set_trial_state(trial_id, state)\n\nWhen multiple processes interacted with the same study (e.g., process A running ask-and-tell and process B reading trials via get_trials()), this led to transient inconsistent views. A reader could observe a trial with state RUNNING and non-None values (after set_trial_values but before set_trial_state), even though the intended invariants were:\n- RUNNING implies values is None\n- COMPLETE implies values is not None\n\nThis inconsistency came from the non-atomic state/values update across processes/storage backends.\n\nThe fix introduces a new atomic storage API, BaseStorage.set_trial_state_values(trial_id, state, values=None) that updates both state and values in a single backend-level operation. The previous methods, set_trial_state() and set_trial_values(), are retained only in backends that need them (RDBStorage, RedisStorage) and are marked as deprecated (planned removal around v5.0.0). InMemoryStorage and _CachedStorage no longer expose these legacy methods.\n\nEach backend implements set_trial_state_values with consistent semantics:\n- Ensure the trial is updatable (raising RuntimeError for finished trials).\n- If values is not None, overwrite existing values.\n- Enforce the RUNNING state transition rule: a trial can be set to RUNNING only from WAITING; otherwise, return False without updating.\n- Update temporal metadata: set datetime_start when transitioning to RUNNING; set datetime_complete when transitioning to a finished state (COMPLETE/PRUNED/FAIL).\n- Maintain cache invariants where applicable (_CachedStorage caches trials when they become RUNNING or finished; RedisStorage updates its heartbeat cache).\n- In RDBStorage, the implementation is done inside a DB transaction with SELECT ... FOR UPDATE and returns False on IntegrityError.\n\nStudy.tell() is updated to call self._storage.set_trial_state_values(trial_id, state, values) in a single finally block, ensuring that observers can no longer see inconsistent combinations of state and values mid-update. Other call sites are similarly updated: popping WAITING trials (_pop_waiting_trial_id), failing stale trials (fail_stale_trials), integration helpers (create_running_trial), and tests that manipulate states/values directly.\n\nNew tests are added for set_trial_state_values to cover:\n- Correct state transitions and datetime_start/datetime_complete behavior.\n- Correct handling of values, including infinite values and sequences.\n- Error and edge conditions: KeyError for missing trials, RuntimeError for finished trials, and no-op/False return for illegal RUNNING transitions.\n\nLegacy tests for set_trial_state and set_trial_values are retained for backends that still implement them but are skipped for InMemoryStorage and _CachedStorage, reflecting their deprecation.",
        "semantic_memory": "This change illustrates a common concurrency and API design lesson: updating logically related fields (like status and result values) via separate operations can introduce race conditions and inconsistent states when the system is accessed concurrently.\n\nGeneralizable concepts and best practices derived from this fix:\n\n1. **Atomic updates for coupled fields**:\n   - When two or more fields represent a single logical transition (e.g., trial state and objective values), updating them in separate operations invites race conditions. Other actors can observe intermediate states that violate invariants.\n   - Introduce atomic operations that update all related fields together. In this case, `set_trial_state_values(trial_id, state, values)` replaces separate `set_trial_state` and `set_trial_values` calls.\n\n2. **Explicit invariants and state machines**:\n   - Clearly defining allowed state transitions helps code correctness: WAITING → ANY; others → {COMPLETE, PRUNED, FAIL, WAITING}, and specifically only WAITING → RUNNING is allowed here.\n   - Encode these rules in the API semantics and enforce them centrally (e.g., only allow RUNNING if current state is WAITING, reject illegal transitions with a boolean result or error).\n\n3. **Consistency across backends**:\n   - When an abstraction (BaseStorage) has multiple implementations (RDB, Redis, in-memory, cached), new APIs should be implemented consistently across all backends: same contract for return values, exceptions, and side effects (timestamps and caching).\n   - This PR ensures that `set_trial_state_values` behaves similarly on all storage backends.\n\n4. **Temporal metadata tied to state transitions**:\n   - Fields like `datetime_start` and `datetime_complete` should be updated exactly when the state machine specifies (e.g., set start time on transition to RUNNING, completion time when transitioning to a finished state). This avoids subtle bugs where timestamps drift from logical states.\n\n5. **Backwards compatibility via deprecation**:\n   - When changing core APIs, keep old methods as thin wrappers or maintain them only where necessary and mark them with explicit deprecation annotations/messages. This allows gradual migration of callers and avoids breaking existing code.\n\n6. **Testing concurrency-sensitive invariants**:\n   - Even in single-threaded unit tests, you can simulate and validate the invariants that matter for concurrency: verifying that certain state-value combinations are impossible or that illegal transitions fail gracefully.\n\n7. **Caching and stateful layers must mirror backend semantics**:\n   - Cached layers (`_CachedStorage`) must update their in-memory representations atomically and in step with backend operations. They should also respect the same update rules and reflect completion (including datetime_complete) consistently.\n\nOverall, this PR shows how to redesign APIs around state changes to be more robust under concurrent usage, by coalescing multiple related operations into a single atomic function and propagating that design consistently through all layers.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify inconsistent observable states.\n- Look for code paths that update logically related fields (e.g., state and values, status and data, flags and counters) in multiple separate storage or network calls.\n- Reproduce or reason through interleavings where other processes/threads can observe intermediate partial updates.\n- Confirm whether those intermediate states violate documented or implied invariants (e.g., RUNNING must not have final values).",
            "Step 2: Define invariants and allowed transitions explicitly.\n- Write down the valid combinations of fields (e.g., {state, values} pairs) and which transitions are allowed (a state machine-style description).\n- Decide on rules like: from which states you can transition to RUNNING, which states are considered finished, and when temporal metadata must be set.",
            "Step 3: Design an atomic API that enforces these invariants.\n- Introduce a new method that updates all coupled fields together, e.g., `set_trial_state_values(trial_id, state, values=None)`.\n- Define its contract clearly: parameters, return value semantics (e.g., bool indicating whether state changed), and exceptions (e.g., RuntimeError for finished entities, KeyError for missing ones).\n- Ensure that the update is atomic at the storage/backend level (e.g., within a DB transaction or a single key update).",
            "Step 4: Implement the atomic API for each backend.\n- For each storage/backend implementation:\n  - Lock or otherwise ensure mutual exclusion if necessary (e.g., DB transaction with SELECT FOR UPDATE, threading locks in in-memory storage, or Redis operations).\n  - Check that the entity is updatable; raise or return appropriate errors for finished/locked states.\n  - Apply the state transition rules (e.g., only allow WAITING → RUNNING; return False otherwise).\n  - Update secondary fields: values (when provided), datetime_start on RUNNING, datetime_complete on finished.\n  - Update any caching layers or heartbeat/state-tracking mechanisms consistently.\n  - Handle backend-specific failure conditions (e.g., IntegrityError in RDB) and map them to the return contract.",
            "Step 5: Migrate existing call sites to the new API.\n- Replace sequences of calls like `set_state(...); set_values(...)` or `set_values(...); set_state(...)` with a single `set_state_values(...)` call.\n- Verify that logical behavior is preserved or improved (i.e., no intermediate inconsistent states can be observed externally).",
            "Step 6: Preserve backward compatibility with deprecation.\n- Keep legacy APIs (e.g., `set_trial_state`, `set_trial_values`) where needed, but decorate them as deprecated and direct users to the new method.\n- Update tests to:\n  - Continue covering legacy methods where they still exist.\n  - Add new tests for the atomic API and skip legacy-related tests on backends that no longer implement them.",
            "Step 7: Add comprehensive tests for the new API.\n- Write tests that verify:\n  - Correct state transitions and that illegal transitions either return False or raise errors as designed.\n  - Timestamps and other derived fields are updated only at the correct times.\n  - Values are set only when allowed and are preserved or overwritten as intended.\n  - Finished entities cannot be modified (state, values, attributes) and raise RuntimeError.\n  - Errors for non-existent IDs (KeyError) are consistent across backends.\n- Include tests for edge values (e.g., infinite numbers) if applicable.\n",
            "Step 8: Review and reason about concurrency.\n- After refactoring, reason through concurrent scenarios again: ask-and-tell in one process and read operations in another.\n- Verify that there is no longer a point where observers can see invalid state-value combinations.\n- If possible, add integration tests that simulate concurrent operations (even if not fully deterministic) to catch regressions.",
            "Step 9: Document the new semantics and migration path.\n- Update internal or public documentation to describe the new atomic API, its guarantees, and recommended usage patterns.\n- Clearly state the deprecation schedule for the old methods and how users should migrate their code."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Yeelight light integration updated to support built-in lighting effects using yeelight 0.3.0. Adds an effect_list, implements set_effect that maps Home Assistant ATTR_EFFECT values to yeelight Flow/transition helpers (disco, police, random loop, etc.), reintroduces the color-mode guard for flash, and ensures flows can be stopped cleanly.",
        "keywords": [
            "homeassistant.components.light.yeelight",
            "Yeelight effects",
            "Flow transitions",
            "ATTR_EFFECT",
            "effect_list",
            "yeelight==0.3.0",
            "lighting effects disco police randomloop slowdown",
            "BulbException handling",
            "flash behavior RGB mode"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Yeelight light platform in Home Assistant was extended to support visual effects using capabilities added in the yeelight Python library v0.3.0.\n\nOriginally, the component only supported basic operations (on/off, brightness, color, color temperature, flash) and had an inlined, very large implementation of effect flows written manually using RGBTransition, TemperatureTransition, SleepTransition, and Flow. This custom code created and controlled effects like Disco, Police, Christmas, and random color loops, as well as a 'Stop' pseudo-effect to cancel running flows. There was also a behavioral change regarding flash: an earlier revision removed the restriction that flash only works in RGB mode, but in the final version this restriction was reinstated to match device limitations.\n\nOnce the upstream yeelight library gained a standardized transitions module (yeelight.transitions) that exposes predefined effect builders (disco, temp, strobe, strobe_color, alarm, police, police2, christmas, rgb, randomloop, slowdown, pulse), the PR was refactored to drop almost all of the inlined effect logic. The Home Assistant integration was updated to:\n\n- Bump the Yeelight dependency from 0.2.2 to 0.3.0 in both homeassistant/components/light/yeelight.py and requirements_all.txt.\n- Declare SUPPORT_EFFECT in the supported features for RGB Yeelight bulbs and introduce ATTR_EFFECT handling.\n- Define a clear list of supported effect names (YEELIGHT_EFFECT_LIST), including Disco, Slow Temp, Strobe epilepsy!, Strobe color, Alarm, Police, Police2, Christmas, RGB, Random Loop, Fast Random Loop, Slowdown, WhatsApp, Facebook, Twitter, and Stop.\n- Expose effect_list on the Yeelight light entity, returning YEELIGHT_EFFECT_LIST so the frontend can show these options.\n- Implement set_effect(effect) that maps each named effect to a Flow instance built from yeelight.transitions helpers. For example: Disco -> Flow(count=0, transitions=disco()), Random Loop -> Flow(count=0, transitions=randomloop()), Fast Random Loop -> Flow(count=0, transitions=randomloop(duration=250)), notification effects (WhatsApp, Facebook, Twitter) -> Flow(count=2, transitions=pulse(r, g, b)). The Stop effect calls self._bulb.stop_flow() and returns without starting a new flow.\n- Ensure errors in starting flows are caught and logged via BulbException.\n- Reinstate the check that flash (ATTR_FLASH) is only used when the bulb color_mode is RGB (color_mode == 1), otherwise log an error and abort the flash.\n- In turn_on(), include ATTR_EFFECT from kwargs and call set_effect(effect) so that selecting an effect from the UI triggers the corresponding Flow.\n\nDuring development, there were intermediate changes like hand-written random loops using Python's random module, switching from randrange to randint, and several large chains of transitions. These were eventually deleted in favor of the new yeelight.transitions-based implementation, simplifying the code and making it align closely with upstream library semantics. A final tweak adjusted how Flow is instantiated with transitions (removing unnecessary trailing commas and ensuring the transitions are passed correctly), addressing issues encountered when passing effect builders as parameters.\n\nThe final result is a cleaner, more maintainable Yeelight platform that exposes a rich set of effects, delegates transition details to the upstream library, and safely handles starting and stopping effect flows.",
        "semantic_memory": "Generalizable lessons from this change involve how to integrate and expose effect-style behaviors in a device integration while relying on an upstream library:\n\n1. **Leverage upstream abstractions instead of inlining complex logic:**\n   - When a device library (like yeelight) offers higher-level abstractions (e.g., transition presets and Flow classes), prefer using those rather than maintaining large, custom effect graphs in the integration code. This reduces duplication, shrinks the code surface, and keeps behavior consistent with upstream.\n   - It also makes it easier to track upstream bug fixes and enhancements since the integration's logic is thin and declarative (mapping names to upstream calls).\n\n2. **Expose effect capabilities cleanly via an effect list and ATTR_EFFECT:**\n   - For UI-driven systems such as Home Assistant, implementing an `effect_list` property and supporting `ATTR_EFFECT` in `turn_on` is a clean pattern. It allows the frontend to query available effects and send effect names back without coupling the UI to specific library calls.\n   - Keeping the list of supported effect names centralized (e.g., `YEELIGHT_EFFECT_LIST`) ensures consistency and makes it easy to add/remove effects.\n\n3. **Guard feature usage with device capabilities:**\n   - Some behaviors, like flashing or certain color effects, only work in specific device modes (e.g., RGB vs. white). The component reinstated a check that flash is only used when `color_mode == 1` (RGB), logging an explicit error otherwise. This pattern prevents user confusion and avoids silent no-ops or cryptic failures.\n\n4. **Provide a dedicated way to stop ongoing effects:**\n   - Long-running flows or animations need a clear cancellation mechanism. Representing 'Stop' as a special effect that calls `stop_flow()` is a simple way to expose this to users and automations.\n   - More broadly: any time you start a long-running stateful process on a device (animations, scenes, loops), design a symmetric stop/reset capability.\n\n5. **Error handling when interacting with hardware:**\n   - Wrapping hardware calls (like starting flows) in a decorator (`_cmd`) or try/except bloc that catches library-specific exceptions (e.g., `BulbException`) and logs context-appropriate errors is essential. This avoids integration crashes from intermittent network or device issues.\n\n6. **Keep dependencies and generated requirement files in sync:**\n   - When relying on new features of a third-party library, always bump the version pin in both the component-level `REQUIREMENTS` and any global `requirements_all.txt`, and regenerate or update them as needed. Consumers must install the correct version to avoid runtime attribute/method errors.\n\n7. **Mapping human-readable effect names to code-level behaviors:**\n   - The integration uses simple string constants (\"Disco\", \"Police\", etc.) to represent effects in the UI and maps them to yeelight.transition helper functions. This string-to-behavior mapping pattern is a reusable approach in other integrations where user-friendly naming is required.\n\nOverall, the change demonstrates a pattern of refactoring from custom, tightly-coupled logic to a thin adapter over a feature-rich upstream library, while exposing clear capabilities (effect_list) and ensuring robust user-facing behavior (mode checks, ability to stop effects).",
        "procedural_memory": [
            "When adding or fixing support for device effects (animations, flows) in an integration, follow these steps:",
            "Step 1: Check and update the upstream library dependency",
            "- Review the device's Python (or other) library to see if it already supports the desired effects or transitions in a structured way (e.g., helper functions, classes like Flow).",
            "- If new capabilities are only available in a newer library version, bump the pinned version in the integration's `REQUIREMENTS` and any global requirements (such as `requirements_all.txt`).",
            "- Run dependency generation scripts or tests to ensure the new version is installed in CI and packaged environments.",
            "",
            "Step 2: Define supported effect names and expose them via the entity interface",
            "- Create constants for each effect name you want to expose (e.g., EFFECT_DISCO = \"Disco\").",
            "- Assemble them into a list (e.g., `YEELIGHT_EFFECT_LIST`) and return that list in the entity's `effect_list` property.",
            "- This ensures the UI (or API consumers) can discover available effects dynamically.",
            "",
            "Step 3: Wire the effect attribute into the control path",
            "- In your entity's control method (e.g., `turn_on` for a light), read the effect from kwargs (e.g., `effect = kwargs.get(ATTR_EFFECT)`).",
            "- After handling basic properties (brightness, color, color temperature, flash), call a dedicated method like `set_effect(effect)` to apply the effect.",
            "- Ensure applying effects is optional and does not break existing behavior when no effect is provided.",
            "",
            "Step 4: Implement a robust effect dispatcher",
            "- Write `set_effect(self, effect)` to map effect names to specific library calls.",
            "- Use clear conditional blocks or a dispatch table (dictionary) to map strings like \"Disco\" to library helpers (e.g., `Flow(count=0, transitions=disco())`).",
            "- Include a special case like \"Stop\" that cancels ongoing effects (`self._bulb.stop_flow()`) and returns early.",
            "- Wrap calls to device methods (like `start_flow`) in try/except around library-specific exceptions (e.g., `BulbException`) and log meaningful errors without propagating exceptions to the caller.",
            "",
            "Step 5: Respect device constraints and modes",
            "- Identify which features require specific modes or capabilities (e.g., flashing only works in RGB color mode).",
            "- Before invoking such features, check the device state (e.g., `self._bulb.last_properties[\"color_mode\"]`). If the constraint is not satisfied, log a clear error and avoid calling the unsupported operation.",
            "- This prevents subtle bugs where user actions appear to do nothing or cause obscure device errors.",
            "",
            "Step 6: Remove duplicated or obsolete custom effect code",
            "- If earlier versions of the integration inlined custom transitions (manually building lists of RGBTransition/SleepTransition), replace these with calls to the upstream library's standardized transitions module when available.",
            "- Delete the now-redundant large effect-building blocks to reduce maintenance cost.",
            "- Keep the mapping from effect names to behaviors as thin as possible: ideally just passing through to the library.",
            "",
            "Step 7: Test flows and stopping behavior end-to-end",
            "- Manually or via automated tests, cycle through each effect to ensure it triggers the expected visual behavior on the device without errors.",
            "- Test the Stop effect to verify ongoing flows are actually cancelled (no residual animations).",
            "- Test mode-dependent features (e.g., flash in non-RGB mode) to confirm the integration logs appropriate error messages and does not crash.",
            "",
            "Step 8: Ensure style and parameter usage matches the library API",
            "- Verify how the upstream Flow/transition constructors accept arguments (keyword vs positional, expected types, varargs).",
            "- Adjust your calls accordingly (e.g., `Flow(count=0, transitions=disco())` if the library expects a `transitions` keyword, or `Flow(count=0, *disco())` if it expects varargs).",
            "- Remove superfluous commas or incorrect keyword names that could lead to runtime TypeError, and re-run tests.",
            "",
            "Following these steps will help you reliably add or repair effect support in device integrations, keep your code aligned with upstream libraries, and ensure users have a predictable, discoverable set of effects with clear stop/cancel semantics."
        ]
    }
}
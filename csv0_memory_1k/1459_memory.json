{
    "search_index": {
        "description_for_embedding": "Introduced an ApiWrapper around PGoApi to robustly handle connection and login issues. The wrapper centralizes auth reset, validates that requests are set and the user is logged in before calling, and retries failed API calls (when result is None) with a configurable max_retry and short sleeps between attempts. This prevents obscure downstream errors like '__getitem__ on bool' caused by None responses and missing request methods.",
        "keywords": [
            "ApiWrapper",
            "PGoApi",
            "connection issues",
            "retry logic",
            "None response",
            "not logged in",
            "ServerBusyOrOfflineException",
            "human_behaviour.sleep",
            "PokemonGoBot",
            "api_endpoint reset",
            "__getitem__ on bool",
            "wrapper pattern",
            "request method list validation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the bot was experiencing unreliable behavior and confusing errors (e.g., '__getitem__ on bool') when the underlying PGoApi connection was unstable or when calls were made in an invalid state. The root issues were: (1) API calls sometimes returned None when the server was busy or offline, and the rest of the code did not handle that case, and (2) calls could be made without any request methods queued, or while not actually logged in, leading to inconsistent internal state and misleading exceptions.\n\nTo address this, a new ApiWrapper class was introduced in pokemongo_bot/api_wrapper.py and wired into PokemonGoBot by replacing the direct PGoApi usage with ApiWrapper(PGoApi()). The wrapper centralizes and hardens several aspects:\n\n- Authentication reset: Previously, login() in PokemonGoBot manually set _auth_token, _auth_provider, and _api_endpoint on the PGoApi instance. This was moved into ApiWrapper.reset_auth(), and PokemonGoBot.login() now calls self.api.reset_auth() instead of touching internal fields directly.\n\n- Pre-call validation: The wrapper defines _can_call(), which checks that _req_method_list exists and is non-empty before a call, raising a clear RuntimeError if a call is attempted with no queued requests. It also verifies that an auth provider is configured and is logged in (via is_login()); otherwise, it logs 'Not logged in!' and raises NotLoggedInException. This avoids calling the API in an invalid state.\n\n- Retry logic on call failure: ApiWrapper.call(max_retry=5) wraps the underlying _api.call(). It caches the original _req_method_list before the first call and, within a loop, reassigns a fresh copy of that list on each retry (because PGoApi clears _req_method_list internally after a call). If the API call returns None, it is interpreted as a transient server issue. The wrapper logs 'Server seems to be busy or offline - try again - {try_cnt}/{max_retry}' in red, sleeps a short period (1 second via human_behaviour.sleep), and retries until max_retry is reached. After exceeding max_retry, it raises ServerBusyOrOfflineException, instead of letting downstream code operate on invalid data.\n\nAdditionally, minor refinements were made: the length check for _req_method_list was tightened (`if not self._api._req_method_list or len(self._api._req_method_list) == 0`), and the retry count was exposed as an optional argument to call(max_retry=5), making it configurable. Non-special methods fall back to the underlying API via __getattr__, while login is explicitly forwarded.\n\nOverall, the fix moved from ad-hoc, fragile handling of the API state to a dedicated wrapper that validates preconditions, retries transient failures, and surfaces clearer errors when conditions aren’t met.",
        "semantic_memory": "This change illustrates several generalizable best practices for interacting with flaky or stateful external APIs:\n\n1. **Encapsulate external API access in a wrapper**: Instead of letting the rest of the codebase touch low-level internal fields (_auth_token, _req_method_list, etc.), create a dedicated wrapper object. The wrapper becomes the single place to enforce preconditions, manage retries, and handle edge cases. This reduces duplication and the risk of inconsistent behavior across the codebase.\n\n2. **Validate preconditions before calling external services**: Before invoking an API call, confirm that all necessary state is present and valid (e.g., there is at least one request queued, the client is authenticated, endpoints are set). Fail fast with clear, descriptive exceptions when these preconditions are violated rather than letting cryptic downstream errors occur.\n\n3. **Treat None or malformed responses as explicit failure modes**: When the underlying client returns None or otherwise indicates a transport issue (server busy, offline, etc.), handle it explicitly—either by retrying with backoff or by raising a specific, meaningful exception. This prevents subtle bugs where the rest of the system assumes a valid response and later crashes with confusing errors such as type mismatches or attribute errors.\n\n4. **Implement retry logic with state restoration**: If the API client mutates its internal state (such as clearing a request list) as part of a call, retries must rebuild or restore that state before each attempt. A naïve retry loop that calls the same method repeatedly without restoring this state will silently do nothing or behave incorrectly. Copying or reconstructing the request payload for each retry is a robust approach.\n\n5. **Centralize authentication reset and lifecycle management**: Resetting auth tokens, providers, or endpoints should be encapsulated in a method (e.g., reset_auth()) within the wrapper or client, not scattered around the code. This makes it easier to reason about the client’s lifecycle, update the logic in one place, and avoid subtle inconsistencies in auth handling.\n\n6. **Provide configurable retry behavior**: Exposing parameters like max_retry (and potentially delay/backoff strategy) allows callers to tune resilience vs. latency trade-offs per use case without duplicating retry logic.\n\n7. **Use clear, domain-specific exceptions**: Raising specific exceptions like NotLoggedInException or ServerBusyOrOfflineException makes it easier for higher-level code to react appropriately (e.g., re-login, pause the bot, notify the user) rather than having to infer meaning from generic errors.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms of unreliable API interaction.\n- Look for sporadic failures, inconsistent behavior, or confusing downstream errors (e.g., '__getitem__ on bool', AttributeError on unexpected types).\n- Check whether these errors correlate with network instability, server downtime, or authentication problems.\n- Inspect logs or add logging around API calls to see if responses are None or contain error flags.",
            "Step 2: Inspect the API client’s state and call semantics.\n- Read the API client’s code or documentation to understand how calls are made, what internal fields it uses (e.g., _req_method_list), and what they represent.\n- Determine whether the client clears or mutates internal state (such as request lists) after each call.\n- Identify how authentication is tracked (tokens, providers, login state) and how failures are signaled (return values, exceptions).",
            "Step 3: Introduce a dedicated wrapper for the external API.\n- Create a wrapper class (e.g., ApiWrapper) that holds a reference to the underlying API client.\n- Move all direct uses of the client in higher-level code to go through this wrapper.\n- In the wrapper, provide methods for lifecycle management (e.g., reset_auth, login) and a unified call method that you control.",
            "Step 4: Enforce preconditions before calling.\n- Implement a helper (e.g., _can_call) that checks crucial preconditions such as:\n  - There are queued requests or parameters to send (non-empty request list).\n  - The client is authentically logged in (auth provider present and is_login() is true).\n- If preconditions fail, log a clear message and raise domain-specific exceptions (e.g., NotLoggedInException) rather than allowing the call to proceed.",
            "Step 5: Implement robust retry logic around API calls.\n- In the wrapper’s call method, accept a configurable max_retry parameter.\n- Before the first call, capture or clone the necessary state that the API mutates during a call (e.g., copy of the request method list or request payload).\n- In a loop:\n  - Restore or clone the captured state into the client before each attempt.\n  - Call the underlying client’s call().\n  - If the response is None or indicates a transient failure, log a concise message including the current retry count.\n  - Sleep for a short interval (possibly configurable) between retries to avoid hammering the server.\n  - Break the loop on a valid response.\n- If the number of attempts reaches max_retry without success, raise a specific exception (e.g., ServerBusyOrOfflineException) and let callers handle it.",
            "Step 6: Replace scattered low-level manipulations with wrapper methods.\n- Remove direct assignments to the API client’s internal fields (e.g., _auth_token, _api_endpoint) from higher-level modules.\n- Expose high-level methods on the wrapper (e.g., reset_auth, login, set_position) for all legitimate manipulations.\n- For any other methods not explicitly wrapped, provide a __getattr__ fallback to delegate to the underlying client, keeping the surface area flexible but still enforcing critical logic in your wrapper.",
            "Step 7: Add logging and configuration hooks.\n- Log meaningful messages around failures and retries, including retry counts and reasons.\n- Make key parameters (max_retry, delay between retries, maybe backoff strategy) configurable via arguments or configuration files, so behavior can be tuned without code changes.",
            "Step 8: Test under simulated failure conditions.\n- Simulate server downtime or force the underlying client to return None or raise connection-related errors.\n- Verify that:\n  - The wrapper retries as expected and restores the request payload each time.\n  - The correct exceptions are raised when max_retry is exceeded.\n  - No downstream code sees misleading types or None where a valid response is expected.\n- Also test the behavior when calling without requests or without being logged in, confirming that clear exceptions are raised early.",
            "Step 9: Roll out and monitor.\n- Deploy the wrapper-based solution.\n- Monitor logs and runtime behavior for improvements in error clarity and robustness.\n- Iterate on retry counts and sleep durations as needed based on real-world server behavior."
        ]
    }
}
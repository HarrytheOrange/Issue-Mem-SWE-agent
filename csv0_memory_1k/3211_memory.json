{
    "search_index": {
        "description_for_embedding": "Home Assistant D-Link W215 smart plug switch integration updated to expose device state attributes (power usage, total consumption, temperature) and to support older firmware versions by upgrading the pyW215 library and adding a use_legacy_protocol configuration flag. Fixes internal errors with early firmware/HA versions and aligns temperature with HA’s unit system.",
        "keywords": [
            "homeassistant",
            "dlink",
            "smart plug",
            "W215",
            "pyW215",
            "legacy firmware support",
            "device_state_attributes",
            "temperature unit conversion",
            "integration bug",
            "external library upgrade",
            "requirements_all.txt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Home Assistant D-Link W215 smart plug switch component was improved to both expose richer device state and fix compatibility issues with older firmware. Previously, the integration did not publish useful attributes like current power consumption, total energy used, or temperature, and it relied on an older pyW215 (v0.1.1) library that had internal issues and did not work well with early Home Assistant versions and older plug firmware.\n\nThe fix involved several coordinated changes:\n1. **Library upgrade and legacy support**: The component’s REQUIREMENTS and requirements_all.txt entries were updated from pyW215 v0.1.1 to v0.3.4, which includes improved support for both v1.x and v2.x firmware and internal error fixes. A new configuration option `use_legacy_protocol` (default False) was added to the platform schema and passed into the `SmartPlug` constructor: `SmartPlug(host, password, username, use_legacy_protocol)`. This allows users with older firmware to opt into the legacy communication protocol supported by the updated library.\n\n2. **Device state attributes**: The `SmartPlugSwitch` class was modified to take `hass` in its constructor so it can access `hass.config.units`. A new `device_state_attributes` property was added to expose:\n   - `Current Consumption` (formatted as \"<value> W\"),\n   - `Total Consumption` (formatted as \"<value> W\"),\n   - `Temperature` (converted from the plug’s Celsius reading to the user’s configured temperature unit and formatted as a string with the unit).\n   The temperature is converted via `self.units.temperature(int(self.smartplug.temperature), TEMP_CELSIUS)` and then combined with `self.units.temperature_unit` for display. These attributes provide sensor-like data directly on the switch entity state.\n\n3. **Integration wiring**: The platform setup now constructs the switch as `SmartPlugSwitch(hass, SmartPlug(...), name)` so that the switch has access to the global unit system.\n\nThis change was tested against both v1.x and v2.x firmware using the new pyW215 library; the contributor confirmed that the legacy protocol flag and temperature conversion worked correctly against Home Assistant’s dev branch. As a result, the D-Link W215 integration now works with legacy firmware, is less error-prone, and provides richer telemetry to users.",
        "semantic_memory": "This case demonstrates several generalizable integration and maintenance practices for home automation components and external-library-based integrations:\n\n1. **Use external libraries as the protocol abstraction layer**: For vendor-specific devices (like D-Link smart plugs), rely on a dedicated Python library (pyW215) to encapsulate protocol details and firmware quirks. When compatibility issues arise (e.g., older firmware breaking the integration), first look to improve or upgrade that library rather than pushing protocol-specific hacks into the Home Assistant component.\n\n2. **Backwards compatibility via feature flags**: When adding support for legacy or nonstandard device behaviors, introduce a clear configuration flag (e.g., `use_legacy_protocol`) rather than guessing protocols automatically. This keeps the default path clean and modern while providing an explicit escape hatch for legacy users.\n\n3. **Propagate configuration through constructors**: If lower-level objects (e.g., SmartPlug) need to know about configuration choices such as protocol versions, pass those flags at construction time and capture them in the API layer. This keeps logic cohesive and avoids global state or hidden side effects.\n\n4. **Expose richer device metadata as attributes**: For entities that inherently measure more than just on/off state, provide additional device state attributes (current consumption, total consumption, temperature). This allows automations, dashboards, and analytics to leverage more of the device’s capabilities without requiring separate sensors.\n\n5. **Respect the host application’s unit system**: Always convert raw device readings into the application’s configured units (e.g., HA’s `hass.config.units`). This provides a consistent UX regardless of device firmware assumptions (Celsius-only, etc.) and centralizes unit management.\n\n6. **Align integration versions with global dependency lists**: When upgrading a component’s `REQUIREMENTS` to a new library version, mirror that change in the global `requirements_all.txt` or equivalent. This prevents version skew between development and packaging environments.\n\n7. **Real-device testing across firmware versions**: For hardware integrations, it’s critical to test on multiple firmware versions (e.g., v1.x and v2.x) to validate that new library versions and flags actually achieve cross-version compatibility and do not regress newer devices.",
        "procedural_memory": [
            "When an integration for a hardware device fails on certain firmware versions or lacks important telemetry, follow these steps:",
            "Step 1: Reproduce and characterize the issue",
            "- Confirm the specific device model and firmware versions affected (e.g., D-Link W215 v1.x vs v2.x).",
            "- Capture error logs from the integration (tracebacks, protocol errors, or missing attributes).",
            "- Identify whether failures occur only on older firmware or across all versions.",
            "",
            "Step 2: Inspect and update the external library",
            "- Locate the underlying Python library used to talk to the device (e.g., pyW215).",
            "- Check the library’s repository for newer releases, bug fixes, or explicit legacy support.",
            "- Upgrade the integration’s dependency declaration (e.g., REQUIREMENTS and requirements_all.txt) to a version that includes necessary fixes or legacy support.",
            "- If needed, contribute or pull in upstream changes that add support for older firmware/variants.",
            "",
            "Step 3: Add explicit configuration for legacy behavior",
            "- Introduce a clear configuration option (e.g., `use_legacy_protocol`) in the platform schema, with a sensible default (usually False).",
            "- Validate inputs using the framework’s config validation utilities (e.g., `cv.boolean`).",
            "- Thread this option through the integration so it reaches the device client constructor (e.g., `SmartPlug(host, password, username, use_legacy_protocol)`).",
            "- Use this flag within the library or device client to select the appropriate protocol variant or compatibility mode.",
            "",
            "Step 4: Expose additional device state attributes",
            "- Identify what telemetry the library can provide (e.g., temperature, current consumption, total consumption).",
            "- Implement the framework’s mechanism to publish those values as entity attributes (e.g., `device_state_attributes` in Home Assistant).",
            "- Prefer structured attributes (typed values) but if the ecosystem expects display strings, format them consistently (e.g., \"<value> W\" for power).",
            "",
            "Step 5: Respect global unit configuration",
            "- Ensure the entity has access to the application’s unit system (e.g., accept `hass` in the entity’s constructor).",
            "- Convert raw device readings into the user’s configured units with the framework’s helpers (`hass.config.units.temperature(value, TEMP_CELSIUS)`).",
            "- Append or otherwise expose the unit symbol (`units.temperature_unit`) alongside the value.",
            "",
            "Step 6: Keep dependency declarations consistent",
            "- After updating a component’s `REQUIREMENTS`, also update the centralized dependency manifest (`requirements_all.txt` or equivalent).",
            "- Verify that local development, CI, and release builds all install the same library version.",
            "",
            "Step 7: Test across firmware versions and document behavior",
            "- Test the updated integration against multiple firmware versions and, if applicable, both with and without the legacy flag enabled.",
            "- Confirm that no regressions occur on newer firmware while legacy devices now function correctly.",
            "- Update documentation to describe the new configuration option (`use_legacy_protocol`), the added attributes, and any caveats for legacy hardware.",
            "",
            "Step 8: Monitor and iterate",
            "- After release, watch for new issues involving the integration to ensure that the library upgrade and legacy support behave as expected.",
            "- If additional firmware-specific quirks surface, prefer extending the library and configuration flags over ad-hoc workarounds in the integration code."
        ]
    }
}
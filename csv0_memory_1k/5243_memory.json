{
    "search_index": {
        "description_for_embedding": "Heartbeat API calls were previously triggered from various movement and pause tasks, which coupled location changes (e.g., sniping teleports) with automatic heartbeats that include device/location data. This PR decouples the heartbeat into a timer-based background process starting on login, and introduces an hb_locked flag to temporarily disable heartbeats during sniping teleports so that spoofed locations are not sent inadvertently.",
        "keywords": [
            "heartbeat decoupled from tasks",
            "timer-based heartbeat",
            "location spoofing",
            "sniping teleport",
            "hb_locked flag",
            "background job",
            "PokemonGo-Bot",
            "get_map_objects in heartbeat",
            "API request location data",
            "avoid heartbeat during teleport"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the bot’s heartbeat mechanism was tightly coupled to various task flows, such as walking (step_walker), random_alive_pause, and sniping (move_to_map_pokemon). These tasks explicitly called bot.heartbeat(), which caused issues when sniping: the sniper temporarily teleports the bot to a remote location to catch a Pokémon. Since all API requests, including heartbeats, contain device and location info, triggering heartbeats during these teleports could leak inconsistent or suspicious location data. Additionally, heartbeats were not managed as a centralized, periodic process and instead depended on disparate parts of the task code calling them.\n\nThe fix introduces two major changes:\n1. **Decoupled, periodic heartbeat**: The bot now starts the heartbeat process right after a successful login by calling self.heartbeat() inside login(). Inside heartbeat(), after processing fort timeouts and possibly sending the heartbeat request, it schedules itself again using threading.Timer(self.heartbeat_threshold, self.heartbeat).start(). This makes heartbeat a periodic background task controlled by a single timing mechanism, rather than being triggered ad hoc by callers.\n2. **Lock to suppress heartbeat during sniping**: A new flag, self.hb_locked, is added to the bot instance and initialized to False. The heartbeat method now checks both the time threshold and the lock: only if (now - last_heartbeat >= heartbeat_threshold) and not hb_locked will it send a heartbeat request. In move_to_map_pokemon.snipe(), the code sets bot.hb_locked = True before teleporting to the sniping location and bot.hb_locked = False after teleporting back and resetting the position. This prevents heartbeats that would expose the temporary teleport coordinates.\n\nAlong with this, explicit calls to bot.heartbeat() were removed from step_walker.step, random_alive_pause._sleep, and move_to_map_pokemon.snipe(), since the heartbeat is now centrally managed. The result is a cleaner, more predictable heartbeat mechanism that runs on a fixed interval and can be disabled during sensitive operations like location spoofing.",
        "semantic_memory": "This fix illustrates several generalizable design lessons about background tasks and side-effectful API calls:\n\n1. **Decouple periodic infrastructure from business logic**: Heartbeats, metrics, and other periodic operations should be managed by a central scheduler or timer, not scattered across unrelated tasks. When every task triggers its own heartbeat, the behavior becomes hard to reason about, and changes in one task can inadvertently alter global timing.\n\n2. **Avoid coupling sensitive global state (like location) to opportunistic calls**: When API calls implicitly carry critical data (location, device fingerprints, auth info), tying those calls directly to operational steps like movement can leak inconsistent or suspicious patterns. A location-aware global operation like heartbeat should have a clearly defined timing and be suppressible when the system temporarily violates normal invariants (e.g., teleports used for sniping).\n\n3. **Use explicit locks/flags to guard global side effects**: Introducing a simple lock flag (hb_locked) provides a clear, centralized control surface to suspend a global background job during critical sequences. This pattern applies broadly: for any background process that must not run during certain operations (database migrations, state rewrites, mock/test modes), a scoped lock can avoid races and unintended side effects.\n\n4. **Schedule recurring work inside the worker itself**: By using threading.Timer inside heartbeat, the code ensures that the recurrence logic lives with the operation. This reduces the risk that callers forget to reschedule and keeps the lifecycle of the periodic task predictable. A more general pattern is to encapsulate all scheduling concerns within the service implementing the periodic behavior.\n\n5. **Remove redundant or obsolete direct calls after centralization**: Once a behavior is centralized (like heartbeat), lingering direct invocations from old call sites can cause doubled frequency, inconsistent state, or unexpected side effects. A thorough cleanup of those calls is part of the refactoring, not an optional step.\n\nThese ideas apply to any system that has recurring background tasks, especially when those tasks carry sensitive or globally meaningful context (location, security tokens, global caches).",
        "procedural_memory": [
            "When diagnosing issues with periodic or global background operations that are triggered from scattered tasks, follow this approach:",
            "Step 1: Identify all call sites of the global operation (e.g., heartbeat, metrics push, cache refresh) across the codebase. Look for calls from task flows, workers, and event handlers.",
            "Step 2: Analyze what side effects accompany that operation (e.g., it sends location data, updates timeouts, renews tokens). Determine whether those side effects are safe at every call site and in every state.",
            "Step 3: Look for problematic sequences where the operation is invoked during unusual or sensitive state transitions (e.g., temporary teleports, test modes, maintenance states). Reproduce the issue and confirm that the operation is indeed firing at those times.",
            "Step 4: Design a centralized execution model for the operation. For periodic tasks, this usually means a timer, scheduler, or loop that triggers the operation based solely on time or explicit scheduling, not on incidental task activity.",
            "Step 5: Implement the central mechanism. For example, trigger the operation once at a stable lifecycle point (like on login or application start), and then schedule recurrent execution from inside the operation using a timer or a recurring job scheduler.",
            "Step 6: Introduce a guard mechanism to disable the operation during critical sequences. This can be a simple boolean flag (e.g., hb_locked), a context manager, or a more formal state machine. Ensure the operation checks this guard before performing side effects.",
            "Step 7: Update sensitive workflows to use the guard. Around critical operations (like teleport-based sniping), set the lock/flag before the sensitive section and unset it afterward. Ensure these sections handle exceptions so that the flag is reliably reset.",
            "Step 8: Remove obsolete direct calls. Once the operation is centrally scheduled, delete the ad hoc invocations from movement, pause, or other tasks that previously triggered it. This avoids double execution and conflicting timing.",
            "Step 9: Add or update tests. Test that the operation runs periodically as expected, that it is suppressed when the lock is active, and that critical workflows (e.g., sniping) do not generate undesired calls during their sensitive phases.",
            "Step 10: Monitor behavior in real runs. Confirm that global state (e.g., last heartbeat timestamps, timeouts lists, server responses) remains consistent, and that no unexpected side effects occur when entering and exiting the guarded operations."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fix AsusWRT SSH device tracker failing after router restart due to pxssh AssertionError and stale connection object. The change catches AssertionError from pxssh login/commands, cleans up the SSH session, and recreates the pxssh instance on each connect/disconnect cycle to avoid invalid internal state.",
        "keywords": [
            "AsusWRT",
            "device_tracker",
            "pxssh",
            "pexpect",
            "AssertionError",
            "SSH reconnect",
            "router restart",
            "connection lifecycle",
            "homeassistant.components.device_tracker.asuswrt",
            "unexpected SSH error"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant AsusWRT device_tracker component, users reported that after an Asus router was restarted, the integration stopped reconnecting properly and the logs were flooded with stack traces. During router downtime, pxssh (from pexpect) raised an AssertionError instead of a typical SSH exception when login or command execution failed. This AssertionError propagated upward, resulting in noisy tracebacks and leaving the pxssh.pxssh object in a broken state. Subsequent reconnect attempts reused the same pxssh instance, which was now in an unusable or 'weird' internal state, preventing successful reconnection once the router was back online.\n\nThe fix had two parts:\n1. Error handling: In SshConnection.get_result(), the code was extended to catch AssertionError in addition to existing pxssh and generic Exception handlers. On AssertionError, it now logs a clear message (\"Connection to router unavailable: <err>\") and calls disconnect(), returning None. This prevents raw AssertionError tracebacks from polluting the logs.\n2. Connection lifecycle: The pxssh instance is no longer created in SshConnection.__init__. Instead, self._ssh is initialized to None. In SshConnection.connect(), pxssh.pxssh() is created each time a connection is initiated, and the login is performed using either an SSH key or password. In SshConnection.disconnect(), the code attempts to logout and, in a finally block, always sets self._ssh = None before calling the base disconnect. This ensures that each connect attempt uses a fresh pxssh object and that any broken state caused by failed connections or router restarts is discarded.\n\nAfter these changes, the component can recover from router restarts: failed attempts during downtime are handled gracefully, logs are cleaner, and once the router is back, the device tracker reconnects successfully using a newly created pxssh instance.",
        "semantic_memory": "This incident illustrates several generalizable patterns and best practices around managing external connection libraries and handling non-standard exceptions:\n\n1. **Do not assume external libraries will only raise documented exceptions.** Libraries like pxssh/pexpect may raise AssertionError or other unexpected exceptions when they encounter internal inconsistencies or edge cases (e.g., abrupt network disconnects, device reboots). Robust code should catch and handle such cases at a boundary layer, translating them into meaningful log messages and safe failure modes.\n\n2. **Treat connection/session objects as disposable resources.** Long-lived connection objects (SSH sessions, DB connections, sockets) can enter an invalid or undefined state after errors, timeouts, or remote endpoint restarts. Reusing such objects can cause subtle, persistent bugs. It is often safer to destroy and recreate the connection object on each (re)connect attempt, especially after failures.\n\n3. **Enforce a clear connection lifecycle (init → connect → use → disconnect → reset).** The object should start without an active connection, create a session on connect(), use it within a controlled scope, and fully tear it down on disconnect(), including clearing internal references. This avoids accidental reuse of stale sessions and simplifies reasoning about validity.\n\n4. **Fail gracefully with meaningful logging instead of propagating raw internal errors.** Instead of letting AssertionError bubble up and clutter logs with stack traces, handle it at the integration boundary and log a concise, user-facing message (e.g., \"Connection to router unavailable\"). This improves observability and user experience without hiding the fact that something went wrong.\n\n5. **Lazy initialization and cleanup improve robustness.** Delaying creation of heavy or fragile objects (like SSH sessions) until they are actually needed, and explicitly nulling them out on teardown, both reduce the chance of interacting with objects that are partially constructed, partially torn down, or in an inconsistent state.\n\n6. **Network instability and device restarts should be first-class scenarios.** For networked integrations (routers, IoT devices, etc.), assume the remote device may reboot or vanish temporarily. Integration code must be designed to handle repeated connection failures and eventual recovery, rather than assuming a stable, long-lived session.\n",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and observe the symptoms\n- Trigger a network or device restart (e.g., reboot the router or remote server) while your integration or service is actively connected.\n- Observe what happens during the downtime and after the device comes back online.\n- Look for repeated exceptions (especially AssertionError or unexpected exceptions) and determine whether the system successfully reconnects afterward.\n",
            "Step 2: Inspect logs and stack traces\n- Examine the logs around the time of failure to identify the exact exception types and call sites.\n- Pay special attention to AssertionError or other unexpected exceptions coming from third-party libraries (e.g., pxssh, DB drivers, HTTP clients).\n- Determine whether these exceptions are being handled or are propagating to the top-level, causing noisy tracebacks or crashes.\n",
            "Step 3: Analyze connection object lifecycle\n- Locate the code managing the external connection/session (e.g., SSH client, database connection, message queue client).\n- Check where the connection object is created (constructor vs. connect method) and how long it is kept alive.\n- Verify if the same object is reused across multiple connect/disconnect cycles or after exceptions.\n- Look for any code paths where the connection might be left in an inconsistent state (half-open, partially closed, or not reset after errors).\n",
            "Step 4: Add robust exception handling at the boundary\n- In the method(s) that execute commands or perform I/O over the connection (e.g., get_result), add specific exception handlers for the known library exceptions, plus a catch for AssertionError or other unexpected errors.\n- On these exceptions, log a clear, user-oriented message (e.g., \"Connection to device unavailable: <err>\") and avoid re-raising them blindly.\n- Ensure the handler triggers proper cleanup (e.g., calling disconnect or similar) to avoid leaving the connection object in a bad state.\n",
            "Step 5: Refactor the connection lifecycle to use fresh instances\n- Change the connection class so that the connection/session object (e.g., pxssh.pxssh()) is not created in __init__ but in a connect() method.\n- Initialize the connection attribute to None in __init__.\n- In connect(), always create a new connection/session object and perform the login/handshake there.\n- In disconnect(), gracefully close/log out from the session, catching and ignoring secondary errors during cleanup, and then set the connection attribute back to None in a finally block.\n- Avoid reusing a connection object once disconnect() or a fatal error has occurred.\n",
            "Step 6: Ensure higher-level logic tolerates transient failures\n- Make sure callers of the connection (e.g., periodic polling loops) handle None or failure return values gracefully instead of assuming success.\n- Provide retry or backoff mechanisms as appropriate, allowing the system to keep trying to reconnect as the remote device comes back online.\n- Avoid flooding logs: distinguish between expected transient failures (e.g., router rebooting) and unexpected bugs, logging them at suitable severity levels.\n",
            "Step 7: Add or update tests\n- Write tests that simulate connection failures and remote reboots: mock the underlying library to raise AssertionError or other exceptions on connect/login or command execution.\n- Verify that the code:\n  - Catches the exceptions without crashing.\n  - Logs appropriate error messages.\n  - Calls disconnect() and resets the connection object to None.\n  - Can successfully reconnect on the next connect() call, using a fresh session object.\n",
            "Step 8: Validate in real or staging environment\n- Deploy the changes to a test environment connected to an actual or realistically simulated device.\n- Reboot the device or emulate network outages and confirm that:\n  - Logs show clean, concise error messages instead of full stack traces.\n  - The integration or service automatically recovers and reconnects when the device is back.\n  - No lingering broken state or resource leaks are observed over multiple cycles."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Added a new 'date_time_utc' display option to Home Assistant's time_date sensor platform, enabling a combined UTC date and time sensor state. Implemented UTC formatting logic, kept existing local-time behavior unchanged, and expanded tests to verify correct behavior across default and non-default time zones.",
        "keywords": [
            "home-assistant",
            "time_date",
            "sensor",
            "date_time_utc",
            "UTC",
            "local time",
            "timezone handling",
            "datetime formatting",
            "sensor display_options",
            "unit tests"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the time_date sensor platform in Home Assistant was extended to support a new display option called 'date_time_utc'. Before this change, the platform offered separate options for local date/time ('date', 'time', 'date_time') and a UTC time-only option ('time_utc'), and an ISO-formatted local date-time ('date_time_iso'), but there was no way to obtain a combined UTC date and UTC time in the same sensor state. Users needing a UTC timestamp-like display had to compose it manually or use multiple sensors.\n\nThe change introduced 'date_time_utc' into the SENSOR_TYPES mapping with a user-facing name 'Date & Time (UTC)'. Internally, the sensor's `_update_internal_state` method was updated to compute both local and UTC representations: `time` and `date` via `dt_util.as_local(time_date)`, and `time_utc` and `date_utc` directly from the UTC `time_date`. A new conditional branch was added so that when `self.type == 'date_time_utc'`, the sensor state is formatted as `\"{date_utc}, {time_utc}\"`, mirroring the existing `date_time` format but in UTC.\n\nTests in `tests/components/time_date/test_sensor.py` were expanded and corrected. The module and class docstrings were fixed to reference the time_date platform instead of an incorrect 'Kira' reference. New assertions were added to `test_states` to verify that both `date_time` and `date_time_utc` produce identical results when the default timezone is UTC. A new `test_states_non_default_timezone` verified behavior when the system default timezone is set to 'America/New_York': local sensors ('time', 'date', 'date_time') reflect the local offset, while UTC sensors ('time_utc', 'date_time_utc') remain in UTC. This confirmed that the UTC formatting logic is independent of the configured local timezone. The icon tests were also updated to ensure `date_time_utc` reuses the calendar-clock icon, consistent with other date-time variants.\n\nOverall, the incident was not a bug but a missing functionality: there was no convenient UTC date+time display option. The fix involved adding a new sensor type, implementing UTC-specific formatting alongside existing local time logic, and thoroughly testing across different time zones to avoid regressions in time handling.",
        "semantic_memory": "This change illustrates generalizable patterns around extending time/date features and handling timezones in sensor-like systems:\n\n- When you introduce a new display or sensor variant, you must wire it through all relevant layers: the public configuration/options mapping, the internal state update logic, and the tests (including icons or metadata). Omitting any layer leads to an incomplete or broken feature.\n- Time and date handling must be explicit about timezone semantics. In systems with both local and UTC concepts, use local-time conversion utilities (e.g., `as_local`) only for those variants that are defined as local, and keep UTC variants strictly based on the underlying UTC datetime to avoid double conversion or subtle offsets.\n- Whenever a feature depends on timezone behavior, tests should cover both default (often UTC) and non-default timezones. This prevents regressions where code appears correct in UTC but fails under other zones.\n- Reuse existing formatting patterns for new variants to maintain consistent UX. In this case, `date_time_utc` mirrors the formatting of `date_time` but swaps local time/date for UTC versions.\n- Naming matters for clarity: user-facing labels like 'Date & Time (UTC)' or '(ISO)' help users understand the format and timezone semantics without reading code.\n\nThese practices apply broadly when adding new configuration options, sensor modes, or display variants in any system that exposes time, date, or formatted states to users.",
        "procedural_memory": [
            "When adding a new time/date display mode or fixing timezone-related gaps in a sensor platform, follow a structured approach:",
            "Step 1: Identify the missing behavior or gap",
            "Clarify what representation is needed (e.g., 'UTC date and time combined', 'local ISO timestamp') and how it differs from existing options. Check current configuration options (e.g., display_options or sensor types) and locate where they are defined.",
            "Step 2: Extend the configuration/type mapping",
            "Add the new display option key (e.g., 'date_time_utc') to the sensor type mapping or configuration schema with a clear, user-friendly label. Ensure the new type appears wherever options are enumerated or validated.",
            "Step 3: Implement internal state computation",
            "In the core update method (e.g., `_update_internal_state`), compute all necessary time/date variants explicitly:\n- Use local-time utilities (like `as_local`) for local variants.\n- Use the raw or explicitly UTC datetime for UTC variants.\nAdd a conditional branch for the new type that sets the state in the desired format (e.g., `\"{date_utc}, {time_utc}\"`).",
            "Step 4: Keep timezone semantics explicit and consistent",
            "Decide which variants should be local vs UTC, and do not mix them. For example, for UTC variants, avoid applying local conversions. For local variants, always convert from the base (often UTC) datetime using a standard utility function.",
            "Step 5: Add or update tests for default and non-default time zones",
            "Create or extend unit tests to cover:\n- Behavior under the default timezone (often UTC): ensure new and existing types produce the expected strings.\n- Behavior under at least one non-UTC timezone: programmatically set the default timezone (e.g., to 'America/New_York') and confirm that local variants change accordingly while UTC variants stay in UTC.\n- Any related metadata, such as icons or attributes, remains correct for the new type.",
            "Step 6: Verify consistency with existing formatting and UX",
            "Ensure the new variant uses formatting consistent with similar existing options (e.g., comma-separated date and time, ISO formatting if relevant). Reuse icons or labels where appropriate so the new option feels coherent with the rest of the platform.",
            "Step 7: Run the full test suite and static checks",
            "Execute the project's test runner (e.g., `tox` or pytest) to ensure that the new code passes all unit tests and style checks. Fix any regressions or timezone-related edge cases uncovered by the tests.",
            "Step 8: Update documentation and examples",
            "Add or update documentation to describe the new display option, including example configuration snippets (e.g., `display_options: ['date_time_utc']`) and a short note about its timezone semantics. This helps users discover and correctly use the new feature."
        ]
    }
}
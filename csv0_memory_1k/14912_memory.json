{
    "search_index": {
        "description_for_embedding": "Home Assistant MQTT binary_sensor enhancement: add support for a configurable unique_id and json_attributes. The entity now parses JSON payloads to extract selected attributes (e.g., battery level from zigbee2mqtt), works together with value_template, and handles invalid or non-dict JSON payloads with warnings while still allowing attribute-only updates.",
        "keywords": [
            "home-assistant",
            "mqtt",
            "binary_sensor",
            "json_attributes",
            "unique_id",
            "value_template",
            "zigbee2mqtt",
            "attribute extraction",
            "JSON parsing",
            "entity registry",
            "payload parsing warning"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant MQTT binary_sensor platform was extended to support both a configurable unique_id and JSON-based state attributes. The motivating use case was integrations like zigbee2mqtt, where binary sensors (e.g., door contacts) send additional data such as battery level in JSON payloads on the same MQTT topic.\n\nPreviously, the MQTT binary_sensor only handled an on/off payload and had no way to expose extra attributes from the payload, nor a way to define a stable unique_id via configuration. unique_id is important for the entity registry and avoiding duplicate entities.\n\nTo address this, the developer:\n- Extended the configuration schema with two new options:\n  - json_attributes: a list (CSV-capable) of JSON keys to expose as entity attributes.\n  - unique_id: an optional string used for entity registry uniqueness (MQTT is treated as a transport exception where exposing unique_id via config is allowed).\n- Updated async_setup_platform to pass json_attributes and unique_id into the MqttBinarySensor constructor.\n- Enhanced MqttBinarySensor:\n  - Stored the configured JSON attribute keys as a set and added an internal _attributes dict.\n  - Added a unique_id property to expose the configured ID.\n  - In the MQTT state callback, when json_attributes is configured, attempted to json.loads the incoming payload. If the result is a dict, it filters that dict to only the configured keys and stores them as attributes. If the JSON is not a dict, it logs a warning. If parsing fails (ValueError), it logs a warning including the payload.\n  - Applied the existing value_template via async_render_with_possible_json_value after attribute extraction, allowing the same JSON payload to be used both for state and attributes.\n  - Removed the early `return` when the payload doesn't match payload_on or payload_off. Instead, it logs a warning but still schedules a Home Assistant state update. This enables handling messages that only carry attribute updates (e.g., battery) without changing the binary state.\n  - Added device_state_attributes to return the extracted attributes.\n\nThe tests were expanded to cover:\n- unique_id behavior: Two MQTT binary_sensors configured with the same unique_id do not create duplicate entities (verifying registry deduplication behavior).\n- Attribute extraction from valid JSON: Given json_attributes: 'val' and payload `{ \"val\": \"100\" }`, the entity exposes attribute 'val' = '100' and logs a warning if the payload does not correspond to a valid on/off state.\n- Handling of non-dict JSON (e.g., a list) with json_attributes, ensuring attributes remain None and a warning is logged.\n- Handling of invalid JSON strings: verifies that attributes remain None and a warning is logged (the debug log was removed per review; the warning now includes the payload itself).\n- Combined use of value_template and json_attributes: Configuration with value_template `{{ value_json.val }}` and payload `{ \"val\": \"100\" }` sets attribute val = '100' and state 'on' when payload_on is '100'.\n- Case where the JSON attributes update but the value is invalid for the binary state: attributes are still updated, while a warning about unmatched payload is logged.\n\nMinor logging adjustments were made following review: instead of separate warning and debug logs for bad JSON, a single warning incorporates the payload. The code was also formatted to satisfy style checks (hound).",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices when working with MQTT-based entities and JSON payloads in Home Assistant or similar systems:\n\n1. **JSON attribute extraction from MQTT payloads**\n   - When MQTT messages contain structured JSON with both the primary state and extra metadata (e.g., battery, voltage), it is useful to allow users to configure which JSON keys should be exposed as entity attributes.\n   - To implement this, parse the payload as JSON in the message callback when a json_attributes configuration is present. If the payload parses to a dict, filter this dict to the configured keys and store those as attributes.\n   - Use a whitelist (set of configured keys) rather than exposing the full JSON payload to keep attributes predictable, reduce noise, and avoid leaking unnecessary data.\n\n2. **Separating attribute updates from state transitions**\n   - MQTT messages may not always represent a state change; sometimes they only carry attribute updates (e.g., periodic battery level reports).\n   - Avoid structuring the callback so that a failure to match the state payload (e.g., not equal to payload_on/payload_off) aborts the entire message handling. Instead, process attributes independently and only log a warning if the state payload is not recognized.\n   - This allows attributes to keep updating even if the message does not change the entity's state, which is important for long-lived sensors.\n\n3. **Ordering: parse JSON once, reuse for attributes and templates**\n   - Where a value_template is used that relies on value_json, the JSON should be parsed once and reused both for attribute extraction and state derivation where possible.\n   - Home Assistant's `async_render_with_possible_json_value` helper is designed for this: it takes the raw payload and optionally an existing value to render templates safely and robustly when the payload may or may not be valid JSON.\n\n4. **Robust error handling for JSON payloads**\n   - MQTT payloads can be malformed or of unexpected types. Always guard JSON parsing with try/except.\n   - If parsing fails (`ValueError`) or the parsed JSON is not a dict when a dict is expected, the system should:\n     - Leave attributes unchanged (or set them to None if appropriate).\n     - Log a warning with enough context (including the payload or key parts of it) for diagnosis, but without crashing or breaking the overall message handling flow.\n   - Avoid over-verbose logging in tight loops; a single warning with payload is often more useful than separate warning/debug messages.\n\n5. **Configurable unique IDs for entities**\n   - unique_id is crucial for entity registries: it identifies an entity across restarts and prevents duplicates.\n   - While most integrations should not expose unique_id via configuration, MQTT is a special case because it is a transport rather than a fixed protocol; the entity identity is not discoverable in the same way.\n   - Allowing users to define unique_id in the MQTT config enables manual MQTT entities to integrate cleanly with the entity registry and supports deduplication (i.e., two configs with the same unique_id represent the same entity).\n\n6. **Testing strategies for MQTT-based entities**\n   - Use helper functions such as `fire_mqtt_message` to simulate incoming MQTT messages in tests.\n   - Patch the module logger to assert that warnings are emitted in error cases (invalid JSON, unexpected payloads), ensuring both functionality and observability are maintained.\n   - Test combinations of features: JSON attributes with and without value_template, good and bad JSON, and correct vs incorrect state payloads to ensure resilience and compatibility.\n\nOverall, this PR demonstrates how to extend an MQTT-based binary sensor to be more feature-complete (attributes, unique_id) while remaining robust in the face of imperfect MQTT payloads and supporting integrations that piggyback multiple pieces of information onto a single topic.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the need for extra attributes and stable identity\n- Observe that an MQTT-based entity only exposes a basic state (e.g., on/off) while the raw MQTT payload includes additional useful data (e.g., battery, voltage, signal strength).\n- Confirm that users or upstream integrations (e.g., zigbee2mqtt) need these extra fields as entity attributes in the UI and automations.\n- Determine whether the entity also needs a stable unique_id for the entity registry (to avoid duplicates and allow renaming/disable in the UI).",
            "Step 2: Extend the configuration schema\n- In the platform’s configuration schema, add:\n  - A `json_attributes` option, defined as a list (or CSV list) of strings, representing JSON keys to expose as attributes.\n  - A `unique_id` option (if appropriate for the platform), validated as a string.\n- Use something like `vol.Optional(CONF_JSON_ATTRS, default=[]): cv.ensure_list_csv` to support both single and multiple values.\n- Document any expectations: for example, that the payload must be JSON for json_attributes to be meaningful, and that value_template may be needed for state extraction.",
            "Step 3: Plumb configuration into the entity\n- Update the setup function (e.g., async_setup_platform) to pass the new json_attributes and unique_id values into the entity constructor.\n- In the entity class, add instance variables for these values (e.g., `_json_attributes`, `_unique_id`, `_attributes`).\n- Optionally convert the json_attributes to a set for efficient membership tests and intersection operations.",
            "Step 4: Implement JSON attribute extraction in the message callback\n- In the MQTT message callback:\n  - Check if json_attributes is configured (non-empty).\n  - If so, attempt to parse the payload with `json.loads(payload)` inside a try/except block.\n  - If parsing succeeds and the result is a dict:\n    - Compute the intersection of configured attribute keys and the dict’s keys.\n    - Build a new dict `{k: json_dict[k] for k in selected_keys}` and assign it to the entity’s internal `_attributes`.\n  - If the result is not a dict, log a warning that the JSON result was not a dictionary and avoid updating attributes.\n  - If parsing fails (ValueError), log a warning including the payload, and do not crash or stop processing the message handler.",
            "Step 5: Apply value templates without breaking attribute updates\n- After parsing attributes, apply any configured value_template to derive the binary state:\n  - Use a safe helper like `async_render_with_possible_json_value(payload, self._state)` to handle both JSON and non-JSON payloads.\n- Use the rendered value to determine whether the state is `payload_on`, `payload_off`, or unknown.\n- If the payload matches neither, log a warning but do NOT `return` early from the callback; doing so would prevent attribute-only updates from being applied.\n- This separation ensures that even messages with an unknown or irrelevant state payload can still update attributes (e.g., battery reading).",
            "Step 6: Expose attributes and unique ID via entity properties\n- Add a `device_state_attributes` property that returns the stored `_attributes` dict (or None if no attributes are set).\n- Add a `unique_id` property that returns the `_unique_id` configured in the constructor.\n- This allows the home automation framework to surface those attributes in the UI and use unique_id in the entity registry.",
            "Step 7: Write and update tests\n- Add tests to cover the new configuration paths and behaviors:\n  - unique_id: configure two entities with the same unique_id and assert that only one entity is effectively created or that the system handles duplicates as expected.\n  - json_attributes with valid JSON: send a JSON payload containing the configured keys and assert that the entity’s attributes reflect these values.\n  - json_attributes with non-dict JSON: send a JSON list or other non-dict structure and assert that attributes remain None and a warning is logged.\n  - json_attributes with invalid JSON: send a non-JSON string; assert that parsing is handled gracefully and an appropriate warning is logged.\n  - Combination of json_attributes and value_template: send a JSON payload; verify both attributes and state are correctly derived.\n  - Case where attributes update but state payload is invalid: verify attributes change and that a warning about unmatched state payload is emitted.\n- Use logger patching (e.g., `@patch('homeassistant.components.binary_sensor.mqtt._LOGGER')`) to assert that warnings are emitted in error scenarios.",
            "Step 8: Validate behavior and logging in practice\n- Run the test suite (e.g., with `tox`) to ensure all tests pass.\n- Deploy locally and simulate MQTT messages, confirming that:\n  - Attributes update correctly from JSON.\n  - State changes as expected when payloads match configured on/off values.\n  - Attribute-only messages do not break the entity and still update attributes.\n  - Logs show clear warnings for invalid JSON, non-dict JSON, or unmatched state payloads, aiding in diagnosing misconfigured brokers or integrations.",
            "Step 9: Document configuration and caveats\n- Update documentation to describe the new json_attributes and unique_id options, including:\n  - Example configurations demonstrating combined use with value_template.\n  - Notes that json_attributes relies on the payload being JSON and that a value_template may be necessary for deriving the state.\n  - Clarification that MQTT is a special case where unique_id can be configured because it functions as a transport rather than a single fixed protocol."
        ]
    }
}
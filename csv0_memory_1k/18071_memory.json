{
    "search_index": {
        "description_for_embedding": "Adds a 'boost' mode to Home Assistant's generic_thermostat climate component, including configuration for a boost temperature, internal state tracking, and a new climate service `set_boost_mode` to toggle this temporary higher target temperature, modeled similarly to existing away mode behavior.",
        "keywords": [
            "home assistant",
            "generic_thermostat",
            "climate",
            "boost mode",
            "temporary setpoint",
            "away mode pattern",
            "set_boost_mode service",
            "configuration schema",
            "thermostat feature enhancement",
            "stateful mode toggle"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the contributor attempted to extend Home Assistant's `generic_thermostat` climate component with a new 'boost' mode. The motivation was to have a temporary higher (or different) target temperature that could be turned on and off, similar in behavior to the existing away mode, but for a comfort/boost scenario.\n\nTo implement this, the developer:\n- Introduced a new configuration option `BOOST_temp` (exposed via `CONF_BOOST_TEMP`) in `generic_thermostat.py` and added it to the component's config validation, coercing it to a float.\n- Extended the `GenericThermostat` constructor signature to accept `boost_temp`, storing it in `self._boost_temp`.\n- Added internal state flags `self._is_boost` and reused `self._saved_target_temp` to remember the pre-boost target temperature.\n- Implemented `is_boost_mode_on` (a read-only property) and two async methods: `async_turn_boost_mode_on` and `async_turn_boost_mode_off`. When boost is turned on, the current target temperature is saved, `_target_temp` is set to `_boost_temp`, and the thermostat control coroutine (`_async_control_heating`) is called before updating HA state. When boost is turned off, the saved target temperature is restored and control/state are updated again.\n- Registered a new climate domain service in `homeassistant/components/climate/services.yaml` called `set_boost_mode`, which accepts `entity_id` and a boolean `boost_mode` flag to toggle boost on supported entities.\n\nThe PR was marked as WIP and the author acknowledged missing pieces (e.g., documentation and likely full integration in the climate platform/service handler). Additionally, Home Assistant's bot repeatedly requested a signed CLA, and the PR eventually went stale and was closed without being merged. The result is a clear pattern for implementing a mode like boost, but the work remained incomplete and not integrated into production.",
        "semantic_memory": "This case illustrates how to implement a new operational mode in a thermostat-like component within a home automation system.\n\nKey generalizable patterns:\n1. **Mode as a stateful overlay on target temperature**: A 'boost' or 'away' mode can be implemented as an overlay on the main target temperature. When the mode is activated, the original target is saved, and a special mode-specific target temperature is applied. On deactivation, the saved value is restored. This avoids permanently altering the user's baseline settings.\n\n2. **Mirroring existing modes to keep behavior consistent**: The new boost mode largely mirrors the existing away mode: configuration option for a special temperature, boolean state flag (e.g., `_is_boost`), and paired methods `turn_boost_mode_on/turn_boost_mode_off`. Reusing patterns from existing modes reduces design risk and makes the feature predictable.\n\n3. **Separation of concerns: configuration, state, services**:\n   - Configuration schema (`vol.Optional(CONF_BOOST_TEMP): vol.Coerce(float)`) declares how the new mode is configured.\n   - Device state (`_is_boost`, `_boost_temp`, `_saved_target_temp`) captures runtime behavior.\n   - Services (`set_boost_mode` in `services.yaml`) expose user-facing control. Each layer is updated coherently.\n\n4. **Async control flow for mode changes**: For HA-style components, operational mode toggles should call the same internal control routines used by normal setpoint changes (here, `_async_control_heating`) and then publish state via `async_update_ha_state()`. This ensures mode changes interact properly with the rest of the system and with other automations.\n\n5. **Schema and naming consistency matter**: Even in a WIP, inconsistencies like using `BOOST_temp` instead of snake_case (`boost_temp`), or copy-paste descriptions referring to 'away mode' rather than 'boost mode' in the new service, can cause confusion and drift. Aligning naming and descriptions with existing conventions is important for maintainability.\n\n6. **Process constraints (CLA, tests, docs) are part of a successful change**: The feature wasn't merged because contributor agreements weren't completed and the PR went stale. Beyond writing code, conforming to contribution requirements (CLA, tests, documentation) is essential for landing a change in large projects.",
        "procedural_memory": [
            "When adding a new operational mode (e.g., boost) to a thermostat-like component in a system like Home Assistant, follow these steps:",
            "Step 1: Analyze existing similar modes.",
            "Inspect the existing implementation of modes such as `away_mode` in the same component. Note the configuration options, internal state variables, services, and methods (e.g., `async_turn_away_mode_on/off`). Use these as a template for consistent behavior.",
            "Step 2: Extend the configuration schema.",
            "Add a new configuration key constant (e.g., `CONF_BOOST_TEMP = 'boost_temp'`) and update the platform's config schema to accept it, using appropriate validation and coercion (e.g., `vol.Optional(CONF_BOOST_TEMP): vol.Coerce(float)`). Ensure naming follows existing conventions (snake_case, all lowercase, etc.).",
            "Step 3: Update the component's constructor and internal state.",
            "Modify the component's `__init__` or factory function to accept the new configuration parameter and store it on the instance (e.g., `self._boost_temp`). Add a boolean state flag (e.g., `self._is_boost = False`) and a variable to save the normal target temperature (often a reused member like `self._saved_target_temp`). Initialize these consistently with existing modes.",
            "Step 4: Implement the mode's API surface on the device class.",
            "Add a property to expose the mode state (e.g., `@property def is_boost_mode_on`). Implement two methods to toggle the mode, `async_turn_boost_mode_on` and `async_turn_boost_mode_off`. In `on`:\n- If already active, return early.\n- Set the flag to True.\n- Save the current `self._target_temp` to `self._saved_target_temp`.\n- Set `self._target_temp = self._boost_temp` (and handle the case where `boost_temp` may be None or missing).\n- Call the internal control routine (e.g., `await self._async_control_heating()`).\n- Call `await self.async_update_ha_state()` to publish the new state.\nIn `off`:\n- If not active, return early.\n- Reset the flag.\n- Restore `self._target_temp` from `self._saved_target_temp`.\n- Call the control routine and update the HA state.",
            "Step 5: Wire up a domain service to control the mode.",
            "Define a new service in the domain services YAML (e.g., in `climate/services.yaml`) with appropriate fields. For a boolean mode toggle:\n- Name the service (e.g., `set_boost_mode`).\n- Add `entity_id` for target entities.\n- Add a field like `boost_mode` with type boolean and a clear description referencing 'boost mode', not copied from another feature.\nThen, in the Python domain component, register this service and implement a handler that calls `async_turn_boost_mode_on` or `async_turn_boost_mode_off` depending on the payload.",
            "Step 6: Ensure consistency with feature flags and capabilities.",
            "If the platform uses support flags (e.g., `SUPPORT_AWAY_MODE`), consider adding a new support flag for boost mode and include it when the configuration option is provided. Update any capability reports or `supported_features` properties to reflect the new mode.",
            "Step 7: Add tests to cover the new mode.",
            "Write unit tests that:\n- Create a thermostat instance with a `boost_temp` configured.\n- Verify that normal operation works without boost.\n- Call the boost mode service or methods and assert that `_target_temp` changes to `boost_temp`, `_is_boost` is True, and that turning it off restores the original target.\n- Validate correct behavior when boost is toggled multiple times or when `boost_temp` is not configured.",
            "Step 8: Update documentation and examples.",
            "Document the new configuration parameter (`boost_temp`), its purpose, and provide an example configuration snippet showing how to enable boost mode. Document the new service (`climate.set_boost_mode` or similar) with parameters and usage examples.",
            "Step 9: Align with project process requirements.",
            "Before expecting the feature to be merged, ensure you have signed any required Contributor License Agreements, run and passed all automated tests (e.g., `tox`), and adhered to linting/style checks. Address project maintainersâ€™ feedback and keep the PR active to avoid it going stale.",
            "Step 10: Review for naming and copy-paste issues.",
            "Before finalizing, search for copy-paste artifacts (e.g., descriptions saying 'away mode' in a 'boost mode' service) and naming mismatches (`BOOST_temp` vs `boost_temp`). Fix these to maintain clarity and consistency across the API and configuration."
        ]
    }
}
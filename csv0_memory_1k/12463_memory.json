{
    "search_index": {
        "description_for_embedding": "Home Assistant upgraded voluptuous from 0.10.5 to 0.11.1, which introduced a breaking change: all default values in schemas must now pass validation. This caused widespread config schema failures where Optional keys used default=None for fields that didn't allow None (e.g., positive_int, string, dict) and where mutable or dynamic objects (like dict_keys views) were used as defaults. The fix removes invalid defaults (especially default=None), adjusts schemas to treat missing keys via dict.get(), tightens validators to match actual possible values (e.g. login threshold sentinel values), and corrects tests accordingly. A temporary patch to voluptuous was used to auto-detect invalid defaults across modules.",
        "keywords": [
            "voluptuous 0.11.1 upgrade",
            "config schema default values",
            "default must pass validation",
            "Home Assistant",
            "vol.Optional default=None",
            "validation error",
            "schema breaking change",
            "mutable default arguments",
            "dict_keys default",
            "login_attempts_threshold",
            "history recorder filters",
            "test fixes"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the project upgraded the voluptuous validation library from version 0.10.5 to 0.11.1. A key backward-incompatible change in voluptuous 0.11 is that default values in schemas must themselves pass the associated validators, just like user-supplied values. The Home Assistant codebase had many config schemas with patterns like `vol.Optional(key, default=None): cv.positive_int` or `cv.string`, as well as container defaults that were non-serializable or dynamic, such as `default=SENSOR_TYPES` (a dict or dict_keys view) or defaults defined as callables.\n\nAfter the upgrade, these invalid defaults started causing schema construction-time or validation-time errors: for instance, `default=None` did not satisfy `cv.positive_int`, and dict-like `SENSOR_TYPES` values did not match list-of-choices validators.\n\nTo systematically find these issues, the maintainer temporarily patched voluptuous' `Schema` constructor to validate each key's default against its schema as schemas were constructed. They also modified `script/gen_requirements.py` to import all component modules, ensuring all schemas would be instantiated and their defaults checked. This surfaced a long list of invalid defaults both in core components and in dependencies.\n\nThe fixes applied in this PR include:\n\n- Upgrading the pinned version of voluptuous in `setup.py`, `package_constraints.txt`, and `requirements_all.txt` to 0.11.1.\n\n- Removing `default=None` from many `vol.Optional(...)` declarations where None was not an allowed value, and instead handling absence by using `dict.get()` or checking `key in conf` at runtime. Examples:\n  - HTTP component: API password, SSL certificate/key, and login attempt threshold were changed so optional fields are truly optional without None defaults. The login threshold uses a sentinel `NO_LOGIN_ATTEMPT_THRESHOLD = -1` and validates with `vol.Any(cv.positive_int, NO_LOGIN_ATTEMPT_THRESHOLD)`; code now uses `.get()` when reading these values.\n  - Numerous components across `alert`, `amcrest`, `android_ip_webcam`, `apple_tv`, various `binary_sensor` and `sensor` platforms, MQTT-based integrations, REST-based components, and switches had `default=None` removed and approximating `entity[CONF_...]` replaced with `entity.get(CONF_...)` when the field is optional.\n\n- Correcting schema defaults that used containers or dynamic views directly:\n  - Where defaults were sets/dicts or `dict_keys` views (e.g., `default=SENSOR_TYPES` or `default=SENSOR_TYPES.keys()`), they were replaced with concrete lists, such as `default=list(SENSOR_TYPES)` or `default=list(MONITORED_CONDITIONS)`, ensuring the default itself passes `vol.All(cv.ensure_list, [vol.In(SENSOR_TYPES)])` or similar validators.\n  - Filters in Alexa and Cloud integrations had their filter defaults changed from a lambda returning a complex object to `default={}` paired with `entityfilter.FILTER_SCHEMA`.\n  - Recorder/history filters and other filter-like configs were updated so that defaults are simple empty dicts/lists, and the runtime logic uses `.get(..., [])` when reading them.\n\n- Adjusting some schema semantics to remain coherent after removing invalid defaults:\n  - KNX climate: removed invalid defaults for setpoint shift min/max in the schema and instead supply `DEFAULT_SETPOINT_SHIFT_MIN/MAX` when reading from config.\n  - Tomato device tracker: port defaults changed from a sentinel `-1` to making the field optional and deciding between 80 and 443 based on SSL at runtime.\n  - Homematic: the local port is no longer given a default in the schema but is defaulted in code to `DEFAULT_LOCAL_PORT`.\n  - History and recorder: handling of include/exclude filters changed to call `.get(CONF_ENTITIES, [])` and `.get(CONF_DOMAINS, [])` so missing keys yield empty lists.\n  - Some schemas that previously required fields with defaults were changed to truly optional fields with defaults computed at runtime.\n\n- Cleaning up tests and test utilities:\n  - History tests mirror the new include/exclude logic using `.get(..., [])`.\n  - Rflink tests were updated to remove usage of `assert_setup_component(platform_count, domain)` and simplified the mock helper signature, in line with changed config behavior.\n  - A secrets/config check test was updated to no longer expect SSL fields in the HTTP config when they are omitted (since they are now optional without default None values).\n  - Minor linting fixes, such as removing unused imports and correcting accidental `vol.Optional.get` typos in schemas.\n\nAfter these changes, the project could successfully run under voluptuous 0.11.1 without schema construction or validation errors, and the tests were updated to reflect the new handling of optional fields and defaults.",
        "semantic_memory": "This incident illustrates several generalizable principles about working with schema/validation libraries and configuration design:\n\n1. **Defaults must be valid instances of the schema**:\n   - If a validator enforces a type or constraint (e.g., positive integer, non-empty string, dict), the schema's default for that field must satisfy the same constraints. Using `default=None` for an integer or string field is invalid unless the validator explicitly allows `None` (e.g., `vol.Any(None, cv.positive_int)` or a custom validator).\n   - This is especially important when a validation library changes its behavior to validate defaults eagerly.\n\n2. **Optional fields vs. default values**:\n   - `vol.Optional(key, default=...)` means the key will always be present in the validated output, with the default substituted if omitted. This default must be valid.\n   - If you truly want a field to be optional (key absent when user does not specify it), do not provide a default in the schema. Access it with `conf.get(key)` or check `if key in conf:`.\n   - Avoid encoding sentinel values as defaults that violate validators; instead, either broaden the validator to include the sentinel (e.g., `vol.Any(cv.positive_int, -1)`) or handle the sentinel at runtime.\n\n3. **Avoid `default=None` when None is not allowed**:\n   - `default=None` was frequently (mis)used as a way to represent 'missing' in schemas. When the validator disallows None, this will break when defaults are validated.\n   - A better pattern is to make the field optional with no default and use `.get()` in code, or use `vol.Any(None, ...)` if you genuinely want None as an allowed value.\n\n4. **Be careful with container defaults (lists, dicts, dict_keys)**:\n   - Validators that expect a list of allowed values typically need a concrete list as a default, not a dict, set, or `dict_keys` view. Use `list(SENSOR_TYPES)` rather than `SENSOR_TYPES` or `SENSOR_TYPES.keys()`.\n   - Avoid using mutable data structures as shared defaults if they might be mutated at runtime (classic 'mutable default argument' issue). While voluptuous doesn't mutate defaults itself, this is a general design concern.\n\n5. **Separating schema semantics from runtime behavior**:\n   - If schema constraints need to be strict (e.g., 'port must be a valid port number or host not provided'), don't work around them by providing invalid defaults; instead, use runtime logic to fill in sensible defaults when keys are missing.\n   - For complex filters or derived defaults, it's often better to default to a simple structure (`{}` or `[]`) and calculate the full semantics in the component's setup code.\n\n6. **Systematic detection of schema issues**:\n   - When upgrading a validation library with a breaking change, you can temporarily instrument the schema constructor to validate defaults at definition time and log any invalid ones.\n   - Combining such instrumentation with a script that imports all modules (or that exercises all schemas) helps surface problems across a large codebase.\n\n7. **Tests must reflect config semantics, not just structure**:\n   - Changes in whether a field appears at all vs. appears with a None default affect tests that assert on serialized configuration or internal config dicts.\n   - When modifying schema behavior (especially defaults and optionality), update tests to use `.get()` and not assume keys will be present.\n\nOverall, this incident highlights that config schemas should be carefully designed so that defaults are valid and minimal, optionality is explicit, and runtime code—not misused defaults—handles dynamic or contextual behavior.",
        "procedural_memory": [
            "Step-by-step strategy to diagnose and fix issues when upgrading a validation library (like voluptuous) that changes how defaults are handled.",
            "Step 1: Review the upstream changelog",
            "Read the changelog of the validation library (here, voluptuous 0.11.0/0.11.1). Identify any breaking changes, especially those affecting default values or schema construction. Note rules like 'Default values MUST now pass validation just as any regular value.'",
            "Step 2: Identify common anti-patterns in your schemas",
            "Search your codebase for patterns that are likely to violate the new rules:\n- `vol.Optional(..., default=None)` where the validator does not accept None (e.g., `cv.string`, `cv.positive_int`, `dict`).\n- Defaults that are non-list containers fed into list-based validators (e.g., `default=SENSOR_TYPES` with `vol.All(cv.ensure_list, [vol.In(SENSOR_TYPES)])`).\n- Defaults that are callables, lambdas, or complex objects if the library expects concrete values.",
            "Step 3: Temporarily instrument the schema constructor to validate defaults",
            "If the library doesn't already validate defaults at schema definition time, temporarily patch it locally to do so. For voluptuous, this was done by adding, at the end of `Schema.__init__`:\n\n```python\nif isinstance(schema, dict):\n    for key, value in schema.items():\n        if not hasattr(key, 'default'):\n            continue\n        if key.default is UNDEFINED:\n            continue\n\n        default = key.default\n        if callable(default):\n            default = default()\n\n        try:\n            Schema(value)(default)\n        except Exception as err:\n            print(f'{default} did not match {value}: {err}')\n```\n\nThis causes invalid defaults to be reported when schemas are created.",
            "Step 4: Ensure all schemas are instantiated",
            "Create or adapt an existing script to import all relevant modules so that all schemas are constructed and your instrumentation can run. In this case, `script/gen_requirements.py` was modified to print the package name and import each component module. Alternatively, write a dedicated script that recursively imports all modules under your components package.\n\nRun this script, capturing all printed error lines that indicate a default value failing validation.",
            "Step 5: Fix invalid defaults in schemas",
            "For each reported default validation failure, adjust the schema:\n- Remove `default=None` from `vol.Optional` when the validator does not allow None and you don't need a sentinel. Instead, make the field optional with no default and access it using `conf.get(key)`.\n- If you truly need a sentinel like -1 or None, widen the validator to include it, e.g., `vol.Any(cv.positive_int, -1)` or `vol.Any(None, cv.string)`.\n- Replace container defaults that aren't of the expected type. For example, use `default=list(SENSOR_TYPES)` instead of `default=SENSOR_TYPES` or `default=SENSOR_TYPES.keys()`.\n- For more complex defaults (e.g., filters), default to a simple type (`default={}` or `default=[]`) and construct richer objects in the component code.\n- Where defaults in schemas are removed, update code that previously assumed keys exist (e.g., `conf[CONF_SSL_KEY]`) to use `.get()` or `if key in conf` checks.",
            "Step 6: Adjust runtime logic for changed optionality",
            "As you remove defaults and change validation constraints, ensure that your component initialization code and runtime logic treat fields consistently:\n- Use `value = conf.get(KEY)` for true optionals.\n- Use `value = conf.get(KEY, SOME_DEFAULT)` when you want to assign a default at runtime.\n- Adjust any logic that previously depended on sentinel values (like -1 or None) to use the new validators and runtime defaults.\n\nExamples from this fix:\n- In the HTTP component, `CONF_LOGIN_ATTEMPTS_THRESHOLD` was changed to allow a sentinel -1 via `vol.Any(cv.positive_int, NO_LOGIN_ATTEMPT_THRESHOLD)`, and code uses that constant to interpret behavior.\n- Tomato device tracker now treats absent `CONF_PORT` as meaning '80 if not SSL, 443 if SSL' instead of using `-1` as an invalid default.",
            "Step 7: Fix and extend tests",
            "Update tests to reflect new schema behaviors:\n- If optional fields no longer appear when omitted, don't assert that they are present with value None.\n- When constructing expected config dicts, use `.get(...)` semantics or only assert keys that are guaranteed to be present.\n- Remove or adjust helper assertions that assumed a specific number of configured platforms or keys based on old defaults.\n\nAlso add tests where appropriate to prevent regressions in semantics (e.g., ensuring sentinel values are accepted by validators).",
            "Step 8: Remove instrumentation and finalize upgrade",
            "Once all invalid defaults are fixed and the test suite passes, remove the temporary instrumentation from the validation library. Then commit the version bump (e.g., `voluptuous==0.11.1` in your requirements) and the schema changes together so the codebase is consistent.",
            "Step 9: General best practices for future schemas",
            "For future work, adopt the following schema design practices:\n- Only specify `default=...` when you truly want to force the key into the validated output. Otherwise, leave the default off and treat the key as optional.\n- Ensure all defaults are valid according to their validators.\n- Avoid `default=None` unless your validator explicitly allows it.\n- Avoid using mutable or dynamic objects (like views) as defaults; prefer primitive values or explicit `list(...)` copies.\n- Keep complex logic and semantics out of default values; perform them in setup or runtime code instead."
        ]
    }
}
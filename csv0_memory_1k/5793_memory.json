{
    "search_index": {
        "description_for_embedding": "Implementation of a new Home Assistant telegram_webhooks component that receives Telegram Bot webhooks via an HTTP endpoint, validates source IP against Telegram trusted networks, validates allowed user IDs, parses slash-commands with arguments, and fires a telegram.command event instead of abusing entity states. Also extends notify.telegram to support Telegram reply keyboards. Uses hass.config.api.base_url to auto-register the webhook URL with Telegram and shares python-telegram-bot dependency.",
        "keywords": [
            "Home Assistant",
            "telegram_webhooks",
            "Telegram bot",
            "webhook integration",
            "HTTP endpoint",
            "HomeAssistantView",
            "telegram.command event",
            "event vs state",
            "trusted_networks",
            "IP allowlist",
            "get_real_ip",
            "python-telegram-bot",
            "notify.telegram",
            "reply keyboard",
            "API base_url",
            "security",
            "automation trigger",
            "webhook registration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the contributor added an entirely new Home Assistant component, telegram_webhooks, and enhanced the existing notify.telegram platform.\n\nInitially, the webhook implementation exposed an unauthenticated HTTP endpoint `/api/telegram_webhooks` that parsed incoming Telegram webhook JSON, validated the user ID, and stored the command and user ID in the state machine (`telegram_webhooks.command` and `telegram_webhooks.user_id`). Reviewers requested several changes:\n\n1. Use events instead of entity states for commands: They pointed out that commands are better modeled as events, not persistent states. The component was refactored to fire a `telegram.command` event on `hass.bus.async_fire` with event data: `{ command: '/cmd', args: 'arg string', user_id: <int> }`. Automations can then trigger on `platform: event` and access `trigger.event.data.args` for dynamic behavior (e.g., `/siren 10` controlling the siren duration).\n\n2. Add security via IP-based access control: The original endpoint did not verify the origin IP; reviewers asked to ensure only Telegram's servers can call the webhook to protect users who expose their instance to the Internet without a proxy. The component was updated to accept a `trusted_networks` configuration (defaulting to the IP ranges published by Telegram), convert them into `ip_network` objects, and use `homeassistant.components.http.util.get_real_ip(request)` to enforce that `real_ip` belongs to one of these networks. Unauthorized IPs receive HTTP 401.\n\n3. Configuration & webhook registration: Initially, the code expected both `api_key` and an explicit `api_url` for webhook registration. This was changed to a more robust approach that uses `hass.config.api.base_url` plus a constant handler path (`/api/telegram_webhooks`) to compute the webhook URL. If an `api_key` is configured, the component creates a `telegram.Bot`, calls `getWebhookInfo()`, and if the registered URL differs from the expected one, it calls `setWebhook(handler_url)` and logs success/failure.\n\n4. Dependency and requirements handling: Instead of importing the REQUIREMENTS from notify.telegram, the new component declares its own `REQUIREMENTS = ['python-telegram-bot==5.3.0']`, and requirements_all.txt already covered this library (shared with notify.telegram). An initial direct edit to requirements_all.txt was cleaned up to rely on the generator script comments.\n\n5. HTTP view implementation details: The webhook handler class (renamed to `BotPushReceiver`) subclasses `HomeAssistantView`, disables auth (`requires_auth = False`), defines a fixed URL `/api/telegram_webhooks`, and transforms the configured `user_id` mapping into a reverse lookup dictionary to cheaply validate `data['from']['id']`. The handler parses `request.json()`, extracts `data['message']`, ensures `data['text']` begins with `/` (command), and drops non-command messages by returning an empty JSON object while logging 'no command'. It emits the `telegram.command` event containing the command, args, and user_id.\n\n6. notify.telegram keyboard support: The PR also extended `homeassistant/components/notify/telegram.py` to support Telegram reply keyboards. A new `ATTR_KEYBOARD` field is recognized under `data` in notify calls. If present, the code normalizes the value to a list, splits each row on commas, strips whitespace, constructs a `telegram.ReplyKeyboardMarkup`, and sends it via `bot.sendMessage` with `reply_markup=keyboard`. Error handling for Telegram errors is consistent with existing photo/document/location senders. Reviewers later did a small cleanup to remove unnecessary `return` statements in the error handlers and refine how `keys` is retrieved.\n\nFinally, styles were aligned with Home Assistant guidelines: constants moved to top, domain and dependencies standardized, configuration schema refined (optional api_key without empty default, explicit TELEGRAM_HANDLER_URL constant), list comprehensions simplified, and some error messages adjusted. Tests were explicitly skipped for this component via .coveragerc.\n\nThe result is a secure, event-driven Telegram webhook integration for Home Assistant that supports commands, arguments, and keyboard-driven interactions, registering its webhook automatically and enforcing IP-based access control.",
        "semantic_memory": "This PR demonstrates several generalizable integration patterns and best practices for building secure, event-driven webhook components in a home automation or similar framework:\n\n1. **Use events for transient commands, not persistent state**: Commands or one-off actions (like chat commands) should be modeled as events (`bus.async_fire`) rather than as artificial entities or states. States are better suited for long-lived, observable conditions; events are better for triggers and actions. This makes automation rules more expressive (filter on event_type and event_data) and avoids misuse of the state machine.\n\n2. **Secure webhooks with IP allowlists and real client IP resolution**: When exposing a webhook to the public internet, especially for systems running on home networks, it is crucial to restrict who can call it. The pattern here is to configure a `trusted_networks` allowlist (with sensible defaults like Telegram’s official IP ranges) and then use `get_real_ip(request)` combined with `ip_network` membership checks to accept or reject requests. This helps mitigate abuse if the endpoint URL is discovered.\n\n3. **Leverage framework configuration (base_url) to build callback URLs**: Rather than asking users to provide full webhook URLs, the integration uses the framework’s own configuration (e.g., `hass.config.api.base_url` plus a known path) to construct the correct callback URL. This reduces configuration friction and avoids mismatches between the configured base URL and the webhook registered with the external service.\n\n4. **Validate incoming payloads defensively and fail with clear HTTP errors**: Incoming webhook JSON is parsed carefully, with `try/except` around `request.json()` and collection access. Clear HTTP error codes (400 for bad JSON or invalid user, 401 for unauthorized source IP) are returned, and non-command updates are quietly ignored. This pattern keeps the webhook robust against malformed or unexpected payloads.\n\n5. **Keep dependencies explicit and shared where appropriate**: The new component declares the same `python-telegram-bot` version as notify.telegram, and the requirement is documented in requirements_all via comments and a generator script. Using a shared library across components keeps behavior consistent and avoids version drift.\n\n6. **Extend notification channels with richer UI constructs via optional data payloads**: The keyboard support in notify.telegram shows a pattern of allowing extra structured data in notification calls (e.g., `data: { keyboard: ... }`). The notification handler inspects `data`, branches on the attribute (photo, document, keyboard, etc.), and delegates to specialized methods. This pattern can be reused to add buttons, inline keyboards, or other rich features to notifications in a backwards-compatible way.\n\n7. **Event payload design for command systems**: For chat- or command-based integrations, representing messages as `{command, args, user_id}` is a clean abstraction. `command` holds the first token (e.g., `/siren`), while `args` aggregates the rest. Automation templates can then use `trigger.event.data.args` to parameterize actions.\n\nTaken together, this PR serves as a blueprint for building webhook-based integrations that are secure (IP filtered), aligned with the host framework’s model (events, not states), easy to configure (auto-derived URLs), and user-friendly (keyboard support).",
        "procedural_memory": [
            "Step-by-step instructions on how to design, implement, and secure a webhook-based command integration similar to telegram_webhooks:",
            "Step 1: Define the integration's configuration schema.\n- Decide what parameters users must provide (e.g., API key, allowed user IDs, optional trusted networks).\n- Use a validation library (e.g., voluptuous) to define a schema under the component's DOMAIN:\n  - Optional API key (no need for a dummy default; omit if not configured).\n  - Required mapping of friendly names to numeric user IDs (e.g., `user_id: { alias: 12345 }`).\n  - Optional `trusted_networks` with a default of official service IP ranges, converted to ip_network objects.",
            "Step 2: Declare dependencies and requirements.\n- Set `DOMAIN`, `DEPENDENCIES` (e.g., `['http']`), and `REQUIREMENTS` with the needed third-party library (`python-telegram-bot==X.Y.Z`).\n- Ensure requirements_all or equivalent is updated via the canonical generation mechanism (e.g., via component comments + generator script) rather than manual edits.",
            "Step 3: Implement setup() to register the webhook URL with the external service.\n- In `setup(hass, config)`, extract the component's config subset (e.g., `conf = config[DOMAIN]`).\n- If an API key is present:\n  - Instantiate the client (e.g., `telegram.Bot(conf[CONF_API_KEY])`).\n  - Fetch current webhook configuration (`getWebhookInfo()` or equivalent).\n  - Compute the expected handler URL from the framework's base URL plus a fixed path, e.g. `handler_url = hass.config.api.base_url + '/api/telegram_webhooks'`.\n  - If the registered webhook URL differs, call `setWebhook(handler_url)` and log success or failure.\n- Register the HTTP view using the framework's HTTP subsystem (e.g., `hass.http.register_view(BotPushReceiver(...)))`.",
            "Step 4: Implement the HTTP view to handle incoming webhooks.\n- Subclass the framework's HTTP view base (e.g., `HomeAssistantView`).\n- Set `requires_auth = False` and static `url` and `name` attributes for your webhook path.\n- In the constructor, pre-process configuration:\n  - Store `trusted_networks` as a list of ip_network objects.\n  - Build a mapping for allowed user IDs (e.g., `{telegram_id: alias}`).\n- Implement an `async def post(self, request)` or `@asyncio.coroutine def post(...)` method that:\n  1. Determines the real client IP using the framework utility (e.g., `get_real_ip(request)`).\n  2. Rejects requests whose IP does not belong to any network in `trusted_networks` with HTTP 401.\n  3. Parses `await request.json()` and safely navigates to the relevant payload fields (`data['message']`, `data['from']['id']`, `data['text']`).\n  4. Validates:\n     - That the payload is well-formed; return HTTP 400 for malformed JSON.\n     - That the user ID is in the allowed users mapping; return HTTP 400 for invalid users.\n     - That the incoming text represents a command (e.g., starts with `/`); if not, log and return an empty JSON response.\n  5. On valid commands, split the text into command and arguments and fire an internal event on the framework’s event bus.",
            "Step 5: Fire framework events instead of altering state for transient actions.\n- Design an event name, e.g., `telegram.command`.\n- Decide on event payload structure, e.g.:\n  - `command`: the first token (e.g., `/siren`).\n  - `args`: string of remaining tokens joined by spaces (e.g., `\"10\"`).\n  - `user_id`: the numeric user ID from the message.\n- In the webhook handler, after validation:\n  - `pieces = data['text'].split(' ')`\n  - `hass.bus.async_fire(EVENT_TELEGRAM_COMMAND, { 'command': pieces[0], 'args': ' '.join(pieces[1:]), 'user_id': data['from']['id'] })`.\n- Avoid setting synthetic states for commands; reserve the state machine for persistent, queryable state.",
            "Step 6: Document how to use the new event in automations or equivalent workflows.\n- Provide examples of automations triggered by the event:\n  - A simple ping/pong:\n    - Trigger on `event_type: telegram.command`, `event_data: { command: '/ping' }`.\n    - Action: send a notification (`notify.telegram`) with message `pong`.\n  - A parameterized command using args:\n    - Trigger on `/siren`.\n    - Action: turn on siren, delay `{{ trigger.event.data.args }}` seconds, then turn it off.\n- Highlight how event_data can include user_id to restrict actions to specific users.",
            "Step 7: Extend an existing notifier to support advanced features (e.g., keyboards).\n- In the notification platform (e.g., notify.telegram), add a new attribute constant for the feature (`ATTR_KEYBOARD = 'keyboard'`).\n- In `send_message`, inspect the `data` payload:\n  - If `ATTR_PHOTO` is present, call `send_photo`.\n  - If `ATTR_DOCUMENT` is present, call `send_document`.\n  - If `ATTR_KEYBOARD` is present:\n    - Normalize `keys = data.get(ATTR_KEYBOARD)` to a list: `keys = keys if isinstance(keys, list) else [keys]`.\n    - Call a helper `send_keyboard(message, keys)`.\n- Implement `send_keyboard` using the external library's constructs, e.g.:\n  - Build a nested list: `[[key.strip() for key in row.split(',')] for row in keys]`.\n  - Create a `ReplyKeyboardMarkup` and call `bot.sendMessage(chat_id=..., text=message, reply_markup=keyboard)`.\n- Wrap send calls in try/except for library-specific errors and log exceptions without crashing the worker.",
            "Step 8: Harden and clean up the implementation.\n- Remove redundant returns inside exception handlers where the caller does not depend on return values.\n- Extract repeated string constants (handler paths, event names, attribute names) to module-level constants.\n- Use Pythonic list/dict comprehensions (e.g., dict comprehensions instead of list-of-tuples) for clarity.\n- Ensure style adheres to project guidelines (names, logging messages, line length), and run linters/CI.",
            "Step 9: Optionally skip test coverage for the HTTP/webhook component if testing is impractical.\n- If tests are not yet feasible (e.g., due to external webhook callbacks), add the component file path to a coverage omit list (e.g., `.coveragerc`).\n- Plan for future tests that can mock HTTP requests and event bus behavior.",
            "Step 10: Communicate constraints and deployment requirements in documentation.\n- Clearly state that the webhook functionality requires the host system to be accessible from the public internet at the configured `base_url` (with proper port forwarding and TLS if applicable).\n- Explain that the component auto-registers the webhook with the external service using this `base_url`, and that trusted networks provide an additional security layer.\n- Document how to configure user IDs, trusted networks, and sample automations using the new events and keyboard features."
        ]
    }
}
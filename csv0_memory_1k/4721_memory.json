{
    "search_index": {
        "description_for_embedding": "Added forecast support to Home Assistant's weather component and OpenWeatherMap platform, including a standardized forecast attribute structure, unit-aware temperature handling, throttled forecast fetching, demo data, and tests. Also fixed mutation of platform-provided forecast data when converting temperatures for display.",
        "keywords": [
            "home-assistant",
            "weather component",
            "OpenWeatherMap",
            "forecast support",
            "forecast attribute",
            "temperature conversion",
            "unit system",
            "Throttle",
            "demo weather platform",
            "state_attributes",
            "data mutation",
            "pyowm"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant weather component was extended to support forecast data, and the OpenWeatherMap (OWM) weather platform was updated to expose this forecast to the frontend.\n\nPreviously, the weather entities only exposed current conditions (temperature, humidity, pressure, etc.) and the OpenWeatherMap weather platform did not provide forecast information. The goal was to add a `forecast` attribute to weather entities so the frontend could render forecast graphs and cards using a consistent structure.\n\nThe implementation introduced a new `ATTR_FORECAST` attribute on the weather component, along with `ATTR_FORECAST_TEMP` (`temperature`) and `ATTR_FORECAST_TIME` (`datetime`) to standardize the forecast entry schema. The base `WeatherEntity` class gained a `forecast` property and was updated so `state_attributes` includes the forecast array when present.\n\nOn the OpenWeatherMap side, the platform was updated to always fetch both current and forecast weather data via the `WeatherData` helper class. Two throttled update methods were used: `update` for current conditions and `update_forecast` for forecast data, with separate `MIN_TIME_BETWEEN_UPDATES` (10 minutes) and `MIN_TIME_BETWEEN_FORECAST_UPDATES` (30 minutes). The forecast is retrieved using `three_hours_forecast_at_coords(...).get_forecast()` and then mapped into a list of dictionaries of the form `{ATTR_FORECAST_TIME: ISO timestamp, ATTR_FORECAST_TEMP: temp_in_celsius}`, using the pyowm API.\n\nTemperature units were handled carefully. The OpenWeatherMap platform now consistently treats its temperatures as Celsius (`temperature_unit` returns `TEMP_CELSIUS`, and forecast temperatures are read in Celsius). Conversion into the user's preferred unit (metric vs imperial) is centralized in the weather component's `_temp_for_display(temp)` method. For the current temperature, `state_attributes` calls `_temp_for_display(self.temperature)`; for forecasts, the weather component iterates over the forecast entries and converts each `ATTR_FORECAST_TEMP` before adding them to the exposed state.\n\nThe demo weather platform was also enhanced to provide synthetic forecast data so that the new forecast attribute could be exercised in the UI and in tests. It now accepts a forecast list of temperatures and constructs a list of forecast entries spaced 4 hours apart, each with `ATTR_FORECAST_TIME` and `ATTR_FORECAST_TEMP`.\n\nTests in `tests/components/weather/test_weather.py` were extended to verify that the forecast attribute is present on the demo weather entity, that it contains seven entries, and that the first and last forecast temperatures match the configured demo values (22 and 21), confirming both the data structure and conversion logic.\n\nFinally, an important bug-like behavior was addressed: previously, the forecast conversion loop in `WeatherEntity.state_attributes` mutated the forecast entries returned by the platform directly (modifying the original list/dicts). This could cause side effects if the platform or other parts of the code reused those structures. The fix copies each forecast entry (`forecast_entry = dict(forecast_entry)`) before adjusting its temperature for display, and assembles a new `forecast` list for exposure via `state_attributes`. This ensures the entity's public state does not accidentally mutate internal or platform-owned data.",
        "semantic_memory": "This change illustrates several generalizable patterns for designing and extending entity models in a home automation system and for safely transforming API data for presentation:\n\n1. **Standardized attribute schemas for extensibility**: Introducing constants like `ATTR_FORECAST`, `ATTR_FORECAST_TEMP`, and `ATTR_FORECAST_TIME` in a shared component module (here, the weather component) allows multiple platforms to expose forecast data in a common structure. This enables generic frontend components and tests to work across different integrations without platform-specific logic.\n\n2. **Base class hooks for optional features**: Adding a default `forecast` property to the base `WeatherEntity` class, returning `None` by default, creates a clear contract. Platforms that support forecasts override this property. The base class `state_attributes` implementation then handles including the forecast conditionally. This pattern generalizes to any optional capability (e.g., hourly data, air quality, UV index) in entity abstractions.\n\n3. **Centralized unit conversion and display logic**: Rather than letting each platform guess the correct output units, the system uses a canonical internal unit (Celsius for weather) and a shared helper (`_temp_for_display`) that looks at the current Home Assistant unit system to convert values. Centralizing conversion logic reduces duplicate code, avoids inconsistencies, and makes it easier to adapt or extend unit handling in the future.\n\n4. **Decoupling data retrieval from entity presentation**: The `WeatherData` helper encapsulates the interaction with the external API (pyowm) and handles throttling, while `OpenWeatherMapWeather` focuses on mapping that data to entity properties and attributes. This separation of concerns makes the code easier to reason about, test, and reuse.\n\n5. **Throttling external API calls**: Using a `Throttle` decorator with separate intervals for current conditions and forecast requests ensures rate limits are respected and reduces load. The concept of separate throttles per data-type (current vs forecast) is generally useful when external APIs have different refresh expectations or quotas for different endpoints.\n\n6. **Non-destructive transformation of platform data**: When preparing data for display, the component should not mutate structures owned by platforms or external libraries. Instead, it should copy the input data before applying transformations (like unit conversion). This avoids subtle bugs where modifications leak back into caches or other consumers that expect original values.\n\n7. **Demo integrations as reference & test drivers**: The demo weather platform is used as a reference implementation to exercise new attributes (forecast here). By updating demo data and writing tests against it, we gain a stable and deterministic environment for verifying core component behavior without relying on live APIs or devices. This pattern is broadly applicable for developing and validating frameworks and base classes.\n\n8. **Test coverage focused on base components**: Tests verify the generic weather component behavior (attribute presence, value conversion, and forecast structure) using the demo platform, rather than testing each third-party platform. This is an effective strategy when many platforms share the same component interface: ensure the base contract is correct and let platforms mostly reuse that logic.\n\nOverall, the fix showcases best practices for designing entity abstractions, managing units and external API data, and preventing unintended side effects when transforming data for UI consumption.",
        "procedural_memory": [
            "When adding a new optional attribute (like forecast) to an entity type with multiple platforms:",
            "Step 1: Define shared constants in the base component module for the new attribute and any nested fields (e.g., ATTR_FORECAST, ATTR_FORECAST_TEMP, ATTR_FORECAST_TIME).",
            "Step 2: Add a corresponding property to the base entity class (e.g., a `forecast` property in WeatherEntity) that returns None by default and has a clear docstring describing its contract.",
            "Step 3: Update the base entity's `state_attributes` method to include the new attribute when the property is not None. If you need to transform data for display (e.g., unit conversion), do it here in a centralized manner.",
            "Step 4: Ensure transformations in `state_attributes` are non-destructive: copy each platform-provided dict (e.g., `forecast_entry = dict(forecast_entry)`) before modifying values, especially when converting units or renaming keys.",
            "Step 5: In each platform implementation that supports the new feature, implement/override the new property to return data in the standardized structure defined by the shared constants. Keep platform logic focused on API interaction and mapping, not on presentation concerns.",
            "",
            "When integrating forecast data from an external weather API:",
            "Step 1: Encapsulate API calls in a helper class (e.g., WeatherData) that holds references to the API client and parameters (lat, lon, etc.).",
            "Step 2: Implement separate throttled methods using decorators or rate-limit logic (e.g., `@Throttle(MIN_TIME_BETWEEN_UPDATES)` for current conditions and `@Throttle(MIN_TIME_BETWEEN_FORECAST_UPDATES)` for forecast). This prevents hitting API rate limits while keeping data reasonably fresh.",
            "Step 3: In the entity's `update` method, call the helper's update methods (current and forecast) and then copy the results into entity attributes (e.g., `self.data` and `self.forecast_data`).",
            "Step 4: Map the external API's forecast objects into a simple, consistent Python structure (list of dicts). For each forecast entry, include only the fields the component needs (e.g., ISO datetime and temperature). Use component-level constants (like ATTR_FORECAST_TEMP) as keys.",
            "Step 5: Normalise API data into a canonical internal unit (e.g., Celsius for temperature) so that all subsequent processing (including conversion for display) can be centralized and consistent.",
            "",
            "When handling temperature units and conversion in an entity framework:",
            "Step 1: Decide on an internal canonical unit (e.g., Celsius) for all platform integrations for a given domain.",
            "Step 2: In each platform, configure the external API or post-process the API response so that values are in the canonical unit.",
            "Step 3: Implement a helper method on the base entity (e.g., `_temp_for_display(temp)`) that inspects the global unit system (e.g., `hass.config.units.temperature_unit`) and converts the canonical-unit temperature to the configured unit.",
            "Step 4: Use this helper whenever you prepare temperatures for state attributes or UI (both current and forecast), rather than converting inside the platform.",
            "Step 5: Add tests that exercise both unit systems where possible to ensure conversions are correct.",
            "",
            "When extending a demo platform and writing tests for core entity behavior:",
            "Step 1: Enhance the demo platform to produce deterministic data for the new feature (e.g., a fixed list of forecast temperatures and timestamps). Keep time generation predictable where possible (or mock time in tests).",
            "Step 2: Structure the demo data using the same constants and format as real platforms (e.g., use ATTR_FORECAST_TEMP and ATTR_FORECAST_TIME as keys).",
            "Step 3: Write tests against the component using the demo platform to verify that the new attribute appears on the entity, has the expected length, and that specific entries match expected values (e.g., first and last forecast temperatures).",
            "Step 4: Also test that existing attributes (temperature, humidity, attribution, etc.) remain correct, ensuring that the new feature did not regress existing behavior.",
            "",
            "When guarding against unintended data mutation in shared code:",
            "Step 1: Identify where shared or platform-provided data structures are being passed into generic code (e.g., `forecast` returned by a platform).",
            "Step 2: Before transforming these structures for display (e.g., converting units), create copies of the relevant objects (e.g., `forecast_entry = dict(forecast_entry)` for dicts, or list comprehensions generating new lists).",
            "Step 3: Apply transformations (such as unit conversion) to the copies only.",
            "Step 4: Assemble the transformed copies into a new list or dict and return that from the generic method (e.g., `state_attributes`) instead of reusing the original structures.",
            "Step 5: If feasible, add tests that indirectly verify that calling `state_attributes` multiple times does not further modify internal state or double-convert values."
        ]
    }
}
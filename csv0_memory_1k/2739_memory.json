{
    "search_index": {
        "description_for_embedding": "Remote SSH runner (ParamikoSSHClient) always opened an SFTP session on connect, which failed under Cygwin/Windows even when only running commands without file transfer. Fix: make SFTP connection lazy via a property, only opening it when SFTP-dependent methods (put, exists, mkdir, etc.) are invoked, and update close logic and tests accordingly.",
        "keywords": [
            "ParamikoSSHClient",
            "ParamikoSSHRunner",
            "SFTP lazy initialization",
            "lazy SFTP connection",
            "remote runner",
            "StackStorm",
            "Cygwin Windows",
            "SSH client",
            "SFTP permission error",
            "optional resource initialization",
            "file upload download",
            "st2actions.runners.ssh.paramiko_ssh"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the StackStorm remote runner using Paramiko (ParamikoSSHClient/ParamikoSSHRunner) was always establishing an SFTP connection immediately after connecting over SSH. This design worked on typical Unix-like environments but caused failures under Cygwin on Windows, where SFTP was either unsupported or required extra permissions. Crucially, many uses of the remote runner do not need SFTP at all (e.g., running simple shell commands), yet the unconditional SFTP setup made those use cases break on Cygwin.\n\nThe root cause was that `connect()` called `self.client.open_sftp()` unconditionally, so any platform-specific SFTP issues surfaced even when no file operations were requested. Closing logic and internal naming also assumed that the SFTP session always existed.\n\nThe fix introduced lazy SFTP initialization. The `ParamikoSSHClient` class was refactored to use `self.sftp_client` as the actual storage and expose an `@property sftp` that opens the SFTP session via `self.client.open_sftp()` only when the property is first accessed. The `connect()` method no longer opens SFTP eagerly. The `close()` method was updated to check `self.sftp_client` and close it only if it exists. This ensures that simple command execution (`run`) does not attempt SFTP at all, while methods that truly require SFTP (`put`, `exists`, `mkdir`, etc.) still work by triggering the lazy initialization.\n\nAdditional unit tests were added in `st2actions/tests/unit/test_paramiko_ssh.py` to verify this behavior: that connecting and running a command does not create an SFTP client, that invoking SFTP-related operations does create it, that closing a client without an SFTP session does not raise, and that when SFTP is created, `close()` properly closes it. The change was reported by Cody A. Ray (st2contrib issue #505) and documented in the changelog as an improvement that also resolves the Cygwin-on-Windows issue.",
        "semantic_memory": "This fix illustrates a general best practice: optional or platform-sensitive subsystems (like SFTP on top of SSH) should be initialized lazily, only when needed, instead of eagerly during a broader connection setup. Eager initialization couples the availability of the optional subsystem to the success of the core operation, causing failures in environments where the optional subsystem is unavailable or restricted, even if the core functionality would have worked fine.\n\nKey generalizable concepts:\n\n1. **Lazy initialization of optional dependencies**: When a class manages multiple related resources (SSH plus SFTP, database plus cache, etc.), only create the resources that are actually needed for the requested operations. This limits failure surface and improves performance.\n\n2. **Cross-platform robustness**: Do not assume that all protocols or extensions (like SFTP in an SSH stack) are available or behave the same on all platforms. Design APIs so that features that may be unsupported are opt-in or lazy, and failures in those parts do not automatically break core features.\n\n3. **Safe shutdown of optionally-created resources**: When resources are lazily initialized, the teardown logic must treat them as optional. `close()` or cleanup routines should check if a resource exists before closing it to avoid `AttributeError` or similar issues.\n\n4. **Testing initialization behavior, not just functionality**: Unit tests should not only verify that methods work but also how and when supporting resources are created and destroyed. In this case, tests assert that calling `run()` does not create an SFTP client, but calling `put()`/`exists()`/`mkdir()` does, and that `close()` behaves correctly in both scenarios.\n\n5. **API design via properties**: Using a property (`@property sftp`) is an effective pattern for hiding lazy initialization behind a familiar attribute-like access pattern, making the calling code simpler while still deferring resource creation until necessary.",
        "procedural_memory": [
            "When diagnosing and fixing issues where optional sub-resources (like SFTP on top of SSH) cause failures even when not used, follow these steps:",
            "Step 1: Identify the failure surface.\n- Reproduce the issue on the affected platform (e.g., Cygwin/Windows).\n- Determine which operation the user is actually performing (e.g., simple SSH command vs file transfer).\n- Examine stack traces and logs to see if the failure originates from an auxiliary component (e.g., SFTP initialization) rather than the primary operation (SSH connection or command execution).",
            "Step 2: Inspect initialization flow.\n- Review the connection setup code (e.g., `connect()` or constructor) for unconditional creation of auxiliary resources (e.g., `open_sftp()`, opening extra sockets, starting background threads).\n- Map each auxiliary resource to the methods that actually require it (e.g., SFTP is only needed for `put`, `get`, `exists`, `mkdir`, etc.).",
            "Step 3: Decide what can be lazy.\n- For each auxiliary resource, decide if it must exist for all use cases, or only for specific methods.\n- If it is only needed for a subset of methods, mark it as a candidate for lazy initialization.",
            "Step 4: Implement lazy initialization.\n- Replace eager initialization with a lazy pattern:\n  - Store the resource in an internal attribute (e.g., `self.sftp_client = None`).\n  - Provide an accessor (often a `@property`) that checks if the attribute is `None` and creates it on first access (e.g., `if not self.sftp_client: self.sftp_client = self.client.open_sftp()`).\n- Remove any unconditional initialization from `connect()` or `__init__()` for that resource.",
            "Step 5: Update teardown logic.\n- Ensure `close()` or cleanup methods treat lazily-created resources as optional:\n  - Check if the resource attribute is not `None` before calling `close()` on it.\n- Keep the order of closing consistent and avoid assuming the resource was always created.",
            "Step 6: Write or update tests.\n- Add tests to assert that:\n  - After `connect()`, the auxiliary resource is still `None` if no resource-dependent methods were called.\n  - Calling core methods that do not need the resource (e.g., `run(cmd=...)`) does not create the resource.\n  - Calling methods that require the resource (`put`, `exists`, `mkdir`, etc.) does create it.\n  - Calling `close()` when the resource was never created does not raise errors.\n  - Calling `close()` after the resource has been created correctly closes it (e.g., assert `close()` call count on mocks).",
            "Step 7: Document behavior and platform impact.\n- Update changelogs or documentation to explain that the resource is now lazily created, and note any platform-specific issues this resolves (e.g., remote runner now works under Cygwin/Windows when SFTP operations are not used).",
            "Step 8: Validate on affected and unaffected platforms.\n- Re-test on the originally problematic platform to confirm that core functionality works when the auxiliary subsystem is not used.\n- Run existing tests on other platforms to ensure that functionality relying on the auxiliary subsystem still behaves correctly with lazy initialization."
        ]
    }
}
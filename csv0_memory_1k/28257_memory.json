{
    "search_index": {
        "description_for_embedding": "Fixes a KeyError in Home Assistant's MQTT climate component when using temperature_low_state_template and temperature_high_state_template in MQTT discovery by adding missing schema entries and tests to validate template-based state parsing and error logging.",
        "keywords": [
            "Home Assistant",
            "MQTT",
            "climate",
            "SCHEMA_BASE",
            "temperature_low_state_template",
            "temperature_high_state_template",
            "temp_low",
            "temp_high",
            "KeyError",
            "discovery",
            "config validation",
            "voluptuous",
            "cv.template",
            "payload parsing"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the MQTT climate integration in Home Assistant had a bug where using `temperature_low_state_template` and `temperature_high_state_template` caused a runtime KeyError when entities were set up via MQTT discovery. The root cause was that these two template options were referenced and supported conceptually, but were missing from the `SCHEMA_BASE` configuration validation schema in `homeassistant/components/mqtt/climate.py`. As a result, discovery messages that included these keys would not pass through the schema correctly and led to errors. The fix added the missing schema entries:\n\n- `vol.Optional(CONF_TEMP_HIGH_STATE_TEMPLATE): cv.template`\n- `vol.Optional(CONF_TEMP_LOW_STATE_TEMPLATE): cv.template`\n\nThis aligns them with the existing `*_state_topic` and `temp_state_template` fields.\n\nTo prevent regression, a new test was added in `tests/components/mqtt/test_climate.py` named `test_set_target_temperature_low_high_with_templates`. This test:\n\n1. Sets up a climate entity using `temperature_low_state_topic`, `temperature_high_state_topic`, and their corresponding templates that extract `temp_low` and `temp_high` from a JSON payload.\n2. Publishes a valid MQTT message: `{\"temp_low\": \"1031\", \"temp_high\": \"1032\"}` to the shared \"temperature-state\" topic and asserts that `target_temp_low` and `target_temp_high` on the climate entity are correctly parsed as 1031 and 1032.\n3. Publishes an invalid payload (`\"-INVALID-\"`) and asserts that a log message about failing to parse the temperature is present, while the previously valid target temperatures remain unchanged.\n\nAlong the way, the contributor fixed minor issues in the test (indentation, docstring text, and a typo from `target_temp_hight` to `target_temp_high`) and confirmed the test suite passed with `tox`. This PR resolves the functional KeyError and adds coverage ensuring template-based high/low temperature parsing behaves correctly and robustly for invalid input.",
        "semantic_memory": "This case illustrates a frequent class of bugs in configuration-driven systems: missing or incomplete schema definitions for supported configuration options. When a config/value is conceptually supported (e.g., templates for high/low temperature in an MQTT climate entity) but the validation schema does not include it, you can get runtime errors, unexpected KeyErrors, or silent failures at discovery or load time.\n\nKey takeaways:\n\n- **Schema consistency is critical**: Whenever new configuration keys are introduced or documented, they must be added to the schema/validation layer (e.g., Voluptuous schemas in Home Assistant) with correct types (`cv.template`, `valid_publish_topic`, `valid_subscribe_topic`, etc.). Even optional keys require explicit schema entries.\n\n- **Discovery and dynamic config paths are brittle to missing schema fields**: MQTT discovery relies on parsing config payloads and validating them. If a field is missing from the schema but present in the payload, the integration may crash or ignore the field. Tests should mimic realistic discovery payloads to catch this.\n\n- **Template-based parsing needs robust error handling**: When using Jinja or similar templates to extract values from MQTT payloads, code should handle invalid payloads gracefully: log the parsing error and keep the last known good state instead of overwriting with invalid data.\n\n- **Tests should cover both success and failure paths**: For template-handled fields, tests should validate (1) correct parsing of valid payloads into entity attributes and (2) behavior on invalid payloads, including logging and state immutability.\n\n- **Minor details matter**: Typos in attribute names (e.g., `target_temp_hight` vs. `target_temp_high`) or docstrings can obscure the intent and cause confusion or test failures. Keeping tests clean and consistent reduces friction for contributors and reviewers.\n\nOverall, the pattern is: configuration keys must have a consistent lifecycle—documented, validated by schema, consumed by logic, and verified by tests—especially in systems that use dynamic/discovery-based configuration like MQTT.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the error by enabling debug logs and using the problematic configuration or discovery payload. For MQTT/Home Assistant, configure the entity with the suspected keys (e.g., `temperature_low_state_template`, `temperature_high_state_template`) and trigger MQTT discovery or entity setup. Observe any KeyError, validation error, or missing behavior.",
            "Step 2: Inspect the integration's configuration schema. Locate the schema definition (e.g., `SCHEMA_BASE` in the relevant component file) and verify that all documented or used config keys (topics, templates, etc.) are present. Pay special attention to optional fields that might have been added later but not reflected in the schema.",
            "Step 3: Compare code paths vs. schema. Search where the config keys are referenced (e.g., `CONF_TEMP_LOW_STATE_TEMPLATE`, `CONF_TEMP_HIGH_STATE_TEMPLATE`) in the code. If the code expects values for these keys but the schema does not define them, this mismatch is likely the source of KeyErrors or missing functionality.",
            "Step 4: Add or correct schema entries. For each missing key, add an appropriate schema line with the correct Voluptuous or validation helper type. For example, in Home Assistant: use `vol.Optional(CONF_SOME_TEMPLATE): cv.template` for template strings, and `mqtt.valid_subscribe_topic`/`mqtt.valid_publish_topic` for MQTT topics.",
            "Step 5: Implement or extend tests to cover the feature. Write a test that sets up a minimal configuration including the newly-added config keys. For template-based MQTT fields, simulate incoming MQTT messages with both valid and invalid payloads and assert that entity attributes and logs reflect the expected behavior.",
            "Step 6: Validate error handling behavior. In tests, send an invalid payload (wrong type, invalid JSON, or incompatible structure) and assert: (a) a clear log message is emitted indicating the parse failure, and (b) the previously valid state remains unchanged. This ensures robustness against malformed messages.",
            "Step 7: Run the test suite and fix any issues. Execute the relevant test suite (e.g., `tox` in Home Assistant). Address failures, including subtle issues like attribute name typos (e.g., `target_temp_high` vs `target_temp_hight`) and indentation/formatting problems in tests, which can prevent tests from actually running.",
            "Step 8: Re-test with real configuration or discovery. After schema and tests are updated, rerun Home Assistant (or the target system) with the original discovery payload or configuration. Confirm that there is no KeyError, the entity initializes correctly, and template-based values are parsed into the correct attributes.",
            "Step 9: Update documentation if needed. Ensure that any newly supported or fixed configuration keys are accurately documented, including their types (string, template, topic) and example usages, so users can configure them correctly and avoid similar issues in the future."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant panel_custom backend was extended to support JavaScript ES modules via a new module_url option, alongside existing js_url and webcomponent_path. The configuration schema was updated with a voluptuous Exclusive group so only one of these URL options can be specified, and tests were added to verify both successful module configuration and failure on conflicting URL options.",
        "keywords": [
            "home assistant",
            "panel_custom",
            "custom panel",
            "javascript module",
            "ES module",
            "module_url",
            "js_url",
            "webcomponent_path",
            "voluptuous",
            "vol.Exclusive",
            "configuration validation",
            "frontend panel",
            "async_setup_component"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant backend for custom panels (panel_custom component) was enhanced to support JavaScript ES modules as a first-class option. Previously, custom panels could be defined either by a webcomponent_path (HTML file) or a js_url (plain script). There was no way for the backend to distinguish ES modules, even though the frontend was gaining module support.\n\nTo solve this, a new configuration key CONF_MODULE_URL ('module_url') was introduced. The async_register_panel function was extended with a module_url parameter, and custom_panel_config now forwards either 'js_url' or 'module_url' into the panel’s _panel_custom config, depending on what was provided.\n\nThe configuration schema was updated using voluptuous: CONF_WEBCOMPONENT_PATH, CONF_JS_URL, and CONF_MODULE_URL were placed in a shared Exclusive group (CONF_URL_EXCLUSIVE_GROUP) with a clear error message: 'Pass in only one of webcomponent_path, module_url or js_url'. This ensures that YAML configuration cannot specify more than one of these URL sources at the same time. On the runtime side, async_setup was updated so that when parsing each panel, it sets either js_url or module_url in the kwargs passed to async_register_panel, never both.\n\nSeveral tests were adjusted and added. The existing JS panel test was updated to remove the obsolete js_is_module flag. A new async test_module_webcomponent verifies that a configuration with 'module_url': '/local/bla.js' produces a panel whose _panel_custom block contains 'module_url', correct name, embed_iframe, and trust_external values, and that the panel is correctly registered and accessible via its frontend_url_path. Another async test (test_url_option_conflict, later renamed to test_url_option_conflict) iterates over configurations that specify multiple URL options (module_url + js_url, webcomponent_path + js_url, webcomponent_path + module_url + js_url) and asserts that async_setup_component returns False for each, confirming that invalid combinations are rejected by the schema.\n\nThere was some churn in the tests (e.g., attempts to use assert_setup_component, mixing sync/async patterns, and various corrections), but the final state cleanly tests both the positive path (module_url works) and the negative path (conflicting URL options fail).",
        "semantic_memory": "When extending a configuration-driven system with new alternative input options, it is crucial to enforce mutual exclusivity between related parameters, maintain clear validation errors, and keep both backend and frontend in sync.\n\nKey generalizable lessons:\n\n1. **Mutually exclusive configuration options**: When multiple options represent alternative ways to specify the same underlying resource (e.g., webcomponent_path, js_url, module_url), they should be modeled as mutually exclusive in the schema. Libraries like voluptuous provide vol.Exclusive groups for this purpose. This avoids ambiguous or conflicting configurations and moves failure detection to load time instead of runtime.\n\n2. **Backward-compatible extension of APIs**: Adding a new option (module_url) to an existing API (async_register_panel) should be done in a way that keeps existing code working: add the parameter as optional, keep existing validation logic but broaden it to include the new option, and ensure that any new branch doesn’t change behavior for existing callers (js_url and webcomponent_path already work as before).\n\n3. **Consistent propagation of new config fields**: Introducing a new configuration key requires consistent handling at all layers: validation schema, data parsing in async_setup, runtime registration (async_register_panel), and the internal structure passed to other subsystems (e.g., the _panel_custom block for the frontend). Forgetting any layer results in partially supported features or hidden bugs.\n\n4. **Negative tests for invalid configs**: It’s not enough to test the happy path; especially when adding validation logic, explicit tests for invalid configurations (e.g., specifying both module_url and js_url) ensure that the system fails predictably and that future refactors don’t relax constraints by accident.\n\n5. **Module vs script distinction**: When supporting modern JavaScript, backends often need to differentiate between classic scripts and ES modules, even if both are \"just URLs\" from the backend perspective. A dedicated field (module_url) makes this explicit and allows the frontend or client to choose the correct loading mechanism (e.g., script type=\"module\"). This pattern applies broadly to any situation where different client behaviors are needed for different resource types.",
        "procedural_memory": [
            "When adding a new alternative URL-type configuration option and ensuring it integrates correctly and safely, follow these steps:",
            "Step 1: Identify existing configuration options that represent alternative paths to the same resource (e.g., webcomponent_path, js_url). Decide how the new option (e.g., module_url) fits conceptually: is it mutually exclusive, or can it be combined?",
            "Step 2: Update the configuration schema to enforce mutual exclusivity. With voluptuous, create a group name (e.g., CONF_URL_EXCLUSIVE_GROUP) and wrap each alternative key in vol.Exclusive(key, group, msg=MSG_URL_CONFLICT). Ensure the conflict message clearly explains the allowed combinations.",
            "Step 3: Adjust runtime validation logic. In any API or registration function (like async_register_panel), update parameter lists to include the new option with a sensible default (e.g., module_url=None). Update ValueError checks so that at least one of the alternatives is required, and prohibit combinations that are not allowed (e.g., html_url combined with either js_url or module_url).",
            "Step 4: Propagate the new option through the setup pipeline. When parsing the user’s configuration in async_setup or similar, translate YAML keys into the appropriate keyword arguments. Ensure only one of js_url/module_url/webcomponent_path is passed downstream by using if/elif chains rather than independent if checks.",
            "Step 5: Update the internal representation passed to clients or other subsystems. Wherever a config block is constructed (e.g., custom_panel_config['_panel_custom']), add the new field (module_url) so that consumers such as the frontend can detect and handle ES modules appropriately.",
            "Step 6: Write or update positive-path tests. Add tests that configure only the new option (module_url) and assert that the component sets up successfully, that the panel is registered, and that the resulting config structure contains the expected module_url and flags (embed_iframe, trust_external, etc.).",
            "Step 7: Write negative-path tests for conflicting configs. Create test cases that specify multiple mutually exclusive URL options in the configuration (e.g., module_url + js_url, webcomponent_path + js_url, webcomponent_path + module_url + js_url). For each, call async_setup_component (or equivalent) and assert that it returns False or otherwise signals failure, confirming that the schema validation is effective.",
            "Step 8: Run the full test suite and linting/CI checks (e.g., tox) to ensure that the new changes don’t break unrelated code and that style/line-length guidelines are followed (especially around long error message strings).",
            "Step 9: Coordinate with frontend and documentation. Ensure that any new backend config option (e.g., module_url) is supported by the frontend code that actually loads panels, and update user-facing documentation with configuration examples so users know when to use js_url versus module_url."
        ]
    }
}
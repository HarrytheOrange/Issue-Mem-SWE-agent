{
    "search_index": {
        "description_for_embedding": "Home Assistant's Zillow Zestimate sensor started failing when the Zillow API stopped returning the 'valueChange' and other optional fields in its XML response. The fix made the sensor robust by checking for key existence and non-None values before accessing nested fields in the parsed response.",
        "keywords": [
            "Home Assistant",
            "Zestimate",
            "Zillow",
            "sensor",
            "API change",
            "XML parsing",
            "KeyError",
            "missing field",
            "valueChange",
            "optional fields",
            "defensive coding"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant integration for Zillow's Zestimate began failing after Zillow modified their API responses. Previously, the integration assumed certain XML fields were always present, including 'amount', 'last-updated', 'valueChange', and 'valuationRange'. When Zillow stopped sending at least 'valueChange' (and potentially other fields) for some properties, the code still executed statements like `details[ATTR_CHANGE] = int(data['valueChange']['#text'])`, which caused KeyError exceptions during the sensor update. The fix updated `homeassistant/components/zestimate/sensor.py` so that the `update` method no longer assumes these keys exist. Instead, it now does guarded access:\n\n- It initializes `details = {}`.\n- For each piece of data, it first checks that the key is present and non-None, e.g. `if 'amount' in data and data['amount'] is not None: ...`, and only then reads nested values and populates the details dict.\n\nThis prevents the sensor from crashing when the API omits fields like `valueChange` or `valuationRange`, while still populating any attributes that are available. The root cause was a third-party API change that removed or made optional fields the integration had treated as mandatory; the solution was to add defensive checks around all optional response fields.",
        "semantic_memory": "This case illustrates a common reliability issue when integrating with third-party APIs: assuming that specific fields will always be present in responses. APIs evolve, fields become optional or are deprecated, and integrations that access nested data without checks can start throwing exceptions (e.g., KeyError, TypeError) as soon as the remote service changes its schema.\n\nGeneralizable lessons:\n- Treat remote API fields as potentially optional unless the provider guarantees otherwise with strong contracts. Even then, be defensive.\n- When parsing nested dictionaries (from JSON or XML-to-dict conversions), avoid direct indexing like `data['field']['sub']` without verifying that `'field'` exists and is not None.\n- Use patterns like `'key' in data and data['key'] is not None` or `value = data.get('key')` and check for truthiness before drilling further.\n- Design integrations so that missing optional data results in partially populated objects or attributes, not hard failures or unhandled exceptions.\n- When a third-party API changes, fixing the integration often involves making the parsing code tolerant of absent or differently structured fields rather than assuming the old schema.\n\nThe broader best practice is defensive response parsing: validate presence and type of external data before using it, and degrade gracefully when parts of the payload are missing.",
        "procedural_memory": [
            "When an integration that consumes a third-party API starts failing (especially suddenly, without local code changes), suspect an upstream API change and inspect how you parse the response.",
            "Step 1: Reproduce and capture the failing response.\n- Enable logging around the integration's update or request path.\n- Log the raw response (or a redacted version) from the third-party API.\n- Compare the current response structure to what the code assumes (e.g., older logs, documentation, or tests).",
            "Step 2: Identify direct dictionary indexing on external data.\n- Search the integration code for patterns like `data['someField']` and `data['someField']['nested']` on objects that originate from JSON/XML responses.\n- Pay special attention to fields mentioned in related bug reports (here, `valueChange`, `amount`, `valuationRange`, etc.).",
            "Step 3: Determine which fields are optional or newly missing.\n- From the captured response, note which keys are absent or sometimes None.\n- Cross-check with the provider's current API documentation: fields may have become optional, renamed, or removed.",
            "Step 4: Add defensive checks before accessing nested data.\n- Replace unsafe access:\n  - Before: `details[ATTR_CHANGE] = int(data['valueChange']['#text'])`\n  - After: `if 'valueChange' in data and data['valueChange'] is not None: details[ATTR_CHANGE] = int(data['valueChange']['#text'])`\n- Do the same for each field that may be missing, e.g. `amount`, `last-updated`, `valuationRange`.\n- Initialize a local result dict (e.g., `details = {}`) and only populate keys when the source data is present.",
            "Step 5: Ensure the rest of the code can handle partially populated data.\n- Review consumers of the parsed structure (e.g., properties, templates, or state attributes) to confirm they can handle missing attributes without failing.\n- Avoid assuming all attributes will be present; treat them as optional metadata.",
            "Step 6: Add or update tests to cover missing-field scenarios.\n- Create unit tests that feed the parser with responses lacking the previously-mandatory fields (e.g., no `valueChange`, no `valuationRange`).\n- Assert that the integration:\n  - Does not raise exceptions during update.\n  - Still sets available attributes correctly.\n  - Leaves missing attributes absent or None as desired.",
            "Step 7: Deploy and monitor.\n- Deploy the fix and monitor logs for a period to ensure the integration no longer throws KeyError/TypeError for missing fields.\n- Optionally add temporary additional logging around newly-guarded fields to confirm how often they are absent and whether further schema changes need handling."
        ]
    }
}
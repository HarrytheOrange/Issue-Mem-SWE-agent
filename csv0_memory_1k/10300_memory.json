{
    "search_index": {
        "description_for_embedding": "Home Assistant Tradfri integration updated for Ikea's new DTLS/PSK authentication model. Switched from a hardcoded identity and static API key to per-installation dynamic identities with generated PSK tokens via pytradfri 4.x APIFactory. Credentials are stored in a hidden config file and reconfiguration is triggered automatically when stored credentials fail, avoiding the need to reset the Tradfri gateway when pairing with a new Home Assistant instance.",
        "keywords": [
            "homeassistant",
            "IKEA Tradfri",
            "tradfri component",
            "pytradfri 4.0.1",
            "DTLS",
            "PSK",
            "aiocoap",
            "APIFactory",
            "dynamic identity",
            "gateway pairing",
            "authentication failure",
            "configuration flow",
            "discovery integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "The Tradfri component in Home Assistant originally used a hardcoded DTLS identity string (\"homeassistant\") and stored a single key in tradfri.conf, reflecting an older Ikea gateway authentication model. With Ikea's newer per-client DTLS PSK approach, this design caused problems: pairing was tied to the hardcoded identity, so if a user installed a new Home Assistant instance or wanted multiple instances, the gateway would refuse new pairings unless it was reset. Additionally, the component accepted credentials in YAML config but did not handle invalid or expired credentials by prompting reconfiguration.\n\nTo address this, the pull request updated the Tradfri integration to use pytradfri 4.0.1 and its aiocoap APIFactory API. During configuration, instead of reusing a fixed identity, the code now generates a unique identity using uuid4().hex for every configuration attempt. It then calls APIFactory(host, psk_id=identity).generate_psk(security_code) to obtain a PSK token from the gateway. The gateway connection is established using APIFactory(host, psk_id=identity, psk=token, loop=hass.loop). On success, the pair (identity, token) is stored per host in a hidden config file, .tradfri_identity.conf, under the Home Assistant config directory.\n\nThe configuration schema was simplified: CONF_API_KEY is removed from YAML, and the only required user input is the security code printed on the bottom of the Ikea Tradfri gateway, entered via Home Assistant's configurator. For discovery-based setups, when a gateway is found, the component checks the hidden config file for stored credentials. If present, it uses those; otherwise, it triggers the configurator to ask for the security code. For manual host configuration, async_setup now reuses the same gateway_discovered logic by calling it directly with the configured host, avoiding duplicated code.\n\nTo improve resilience, _setup_gateway was refactored to accept identity and token parameters. If a RequestError or any exception occurs during gateway_info retrieval (for example, due to invalid or outdated credentials), the component logs the failure, triggers a reconfiguration by invoking request_configuration again, and returns False instead of failing silently. This ensures that wrong or stale credentials stored in the hidden config file lead to a guided re-pairing workflow rather than leaving the integration broken. The user who contributed the later commits noted that a remaining edge case is an apparent loop when entering an incorrect security code repeatedly, but the core fix—dynamic identities, token-based authentication, hidden credential storage, and automatic reconfiguration on failure—is implemented.",
        "semantic_memory": "This fix illustrates several general principles for handling evolving authentication schemes and device integrations:\n\n1. **Do not hardcode client identities in per-device authentication protocols.** When a device or service uses per-client DTLS/PSK or similar mechanisms, tying the integration to a fixed identity (e.g., 'homeassistant') can make it impossible to pair new installations or multiple instances without resetting the device. Instead, generate unique identities per installation or per configuration attempt, and store them alongside their corresponding credentials.\n\n2. **Adapt integrations when upstream APIs or protocols evolve.** Ikea's Tradfri gateway moved to a model where clients must obtain per-identity PSKs via a pairing step. Libraries like pytradfri encapsulate this via new APIs (APIFactory, generate_psk). Integrations must be updated to use these APIs rather than treating the original security code as a static key.\n\n3. **Separate transient pairing secrets from long-lived tokens.** The security code printed on the device is used only to derive a per-identity PSK token. That token, not the original security code, should be stored for subsequent connections. This reduces what needs to be persisted and aligns with the device's intended security model.\n\n4. **Store sensitive credentials in dedicated, preferably hidden, configuration files.** Instead of keeping tokens in the main configuration or YAML, storing them in a hidden file (e.g., .tradfri_identity.conf) reduces clutter and makes it clearer which data is generated and managed by the integration. It also allows more flexible, per-host credential management.\n\n5. **Handle credential failure by initiating reconfiguration, not by hard failing.** When an integration's stored credentials become invalid (e.g., due to resets, firmware updates, or user changes), the integration should catch errors from the API (like RequestError), log them meaningfully, and guide the user back into a pairing or login flow. This avoids a broken state where the integration silently stops working.\n\n6. **Unify discovery and manual configuration flows.** Rather than maintaining separate code paths for discovered vs. manually configured devices, it's cleaner to centralize the logic (for example, by calling the discovery handler with a synthetic event for manually configured hosts). This reduces duplication and the risk of behavior drift.\n\n7. **Prefer explicit identity+token models over opaque single 'key' fields.** Conceptually separating an 'identity' (client ID) and its associated 'token' (PSK or credential) makes it easier to reason about authentication, rotate credentials, and adapt to changes in underlying protocols.\n\nThese practices apply broadly to integrations with IoT devices, cloud services, and any system that uses per-client credentials and pairing workflows.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues related to evolving device authentication and pairing flows:",
            "Step 1: Detect symptoms of outdated or rigid authentication.",
            "- Look for user reports that they must reset a device (e.g., gateway, hub) whenever they reinstall or move the controlling application, or that multiple instances cannot connect simultaneously.",
            "- Check whether credentials are hardcoded or shared across installations (e.g., a fixed identity string or a single static key).",
            "- Review logs for recurring authentication or handshake failures after device firmware updates or library version bumps.",
            "Step 2: Investigate the upstream protocol and library changes.",
            "- Read the device's current API/protocol documentation to understand the intended authentication model (e.g., per-client DTLS PSK, OAuth client IDs, pairing codes).",
            "- Inspect the changelog of the integration's underlying library (here: pytradfri) for new abstractions (e.g., APIFactory, generate_psk) that support the updated authentication flow.",
            "- Confirm whether the 'key' being used is a one-time pairing secret or a long-lived credential; designs often change over time.",
            "Step 3: Redesign the credential model in your integration.",
            "- Replace any hardcoded client identities with dynamically generated identifiers, such as UUIDs, ideally per installation or per pairing attempt.",
            "- Separate the concepts of 'identity' (client ID) and 'token' (secret/PSK), reflecting how the upstream protocol expects clients to authenticate.",
            "- Ensure the integration can store and retrieve the identity+token tuple per device/host instead of a single opaque key.",
            "Step 4: Implement the new pairing flow.",
            "- Use the updated library APIs (e.g., APIFactory(host, psk_id=identity).generate_psk(security_code)) to transform the device's printed or user-provided security code into a per-identity token.",
            "- After obtaining the token, construct authenticated clients using both identity and token (e.g., APIFactory(host, psk_id=identity, psk=token, loop=loop)).",
            "- Validate the credentials by making a simple, reliable API call (e.g., gateway.get_gateway_info()) and treating failures as pairing failures.",
            "Step 5: Persist credentials safely and cleanly.",
            "- Create a dedicated configuration file for generated credentials (e.g., .device_identity.conf) separate from user-editable configuration.",
            "- Store credentials keyed by host or device identifier, containing both the identity and token.",
            "- Consider using a hidden file or a dedicated credentials directory to reduce user confusion and accidental edits.",
            "Step 6: Integrate with discovery and manual configuration.",
            "- On device discovery, look up the host in the stored credentials; if found, use them to connect automatically.",
            "- If no credentials exist for the host, initiate a configuration or pairing UI flow prompting the user for the device's security code.",
            "- For manual host entries, reuse the same logic by calling the discovery handler (or equivalent) with the manually configured host to avoid duplicate code.",
            "Step 7: Handle invalid or expired credentials gracefully.",
            "- Wrap the initial connection and a simple API call in try/except blocks that catch the library's specific request/authorization errors.",
            "- On failure, log clear diagnostic messages and trigger the configuration/pairing flow again, informing the user that re-pairing is required.",
            "- Avoid infinite reconfiguration loops: ensure that failures during the pairing UI (e.g., user entering a wrong security code) are handled without repeatedly re-triggering the same UI step unnecessarily.",
            "Step 8: Update configuration schemas and documentation.",
            "- Remove obsolete configuration fields (e.g., legacy API keys) from YAML schemas or configuration files.",
            "- Document that the user must provide only the device's printed security code when first pairing; subsequent connections use the stored identity+token automatically.",
            "- Explain how to reset or re-pair the device if the credentials become invalid (e.g., delete the hidden credential file and restart pairing).",
            "Step 9: Test various scenarios.",
            "- Test first-time pairing via discovery and manual host configuration.",
            "- Test the behavior when credentials are removed or corrupted in the hidden file: the integration should prompt for reconfiguration, not crash.",
            "- Test multiple Home Assistant instances or reinstallation flows to confirm that unique identities allow pairing without resetting the gateway.",
            "- Test user entering incorrect security codes to ensure the UI error handling is reasonable and does not lock into an infinite loop."
        ]
    }
}
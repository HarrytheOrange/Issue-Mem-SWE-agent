{
    "search_index": {
        "description_for_embedding": "Updated napari to match npe2 schema changes: manifest contributions now use `display_name` instead of `name`, writer/widget objects expose `display_name`, and the built-in plugin id changed from `napari-builtins`/`builtins` to `napari`. Code and tests were updated to use the new fields and plugin ids, with fallbacks when npe2 is not installed.",
        "keywords": [
            "napari",
            "npe2",
            "schema change",
            "plugin manifest",
            "display_name vs name",
            "writer display_name",
            "widget display_name",
            "napari-builtins",
            "plugin id migration",
            "backwards compatibility",
            "test failures",
            "API change"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari needed to integrate final schema changes from npe2 (see napari/npe2#49). The npe2 plugin manifest and contribution API changed: contributions in YAML and npe2 objects now use `display_name` instead of `name` for human-readable labels, and the manifest plugin id for built-ins changed (from `napari-builtins`/`builtins` to `napari`, plus `svg` → `napari-svg`). As a result, existing code that referenced `contrib.name`, `writer.name`, `wdg_contrib.name`, and plugin ids like 'builtins' and 'svg' would no longer work correctly when npe2 was present, breaking plugin discovery and save operations.\n\nThe fix updated the built-in napari manifest (`builtins.yaml`) to replace `name` with `display_name` for writer contributions. The npe2 integration module (`napari/plugins/_npe2.py`) was adapted to use `display_name` instead of `name` when matching widgets and constructing UI titles for writers, and to surface widget display names instead of internal names in `widget_iterator`. The setuptools entry point in `setup.cfg` was updated so `napari.manifest` now exposes the manifest under the plugin id `napari` instead of `napari-builtins`.\n\nTests that referenced plugin ids and writer names were also updated. In multiple test modules (`test_layers_list.py`, `test_layer_save.py`, `test_save_layers.py`), the plugin names used when calling `layers.save()` and `save_layers()` were made conditional: if `npe2` imports successfully, the tests use 'napari' and 'napari-svg'; otherwise they fall back to the old 'builtins' and 'svg' plugin ids. This keeps the test suite working both with and without npe2 installed, easing the transition. There was some initial confusion about unrelated test failures triggered by a recent dask release, but those were acknowledged as separate from this schema-integration work.",
        "semantic_memory": "When an upstream plugin or configuration schema changes (e.g., npe2's manifest and contribution API), all dependent code paths that rely on those schema fields must be updated consistently. Human-facing labels are often renamed from generic `name` fields to more explicit `display_name` fields, and tests and UI logic that previously assumed `name` held a user-facing label must be updated.\n\nGeneralizable points:\n- Schema and API evolution in plugin systems often entails renaming fields (e.g., `name` → `display_name`) and changing plugin identifiers; this can silently break discovery, matching, and tests that use hard-coded ids or attribute names.\n- Backwards compatibility can be maintained by detecting the presence of the new system (here, trying to import `npe2`) and picking plugin ids or behaviors accordingly. This pattern lets the same codebase operate in environments with and without the new plugin engine.\n- Tests that depend on plugin names, entry points, or schema fields should mirror migration logic used in the application code, rather than hard-coding outdated identifiers.\n- Entry points and manifests are part of the API surface: renaming an entry point (e.g., `napari-builtins` → `napari`) requires synchronized changes in both configuration files and code/tests that refer to that entry point.\n- When exposing plugin or writer metadata in the UI, use the field intended for user display (`display_name`), not the internal identifier, and adapt to upstream changes in those semantics.",
        "procedural_memory": [
            "When tests or functionality break after an upstream plugin/schema update, systematically locate and update all references to changed fields and plugin ids, while maintaining compatibility if multiple versions must be supported.",
            "Step 1: Identify the upstream schema/API change.\n- Read the upstream release notes or linked issues/PRs (e.g., napari/npe2#49).\n- Determine exactly which fields or identifiers changed (e.g., `name` → `display_name`, plugin id migrations).",
            "Step 2: Search for usages of the old fields/ids in your codebase.\n- Grep for attribute and key names like `.name`, `name:`, or specific ids like 'builtins', 'napari-builtins', 'svg'.\n- Include manifests (YAML/JSON), plugin registration code, UI constructors, and tests in your search.",
            "Step 3: Update manifests and configuration files.\n- In plugin manifests (e.g., YAML), rename fields according to the new schema (e.g., `name` → `display_name`).\n- Update entry point definitions (e.g., in `setup.cfg`/`pyproject.toml`) to use the new plugin id if it has changed.\n- Verify that the new ids match what the plugin manager expects.",
            "Step 4: Update runtime code to use the new API surface.\n- Replace accesses to deprecated fields with the new ones (e.g., `contrib.display_name` instead of `contrib.name`, `writer.display_name` instead of `writer.name`).\n- Ensure UI-facing labels are built using `display_name` and adjust any logic that matches on names to match the new fields.\n- For lookups, confirm that you use the field that the upstream library now defines as user-facing vs internal identifier.",
            "Step 5: Add compatibility shims if you must support environments with and without the new system.\n- Detect the new system via feature or import checks (e.g., `try: import npe2`), not version string parsing when possible.\n- Define constants (e.g., `BUILTINS` and `SVG`) that map to new plugin ids when the new library is present (e.g., 'napari', 'napari-svg') and to legacy ids otherwise (e.g., 'builtins', 'svg').\n- Use these constants throughout tests and application code instead of hard-coded strings.",
            "Step 6: Update tests to reflect the new schema and ids.\n- Replace hard-coded plugin identifiers and attribute accesses with ones that follow the new schema or use the compatibility constants.\n- For tests that assert titles or labels, update expectations to use `display_name` and any new formatting logic.\n- Ensure tests run successfully both with and without the new plugin engine if that dual support is required.",
            "Step 7: Run the full test suite in multiple environments.\n- Run tests with the new plugin engine installed (e.g., with `npe2`) and without it to guarantee backward compatibility.\n- Investigate failures to separate those caused by the schema change from unrelated external issues (e.g., new releases of dependencies like dask).",
            "Step 8: Document the migration.\n- Note in developer or migration docs which fields/ids changed, and how to refer to built-in plugins going forward.\n- Highlight any compatibility layer so future changes can safely remove it once legacy support is dropped."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant: new Islamic prayer times sensor platform that exposes Fajr, Sunrise, Dhuhr, Asr, Maghrib, Isha, and Midnight as timestamp sensors using an external `prayer_times_calculator` library. Implements async setup, non-polling entities, a daily reschedule mechanism based on calculated Islamic midnight, configuration of calculation method, and comprehensive tests with external dependency mocking and time-based updates.",
        "keywords": [
            "homeassistant",
            "sensor",
            "islamic_prayer_times",
            "prayer_times_calculator",
            "time-based scheduling",
            "async_track_point_in_time",
            "DEVICE_CLASS_TIMESTAMP",
            "non-polling sensor",
            "external dependency",
            "MockDependency",
            "dt_util.utcnow",
            "calculation_method"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request added a new Home Assistant sensor platform `islamic_prayer_times` that exposes Islamic prayer times as timestamp sensors. The platform relies on the external Python package `prayer_times_calculator==0.0.3` and uses the Home Assistant configuration's latitude and longitude to compute prayer times. It supports a configurable `calculation_method` (karachi, isna, mwl, makkah) and a list of sensors (Fajr, Sunrise, Dhuhr, Asr, Maghrib, Isha, Midnight). The core flow is:\n\n1. `async_setup_platform` reads latitude/longitude from `hass.config`, validates configuration (calculation method, sensor list), initializes an `IslamicPrayerTimesData` object, and immediately fetches today's prayer times with `get_new_prayer_times()`.\n2. It then instantiates one `IslamicPrayerTimeSensor` entity per configured sensor type. Each sensor stores its own name and initial state by converting the library's prayer time string (e.g. '17:35') into a `datetime` using `dt_util.parse_datetime`, then to ISO 8601 for the state.\n3. Sensors are non-polling (`should_poll=False`) and with device class `DEVICE_CLASS_TIMESTAMP` to align with Home Assistant's semantic model for time points.\n4. Updates are scheduled using `async_track_point_in_time`. The helper `schedule_future_update` computes the next update time based on the library's calculated `Midnight` value. If calculated midnight is still ahead in the current date, the update is scheduled for the start of the next local day; if calculated midnight is already in the past relative to `now`, the update is scheduled for one minute after the next day's calculated midnight. This ensures prayer times are not refreshed too early and remain correct around midnight.\n5. When the scheduled time is reached, `update_sensors` calls `get_new_prayer_times()` again on `IslamicPrayerTimesData`, then triggers `async_schedule_update_ha_state(True)` on each sensor so they recompute their internal state from the new `prayer_times_info` dictionary.\n\nDuring review, the internal `_prayer_times` attribute was made public as `prayer_times_info` to simplify access from entities and tests. A previously defined `get_prayer_times_info` accessor method was removed as stale. Tests were refined to use `MockDependency('prayer_times_calculator')` instead of the real external dependency, to validate configuration handling, multiple sensor creation, correct timestamps, and the rescheduling logic. Time-based behavior in tests was validated by patching `homeassistant.components.sensor.islamic_prayer_times.dt_util.utcnow` and firing time-changed events with `async_fire_time_changed`.\n\nThe PR also updated `requirements_all.txt` to include `prayer_times_calculator==0.0.3`. A community discussion raised that not all calculation methods available in the underlying library were exposed; the author chose a smaller subset for initial simplicity with the option to extend methods later.",
        "semantic_memory": "Generalizable lessons from this change span three areas: Home Assistant integration patterns, time-based scheduling, and testing external dependencies and schedule-driven logic.\n\n1. **Home Assistant Sensor Integration Design**\n   - **Configuration-driven behavior**: New platforms should define a `PLATFORM_SCHEMA` that validates all user-facing options (e.g., `calculation_method`, `sensors`) using `voluptuous` and `homeassistant.helpers.config_validation`. Restricting values (via `vol.In`) ensures misconfiguration is caught early, before runtime calls into external APIs.\n   - **External dependencies**: Third-party libraries must be declared in a `REQUIREMENTS` list at the top of the component file and added to `requirements_all.txt`. They should be imported inside the function where they are used (here, `IslamicPrayerTimesData.get_new_prayer_times`) to play nicely with Home Assistant's dynamic dependency loader and to avoid import-time errors when the component is not in use.\n   - **Shared data objects**: A pattern of using a dedicated data class (here `IslamicPrayerTimesData`) to encapsulate calls to external services decouples entities from data fetching. Entities only read from `prayer_times_info`. This improves testability and separation of concerns.\n   - **Non-polling entities**: When data updates on a known schedule rather than needing continuous polling, entities should set `should_poll=False` and rely on explicit rescheduling (e.g., via `async_track_point_in_time`) plus `async_schedule_update_ha_state()` to push updates. This is more efficient and avoids unnecessary load on external services.\n   - **Proper device classes and state format**: Time-based sensors should use `DEVICE_CLASS_TIMESTAMP` and store states in ISO 8601 format. This enables consistent rendering, time zone conversion, and interoperability with other Home Assistant features.\n\n2. **Time-based Scheduling and Edge Cases Around Midnight**\n   - **Domain-specific scheduling**: When refreshing data that is tied to a domain-specific concept of \"midnight\" or day boundaries, relying solely on traditional midnight (00:00) can be wrong. The PR's logic uses an Islamic calculated midnight to determine when the day's prayer obligations expire and schedules updates accordingly, ensuring new values are not fetched in a window that would produce inconsistent or wrong daily times.\n   - **Handling crossing midnight**: The code distinguishes between cases where calculated midnight lies before the current day’s end vs. after it. It schedules the update at either the next local day start or one minute after the next day's calculated midnight. This pattern shows a way to avoid reusing day-bound data beyond its spiritual/semantic validity, and can be reused for other domain-specific scheduling boundaries.\n   - **Using `dt_util`**: Home Assistant provides `homeassistant.util.dt` helpers (`as_local`, `now`, `start_of_local_day`, `parse_datetime`, `utcnow`) that handle timezones and internal expectations. Using these rather than the standard library's naive datetime helpers avoids subtle timezone bugs in scheduling.\n\n3. **Testing External Dependencies and Scheduled Updates**\n   - **Mocking external libraries**: For components that rely on external services or libraries, use `tests.common.MockDependency` to stub the dependency module (e.g., `prayer_times_calculator`) and control its behavior. This avoids network calls, keeps tests deterministic, and makes it clear at test level what the external API returns.\n   - **Side-effect sequences for consecutive calls**: When the component calls the dependency multiple times over its lifecycle (initial fetch and subsequent refresh), configure the mock with a `side_effect` list. This allows simulating state evolution over time and verifying that entities update correctly when the underlying data changes.\n   - **Scheduling tests using patched time**: For code depending on `async_track_point_in_time` and specific future times, patch `dt_util.utcnow` to return a controlled future timestamp and trigger the scheduler with `async_fire_time_changed`. This pattern allows testing asynchronous, time-based logic without waiting in real time.\n   - **Verifying entity creation and naming**: Tests should assert that each configured sensor yields a state object with correct entity id, ISO timestamp state, and human-readable name that matches the domain logic (here, capitalized prayer name), ensuring UI consistency.\n\nOverall, this PR demonstrates how to integrate a time-domain-specific external calculation library into a Home Assistant sensor, using a data class and scheduled updates, while maintaining robust tests through dependency and time mocking. These patterns can be reused for any integration that fetches daily or periodic data tied to domain-specific calendar rules.",
        "procedural_memory": [
            "How to add a time-based, non-polling sensor platform in Home Assistant that uses an external library and updates once per day around a domain-specific \"midnight\".",
            "Step 1: Define configuration schema.\n- In your sensor module, import `PLATFORM_SCHEMA` from `homeassistant.components.sensor` and `voluptuous`/`config_validation`.\n- Define constants for config keys (e.g., `CONF_CALC_METHOD`, `CONF_SENSORS`), allowed values (e.g., `CALC_METHODS`, `SENSOR_TYPES`), and defaults.\n- Extend `PLATFORM_SCHEMA` with your optional and required keys. Use `vol.In([...])` for enumerated options and `vol.All(cv.ensure_list, vol.Length(min=1), [vol.In(SENSOR_TYPES)])` for lists of sensors.",
            "Step 2: Declare and import external dependencies correctly.\n- At the top of the component file, add a `REQUIREMENTS = ['your_library==x.y.z']` list.\n- Add the same pinned version to `requirements_all.txt` with a comment showing the component name.\n- In your runtime logic (not at module import time), import from the external library inside the method that uses it (e.g., `from your_lib import Client` in `get_new_data()`). This matches Home Assistant’s lazy-loading behavior and reduces import issues.",
            "Step 3: Create a data holder class for external data.\n- Implement a class like `MyIntegrationData` that stores configuration (e.g., latitude, longitude, calculation_method).\n- Add a method `get_new_data()` that instantiates the external client with these parameters and fetches data from it (e.g., `self.data_info = client.fetch()`), returning the result.\n- Store the latest data in a public attribute (`self.data_info`) so entities can read from it without triggering new I/O.\n- Avoid making entities directly depend on the external client; this keeps entities simple and testable.",
            "Step 4: Implement the sensor entities.\n- Create an entity class subclassing `Entity`. In `__init__`, accept `sensor_type` and the shared data object.\n- Derive a human-readable name from the sensor type (e.g., `self._name = sensor_type.capitalize()`).\n- Set `self._device_class` to an appropriate value (e.g., `DEVICE_CLASS_TIMESTAMP` for time).\n- During initialization, read the relevant value from `data.prayer_times_info` (or your equivalent) and convert it to the state format you want (e.g., convert `'HH:MM'` strings to datetimes via `dt_util.parse_datetime()` and then `isoformat()`).\n- Implement properties `name`, `state`, `icon` (if desired), `device_class`, and `should_poll` (return `False` for non-polling sensors).\n- Implement `async_update` to recalculate the state from the current data in the data holder class.",
            "Step 5: Implement async setup and an update scheduler.\n- Implement `async_setup_platform(hass, config, async_add_entities, discovery_info=None)`.\n- Read global configuration values as needed (e.g., `latitude = hass.config.latitude`). Validate that required values are present; log an error and return early if not.\n- Instantiate your data class with configuration parameters and call `get_new_data()` to fetch initial data.\n- Build a list of entity instances based on the configured sensor types and call `async_add_entities(entities, True)` to add them.\n- Implement a helper `schedule_future_update(hass, entities, boundary_value, data_obj)` that computes the next update time based on your domain-specific boundary (e.g., calculated midnight vs. traditional midnight). Use `dt_util.as_local(dt_util.now())`, `dt_util.start_of_local_day()`, and `datetime` arithmetic to compute `next_update_at`.\n- Use `async_track_point_in_time(hass, update_sensors(hass, entities, data_obj), next_update_at)` to register the update callback. The callback should call `data_obj.get_new_data()`, then `entity.async_schedule_update_ha_state(True)` for each entity, and finally reschedule itself for the next day.",
            "Step 6: Test config handling and entity creation.\n- In tests, use `MockDependency('your_library')` to stub the external module. Inside the context manager, configure the mock class to return deterministic data: `mock_lib.Client.return_value.fetch.return_value = FAKE_DATA`.\n- Use `async_setup_component(hass, 'sensor', config)` with different configurations (minimum config, multiple sensors, different calculation methods) and assert it returns `True`.\n- After setup, derive the expected entity ids (e.g., `'sensor.islamic_prayer_time_maghrib'`) and check `hass.states.get(entity_id)`.\n- Assert that the state matches the expected converted value (using the same conversion logic as the component) and that the `name` is correct.",
            "Step 7: Test scheduled updates and time-dependent behavior.\n- For components that schedule updates via `async_track_point_in_time`, create an initial configuration and set up the component under a `MockDependency` context with an external client mock.\n- Use `side_effect` on the mock's `fetch` method to return a sequence of data snapshots (e.g., `[INITIAL_DATA, UPDATED_DATA]`) to simulate data changing between runs.\n- Compute a `future` datetime when your scheduled update should occur (e.g., based on your `Midnight` plus a day and an offset). Convert strings from the data to datetime objects using the same formatting logic as in production code.\n- Patch `'homeassistant.components.sensor.your_component.dt_util.utcnow'` to return this `future` value.\n- Call `async_fire_time_changed(hass, future)` and then `await hass.async_block_till_done()` to allow scheduled callbacks to run.\n- Re-read the entity state from `hass.states.get(entity_id)` and assert that it now reflects `UPDATED_DATA`.",
            "Step 8: Maintain clean code and public interfaces.\n- If tests or entities require read-only access to an internal cache, prefer exposing it as a public attribute (e.g., `prayer_times_info`) rather than using an intermediate getter method that adds no value. This simplifies tests and code.\n- Remove commented-out or stale code (as was done with the old `get_prayer_times_info` method) to keep the component maintainable.\n- If the underlying library supports more options than initially needed (e.g., additional calculation methods), expose a minimal, well-documented subset first, and extend later when there is clear user demand."
        ]
    }
}
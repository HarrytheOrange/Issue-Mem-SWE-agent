{
    "search_index": {
        "description_for_embedding": "StackStorm bug where trigger tags defined in sensor YAML were not stored or returned by `st2 trigger get`. Root cause: the `tags` field was not propagated into trigger type creation (`_create_trigger_type` / `_add_trigger_models`). Fix: add `tags` parameter to trigger type creation, pass tags from sensor-trigger definition, and make tags optional with a safe default.",
        "keywords": [
            "StackStorm",
            "st2",
            "trigger tags not stored",
            "sensor registration",
            "trigger_type",
            "st2common.services.triggers",
            "missing optional field",
            "YAML config not reflected in DB",
            "create_or_update_trigger_type_db"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, users noticed that when running `st2 trigger get`, no tags were shown on triggers, even though tags were defined in the corresponding sensor YAML files. Investigation showed that while `trigger_type` dictionaries from sensor registration included a `tags` field, the internal helper `_create_trigger_type` did not accept or forward `tags` to `create_or_update_trigger_type_db`. As a result, tags were silently discarded during trigger type creation. The fix introduced a `tags` parameter to `_create_trigger_type(pack, name, description=None, payload_schema=None, parameters_schema=None, tags=None)` and added `'tags': tags` to the trigger_type dict passed to `create_or_update_trigger_type_db`. In `_add_trigger_models(trigger_type)`, the code was updated to read tags from the incoming `trigger_type` definition with `tags = trigger_type['tags'] if 'tags' in trigger_type else {}` and pass it to `_create_trigger_type`. A small follow-up patch corrected an indentation/typo in the tags assignment. After these changes, tags defined in sensor YAML are correctly stored in the database and visible via `st2 trigger get`.",
        "semantic_memory": "This bug illustrates a common class of issues where configuration fields are defined at the edge (e.g., YAML, API input) but are lost somewhere in the internal creation or persistence pipeline. Optional or newly added fields must be consistently propagated through all helper functions and layers that construct and persist domain objects. If a helper function's signature is not updated to accept new fields, or if it fails to attach those fields to the final data model, the system will appear to \"ignore\" user configuration without throwing an obvious error. A robust pattern is to (1) ensure constructors and persistence calls accept a well-defined set of fields, including optional ones; (2) safely handle absent fields with defaults to avoid KeyError while still storing them when present; and (3) add tests that verify round-trip behavior (define field in config, register, then fetch and assert that the field is present). This case also shows the importance of scanning for and updating all helper functions when introducing or modifying model attributes.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the symptom.\n- Define an object (e.g., trigger, sensor, resource) with a field in configuration (YAML/JSON) such as `tags`.\n- Register or create the object using the normal workflow.\n- Retrieve it via the official API/CLI (e.g., `st2 trigger get`) and confirm that the field is missing or empty.",
            "Step 2: Verify the field in intermediate data structures.\n- Add logging or use a debugger to inspect the in-memory representation right after parsing the config (e.g., the `trigger_type` dict loaded from YAML).\n- Confirm whether the problematic field (e.g., `tags`) is present at this stage. If it is already missing, the issue is in config parsing. If it is present, the issue is in later processing/persistence.",
            "Step 3: Trace the object creation pipeline.\n- Identify helper functions and services responsible for creating/persisting the object (e.g., `_add_trigger_models`, `_create_trigger_type`, and `create_or_update_trigger_type_db`).\n- For each stage, check function signatures and calls: does each helper accept the new/optional field? Is the field forwarded when calling the next function?",
            "Step 4: Ensure the field is passed through all layers.\n- Update helper function signatures to accept the field (e.g., add `tags=None` to `_create_trigger_type`).\n- In the body, attach the field to the data model/dict passed to persistence (e.g., add `'tags': tags` to the trigger_type dict).\n- At call sites, read the field safely from the source structure: `field = obj['field'] if 'field' in obj else <default>`.",
            "Step 5: Handle optionality safely.\n- Avoid direct `obj['field']` access on optional keys that might not exist.\n- Use `obj.get('field', <default>)` or a conditional expression (as in the patch: `tags = trigger_type['tags'] if 'tags' in trigger_type else {}`) to prevent KeyError.\n- Choose a sensible default (empty list/dict/None) that downstream logic can handle.",
            "Step 6: Add or update tests.\n- Create or modify unit tests to define the field in a mock config object.\n- Run the registration/creation flow and then retrieve the object from the DB/API.\n- Assert that the field persists end-to-end (e.g., `self.assertEqual(stored_trigger.tags, expected_tags)`).\n- Also test the case where the field is omitted to ensure no exceptions are thrown and defaults are applied.",
            "Step 7: Code review and cleanup.\n- Review the diff for consistency (e.g., ensure all relevant helpers and call sites now include the field).\n- Fix any typos or indentation issues (as in the follow-up patch for the `tags` assignment).\n- Remove or adjust any redundant defaulting logic if the model already sets a default.",
            "Step 8: Re-run the original scenario.\n- Re-register sensors or triggers.\n- Call the user-facing command/API again (e.g., `st2 trigger get`) to confirm the field is now correctly stored and visible.\n- Optionally inspect the database directly to confirm the field is persisted."
        ]
    }
}
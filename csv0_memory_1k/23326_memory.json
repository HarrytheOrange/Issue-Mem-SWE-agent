{
    "search_index": {
        "description_for_embedding": "Refactor of Home Assistant's EnOcean integration to support multiple sensors and covers, switch to a dispatcher-based packet routing model, update the enocean library to 0.50, and ensure the real dongle base ID is used in outgoing packets. Platforms (binary_sensor, light, sensor, switch, cover) now parse EnOcean EEP telegrams themselves, enabling support for power, temperature, humidity, dimmers, switches, and covers.",
        "keywords": [
            "EnOcean",
            "homeassistant.components.enocean",
            "multiple sensors",
            "cover support",
            "dongle base ID",
            "enocean==0.50",
            "dispatcher",
            "EEPs",
            "packet routing",
            "hardware integration refactor"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the EnOcean integration in Home Assistant was refactored to support multiple EnOcean devices of various types and to add cover (blind/shutter) support. The original implementation maintained a list of devices in a global ENOCEAN_DONGLE object, manually decoded incoming RadioPacket payloads inside the dongle callback, and dispatched simple numeric values (e.g., power, on/off) to devices based on their type and hard-coded conditions. Outgoing packets used the EnOcean library's default behavior to assign a sender ID, which caused issues for the author who needed the real dongle ID to appear in telegrams. \n\nThe refactor introduces a central EnOceanDongle that still handles the SerialCommunicator but now exposes its base_id and uses Home Assistant's dispatcher for pub/sub style communication. Two new dispatcher signals are introduced: `enocean.receive_message` for incoming packets, and `enocean.send_message` for outgoing packets. The integration stores the dongle instance in `hass.data['enocean']`. The callback now forwards all RadioPackets through the dispatcher instead of decoding them centrally; it also intercepts RESPONSE packets to update the dongle's base_id when the gateway returns it. Outgoing commands are no longer sent directly from entities to the SerialCommunicator; instead, entities dispatch a `SIGNAL_SEND_MESSAGE` event with the prepared Packet, which the dongle listens for and sends on the serial line.\n\nThe base entity class `EnOceanDevice` was significantly changed. Instead of registering devices in the dongle, it now stores `dev_id`, `dev_name`, and `base_id`. In `async_added_to_hass`, each entity subscribes to `SIGNAL_RECEIVE_MESSAGE`; when a packet arrives whose sender matches its `dev_id` (using `enocean.utils.combine_hex`), `value_changed(packet)` is called. Each platform subclass now interprets the raw packet according to relevant EnOcean Equipment Profiles (EEPs): \n\n- Binary sensors (`binary_sensor.enocean`) now handle F6-02-xx rocker switches, interpret pressed/released state from packet.data, determine which button and action, and fire a `button_pressed` event with rich context (id, id_str, entity_id, name, pushed, which, onoff).\n- Lights (`light.enocean`) treat dimmer feedback telegrams (A5-02-02 etc.) and only accept A5 4BS packets; brightness is mapped from 0–100% to HA's 0–255 scale.\n- Sensors (`sensor.enocean`) are split into power, temperature, and humidity sensors. Power sensors parse A5-12-01 meter telegrams using `packet.parse_eep`, extracting current power from MR/DIV fields. Temperature sensors support common 8-bit temp EEPs (A5-02-x, A5-04-x, A5-10-x), with configurable min/max and raw range mapping to °C. Humidity sensors compute %RH from raw 0–250 values on A5 telegrams.\n- Switches (`switch.enocean`) now compose D2-01-01 telegrams that include `self.base_id` in the data, ensuring the real dongle ID is used as the sender. They also parse actuator status (D2) telegrams using EEP 0x01-0x01 to track on/off state per channel and can optionally infer on/off from power-meter telegrams.\n- Covers (`cover.enocean`) are added as a new platform. They send D2-05-00 style commands including the dongle base_id to open, close, stop, or set position. The cover entity tracks `percent_closed` and uses parsed actuator feedback telegrams (CMD == 4, POS field) to update state. A delayed callback (via `async_call_later`) resets `_is_opening` and `_is_closing` after movement is presumed complete.\n\nThe environment is updated to use `enocean==0.50` instead of 0.40: the component manifest, `requirements_all.txt`, and `requirements_test_all.txt` are updated, and `enocean` is added to the generator exclusion list in `gen_requirements_all.py`. An earlier attempt to declare `REQUIREMENTS = ['enocean==0.50']` inside the component is removed in favor of manifest-based dependency management.\n\nOverall, the problem of unreliable or incorrect EnOcean communication (incorrect sender ID, limited device support, centralized decoding) is addressed by updating the library, using the actual dongle base ID in telegrams, and decentralizing packet parsing to device classes that interpret protocol-specific EEPs, all coordinated through Home Assistant's dispatcher.",
        "semantic_memory": "This change illustrates several general integration and architectural patterns for hardware/protocol-based systems in Home Assistant and similar frameworks:\n\n1. **Decouple hardware I/O from entity logic via a dispatcher/event bus**:\n   - Instead of having a central component maintain a list of entities and hard-code all protocol parsing logic, it is cleaner to have a single communication object (e.g., a dongle wrapper) that handles low-level I/O and publishes raw messages to a dispatcher or event bus. Individual entities subscribe and perform their own filtering and decoding. This reduces coupling and makes it easier to add new device types and EEPs without modifying the core component.\n\n2. **Use the framework's async/event infrastructure correctly**:\n   - Home Assistant expects entities to use `async_added_to_hass` for registering callbacks and `schedule_update_ha_state()` to notify the state machine. The refactor uses `hass.helpers.dispatcher.async_dispatcher_connect` for subscriptions and `dispatcher_send` for outgoing commands, aligning with HA's async model and avoiding manual thread management.\n\n3. **Protocol-specific parsing should live with device classes**:\n   - EnOcean telegrams differ by RORG and EEP; different devices care about different fields. Moving parsing logic into each platform/entity class (binary sensor, light, sensor, switch, cover) makes it easier to reason about and extend. It also embraces the `packet.parse_eep(rorg_func, type)` abstraction provided by the `enocean` library, rather than re-implementing bit arithmetic. This pattern applies generally: device-specific protocol semantics should be encapsulated in the device's code, not in a global hub.\n\n4. **Ensure correct identity in protocol messages (base ID / sender ID)**:\n   - Many protocols require a stable sender ID (e.g., EnOcean base ID) for devices to learn and authenticate. Relying on library defaults can lead to mismatches or unstable IDs. Explicitly setting the sender/base ID in outgoing frames and updating from RESPONSE packets ensures the gateway's identity is correct. This is a general best practice: do not assume protocol libraries will pick the right identity; manage it deliberately when necessary.\n\n5. **Library version upgrades should be coordinated with requirement management**:\n   - The integration depends on specific features (e.g., `parse_eep`, new constants) of `enocean==0.50`. Updating the component manifest, global requirements (`requirements_all.txt`), and test requirements (`requirements_test_all.txt`) ensures all environments (runtime, dev, CI) use compatible versions. Centralizing version management also avoids duplicate `REQUIREMENTS` declarations in the component where manifest already defines them.\n\n6. **Use configuration for scaling and calibration of sensor data**:\n   - Temperature sensors use configurable parameters (`min_temp`, `max_temp`, `range_from`, `range_to`) to map raw telegram values to physical units. This pattern—allowing scaling and offset configuration—generalizes to many other sensors where devices use different ranges or calibration curves.\n\n7. **State tracking based on asynchronous feedback**:\n   - For actuators like switches and covers, the code updates internal state based not only on outgoing commands but also on feedback telegrams (actuator status, power measurements). Incorporating feedback yields more accurate states and allows inferring the real device status even if commands are missed or overridden. For covers, temporary `_is_opening`/`_is_closing` flags and delayed resets model movement in the absence of continuous position updates.\n\nOverall, the refactor emphasizes separation of concerns (I/O hub vs. protocol decoding vs. entity state), explicit handling of protocol identity, and alignment with the host framework's async and configuration conventions.",
        "procedural_memory": [
            "How to refactor a hardware integration to support multiple device types and proper packet routing:",
            "Step 1: Centralize low-level communication in a single hub object (e.g., EnOceanDongle) that owns the serial or network connection. This object should provide a simple callback for incoming frames and a method to send packets, but it should not know about specific entities or device types.",
            "Step 2: Introduce a dispatcher or messaging abstraction. In Home Assistant, define two signals: one for incoming messages (e.g., `enocean.receive_message`) and one for outgoing ones (e.g., `enocean.send_message`). In the hub's callback, publish incoming packets via the receive signal; in the hub's constructor, subscribe to the send signal to relay commands to the hardware.",
            "Step 3: Store the hub instance in the framework's shared data registry (e.g., `hass.data[DOMAIN]`) rather than in global module variables, so entities and platforms can access it in a structured way.",
            "Step 4: In the base entity class, store the device's protocol ID (`dev_id`) and any shared metadata (e.g., human name, base ID). In `async_added_to_hass`, subscribe to the incoming message signal. In the callback, filter packets by sender (e.g., EnOcean `packet.sender_int` versus the entity's `dev_id`), and call `value_changed(packet)` when a match occurs.",
            "Step 5: Move protocol-specific parsing into each entity subclass. For each platform (binary_sensor, light, sensor, switch, cover), implement `value_changed(packet)` to interpret the relevant RORG/EEP and update `_state`, `_brightness`, `_on_state`, `percent_closed`, etc. Use library-provided helpers (like `packet.parse_eep(...)`) whenever possible instead of hand-parsing bits.",
            "Step 6: For outgoing commands, have entities construct the appropriate packet (correct RORG/EEP layout) and include the true hub identity (e.g., the EnOcean base ID) in the data fields. Instead of sending directly via the serial communicator, call a method like `self.send_command(...)` that wraps the packet in a `SIGNAL_SEND_MESSAGE` dispatch. The hub's send callback then sends it over the wire.",
            "Step 7: Ensure the hub learns and maintains its identity. When the hardware returns its base ID in a RESPONSE packet, detect those messages (check `packet_type`, response code, and data length), and store the `base_id` in the communicator and in the hub object. Use this base ID when constructing outgoing telegrams.",
            "Step 8: Align dependency management with the framework. If new protocol features require a newer version of a library (e.g., `enocean==0.50`), update the integration manifest and global requirements files. Avoid conflicting in-component `REQUIREMENTS` if the framework expects requirements to be declared in manifests. Add the library to any requirement generation whitelist/blacklist scripts as needed.",
            "Step 9: For sensors with non-linear or variable scales (e.g., temperature, humidity), expose configuration options in the platform schema to define min/max values and raw ranges. Use these values to map raw payload bytes to meaningful units, and round to a reasonable precision before updating state.",
            "Step 10: For actuators that move over time (e.g., covers), maintain transient flags (`_is_opening`, `_is_closing`) and use delayed callbacks (e.g., `async_call_later`) to reset these flags once motion should be complete, based on feedback telegrams. Always call `schedule_update_ha_state()` after changing state-related attributes to ensure the framework updates the UI and automations.",
            "Step 11: When migrating from an older integration, remove any legacy patterns such as global device lists, hard-coded logic in the hub, or ad-hoc packet parsing. Replace them incrementally with dispatcher-based routing and entity-local parsing, adding tests and example configuration for each new entity type.",
            "Step 12: Use framework event buses for user-facing events. For example, if a binary sensor represents a wall switch, fire a custom event (like `button_pressed`) with rich context (device ID, string ID, entity_id, name, and action details) whenever the switch is pressed or released. This pattern separates low-level protocol concerns from higher-level automation logic."
        ]
    }
}
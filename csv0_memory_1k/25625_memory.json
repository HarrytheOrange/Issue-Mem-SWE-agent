{
    "search_index": {
        "description_for_embedding": "Home Assistant UniFi integration bug: device tracker entities remained available even when the corresponding UniFi devices were disabled in the controller. Fix: use the new `disabled` flag from aiounifi v9 to mark such entities as unavailable, and add tests to confirm state transitions.",
        "keywords": [
            "Home Assistant",
            "UniFi",
            "device_tracker",
            "disabled devices",
            "entity availability",
            "aiounifi==9",
            "integration bug",
            "controller state sync"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant UniFi integration, device tracker entities did not correctly reflect when a UniFi device was disabled in the controller. Previously, the `available` property of `UnifiDeviceTracker` only checked `self.controller.available`, so the entity stayed available even if the underlying UniFi client/device was disabled. The fix updated `available` to also consider the device's `disabled` flag: `return not self.device.disabled and self.controller.available`. To support this, the aiounifi library was bumped from version 8 to 9 in `manifest.json`, `requirements_all.txt`, and `requirements_test_all.txt` to expose the `disabled` attribute on devices. A regression test was added in `tests/components/unifi/test_device_tracker.py`: it copies `DEVICE_1`, sets `disabled = True`, feeds this back through the mock controller, runs an update, and asserts that the corresponding `device_tracker.device_1` state becomes `unavailable`. This ensures that when a UniFi device is disabled on the controller, the Home Assistant entity is marked unavailable instead of incorrectly remaining 'home' or otherwise available.",
        "semantic_memory": "Entity availability in an integration should mirror the true usability or active status of the underlying resource, not just the controller's online/offline state. When upstream APIs add explicit flags such as `disabled`, `active`, or `is_deleted`, integrations should use them to drive `available` and/or state transitions. This avoids stale or misleading entities in automations and dashboards. Upgrading dependencies can be necessary not only for bug fixes but also to gain access to new attributes that allow more accurate modeling. In tests, mocking back-end responses to simulate disabled or inactive devices and asserting entity state changes is an effective way to guard against regressions. Generally, `available` should be a composition of controller health and individual resource state, rather than only controller health.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce the issue by toggling the underlying resource state in the external system (e.g., disable a device in the controller UI) and observe if the corresponding entity in Home Assistant (or similar system) changes `state` or `available` as expected.",
            "Step 2: Inspect the integration's entity class (e.g., a device tracker or sensor entity) and find how it implements the `available` property and state determination. Check whether it only considers the controller's connection status or also inspects per-device flags.",
            "Step 3: Examine the upstream client library (here, aiounifi) documentation and models to see if it exposes a flag representing disabled/inactive status (e.g., `disabled`, `active`, `is_blocked`). If not present in the current version, verify if a newer version has added this capability.",
            "Step 4: If needed, bump the dependency version in the integration's manifest and global requirements files, ensuring the new version provides the necessary attribute. Run dependency checks and tests after updating.",
            "Step 5: Modify the entity's `available` property (and/or state logic) to incorporate the new flag. For example, change from `return self.controller.available` to `return not self.device.disabled and self.controller.available`, combining controller health with per-device status.",
            "Step 6: Add or update tests that mock the backend devices/clients to simulate the disabled state. For example, clone an existing mock device, set `device['disabled'] = True`, feed it through the mock controller response, trigger an update, and assert that the entity becomes `unavailable` (or another appropriate state).",
            "Step 7: Run the full test suite, including integration-specific tests, to verify that the change doesnâ€™t break other behavior and that the new scenario passes.",
            "Step 8: Manually validate in a real or staging environment by disabling and re-enabling devices in the external system and confirming that entity availability and state in the integration now tracks those changes correctly.",
            "Step 9: Document the behavior if it is user-visible (e.g., entities becoming unavailable when disabled upstream), especially if it represents a breaking or notable change in how entities appear in the UI or automations."
        ]
    }
}
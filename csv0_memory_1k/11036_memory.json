{
    "search_index": {
        "description_for_embedding": "Home Assistant Coinbase integration caused recorder/logbook failures because a complex CoinbaseData object was passed through the event bus and could not be JSON-serialized. The fix stored the CoinbaseData/client in hass.data and only passed simple serializable values (account info, currencies) via discovery_info, added exchange rate sensors, and handled authentication errors gracefully.",
        "keywords": [
            "Home Assistant",
            "Coinbase",
            "sensor platform",
            "hass.data",
            "load_platform",
            "JSONEncoder",
            "Object of type X is not JSON serializable",
            "event bus",
            "recorder error",
            "AuthenticationError",
            "API time drift",
            "exchange_rate_currencies"
        ]
    },
    "agent_memory": {
        "episodic_memory": "A new Coinbase component and sensor platform were added to Home Assistant to monitor wallet balances and exchange rates using a Coinbase API key and secret. Initially, the integration stored a CoinbaseData object (wrapping the Coinbase client and API data) and passed complex objects around in a way that ended up on the Home Assistant event bus. When the recorder/logbook tried to persist events, JSON encoding failed with `Object of type 'CoinbaseData' is not JSON serializable` and the recorder thread crashed.\n\nTo fix this, the author reworked the integration so that the complex CoinbaseData object and the Coinbase API client are stored exclusively in `hass.data` under the `coinbase_cache` key. Sensor platforms are created via `load_platform`, but only simple discovery information is passed over the event bus: either basic account identifiers (name and currency) or currency codes for exchange rate sensors. The sensors then look up the shared CoinbaseData instance from `hass.data` and read updated account and exchange rate data from there, instead of receiving the CoinbaseData object via discovery_info.\n\nAdditionally, the integration was expanded to support `exchange_rate_currencies`, creating `ExchangeRateSensor` entities that expose coin-to-native exchange rates. Update calls in `CoinbaseData.update` were throttled with `@Throttle` and extended to also retrieve exchange rates. A try/except around the Coinbase API calls catches `AuthenticationError` from the Coinbase SDK and logs a clear error message instead of letting the component crash. During setup, the component now checks if `coinbase_data` has an `accounts` attribute and aborts setup (returns False) if account retrieval failed.\n\nA user later reported an `AuthenticationError: request timestamp expired`. This turned out not to be a permission issue but a system clock problem: the server time was several minutes behind real time, causing Coinbase to reject the signed requests. After resynchronizing the system clock, the integration worked correctly.",
        "semantic_memory": "This case illustrates several general integration and architecture practices for Home Assistant and similar event-driven systems:\n\n1. **Do not pass complex or non-serializable objects on the event bus**: Anything placed in event data may be serialized to JSON (for recorder/logbook, remote APIs, etc.). ORM models, third-party client instances, or custom data containers (like `CoinbaseData`) will often break JSON encoding. Instead, only pass primitive, serializable types (strings, numbers, lists, dicts of primitives).\n\n2. **Use shared data storage (e.g., hass.data) for complex state and clients**: For HA components, the proper place to store external API clients, paginated result objects, and other complex state is `hass.data[DOMAIN]`. Platforms (sensors, switches, etc.) look up that shared object at runtime, rather than receiving it via events. This avoids serialization problems and centralizes API access.\n\n3. **Discovery communication should be minimal and serializable**: When using `load_platform` with `discovery_info`, send only the minimal information needed for platform setup (IDs, names, currencies). Let the platform reconstruct or look up richer objects using that information and shared state.\n\n4. **Throttle API calls and share results**: Use a throttling mechanism (such as Home Assistant's `Throttle`) to prevent excessive API calls. Multiple entities can share a single data object that handles all network communication and caches results.\n\n5. **Graceful error handling for external APIs**: Wrap calls to third-party APIs in try/except blocks for common errors (e.g., `AuthenticationError`). Log a clear error message and fail setup or updates gracefully, instead of propagating exceptions that crash background threads or the whole integration.\n\n6. **Check for successful initialization before using shared data**: After constructing a shared data object, verify that critical attributes (like `accounts`) were successfully populated. If not, abort component setup. This makes misconfiguration or connectivity issues fail fast and visibly.\n\n7. **Time synchronization is critical for APIs using timestamps/signatures**: Some services (including Coinbase) require requests with accurate timestamps. If the host system clock is skewed by a few minutes, valid credentials will still fail with authentication errors like `request timestamp expired`. Ensuring NTP/time synchronization is an essential part of diagnosing such errors.\n\nThese patterns apply broadly to any framework that serializes events or state (e.g., HA, microservices with JSON-based queues) and to any integration with signed, timestamped API requests.",
        "procedural_memory": [
            "How to diagnose and fix JSON serialization errors from complex objects on an event bus, and how to build a robust Home Assistant integration using shared data and discovery.",
            "Step 1: When you see an error like `Object of type 'X' is not JSON serializable` (especially from a recorder/logbook or event persistence module), inspect the stack trace to see where JSON encoding is triggered (e.g., event logging, recorder, or a REST/remote call). Confirm that the failing object type (here, `CoinbaseData`) is being placed in event data or similar.",
            "Step 2: Review any code that calls into the event system or discovery mechanisms (`hass.bus.fire`, `load_platform`, etc.). Check what is being put into `event.data` or `discovery_info`. Look for complex objects: API clients, custom classes, paginated result objects, ORM models, etc.",
            "Step 3: Refactor the code so that only JSON-serializable primitives are passed via events or discovery. For Home Assistant, adopt the pattern of storing shared complex objects in `hass.data[DOMAIN]` and passing only minimal identifiers (e.g., account name, currency code) through `discovery_info`.",
            "Step 4: In each platform (sensor, switch, etc.), obtain the shared data object from `hass.data[DOMAIN]` in `setup_platform` and in entity instances. Use that object to read/update state, rather than having the platform own its own API client or receive the client via `discovery_info`.",
            "Step 5: Introduce a data wrapper class (like `CoinbaseData`) that encapsulates API calls and caches results. Protect its `update` method with a throttling decorator (such as Home Assistant's `Throttle`) to limit how often network requests are made, especially if multiple entities share the same data.",
            "Step 6: Handle common API errors in the data wrapper. For example, catch authentication or network errors (`AuthenticationError`, timeouts) around API calls. Log informative messages and avoid raising unhandled exceptions from background threads. Optionally, signal setup failure by not creating entities or by returning False from the component setup if core data (like accounts) could not be fetched.",
            "Step 7: After constructing the shared data object during component setup, verify that its critical attributes (e.g., `accounts`) exist and are valid. If not, abort setup to avoid later AttributeErrors or inconsistent state.",
            "Step 8: When adding derived sensors (like exchange rate sensors), continue the pattern: create entities via `load_platform` with simple discovery_info (e.g., `{ 'native_currency': 'USD', 'exchange_currency': 'BTC' }`), and use the shared data object to look up and compute current values (`1 / rate`, rounding as needed).",
            "Step 9: For authentication errors that mention timestamps (e.g., `request timestamp expired`), check the system clock on the server running the integration. Ensure NTP or another time synchronization service is active and that the clock is accurate to within a few seconds.",
            "Step 10: Add basic logging around setup and update paths (_LOGGER.debug/info/error) to aid future debugging, particularly for edge cases like missing currencies, authentication failures, or empty account lists."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant Hue light platform failed when discovered via discovery because optional configuration values (filename, allow_unreachable, allow_in_emulated_hue) relied on schema defaults that were not applied in the discovery path. Fix: remove defaults from PLATFORM_SCHEMA and explicitly provide fallback defaults in setup_platform() using config.get(key, DEFAULT).",
        "keywords": [
            "Home Assistant",
            "Hue",
            "Philips Hue",
            "light.hue",
            "discovery",
            "PLATFORM_SCHEMA",
            "optional config",
            "default values",
            "config validation",
            "integration not working",
            "setup_platform",
            "runtime defaults"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Philips Hue light platform stopped working correctly when the integration was set up via discovery rather than via configuration files. Users reported that Hue lights were not working in Home Assistant 0.37. The root cause was that several optional configuration options—`CONF_ALLOW_UNREACHABLE`, `CONF_FILENAME`, and `CONF_ALLOW_IN_EMULATED_HUE`—had default values defined only in the `PLATFORM_SCHEMA`. When the platform was initialized from discovery, the config did not go through that schema in the same way, so those defaults were never applied. As a result, `setup_platform` received a config dictionary missing those keys and called `config.get(...)` without default values, resulting in `None` or otherwise invalid configuration for critical parameters like the Hue configuration filename and reachability behavior.\n\nThe fix changed the division of responsibility for defaults. In `homeassistant/components/light/hue.py`, the `PLATFORM_SCHEMA` was modified so that the optional parameters no longer specify `default=` values; they are just optional booleans/strings:\n- `vol.Optional(CONF_ALLOW_UNREACHABLE): cv.boolean`\n- `vol.Optional(CONF_FILENAME): cv.string`\n- `vol.Optional(CONF_ALLOW_IN_EMULATED_HUE): cv.boolean`\n\nThen, in `setup_platform`, the code was updated to explicitly provide runtime defaults via `config.get(key, DEFAULT)`:\n- `filename = config.get(CONF_FILENAME, PHUE_CONFIG_FILE)`\n- `allow_unreachable = config.get(CONF_ALLOW_UNREACHABLE, DEFAULT_ALLOW_UNREACHABLE)`\n- `allow_in_emulated_hue = config.get(CONF_ALLOW_IN_EMULATED_HUE, DEFAULT_ALLOW_IN_EMULATED_HUE)`\n\nThis ensures that whether the platform is loaded via YAML configuration or via discovery, the same default values are applied and the Hue platform initializes correctly. The `CONF_ALLOW_HUE_GROUPS` option still uses its default in the schema, as that path was not implicated in the bug.",
        "semantic_memory": "This fix illustrates an important pattern around configuration defaults and multiple initialization paths. When a component can be initialized both from explicit configuration (e.g., YAML) and from an automatic discovery mechanism, relying solely on schema-level defaults (e.g., voluptuous `PLATFORM_SCHEMA` defaults) may not be sufficient, because the discovery path may bypass or partially apply the schema. If defaults are only enforced in the schema, the component's runtime code (e.g., `setup_platform`) might receive configs missing optional keys and then incorrectly treat them as `None`, causing runtime failures or behavioral changes.\n\nA more robust pattern is to ensure that critical defaults are enforced at the point of use (runtime), not only during validation. That can mean:\n- Using `config.get(option, DEFAULT_VALUE)` in the setup function for parameters required for correct operation.\n- Or ensuring that *all* code paths, including discovery, run the config through the same schema so defaults are consistently applied.\n\nAnother general principle: configuration schemas are great for validation and documenting defaults, but components should not assume that every caller has gone through that schema, especially in dynamic systems with plugins, discovery, or external integrations. Defensive programming in setup code—explicit defaults, sanity checks, and fallbacks—prevents subtle bugs when the environment or initialization flow changes.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify symptoms and context.\n- Observe that a component works in one configuration path (e.g., manual configuration) but fails or behaves differently in another (e.g., discovery, dynamic loading).\n- Collect logs and user reports to confirm the failure is tied to a specific initialization path.",
            "Step 2: Compare configuration objects across initialization paths.\n- Add temporary logging or breakpoint inspection in the component's setup function (e.g., `setup_platform`) to print or inspect the incoming `config` dict for both the working and failing scenarios.\n- Look for missing keys or unexpected `None` values in the failing path.",
            "Step 3: Check how and where defaults are applied.\n- Review the configuration schema (e.g., `PLATFORM_SCHEMA` or equivalent) to see which options have `default=` values.\n- Determine whether the discovery or alternate initialization path actually runs the config through that schema, or whether it bypasses or uses a different validation flow.",
            "Step 4: Confirm the root cause.\n- If the failing path produces a config without keys that the component's setup function assumes are present, verify that those keys are optional in the schema and depend on schema-level defaults.\n- Check whether `config.get(key)` in setup is being called without a fallback default, leading to `None` or missing configuration.",
            "Step 5: Choose a fix strategy.\n- Option A: Ensure all initialization paths (including discovery) pass through the same schema so that schema defaults are always applied.\n- Option B (as in this fix): Move or duplicate critical defaults into the runtime setup code by using `config.get(KEY, DEFAULT_VALUE)` for each important setting.\n- Consider which approach is more maintainable in your codebase; often, minimal change is to add runtime defaults in `setup_platform` or equivalent.",
            "Step 6: Implement runtime defaults.\n- For each critical optional config value, update the setup function to use `config.get(key, DEFAULT)` rather than `config.get(key)`.\n- If desired, remove `default=` from the schema for those options to avoid confusion about where defaults are applied, or leave them if other code paths rely on them—but be explicit in code comments.",
            "Step 7: Test across all initialization paths.\n- Reproduce the original failing conditions (e.g., via discovery) and verify that the component now initializes successfully and behaves as expected.\n- Also verify the component still works when configured through the original, working path (e.g., manual configuration).",
            "Step 8: Add or update regression tests and documentation.\n- If the project has tests for configuration handling, add tests that simulate both manual config and discovery config to ensure defaults are properly applied in both cases.\n- Update documentation and/or comments to clarify where defaults are enforced (schema vs runtime) and how discovery interacts with configuration."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Home Assistant ZHA enhancement: add support for new Zigbee sensor cluster types (Centralite battery via PowerConfiguration, Metering, RelativeHumidity, IlluminanceMeasurement), skip endpoints using manufacturer-specific Zigbee profile IDs, and expose Zigbee endpoint/cluster metadata on entities for easier debugging and identification.",
        "keywords": [
            "Home Assistant",
            "ZHA",
            "Zigbee",
            "sensor",
            "PowerConfiguration",
            "Metering",
            "RelativeHumidity",
            "IlluminanceMeasurement",
            "Centralite battery",
            "manufacturer specific profile",
            "endpoint profile_id",
            "entity_id naming",
            "cluster metadata",
            "homeassistant.components.zha",
            "homeassistant.components.sensor.zha",
            "zigbee.smartenergy",
            "zigbee.measurement"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request enhanced Home Assistant's Zigbee Home Automation (ZHA) integration by adding support for several additional Zigbee sensor types and improving device handling. Previously, ZHA only handled TemperatureMeasurement as a sensor in this factory path and tried to initialize all endpoints, including those using manufacturer-specific Zigbee profile IDs that ZHA doesn't know how to interpret, leading to poor UX or incorrect entity creation.\n\nThe change introduced a factory method update in homeassistant/components/sensor/zha.py to detect multiple clusters:\n- TemperatureMeasurement -> TemperatureSensor (existing)\n- PowerConfiguration (only for manufacturer 'CentraLite') -> CentraliteBatterySensor\n- Metering -> MeteringSensor\n- IlluminanceMeasurement -> IlluminanceMeasurementSensor\n- RelativeHumidity -> RelativeHumiditySensor\n\nEach new sensor class subclasses the base ZHA sensor entity (Sensor) and defines a value_attribute and unit_of_measurement when needed. The CentraliteBatterySensor maps a raw voltage-like value (attribute 32 on PowerConfiguration) into a percentage based on a specific Centralite voltage-to-percentage table, clamping values to a configured min/max range and returning 'unknown' when the state is unknown. MeteringSensor uses attribute 1024 and reports its value as watts ('W') without additional conversion. IlluminanceMeasurementSensor reports lux ('LUX'), and RelativeHumiditySensor reports percentage ('%').\n\nIn homeassistant/components/zha/const.py, the SINGLE_CLUSTER_DEVICE_CLASS mapping was extended so that endpoints with these clusters are recognized as 'sensor' devices, enabling automatic entity creation: IlluminanceMeasurement, RelativeHumidity, PowerConfiguration, and Metering are now mapped to the 'sensor' component.\n\nIn homeassistant/components/zha/__init__.py, device initialization was improved. If an endpoint's profile_id is not in zha_const.DEVICE_CLASS, it is treated as possibly manufacturer-specific, logged, and skipped, instead of attempting to treat it as a standard profile. This avoids creating broken or misleading entities for unsupported manufacturer-specific profiles.\n\nEntity identity and attributes also became richer. The entity_id now includes the class name for non-generic devices: '%(domain)s.%(manufacturer)s_%(model)s_%(ieeetail)s_%(endpoint_id)s_%(class_name)s', improving uniqueness and clarity. Additional device_state_attributes were added: endpoint_id, the device IEEE address, and a per-cluster attribute name for in_clusters and out_clusters (e.g., 'in_cluster (cluster_id)': cluster.name, 'out_cluster_cluster_id': cluster.name). These attributes expose low-level Zigbee details on each entity, aiding debugging and integration validation.\n\nAfter several iterations, whitespace and style issues (flake8/hound) were cleaned up, including dict spacing, comment formatting, and long log lines. The PR eventually was closed for CLA/signature reasons with a note that the author would open a new PR, but the technical change set remains a reference for how to extend ZHA with new sensor types and better metadata handling.",
        "semantic_memory": "Generalizable knowledge from this change:\n\n1. Mapping Zigbee clusters to platform entities\n- In a Zigbee-based integration, each standard cluster often corresponds to a specific type of logical entity (sensor, switch, binary_sensor, etc.). Maintaining a central mapping (e.g., SINGLE_CLUSTER_DEVICE_CLASS) from cluster classes to component types allows the system to automatically choose the correct Home Assistant platform for a given endpoint.\n- A factory function that inspects in_clusters of an endpoint and instantiates different entity subclasses based on the presence of specific cluster IDs is a clean way to support multiple sensor types from the same underlying discovery mechanism.\n\n2. Handling manufacturer-specific profiles safely\n- Zigbee devices may expose endpoints with manufacturer-specific profile IDs that don't conform to the standardized device/cluster mappings used by a generic integration. Treating these as standard profiles can create broken entities or silent failures.\n- A robust integration should explicitly check whether an endpoint's profile_id is known/handled; if not, it should log and skip initialization rather than guessing. This pattern applies broadly to protocol integrations where vendor-specific extensions exist.\n\n3. Exposing low-level protocol metadata for debugging\n- Including protocol-level context (endpoint ID, IEEE address, in/out cluster IDs and names) in an entity's state attributes is highly valuable for debugging, and for power users building automations or diagnosing why entities appear in certain ways.\n- Enriching entity_id naming with manufacturer, model, endpoint, and even the entity class name improves uniqueness and makes it easier to identify entities, especially when multiple similar devices are present.\n\n4. Vendor-specific value conversion logic\n- Some vendors expose raw sensor readings in non-standard units or scales. Implementing vendor-specific conversion logic (e.g., Centralite battery voltage-to-% mapping) in a dedicated entity subclass, and gating its use by manufacturer name, helps keep the general path generic while still supporting popular vendor quirks.\n- When doing such conversions, clamping raw values to a valid range and returning 'unknown' for invalid/uninitialized values is safer than trusting the raw input.\n\n5. Style and maintainability\n- Iteratively cleaning up code to follow project style (spacing, comments, line length) keeps the integration maintainable and consistent, which matters especially for large home automation projects where many contributors extend device support over time.",
        "procedural_memory": [
            "Step-by-step instructions on how to add and safely support new Zigbee sensor types in a Home Assistantâ€“like ZHA integration:",
            "Step 1: Identify the Zigbee clusters and device classes",
            "Determine which ZCL clusters correspond to the new sensor functionality (e.g., measurement.RelativeHumidity, measurement.IlluminanceMeasurement, general.PowerConfiguration, smartenergy.Metering).",
            "Confirm the attribute ID that carries the primary value (e.g., battery voltage attribute 32 on PowerConfiguration, attribute 1024 for Metering).",
            "If vendor-specific scaling or interpretation is required, note the manufacturer(s) that need special handling.",
            "Step 2: Extend the device-class mapping",
            "In your central ZHA constants or device-class registry (e.g., SINGLE_CLUSTER_DEVICE_CLASS), map each new cluster to the appropriate component type (usually 'sensor'):",
            "    SINGLE_CLUSTER_DEVICE_CLASS.update({",
            "        zcl.clusters.measurement.IlluminanceMeasurement: 'sensor',",
            "        zcl.clusters.measurement.RelativeHumidity: 'sensor',",
            "        zcl.clusters.general.PowerConfiguration: 'sensor',",
            "        zcl.clusters.smartenergy.Metering: 'sensor',",
            "    })",
            "This ensures endpoints with these clusters are discovered as sensors.",
            "Step 3: Implement sensor subclasses for each new cluster",
            "Create concrete entity classes that extend your base ZHA entity (e.g., Sensor extends zha.Entity):",
            "- For each sensor type, define:",
            "  - value_attribute: the ZCL attribute id to read.",
            "  - unit_of_measurement: the unit string to display.",
            "  - state: property that converts or returns the stored raw value.",
            "Example for a vendor-specific battery sensor:",
            "    class CentraliteBatterySensor(Sensor):",
            "        value_attribute = 32",
            "        minVolts = 15",
            "        maxVolts = 28",
            "        values = {",
            "            28: 100, 27: 100, 26: 100,",
            "            25: 90,  24: 90,",
            "            23: 70,  22: 70,",
            "            21: 50,  20: 50,",
            "            19: 30,  18: 30,",
            "            17: 15,  16: 1,   15: 0,",
            "        }",
            "        @property",
            "        def unit_of_measurement(self):",
            "            return '%'",
            "        @property",
            "        def state(self):",
            "            if self._state == 'unknown':",
            "                return 'unknown'",
            "            if self._state < self.minVolts:",
            "                self._state = self.minVolts",
            "            elif self._state > self.maxVolts:",
            "                self._state = self.maxVolts",
            "            return self.values.get(self._state, 'unknown')",
            "For simpler sensors (e.g., lux or humidity), just set the unit and return the raw value or a scaled variant.",
            "Step 4: Update the sensor factory / discovery logic",
            "Modify your ZHA sensor factory (e.g., make_sensor) to detect the new clusters in in_clusters and instantiate the correct class:",
            "    def make_sensor(discovery_info):",
            "        from bellows.zigbee.zcl.clusters.measurement import TemperatureMeasurement, IlluminanceMeasurement, RelativeHumidity",
            "        from bellows.zigbee.zcl.clusters.general import PowerConfiguration",
            "        from bellows.zigbee.zcl.clusters.smartenergy import Metering",
            "",
            "        in_clusters = discovery_info['in_clusters']",
            "",
            "        if TemperatureMeasurement.cluster_id in in_clusters:",
            "            sensor = TemperatureSensor(**discovery_info)",
            "        elif PowerConfiguration.cluster_id in in_clusters and discovery_info['manufacturer'] == 'CentraLite':",
            "            sensor = CentraliteBatterySensor(**discovery_info)",
            "        elif Metering.cluster_id in in_clusters:",
            "            sensor = MeteringSensor(**discovery_info)",
            "        elif IlluminanceMeasurement.cluster_id in in_clusters:",
            "            sensor = IlluminanceMeasurementSensor(**discovery_info)",
            "        elif RelativeHumidity.cluster_id in in_clusters:",
            "            sensor = RelativeHumiditySensor(**discovery_info)",
            "        else:",
            "            sensor = Sensor(**discovery_info)",
            "Ensure that on first join you bind the relevant cluster and set reporting/attribute read as appropriate, reusing existing patterns from the base Sensor/TemperatureSensor.",
            "Step 5: Safely handle manufacturer-specific Zigbee profiles",
            "In the async device initialization code, before using an endpoint, check whether its profile_id is recognized:",
            "    if endpoint.profile_id in zha_const.DEVICE_CLASS:",
            "        profile = zha_const.DEVICE_CLASS[endpoint.profile_id]",
            "        profile_clusters = profile.CLUSTERS[endpoint.device_type]",
            "        profile_info = zha_const.DEVICE_CLASS[endpoint.profile_id]",
            "        component = profile_info[endpoint.device_type]",
            "    else:",
            "        _LOGGER.info('Skipping endpoint with profile_id: %s', endpoint.profile_id)",
            "        continue",
            "This avoids trying to treat manufacturer-specific profiles as standard ZHA profiles, which would otherwise yield broken entities or errors.",
            "Step 6: Enrich entity identification and attributes",
            "Improve entity_id templates to include manufacturer, model, endpoint, and optionally the entity class name to reduce ambiguity:",
            "    self.entity_id = '%s.%s_%s_%s_%s_%s' % (",
            "        self._domain, slugify(manufacturer), slugify(model),",
            "        ieeetail, endpoint.endpoint_id, slugify(self.__class__.__name__),",
            "    )",
            "Attach Zigbee metadata to device_state_attributes for debugging:",
            "    self._device_state_attributes['endpoint_id'] = endpoint.endpoint_id",
            "    self._device_state_attributes['ieee'] = '%s' % (endpoint.device.ieee, )",
            "    for cluster in in_clusters.values():",
            "        cluster.add_listener(self)",
            "        self._device_state_attributes['%s (%s)' % ('in_cluster', cluster.cluster_id)] = cluster.name",
            "    for cluster in out_clusters.values():",
            "        cluster.add_listener(self)",
            "        self._device_state_attributes['%s_%s' % ('out_cluster', cluster.cluster_id)] = cluster.name",
            "This pattern generalizes to any protocol integration: include low-level IDs and names to aid troubleshooting.",
            "Step 7: Style, tests, and CLA (project hygiene)",
            "Run linters (flake8, hound, etc.) and fix spacing, comments, and long lines to match project guidelines.",
            "Add or adapt tests (if available in the project) to cover the new sensor classes and discovery routing.",
            "Ensure all commits are associated with a valid GitHub account and the project's CLA is signed before expecting the PR to be merged.",
            "Step 8: Diagnosing issues if a similar enhancement misbehaves",
            "- If new sensors are not appearing:",
            "  - Confirm the cluster is present in in_clusters and that the factory logic checks for its cluster_id.",
            "  - Ensure the cluster is added to the SINGLE_CLUSTER_DEVICE_CLASS mapping so the platform is detected as 'sensor'.",
            "  - Check logs for 'Skipping endpoint with profile_id' to see if the endpoint profile is unsupported.",
            "- If values look wrong:",
            "  - Verify value_attribute matches the correct Zigbee attribute ID.",
            "  - Confirm vendor-specific conversions (like battery) are correct for the given manufacturer.",
            "  - Check for 'unknown' state handling and whether the raw state is being received from the device at all.",
            "- If entities collide or are hard to distinguish:",
            "  - Consider including class name (or endpoint_id) in entity_id similar to this PR to improve uniqueness."
        ]
    }
}
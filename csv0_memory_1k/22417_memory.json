{
    "search_index": {
        "description_for_embedding": "Home Assistant Daikin integration extended to support AirBase zone control via switch entities. Adds a new switch platform that exposes each Daikin AirBase zone as a ToggleEntity, wires it into the config_entry flow, and bumps pydaikin from 1.2.0 to 1.3.1 to get zone support. Also sets PARALLEL_UPDATES=0 to serialize device access.",
        "keywords": [
            "Home Assistant",
            "Daikin",
            "AirBase",
            "zone control",
            "switch platform",
            "ToggleEntity",
            "config_entry",
            "pydaikin 1.3.1",
            "integration feature addition",
            "device.zones",
            "PARALLEL_UPDATES"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the Home Assistant Daikin integration was enhanced to support controlling Daikin AirBase zones, which previously were not exposed at all. The integration originally only registered 'climate' and 'sensor' platforms. Users wanted to individually enable/disable AirBase zones, but the library and integration provided no way to do this through Home Assistant.\n\nTo implement zone support, the developer:\n- Updated the Daikin component's COMPONENT_TYPES list to include 'switch' alongside 'climate' and 'sensor', allowing Home Assistant to set up a switch platform for Daikin devices.\n- Introduced a new `homeassistant/components/daikin/switch.py` module, defining a `DaikinZoneSwitch` class derived from `ToggleEntity`.\n- Implemented `async_setup_entry` in the switch platform to obtain the per-config-entry Daikin API object from `hass.data[DAIKIN_DOMAIN][entry.entry_id]`, inspect `daikin_api.device.zones`, and create one switch entity per zone index.\n- Ensured compatibility with legacy YAML-based setup by providing a no-op `setup_platform` function, so accidental configuration entries for `daikin.switch` don't crash the system, but are simply ignored.\n\nEach `DaikinZoneSwitch` entity:\n- Uses a unique ID composed of the Daikin MAC address and the zone index (`\"{mac}-zone{index}\"`).\n- Exposes a user-friendly name combining the Daikin device name and the zone name from `device.zones`.\n- Defines an icon (`mdi:home-circle`).\n- Implements `is_on` by checking whether the zone state field equals `'1'` in `device.zones[zone_id][1]`.\n- Implements `async_turn_on` and `async_turn_off` by calling `daikin_api.device.set_zone(zone_id, '1'/'0')`.\n- Implements `async_update` by delegating to `daikin_api.async_update()`.\n- Exposes `device_info` from the underlying daikin API to integrate with Home Assistant's device registry.\n\nDuring refinement, the name property was fixed to prefix the zone name with the device name, improving clarity in the UI. The retrieval of the `daikin_api` object in `async_setup_entry` was also corrected to use direct indexing (`hass.data[DAIKIN_DOMAIN][entry.entry_id]`) instead of `.get()`, ensuring an error surfaces if the entry is missing rather than silently returning `None`.\n\nTo support zone features provided by the underlying library, the `pydaikin` dependency was bumped from 1.2.0 to 1.3.1 in both the component (`REQUIREMENTS = ['pydaikin==1.3.1']`) and `requirements_all.txt`. Additionally, `PARALLEL_UPDATES = 0` was added to the Daikin integration to serialize updates, likely because the device or library is not safe or efficient with concurrent update calls.\n\nUsers confirmed the behavior by overriding the component inside a Docker container and testing with a real Daikin AirBase unit: zones appeared as switches in the Home Assistant UI and could be toggled on and off successfully.",
        "semantic_memory": "This change illustrates several generalizable patterns for extending an integration and safely exposing new device capabilities:\n\n1. **Adding a new entity platform to an existing integration**:\n   - Many Home Assistant integrations support multiple platform types (e.g., `climate`, `sensor`, `switch`). To add support for a new platform, you must register it in the integration's `COMPONENT_TYPES` (or an equivalent mechanism), and implement the new platform module (`switch.py`, `light.py`, etc.) with the standard `async_setup_entry` entry point.\n   - Use the integration's data stored in `hass.data[DOMAIN][entry_id]` so that all platforms share the same underlying API client per config entry.\n\n2. **Mapping device-specific concepts to standard entity types**:\n   - Daikin AirBase zones are an internal concept on the device, but they map neatly to a binary on/off entity in Home Assistant. Implementing them as `ToggleEntity` (switches) is a natural fit.\n   - When designing such mappings, choose entity classes that match behavior: zones as switches, feature flags as binary_sensors or switches, etc.\n\n3. **Using library version bumps to expose new capabilities**:\n   - Sometimes the integration cannot support a feature because the underlying library lacks it. When the library adds that feature, you must bump the dependency and ensure `requirements_all.txt` stays in sync.\n   - Version bumps should be minimal and deliberate, focusing on the feature required (here, `pydaikin` 1.3.1 for AirBase zones), and tested end-to-end.\n\n4. **Deriving robust unique IDs and entity names**:\n   - Unique IDs should combine stable identifiers (like device MAC addresses) with local indexes or identifiers (like a zone index) so Home Assistant can track entities across restarts and config changes.\n   - Entity names should be user-friendly; often combining the parent device name with a sub-component name (\"Living Room AC Zone 1\") is more understandable than the raw sub-component label alone.\n\n5. **Error handling and data access patterns in HA integrations**:\n   - Using `.get()` on required entries in `hass.data` can mask configuration or setup problems by returning `None` silently. Direct indexing ensures that missing entries raise errors during startup, making misconfigurations easier to detect.\n   - Provide legacy `setup_platform` stubs for integrations migrated to config entries so that legacy YAML references are safely ignored instead of breaking.\n\n6. **Concurrency control in device integrations**:\n   - Setting `PARALLEL_UPDATES = 0` ensures only one update runs at a time for the integration, which is important when the device or underlying library does not behave well under concurrent requests (e.g., network devices with simple/fragile HTTP APIs).\n   - This pattern can prevent subtle race conditions, timeouts, or inconsistent state when multiple entities share the same underlying connection.\n\nOverall, the fix demonstrates a pattern for cleanly exposing a new per-device feature (zones) while maintaining architectural consistency: use config entries, share a single API client, respect Home Assistant's entity lifecycle, and align dependency versions.",
        "procedural_memory": [
            "How to extend a Home Assistant integration to expose a new device capability via a new entity type (e.g., zones as switches).",
            "Step 1: Identify the underlying device feature and confirm library support",
            "Step 2: Update the integration's platform registration to include the new entity platform",
            "Step 3: Implement the new platform module with config_entry-based setup",
            "Step 4: Map device data structures to entity properties and unique IDs",
            "Step 5: Implement entity control methods (turn_on/turn_off) using the library's API",
            "Step 6: Ensure dependency versions and global requirements are updated",
            "Step 7: Consider concurrency limitations and set PARALLEL_UPDATES if needed",
            "Step 8: Provide safe handling for legacy configuration paths and test end-to-end",
            "Step 1: Verify the device library exposes the needed feature\n- Inspect the Python library (here, `pydaikin`) used by the integration and verify there is an API for the new feature (e.g., a `device.zones` property and `set_zone()` method).\n- If not available, upgrade the library to a version that includes the feature, and confirm its API surface from documentation or code.\n\nStep 2: Bump the integration's dependency and global requirements\n- Update the integration's `REQUIREMENTS` constant to the new library version (e.g., change `pydaikin==1.2.0` to `pydaikin==1.3.1`).\n- Update `requirements_all.txt` to the same version so that CI and full builds use the new library.\n- Run the requirements generation script if applicable (e.g., `script/gen_requirements_all.py`).\n\nStep 3: Register the new entity platform\n- Locate the integration's main `__init__.py` and find the list of supported platforms (e.g., `COMPONENT_TYPES = ['climate', 'sensor']`).\n- Add the new platform type (e.g., `'switch'`) to this list.\n- Ensure the integration's setup routines iterate over this list to call `async_forward_entry_setup` or equivalent for all supported platforms.\n\nStep 4: Implement the new platform module\n- Create a new module such as `homeassistant/components/<domain>/switch.py`.\n- Import the appropriate entity base class (e.g., `from homeassistant.helpers.entity import ToggleEntity`).\n- Implement `async_setup_entry(hass, entry, async_add_entities)`:\n  - Retrieve the integration's API client: `daikin_api = hass.data[DOMAIN][entry.entry_id]`.\n  - Access the relevant feature data (e.g., `zones = daikin_api.device.zones`).\n  - If zones exist, create one entity instance per zone index and pass them to `async_add_entities`.\n- Implement a no-op `setup_platform` if you need to gracefully handle deprecated YAML-based platform setups.\n\nStep 5: Design the entity class mapping\n- Subclass a suitable entity type (e.g., `class DaikinZoneSwitch(ToggleEntity)`).\n- Store references to the shared API client and a feature-specific identifier (e.g., `zone_id`).\n- Implement:\n  - `unique_id` using stable identifiers (e.g., `f\"{api.mac}-zone{zone_id}\"`).\n  - `name` combining parent device name and the sub-feature name (e.g., `f\"{api.name} {zone_name}\"`).\n  - `icon` if a specific icon is appropriate.\n  - `is_on` by mapping the device state (e.g., `device.zones[zone_id][1] == '1'`).\n  - `device_info` returning the parent device info for the device registry.\n  - `async_update` delegating to the shared API client's update method.\n  - `async_turn_on` / `async_turn_off` calling the library methods (e.g., `set_zone(zone_id, '1'/'0')`).\n\nStep 6: Access integration data robustly\n- When accessing `hass.data[DOMAIN]`, use direct indexing (`[...]`) for required entries, not `.get()`, so missing data raises clear errors during setup.\n- Keep all platforms using the same entry key (`entry.entry_id`) so they share the same underlying connection or client instance.\n\nStep 7: Manage concurrency if the device is sensitive\n- If the device or library misbehaves under concurrent access, set `PARALLEL_UPDATES = 0` in the integration's `__init__.py` to serialize all entity updates.\n- Alternatively, configure an appropriate positive integer if limited parallelism is supported.\n\nStep 8: Provide compatibility and test\n- Include a `setup_platform` stub for deprecated YAML config paths that safely do nothing but avoid errors when users accidentally configure the platform explicitly.\n- Build a test environment (e.g., Docker image overriding component files) to run Home Assistant with the updated integration.\n- Verify that the new entities appear in the UI, that their names and unique IDs are correct, and that toggling them changes the device state as expected.\n- Run the test suite (tox, pytest, etc.) to ensure no regressions."
        ]
    }
}
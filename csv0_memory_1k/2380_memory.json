{
    "search_index": {
        "description_for_embedding": "Revert of a 'keep_for_evo' batch evolution feature in PokemonGo-Bot that modified transfer_pokemon release logic. The feature used candy counts and complex grouping to keep Pokémon for evolution, but it caused incorrect release decisions and mass deletion of high-value Pokémon. The fix removes the keep_for_evo config, candy-based logic, and extra paths in transfer_pokemon, simplifying should_release_pokemon and returning to safer, simpler keep_best and release_below_cp/iv behavior.",
        "keywords": [
            "PokemonGo-Bot",
            "transfer_pokemon.py",
            "keep_for_evo",
            "batch evolution",
            "release logic bug",
            "mass transfer",
            "config interaction",
            "candies inventory",
            "revert feature",
            "data loss"
        ]
    },
    "agent_memory": {
        "episodic_memory": "A feature PR introduced a `keep_for_evo` configuration to PokemonGo-Bot that attempted to keep enough Pokémon for batch evolution based on available candies. It extended the transfer logic in `pokemongo_bot/cell_workers/transfer_pokemon.py` and added a `get_candies` helper in `utils.py`. This logic attempted to: (1) group Pokémon by species, (2) keep \"best\" Pokémon by CP/IV, (3) then keep additional Pokémon for evolution based on candy counts and evolution requirements, and finally (4) transfer the rest. The feature also added `keep_for_evo` examples to multiple config templates.\n\nIn practice, this drastically complicated an already complex release/transfer function and interacted badly with existing release configuration (keep_best, release_below_cp, release_below_iv, etc.). Users reported that the bot started releasing high-value Tier 2 and Tier 3 Pokémon (e.g., Charizard, Dragonite) even though their configs had not changed and did not indicate that these should be released. The issue was severe because it caused irreversible loss of rare Pokémon; it was traced back to the new batch-evolution/keep_for_evo logic altering which Pokémon were considered safe to transfer.\n\nTo quickly stop the data loss and stabilize behavior, the maintainer reverted the feature. The fix commit:\n- Removed `keep_for_evo` examples from `configs/config.json.*.example` files.\n- Deleted `get_candies(bot)` from `pokemongo_bot/cell_workers/utils.py` and all candy-based evolution calculations.\n- Simplified `TransferPokemon.work`: it now either (a) computes and logs best Pokémon to keep (by CP/IV) and transfers the others using a clear `transfer_pokemons` list, or (b) sorts by CP and applies standard `should_release_pokemon` logic for transfer, without any evolution-specific behavior.\n- Removed the `keep_for_evo` flag from `_validate_keep_best_config` so it only returns `keep_best`, `keep_best_cp`, and `keep_best_iv`.\n- Adjusted `should_release_pokemon` to accept an optional `keep_best_mode` flag and to treat the \"within keep-best selection\" case differently: when running in keep-best mode and no explicit `never_release`, `always_release`, or release_below_* thresholds are configured, it simply marks the non-best Pokémon as transferable instead of trying to reinterpret the config.\n\nThe net effect is that the bot returns to the prior, simpler behavior that only respects explicit release rules and keep_best settings, without attempting to optimize for batch evolution via candy counts, thereby eliminating the bug that caused unintended mass releases.",
        "semantic_memory": "This incident illustrates several generalizable lessons about designing and deploying features that affect destructive operations (like deletions or transfers of valuable items):\n\n1. **Destructive logic must be simple and testable.** The original transfer logic was already complex; adding a `keep_for_evo` mode with candy-based calculations increased complexity to the point where subtle logic errors led to catastrophic outcomes (releasing rare Pokémon). For operations that can cause irreversible data loss, the logic should be minimized, well-factored, and heavily tested.\n\n2. **Avoid entangling multiple concerns in one function.** The transfer worker attempted to handle: (a) keeping best Pokémon, (b) honoring general release criteria, and (c) calculating optimal sets to keep for evolution based on candy counts. Combining these concerns made it hard to reason about which configuration applied when, and how edge cases were handled. Separate, smaller methods or even separate tasks make behavior clearer and easier to validate.\n\n3. **Configuration-driven behavior is high-risk when it changes deletion semantics.** Adding a new boolean flag `keep_for_evo` that subtly altered transfer decisions created surprising behavior for users who did not change their config. When configs can affect deletions, new options should default to safe behavior, be clearly documented, and be guarded by feature flags or staged rollout.\n\n4. **If a bug causes severe data loss, a full revert is often the correct immediate response.** Instead of attempting an in-place hotfix in complicated logic, reverting the feature restored known-good behavior quickly. The feature can then be redesigned and reintroduced later with better structure and automated tests.\n\n5. **Automated tests around critical invariants are crucial.** There were no robust tests asserting that certain Pokémon (e.g., tiered or high-IV ones) must never be released under given configs. The author later acknowledged the need to add tests specifically around release logic. High-risk operations should be guarded by unit and integration tests that simulate realistic configurations and inventories.\n\n6. **Advanced features depending on dynamic state (like candy counts) should be isolated.** Using external, dynamic state (candies from inventory) to decide what to delete complicates reasoning about safety. Such logic should be clearly isolated, possibly optional, and covered by scenario tests that verify that the resulting set of deletions matches expectations.\n\nOverall, the core pattern is: when extending behavior around deletion/transfer of user assets, minimize complexity, isolate new features, add strong safety tests, and be ready to revert quickly if production behavior is not fully understood.",
        "procedural_memory": [
            "When a new feature changes delete/transfer logic and users report unexpected data loss, prioritize safety and rollback before attempting refinements.",
            "Step 1: **Stop the damage.** Disable the feature in production if possible (e.g., by config or feature flag). If not, prepare a quick revert of the offending PR or commit.",
            "Step 2: **Reproduce the problem in a safe environment.** Use test accounts or mocked data to replicate user configs and inventories. Verify that the new logic indeed releases items that should be kept.",
            "Step 3: **Inspect configuration interactions.** Look at how new config keys (e.g., `keep_for_evo`) interact with existing keys (`keep_best_cp`, `keep_best_iv`, `release_below_cp`, `release_below_iv`, `never_release`, `always_release`). Identify any branches where default or missing values lead to unintended deletion decisions.",
            "Step 4: **Trace the decision path in the code.** In the deletion/transfer function (here `TransferPokemon.work` and `should_release_pokemon`), follow:\n  - How items are grouped (by species or other keys).\n  - Which items are considered \"best\" and removed from the candidates list.\n  - How remaining items are filtered by release logic, especially when multiple modes (keep_best, keep_for_evo, etc.) are combined.\n  - Any use of external state (inventory, candy counts) that might change the effective thresholds.",
            "Step 5: **Check for side effects caused by in-place mutations.** Be careful with modifying lists (e.g., removing Pokémon from `group`) while iterating over them; this can produce skipped elements or mismatched counts and lead to erroneous deletions. Prefer building new lists (`to_keep`, `to_transfer`) rather than in-place removals.",
            "Step 6: **If logic is too tangled to be safely patched, revert.** When a function conflates several concerns and a quick patch risks introducing new bugs, revert the feature to restore the previous, known-good behavior. This is what was done here: remove the `keep_for_evo` config, candy-based evolution logic, and extra branching paths.",
            "Step 7: **Simplify and refactor before reintroducing.** Plan to break down the feature into smaller, well-defined methods, for example:\n  - One method to select 'best' items to always keep.\n  - One method to compute how many items to keep for evolution based on candies.\n  - One method that applies release rules and executes transfers.\n  Each should have clear inputs/outputs with no hidden state.",
            "Step 8: **Add regression tests for deletion invariants.** Write tests that encode the expectations users care about, such as: 'Given this config and this inventory, no Tier 2/3 or high-IV Pokémon are released.' Include:\n  - Tests that cover each combination of config flags, including defaults.\n  - Tests specifically for new features (e.g., batch evolution) verifying both kept and transferred sets.",
            "Step 9: **Guard new behavior behind explicit, safe defaults.** For any future `keep_for_evo`-like feature, ensure that:\n  - The default is off (or safe) unless the user opts in.\n  - The behavior is clearly documented in example configs.\n  - Edge cases (e.g., zero candies, multiple evolution stages) are handled safely (prefer keeping too many rather than releasing too many).",
            "Step 10: **Communicate risk and request testing for critical PRs.** Before merging features that can delete user assets, mark the PR as high-risk, request manual testing from multiple contributors, and consider staging or canary deployment if the project supports it."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Fixes PokemonGo-Bot inventory desync by updating internal player experience on catch/evolve/spin events and avoiding redundant level_up_rewards API calls. Level-up is now computed locally when exp crosses next_level_xp, with a guard to prevent recursive setter issues.",
        "keywords": [
            "inventory",
            "player exp",
            "experience desync",
            "level_up_rewards API spam",
            "property setter side effects",
            "PokemonGo-Bot",
            "level up logic",
            "fort spin experience_awarded",
            "pokemon_catch_worker",
            "evolve_pokemon",
            "performance optimization",
            "API throttling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the bot's internal player statistics were out of sync with the game server, and it was making redundant calls to the level_up_rewards API. The inventory component had logic in the level and exp property setters that called level_up_rewards whenever these values changed and a TTL elapsed. This caused unnecessary API calls and was a poor place for side-effectful behavior.\n\nAt the same time, the bot wasn't updating its internal player experience for common actions such as catching a Pokémon, evolving a Pokémon, or spinning a fort. As a result, the in-memory player exp and level could lag behind what the server considered the player state, leading to inconsistent behavior around level-ups and rewards.\n\nThe fix had two main parts:\n1. Update internal exp on relevant gameplay events:\n   - In evolve_pokemon.py, after a successful evolution, the code now increments `inventory.player().exp` by the XP reward from evolution.\n   - In pokemon_catch_worker.py, after adding a caught Pokémon to inventory, it computes `exp_gain` from the capture_award XP and increments `inventory.player().exp` by that amount.\n   - In spin_fort.py, when handling a successful fort spin, it reads `experience_awarded` from the FORT_SEARCH response and increments `inventory.player().exp` accordingly.\n\n2. Simplify and correct the level/exp handling in inventory.py:\n   - Removed `last_lvl_up_reward` and the `level_up_rewards` API calls from the `level` and `exp` setters, eliminating the hidden side effects and API spam.\n   - Changed the `exp` setter to perform a local level-up check: when the new exp value is greater than or equal to `next_level_xp`, it increments the internal level and temporarily inflates `next_level_xp` by a large number (10,000,000) to prevent repeated level-ups until the next server heartbeat updates stats.\n   - Initially, the code incorrectly used `self.level + 1` (which would trigger the level setter and potentially cause recursion or depend on outdated value); this was corrected to `self._level + 1`, directly incrementing the underlying field.\n   - The parsing order was adjusted so that `next_level_xp` is set from the server `item` before assigning `exp`, ensuring the exp setter compares against a proper threshold.\n\nAfter these changes, the bot's internal exp and level track real gameplay events more accurately, avoids redundant level_up_rewards calls from property setters, and has a safer, more predictable level calculation path.",
        "semantic_memory": "This fix highlights several generalizable software engineering lessons:\n\n1. Avoid heavy side effects in property setters/getters:\n   - Embedding API calls (like `level_up_rewards`) inside simple property setters (e.g., `exp`, `level`) can cause invisible, hard-to-debug behavior, including redundant network calls and unexpected recursion.\n   - Setters should primarily manage local state; expensive operations should be triggered explicitly in well-defined flows.\n\n2. Keep client-side state in sync with server responses at the source of truth:\n   - Whenever an action (catching, evolving, spinning a fort) yields rewards such as XP, the corresponding in-memory state should be updated immediately using the values returned by the server response.\n   - Relying solely on periodic heartbeats or separate API calls to 'refresh' state can lead to lagging or inconsistent behavior.\n\n3. Order of initialization matters when logic depends on related fields:\n   - The level-up logic required that `next_level_xp` be set before assigning `exp`, because the exp setter compares against `next_level_xp`. Parsing fields in the wrong order can lead to subtle bugs where thresholds are incorrect during initialization.\n\n4. Be careful with recursive or indirect property usage inside setters:\n   - Using `self.level` inside the `exp` setter to update `level` can call the level setter and cause unintended recursion or re-trigger logic.\n   - When necessary, manipulate the underlying storage (`self._level`) inside setters to avoid re-entering high-level logic.\n\n5. Rate-limit and centralize network calls that depend on state transitions:\n   - Instead of tying API calls to every exp change, trigger them on clear, validated state transitions (e.g., confirmed level-up events from the server) or in a heartbeat mechanism that checks for changes.\n   - This improves performance and reduces the risk of hitting rate limits or being flagged for suspicious behavior.\n\n6. Use temporary guards/hacks with clear comments when awaiting authoritative updates:\n   - The fix uses a large bump to `next_level_xp` as a guard to prevent multiple local level-ups before the next heartbeat refreshes stats from the server. When such patterns are used, they should be clearly documented as interim guards depending on a later authoritative sync.",
        "procedural_memory": [
            "When diagnosing issues where a client-side game bot or app has inconsistent user stats and/or makes redundant API calls, follow these steps:",
            "Step 1: Identify where state is updated.",
            "Search for all places where key state (e.g., player exp, level, currency) is modified. Check both explicit updates in feature logic (e.g., after an action) and implicit updates in property setters/getters or observers.",
            "Step 2: Look for hidden side effects in setters/getters.",
            "Inspect property setters (like `exp` and `level`) for any non-trivial side effects such as network calls, disk I/O, or triggering complex workflows. If they exist, consider whether these should instead be handled in more explicit, higher-level logic.",
            "Step 3: Ensure the state is updated at the point of the server response.",
            "For each action that yields rewards (catch, evolve, spin, battle, etc.), locate the API response handling. Extract experience or other rewards (e.g., `capture_award.xp`, `FORT_SEARCH.experience_awarded`) and update the internal state there, immediately after the response is confirmed as successful.",
            "Step 4: Centralize and rationalize transition-triggered API calls.",
            "If you have an API like `level_up_rewards` that is supposed to be called on specific state transitions (like leveling up), implement a clear, central mechanism to decide when to call it. Do not scatter calls in multiple setters or unrelated code paths. Prefer a single point where the level change is confirmed, then invoke the external API once.",
            "Step 5: Correct initialization order for dependent fields.",
            "When parsing or initializing state objects, ensure that dependent fields are set in the correct order. For example, if the `exp` setter compares against `next_level_xp`, assign `next_level_xp` from the server data before setting `exp` so the comparison uses a valid threshold.",
            "Step 6: Avoid recursive property usage inside setters.",
            "Inside a setter (e.g., `exp`), be cautious about reading or setting other properties that themselves have setters with logic. If needed, operate on the underlying private fields (e.g., `self._level`) instead of the public property (`self.level`) to avoid re-entering higher-level logic or causing recursion.",
            "Step 7: Implement a local guard for inferred transitions, then sync with the server.",
            "If you infer state transitions locally (e.g., exp surpassing `next_level_xp` implies a level-up), implement a guard to avoid repeated triggering (e.g., temporarily setting `next_level_xp` to a high value) until an authoritative server sync (heartbeat) confirms the new level and updated thresholds.",
            "Step 8: Test a full flow across multiple actions.",
            "After changes, run through realistic usage scenarios (catching, evolving, spinning forts, etc.) and verify that internal exp and level match server responses, that level-up transitions occur once, and that transition-related APIs are called exactly once per real event.",
            "Step 9: Monitor API call volume before and after.",
            "Measure how often specific APIs (like level_up_rewards) are called before and after your fix. Confirm that redundant calls are eliminated while functional calls still occur when needed."
        ]
    }
}
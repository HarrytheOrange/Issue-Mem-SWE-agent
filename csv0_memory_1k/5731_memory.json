{
    "search_index": {
        "description_for_embedding": "Home Assistant webOS TV integration (media_player.webostv and notify.webostv) previously stored the LG webOS pairing key in the user's home directory (~/.pylgtv). This caused issues with Home Assistant's configuration and portability. The fix adds a configurable filename option, stores the pairing key in Home Assistant's config directory (default webostv.conf), and updates the pylgtv dependency to a version that supports custom key file paths.",
        "keywords": [
            "webostv",
            "media_player.webostv",
            "notify.webostv",
            "pylgtv",
            "pairing key",
            "config directory",
            "CONF_FILENAME",
            "hass.config.path",
            "Home Assistant",
            "configuration path bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant webOS TV integration stored its pairing key (used to authenticate with LG webOS TVs) in a hard-coded location: $HOME/.pylgtv. This was inconsistent with Home Assistant's standard practice of keeping integration configuration inside the Home Assistant configuration directory, and it also made setups less portable and more confusing for users running HA under different accounts or in containers.\n\nTo fix this, the media_player.webostv and notify.webostv components were updated to accept a configurable filename for the key file via the standard configuration.yaml. A new constant CONF_FILENAME is used, with a default of 'webostv.conf'. In media_player.webostv, the setup_platform reads CONF_FILENAME from the config, converts it to an absolute path under the Home Assistant configuration directory using hass.config.path(), and passes that path to the pylgtv WebOsClient constructor. The notify.webostv component mirrors this behavior: it also reads CONF_FILENAME, resolves it with hass.config.path(), and passes it to WebOsClient as key_file_path.\n\nBecause the existing pylgtv library didn’t support specifying a custom key-file path, the integration bumped its dependency from the old TheRealLink/pylgtv v0.1.2 to a forked/updated version pschmitt/pylgtv v0.1.3, which introduces support for providing a key_file_path parameter. requirements_all.txt was updated accordingly to reference the new pylgtv archive URL and version.\n\nAfter this change, the pairing key is stored as webostv.conf inside the Home Assistant config directory by default, or in a user-specified file under that directory. This aligns the integration with HA’s configuration conventions and avoids the previous confusion and environment-specific path issues.",
        "semantic_memory": "Several generalizable lessons emerge from this fix:\n\n1. **Respect the host application's config directory**: Integration-specific state (credentials, pairing keys, etc.) should be stored in a location controlled by the host application (here, Home Assistant’s config directory), not in arbitrary user-level paths like $HOME/.something. This ensures consistent behavior across environments (systemd services, Docker, virtualenvs, different users) and simplifies backups and migration.\n\n2. **Make file paths configurable, but with sensible defaults**: Introduce configuration options (e.g., CONF_FILENAME) with safe, documented defaults (e.g., 'webostv.conf'). This preserves backward compatibility while giving advanced users flexibility without hard-coding paths in code.\n\n3. **Use the framework’s path utilities**: Always use the platform’s helper functions (e.g., hass.config.path()) to resolve file paths relative to the app’s configuration directory. This avoids subtle bugs with relative vs. absolute paths and different working directories.\n\n4. **Coordinate with external dependencies**: When you need new behavior from an external library (like specifying a custom key file path), you may need to update or fork that dependency. Remember to bump the requirement version and update global requirements lists or lockfiles. Ensure the library API actually supports the new usage before changing integration code.\n\n5. **Keep related components consistent**: When multiple components (media_player.webostv and notify.webostv) rely on the same underlying library and state files, they should share configuration conventions (same filename option and path resolution behavior) to avoid duplicated configuration and surprising differences for users.\n\n6. **Avoid hidden global state via third-party defaults**: Libraries that default to writing in $HOME or other global locations hide state outside the main app’s control. When integrating such libraries, override those defaults so that all persistent state is explicitly managed by the host application.",
        "procedural_memory": [
            "How to diagnose and fix a mislocated config/credential file in an integration:",
            "Step 1: Identify the symptom. Look for user reports that an integration cannot connect or re-pairs repeatedly, especially after environment changes (different user, container, or host). Check logs for missing or unreadable state/credential files.",
            "Step 2: Locate where the integration or its underlying library writes persistent state (e.g., pairing keys, tokens). Search for hard-coded paths (like '~/.libname', '/tmp/…', or direct uses of os.path.expanduser) in both the integration code and the library.",
            "Step 3: Verify alignment with the host application's conventions. For Home Assistant, persistent integration state should generally live under hass.config.path(...). If the library defaults to $HOME or another global location, treat this as a design issue.",
            "Step 4: Introduce a configuration option if needed. Add a config schema entry (e.g., vol.Optional(CONF_FILENAME, default='webostv.conf'): cv.string) and update docs to expose this to the user. Choose a sane default filename that will live under the app’s config directory.",
            "Step 5: Resolve the correct path using the framework's helper. In setup or initialization code, take the configured filename and convert it to an absolute path using the application helper (for HA: path = hass.config.path(config.get(CONF_FILENAME))). Avoid manual path concatenation or relying on the current working directory.",
            "Step 6: Wire the resolved path into the external library. Update the integration to pass the resolved path into the library constructor or initialization, using the library's supported parameter (e.g., WebOsClient(host, key_file_path=path)). Update the library dependency if required.",
            "Step 7: Update dependencies. If a new version of the library is needed to support the custom path, bump the version in the component’s REQUIREMENTS and any global requirements files (such as requirements_all.txt). Ensure the source URL and version match and run dependency generation scripts if your project uses them.",
            "Step 8: Keep all related components consistent. For any other components using the same library or state file, add the same configuration option and path resolution logic so they all point to the same file under the config directory.",
            "Step 9: Test end-to-end. Start with a clean environment without an existing key file: configure host and filename, start the application, pair with the device, and verify that the new file is created in the expected config directory. Restart the app and confirm that it reuses the same file and does not reprompt for pairing.",
            "Step 10: Document the behavior. Update integration documentation to describe the new filename option, the default path (e.g., $HASS_CONFIG_DIR/webostv.conf), and migration notes (e.g., users may want to move existing keys from ~/.pylgtv to the new location)."
        ]
    }
}
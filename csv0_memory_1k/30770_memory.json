{
    "search_index": {
        "description_for_embedding": "Refactor of Home Assistant's sun integration to use a config entry and config flow instead of purely YAML-based setup. Introduces a single-instance config flow, wires async_setup to start the flow, defines DOMAIN in const.py, marks manifest as config_flow-enabled, and adds tests ensuring only one sun config entry can be created.",
        "keywords": [
            "home-assistant",
            "sun integration",
            "config entry",
            "config_flow",
            "single_instance_allowed",
            "async_setup_entry",
            "DOMAIN",
            "manifest.json",
            "generated/config_flows.py",
            "MockConfigEntry",
            "integration migration",
            "non-device integration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the author attempted to modernize the Home Assistant `sun` integration by migrating it from a purely YAML-based setup to a config-entry-driven integration with a config flow. The main goals were: (1) make `sun` use the same config entry framework as other integrations, (2) ensure the system enforces that only a single instance of `sun` can be configured, and (3) keep behavior functionally identical from the user's perspective.\n\nThe implementation introduced a new `const.py` with `DOMAIN = \"sun\"`, updated `__init__.py` to:\n- Import `SOURCE_USER`, `configured_instances`, and the shared `DOMAIN`.\n- In `async_setup`, short-circuit if there is already a configured instance.\n- Preserve a warning if `CONF_ELEVATION` is set in YAML, pointing users to the core config.\n- Kick off a config flow via `hass.config_entries.flow.async_init(DOMAIN, context={\"source\": SOURCE_USER})` and return `True`.\n- Add `async_setup_entry` which instantiates the `Sun` entity when a config entry is created.\n\nA new `config_flow.py` defined `configured_instances(hass)` to return the set of existing sun config entry IDs and registered `SunFlowHandler` with the config entries system. `SunFlowHandler.async_step_user` aborts with reason `single_instance_allowed` if any sun entries already exist; otherwise, it creates a single default entry with empty data. Type hints were added and a minor lint cleanup removed an unnecessary blank line.\n\nThe `manifest.json` was updated to `\"config_flow\": true`, and `sun` was added to `generated/config_flows.py` so the system recognizes that it supports config flows. Localized strings (`strings.json` and `.translations/en.json`) were added for the integration title and the single-instance abort message. Tests in `tests/components/sun/test_config_flow.py` validated that a second instance is rejected and that the initial user step creates a default entry with empty data. The PR passed local tests.\n\nHowever, during review, core maintainers questioned whether `sun` (a core, built-in abstraction rather than a device or external service) should be represented as a config entry at all. Config entries are primarily targeted at devices/services, while other internal integrations are managed differently. With no clear consensus and concerns about the architectural direction (e.g., other integrations like zones being moved out of config entries), the author ultimately closed the PR, noting they would reopen when there was a clearer decision. Thus, the proposed migration was fully implemented in code but not merged.",
        "semantic_memory": "This PR illustrates patterns and considerations when migrating a simple, core Home Assistant integration to the config entries framework, and the design trade-offs involved.\n\nKey conceptual takeaways:\n\n1. **Single-instance config flow pattern**:\n   - Some integrations should only exist once (e.g., global abstractions like `sun`). For these, the config flow should enforce a single-instance constraint.\n   - The pattern is to have a helper like `configured_instances(hass)` that scans `hass.config_entries.async_entries(DOMAIN)` and uses that in `async_step_user` to abort additional flows with a standardized `single_instance_allowed` reason.\n   - This is paired with matching translation/strings entries for the `single_instance_allowed` abort reason.\n\n2. **Bootstrap from legacy YAML setup to a config entry**:\n   - For integrations that historically were set up via `async_setup(hass, config)`, you can keep `async_setup` very thin and use it to kick off a config flow instead of performing the actual setup logic.\n   - `async_setup` can call `hass.config_entries.flow.async_init(DOMAIN, context={\"source\": SOURCE_USER})` and then immediately return `True`, letting the config entries framework eventually call `async_setup_entry` where the actual integration initialization occurs.\n   - This allows a smooth migration path from YAML-based setup to config entries while maintaining backward compatibility and automatic onboarding of existing setups.\n\n3. **Separation of concerns via `const.py` and manifest flags**:\n   - Centralizing the `DOMAIN` constant in `const.py` and importing it wherever needed (config flow, __init__, tests) is a typical Home Assistant pattern, reducing duplication and typos.\n   - Marking `\"config_flow\": true` in `manifest.json` and listing the integration in `generated/config_flows.py` are mandatory wiring steps to enable the config flow system.\n\n4. **Tests for config flows**:\n   - Config flows should be unit tested with scenarios like \"first run\" (creates entry) and \"duplicate run\" (aborts with appropriate reason).\n   - `MockConfigEntry` can be used to simulate an existing integration entry in `hass`, allowing tests to verify the `single_instance_allowed` behavior.\n\n5. **Architectural consideration: when to use config entries**:\n   - Config entries are best suited for integrations representing devices or external services that are user-configurable and may exist in multiple instances (or at least conceptually are user-added units).\n   - Core, always-on abstractions that don't have user-tunable connection parameters (like `sun`) may not need or benefit from being config entries; they can remain as internal integrations with simple `async_setup` routines.\n   - Decisions to migrate such core integrations should consider broader architectural direction, to avoid churn (e.g., some integrations being moved out of config entries while others are being moved in).\n\nOverall, this PR demonstrates the pattern to refactor an integration into a config entry and the importance of aligning such changes with the overarching architectural guidelines for the platform.",
        "procedural_memory": [
            "Step-by-step guide: Migrating a simple integration to a config entry with a single-instance config flow in Home Assistant:",
            "Step 1: Extract and centralize DOMAIN",
            "Create a `const.py` for the integration and define `DOMAIN = \"your_domain\"` there.\nUpdate all modules that previously hard-coded the domain string (such as `__init__.py`, `config_flow.py`, and tests) to import `DOMAIN` from this module.",
            "Step 2: Enable config flow in the manifest",
            "In `manifest.json`, add or set `\"config_flow\": true` for the integration.\nEnsure other manifest fields (domain, name, documentation, requirements) are correct.",
            "Step 3: Register the integration in generated config_flows",
            "Add the integration's domain string (e.g., \"sun\") to `homeassistant/generated/config_flows.py` in the list of supported config flow domains.\nRegenerate this file via the appropriate project script if necessary, instead of editing manually in production workflows.",
            "Step 4: Implement the config flow handler",
            "Create `config_flow.py` for the integration.\nImport `config_entries` and `HomeAssistant`/`callback` from `homeassistant.core`.\nDefine a helper:\n\n```python\n@callback\ndef configured_instances(hass: HomeAssistant) -> Set[str]:\n    return {entry.entry_id for entry in hass.config_entries.async_entries(DOMAIN)}\n```\n\nRegister the config flow handler:\n\n```python\n@config_entries.HANDLERS.register(DOMAIN)\nclass YourIntegrationFlowHandler(config_entries.ConfigFlow):\n    VERSION = 1\n    CONNECTION_CLASS = config_entries.CONN_CLASS_ASSUMED\n\n    async def async_step_user(self, user_input: Optional[dict] = None) -> Dict[str, Any]:\n        if configured_instances(self.hass):\n            return self.async_abort(reason=\"single_instance_allowed\")\n        return self.async_create_entry(title=\"Default\", data={})\n```\n\nFor multi-instance integrations, replace the single-instance logic with appropriate user-input forms and validation.",
            "Step 5: Wire up async_setup to bootstrap the config flow",
            "In `__init__.py`, import `SOURCE_USER` from `homeassistant.config_entries`, and `configured_instances` and `DOMAIN` from the integration's modules.\nModify `async_setup(hass, config)` as follows:\n- If the integration should only exist once, check `if configured_instances(hass): return True` to no-op when already configured.\n- Preserve any backward-compatible warnings or handling for deprecated YAML options.\n- Use `hass.async_create_task(hass.config_entries.flow.async_init(DOMAIN, context={\"source\": SOURCE_USER}))` to kick off a config flow.\n- Return `True` to indicate setup succeeded (the actual integration setup will be done in `async_setup_entry`).",
            "Step 6: Implement async_setup_entry",
            "Add an `async_setup_entry(hass, config_entry)` function to `__init__.py`.\nMove or replicate the integration's core initialization code here (e.g., creation of entities, registration of listeners, etc.).\nFor a simple integration like `sun`, this might just instantiate the main entity: `Sun(hass)`.\nReturn `True` to indicate entry setup success.",
            "Step 7: Add translations for config flow UI messages",
            "Create or update `strings.json` and `.translations/en.json` (and other languages as needed) to include `config.title` and any abort reasons.\nExample:\n\n```json\n{\n  \"config\": {\n    \"title\": \"Sun\",\n    \"abort\": {\n      \"single_instance_allowed\": \"Only a single configuration of the sun integration is allowed.\"\n    }\n  }\n}\n```\n\nThis ensures that the UI shows meaningful text when the config flow aborts due to existing instances.",
            "Step 8: Write tests for the config flow behavior",
            "Create tests under `tests/components/<integration>/test_config_flow.py`.\nUse `MockConfigEntry` to simulate existing entries.\nTest cases should include:\n- When an entry already exists, `async_step_user` returns an abort result with reason `single_instance_allowed`.\n- When no entry exists, `async_step_user` returns a create entry result with the expected `title` and `data`.\nExample pattern:\n\n```python\nasync def test_more_than_one_instance_error(hass):\n    MockConfigEntry(domain=DOMAIN, data={}).add_to_hass(hass)\n    flow = config_flow.YourIntegrationFlowHandler()\n    flow.hass = hass\n    result = await flow.async_step_user()\n    assert result[\"type\"] == data_entry_flow.RESULT_TYPE_ABORT\n    assert result[\"reason\"] == \"single_instance_allowed\"\n```\n\nEnsure tests run via the project's test runner (e.g., `tox`).",
            "Step 9: Consider architectural fit before merging",
            "Before committing to migrating a core integration to config entries, confirm it aligns with the platform's architectural direction.\nAsk: is this integration a device or external service with user-managed instances, or a core abstraction that may be better configured globally without entries?\nIf in doubt, discuss with project maintainers early; this can prevent implementing a full migration that ends up being rejected or rolled back.",
            "Step 10: Diagnose similar issues in the future",
            "When an integration needs modernization or configuration unification:\n- Check if it currently uses YAML-only setup in `async_setup`.\n- Determine whether there is a need for multiple instances or only a single instance.\n- If migrating to config entries, follow the pattern above, being careful to maintain backward compatibility and to preserve important warnings/behavior.\n- Validate via tests that the new flow handles existing configurations and prevents duplicates appropriately."
        ]
    }
}
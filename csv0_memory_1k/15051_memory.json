{
    "search_index": {
        "description_for_embedding": "Home Assistant camera platform enhancement adding explicit turn_on/turn_off services, a SUPPORT_ON_OFF feature flag, an is_on property, and HTTP behavior that prevents streaming/snapshots from cameras that are off. Demo camera updated to implement on/off behavior, local-push updates, and comprehensive tests for the new API.",
        "keywords": [
            "homeassistant",
            "camera component",
            "turn_on",
            "turn_off",
            "SUPPORT_ON_OFF",
            "supported_features",
            "is_on",
            "async_get_image",
            "HTTPServiceUnavailable",
            "HTTPNotFound",
            "demo camera",
            "motion_detection",
            "entity services",
            "local push vs polling"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request implemented explicit on/off control for Home Assistant cameras. Previously, the camera component had no standardized way to turn cameras on or off, and services like snapshot/streaming did not consider the powered state of the device.\n\nChanges in detail:\n- A new bitmask flag SUPPORT_ON_OFF was introduced to the camera entity API. Platforms that implement on/off behavior should expose this via the supported_features property.\n- New helper functions and services were added:\n  - Python helpers: camera.turn_off/async_turn_off and camera.turn_on/async_turn_on, which call the corresponding Home Assistant services.\n  - Services: camera.turn_off and camera.turn_on are registered by the camera component and serviced by a shared async_handle_camera_service handler. That handler only calls async_turn_off/async_turn_on on entities whose supported_features includes SUPPORT_ON_OFF.\n- The base Camera entity was extended with:\n  - supported_features property (default 0).\n  - is_on property (default True) and state property that maps streaming/idle based on is_streaming/is_recording.\n  - New methods turn_off/async_turn_off, turn_on/async_turn_on that platforms must implement for on/off support. The async_* wrappers delegate to the sync methods through hass.async_add_job.\n  - async_enable_motion_detection and async_disable_motion_detection wrappers were standardized similarly.\n- The HTTP view for camera streaming was adjusted:\n  - If the camera entity is not found, raise web.HTTPNotFound() instead of manually returning a Response.\n  - If the user is unauthenticated and no valid token is provided, raise web.HTTPUnauthorized().\n  - If the camera exists but camera.is_on is False, log a debug message and raise web.HTTPServiceUnavailable() so clients know the camera is temporarily unavailable.\n- The async_get_image helper was updated to:\n  - Look up the camera entity.\n  - Raise HomeAssistantError('Camera not found') if missing.\n  - Check camera.is_on, and raise HomeAssistantError('Camera is off') if the camera is powered off, preventing snapshots from powered-down devices.\n- The demo camera platform was updated to serve as a reference implementation:\n  - Constructor simplified to DemoCamera(name) and no longer stores hass; it’s now a local push entity (should_poll = False) and calls schedule_update_ha_state() whenever state changes.\n  - Implements SUPPORT_ON_OFF in supported_features.\n  - Implements is_on as an alias for its internal is_streaming boolean.\n  - Implements turn_on and turn_off, toggling is_streaming and scheduling state updates.\n  - camera_image() now cycles through demo_0.jpg..demo_3.jpg, logging the chosen image path. Caching was removed in favor of a simple index counter.\n- Tests were updated and expanded in tests/components/camera/test_demo.py:\n  - Fixtures set up a demo camera using async_setup_component.\n  - test_init_state_is_streaming validates initial state is STATE_STREAMING and that async_get_image loads one of the demo images.\n  - test_turn_on_state_back_to_streaming ensures async_turn_off transitions the entity from STATE_STREAMING to STATE_IDLE, and async_turn_on returns it to STATE_STREAMING.\n  - test_turn_off_image ensures that after async_turn_off, calling async_get_image raises HomeAssistantError('Camera is off').\n  - test_turn_off_invalid_camera ensures turning off a non-existent camera does nothing and the real camera stays streaming.\n  - test_turn_off_unsupport_camera patches DemoCamera.supported_features to 0 and verifies that turn_off does not change the camera state.\n  - test_motion_detection still verifies that enable_motion_detection service correctly sets the motion_detection attribute.\n\nThrough several review iterations, the PR removed an unused 'option' parameter from the turn_on service, removed an off-image asset in favor of error behavior when the camera is off, reverted an overcomplicated async_add_executor_job usage back to async_add_job for consistency with other entities, and switched HTTP endpoints to raise aiohttp HTTP exceptions instead of returning raw Response objects.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices for building serviceable device entities in an asynchronous home automation framework:\n\n1. **Feature flags for optional behaviors**\n   - Use a bitmask supported_features property on entities to advertise which optional capabilities they implement (e.g., SUPPORT_ON_OFF). Core services and UI components must consult this flag before invoking optional operations.\n   - This allows the same service (like turn_off) to exist broadly, while individual platforms remain free to implement only the subset they support.\n\n2. **Clear separation of sync and async methods**\n   - Entity classes should expose synchronous methods (turn_on, turn_off, enable_motion_detection, etc.) for domain logic and wrap them with async_* helpers that schedule work on the event loop using hass.async_add_job.\n   - This keeps I/O and CPU-bound work out of the event loop while providing a coroutine-friendly API to the rest of the system.\n\n3. **Modeling device power/state in the domain, not view logic**\n   - Introduce an is_on property (and state mapping) to represent whether a device is operational. This simplifies decisions in multiple layers: snapshot helpers, HTTP views, and UI all rely on the same semantic state.\n   - Disallow actions that don’t make sense when the device is off (e.g., capturing images or streaming video) by raising domain-specific exceptions (HomeAssistantError) or HTTP errors (HTTPServiceUnavailable). This improves correctness and user feedback.\n\n4. **Local push entities vs polling**\n   - If an entity can push its own updates (e.g., DemoCamera toggling its internal flags), set should_poll = False and call schedule_update_ha_state() on every state transition.\n   - This avoids unnecessary polling and clearly communicates where state changes originate.\n\n5. **Consistent error handling in HTTP views**\n   - Instead of returning raw Response(status=...), raise the appropriate aiohttp.web HTTP exception (HTTPNotFound, HTTPUnauthorized, HTTPServiceUnavailable). This leads to cleaner, more idiomatic route handlers and consistent behavior across the API.\n\n6. **Testing async services and entities**\n   - Use async_setup_component to configure platforms in tests and await hass.async_block_till_done() to ensure service calls have been processed.\n   - Verify state transitions at the entity level (demo_camera.state) and global state (hass.states.get(...)).\n   - When testing error behavior, assert on specific exception messages (e.g., 'Camera is off') to ensure domain logic is enforced.\n\n7. **Avoid unnecessary parameters and assets**\n   - The initial design included an 'option' parameter for camera.turn_on and a dedicated off-image asset. Reviews concluded that these added complexity without clear value and were removed, showing the importance of keeping public APIs minimal and focused.\n\nOverall, this PR provides a template for adding on/off semantics to any entity type: define a capability flag, add is_on and state mapping, implement sync and async on/off methods, wire them through services, and ensure all higher-level operations respect the powered state.",
        "procedural_memory": [
            "Step-by-step instructions on how to design and implement on/off behavior and state-aware operations for an entity in a Home Assistant–like system:",
            "Step 1: Introduce a capability flag",
            "Define a new bit in the entity's supported_features bitmask (e.g., SUPPORT_ON_OFF = 1) to represent the ability to be turned on and off. In the base entity class, implement supported_features to return 0 by default. In each platform that supports on/off, override supported_features to include SUPPORT_ON_OFF.",
            "Step 2: Add is_on and state mapping",
            "Add an is_on property to the entity base class that reflects whether the device is operational (default True). For cameras, this may proxy to an is_streaming internal flag; for other devices, map to the platform’s power state. Update the state property to return meaningful, domain-specific states (e.g., 'streaming' or 'idle') based on is_streaming/is_recording and is_on.",
            "Step 3: Define synchronous and async on/off methods",
            "In the entity base class, declare abstract synchronous methods turn_on and turn_off that platforms must implement. Then provide async_turn_on and async_turn_off wrappers that use hass.async_add_job(self.turn_on/turn_off). These wrappers expose coroutine-based APIs to the rest of the system while letting platforms keep the device I/O in sync methods.",
            "Step 4: Register services and helpers",
            "In the component’s setup function, register new services like DOMAIN.turn_on and DOMAIN.turn_off. Implement a shared async_handle_*_service that:\n- Retrieves the entity from the component registry.\n- Checks entity.supported_features for SUPPORT_ON_OFF before calling async_turn_on/async_turn_off.\nCreate matching module-level helper functions (turn_on/async_turn_on, turn_off/async_turn_off) that construct the service data (ATTR_ENTITY_ID) and call hass.services.async_call.",
            "Step 5: Enforce state in higher-level operations",
            "In any helper that performs an operation dependent on the device being on (e.g., async_get_image for cameras):\n- Look up the entity by ID.\n- Raise a domain error (HomeAssistantError) if the entity is missing or if entity.is_on is False (e.g., 'Camera is off').\nIn HTTP views or API routes, translate these domain states into proper HTTP errors (HTTPNotFound, HTTPUnauthorized, HTTPServiceUnavailable) by raising the relevant aiohttp.web exceptions.",
            "Step 6: Implement on/off behavior in platforms",
            "For each platform (like DemoCamera):\n- Maintain an internal boolean (e.g., is_streaming) that reflects power/streaming state.\n- Implement is_on to return that flag.\n- Implement turn_on/turn_off to toggle the flag and call schedule_update_ha_state() if should_poll is False.\n- If feasible, treat the platform as a local push entity by returning should_poll = False and explicitly scheduling updates on state changes.",
            "Step 7: Update tests for the new behavior",
            "Write or update tests to verify:\n- Initial state and basic functionality (e.g., demo camera starts in STATE_STREAMING and returns an image).\n- Turning off the entity transitions its state appropriately (to STATE_IDLE for cameras) and causes high-level operations (async_get_image) to raise the expected errors.\n- Turning back on restores the original state and functionality.\n- Attempting to call turn_on/turn_off on non-existent entities fails silently or in a controlled fashion as designed.\n- Attempting to call turn_off on an entity that does not advertise SUPPORT_ON_OFF does not change its state.",
            "Step 8: Simplify and refine the API through review",
            "Remove unnecessary parameters (such as generic 'option' modes if they are not strongly justified) and assets (like separate off images) that complicate the design. Favor simple, clear semantics: when off, the entity does not provide its primary service (e.g., no image or stream), and APIs report this explicitly.",
            "Step 9: Align HTTP behavior with the entity model",
            "Ensure web views are consistent with the entity's state model. For example, when a camera is off, the streaming endpoint should raise HTTPServiceUnavailable. When the entity is missing, raise HTTPNotFound. When unauthenticated, raise HTTPUnauthorized. This makes the API predictable for clients and keeps error handling centralized and standard."
        ]
    }
}
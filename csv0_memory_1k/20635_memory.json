{
    "search_index": {
        "description_for_embedding": "Home Assistant refactor to consolidate config-flow-enabled integrations into the new `integration/platform.py` layout (e.g., `lifx/light.py` instead of `light/lifx.py`). The change required mass renaming of component files, updating imports and test patch paths, adjusting requirements comments that key off module paths, correcting coverage omit patterns, and partially reverting the UniFi device_tracker move because it’s not config-entry-based yet.",
        "keywords": [
            "Home Assistant",
            "config flow",
            "component layout",
            "module path refactor",
            "integration/platform.py",
            "lifx/light.py",
            "device_tracker/unifi.py",
            "tests failing due to import path",
            "patch target path",
            "requirements_all.txt comments",
            "coverage omit patterns",
            ".coveragerc",
            "git mv",
            "binary_sensor",
            "media_player",
            "sensor",
            "nest",
            "lutron",
            "sonos",
            "cast",
            "mqtt device_tracker",
            "owntracks",
            "smhi",
            "tellduslive",
            "tradfri"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request was a structural refactor in Home Assistant to consolidate several config flow integrations into the new component layout. Previously, platform implementations were stored as `platform/integration.py` (e.g., `light/lifx.py`, `media_player/cast.py`). The new standard is `integration/platform.py` (e.g., `lifx/light.py`, `cast/media_player.py`).\n\nA small script using `pathlib` and `git mv` was used to automate moving files. It ensured that if an integration existed as a single `integration.py`, it became `integration/__init__.py`, and all `*/integration.py` platform files were moved into `integration/platform.py` under the component directory. This was applied to integrations like cast, daikin, hangouts, homematicip_cloud, ifttt, ios, lifx, luftdaten, lutron, mqtt device_tracker, nest, owntracks, point, smhi, sonos, tellduslive, tradfri, unifi, and upnp.\n\nAfter the moves, tests and infrastructure broke because code and tests referenced the old module paths. Several follow-up commits fixed this:\n- Imports and patch targets in tests were updated to point to the new layout, e.g.:\n  - `homeassistant.components.media_player.cast` → `homeassistant.components.cast.media_player`\n  - `homeassistant.components.media_player.sonos` → `homeassistant.components.sonos.media_player`\n  - `homeassistant.components.weather.smhi` import behavior was adjusted to `from homeassistant.components.smhi import weather as weather_smhi`.\n- A concrete example in production code: `lutron_caseta` previously imported helper functions from `homeassistant.components.light.lutron` and was corrected to `homeassistant.components.lutron.light`.\n- Mock patch paths in tests were updated for mqtt device_tracker and owntracks, e.g. `homeassistant.components.device_tracker.mqtt.async_setup_scanner` → `homeassistant.components.mqtt.device_tracker.async_setup_scanner` and `homeassistant.components.device_tracker.owntracks.get_cipher` → `homeassistant.components.owntracks.device_tracker.get_cipher`.\n\nSome automated moves turned out to be incorrect from an architectural standpoint. UniFi’s device tracker is not config-entry-based yet, so it was moved back from `homeassistant/components/unifi/device_tracker.py` to its original `homeassistant/components/device_tracker/unifi.py`. The corresponding tests and requirements comments were reverted to match this. Requirements comments such as `# homeassistant.components.device_tracker.unifi` were kept consistent because tooling relies on those comments to map dependencies to components.\n\nCoverage configuration also needed adjustment. The `.coveragerc` file had lists of individual module paths to omit from coverage. After the layout change, many of these entries were no longer valid. The PR replaced a number of per-module omits with per-package patterns to match the new layout. Examples:\n- `homeassistant/components/ambient_station/__init__.py` and `ambient_station/sensor.py` → `homeassistant/components/ambient_station/*`.\n- `*/*/cast.py` removed; `homeassistant/components/cast/*` retained.\n- Old nest, daikin, point, sonos, tellduslive, tradfri, ios, homematicip_cloud omits changed from specific file lists like `homeassistant/components/*/nest.py` to `homeassistant/components/nest/*`, `homeassistant/components/daikin/*`, `homeassistant/components/point/*`, etc.\n- Removed omits for paths that no longer exist under the new layout (e.g., `sensor/luftdaten.py`, `sensor/upnp.py`, `light/lifx.py`) and added omit entries for their new package directories instead (e.g., `homeassistant/components/luftdaten/*`, `homeassistant/components/upnp.py` remains as a root component, `homeassistant/components/lifx/*`).\n\nSeveral test files were also moved to align with the new component layout, for example:\n- `tests/components/media_player/test_cast.py` → `tests/components/cast/test_media_player.py`.\n- `tests/components/weather/test_smhi.py` → `tests/components/smhi/test_weather.py`.\n- `tests/components/media_player/test_sonos.py` → `tests/components/sonos/test_media_player.py`.\n\nA later commit restored the UniFi test file to `tests/components/device_tracker/test_unifi.py` to reflect its reverted module location, adjusting imports and patch paths accordingly.\n\nOverall, the incident was not a functional runtime bug but a large-scale structural change that required careful synchronization of file moves, imports, tests, dependency metadata, and coverage configuration. One misaligned integration (UniFi) highlighted the importance of understanding which components are allowed or ready to follow a given structural convention (config entry vs. legacy).",
        "semantic_memory": "The core lessons from this change revolve around how to safely perform large-scale module layout refactors and keep the rest of the ecosystem (tests, tooling, config) consistent.\n\n1. **Refactoring module layout requires synchronized updates across code, tests, and tooling**:\n   - Moving modules (e.g., from `platform/integration.py` to `integration/platform.py`) does not just affect import statements. Tests that patch functions by string path, requirement mapping comments that encode module paths, and coverage omit lists must all be updated in lockstep.\n   - When a project uses comments or naming conventions as metadata (e.g., `# homeassistant.components.device_tracker.unifi` preceding `pyunifi==...`), these comments effectively become part of the API for internal tooling and cannot be neglected.\n\n2. **Automated file moves are powerful but must be constrained by architecture rules**:\n   - A simple script using `git mv` and globbing can systematically reorganize an entire subsystem. However, over-generalizing (e.g., moving UniFi’s device tracker into a new layout before it follows the config entry model) can violate architectural assumptions and requires reversion.\n   - Before applying a mechanical transformation, clearly define the scope (e.g., 'only integrations that already use config flow') and include explicit exceptions.\n\n3. **Designing a stable, future-proof layout**:\n   - Grouping all integration-specific platforms under `integration/` (e.g., `lifx/light.py`, `lutron/cover.py`) makes the codebase easier to navigate and reason about; it also encourages cohesive integration packages that share constants and common logic under the same directory.\n   - This pattern simplifies long-term maintenance (one folder per integration) and aligns tests and coverage more naturally by mirroring the runtime structure.\n\n4. **Coverage configuration should use stable patterns, not brittle paths**:\n   - Instead of enumerating individual module files in `.coveragerc`, it is more resilient to omit entire integration packages with wildcard patterns, especially when the directory structure is evolving. For example, use `homeassistant/components/nest/*` instead of `homeassistant/components/nest/__init__.py` and `homeassistant/components/*/nest.py`.\n   - This avoids repeatedly updating coverage configuration for every file move within the same integration.\n\n5. **Tests that patch by import path are sensitive to refactors**:\n   - Many Python tests use `unittest.mock.patch('module.path.func')`. When modules move, these strings do not fail fast at import-time; they break only when the patch happens. It is easy to miss them without running the full test suite.\n   - Consistently using a central import alias in tests (e.g., `from homeassistant.components import cast`) or using object-based patching where possible can mitigate some of this fragility, but for frameworks where string patches are standard, full-test runs and search/replace are necessary.\n\n6. **Not all components can adopt a new pattern at once**:\n   - Introducing a new preferred layout (config-entry-based integration folder structure) must respect the maturity and architecture of each integration. Some legacy components (like UniFi device tracker here) must remain in the old structure until their internal APIs or lifecycle (e.g., config entry support) are upgraded.\n\nThese concepts apply broadly to any large Python (or similar) codebase undergoing structural refactoring: treat module paths as part of the public contract with tests and tooling, use patterns instead of specific paths where feasible, and ensure that architectural eligibility is respected when applying sweeping changes.",
        "procedural_memory": [
            "When refactoring integration/module layout (e.g., moving from `platform/integration.py` to `integration/platform.py`):",
            "Step 1: Define the target layout and scope clearly.\n- Decide the new standard structure (e.g., `integration/` as the root package with `light.py`, `sensor.py`, etc.).\n- Identify which integrations are eligible (e.g., those that already use config entries) and explicitly list any that must be excluded (e.g., legacy components like UniFi device_tracker that are not config-entry-based yet).",
            "Step 2: Automate the file moves safely.\n- Use a script to perform `git mv` operations to preserve history, something like:\n  - If `components/<integration>.py` exists and not a directory, create `components/<integration>/` and move the file to `components/<integration>/__init__.py`.\n  - For each `components/<platform>/<integration>.py`, move it to `components/<integration>/<platform>.py`.\n- Run this script for each integration in the scoped list.\n- Commit the moves separately to keep history and review easier.",
            "Step 3: Update imports in code.\n- Perform a search for old import paths (e.g., `homeassistant.components.light.lifx`, `homeassistant.components.media_player.cast`).\n- Replace them with the new paths (e.g., `homeassistant.components.lifx.light`, `homeassistant.components.cast.media_player`).\n- Be especially careful with internal integrations that depend on each other (e.g., `lutron_caseta` using `homeassistant.components.lutron.light`).",
            "Step 4: Update tests and patch targets.\n- Search in the test suite for any string-based patch paths referencing the old layout, such as `homeassistant.components.media_player.cast` or `homeassistant.components.device_tracker.owntracks`.\n- Update them to match the new module paths (e.g., `homeassistant.components.cast.media_player`, `homeassistant.components.owntracks.device_tracker`).\n- If the test folder structure mirrors the integration layout, move test files to match (e.g., `tests/components/media_player/test_cast.py` → `tests/components/cast/test_media_player.py`).\n- Run the full test suite to catch any missed patch strings or import errors.",
            "Step 5: Keep requirements metadata in sync.\n- If the project uses comments to associate pip dependencies with component modules (as Home Assistant does), update those comments to match the new paths.\n  - Example: change `# homeassistant.components.device_tracker.unifi` if you move the module, or revert the comment if you revert the move.\n- Ensure that these comments stay consistent with your actual module path so any tooling that parses them continues to function correctly.",
            "Step 6: Update coverage configuration.\n- Review `.coveragerc` (or equivalent) for omit/include patterns that reference specific files under the old layout, like `homeassistant/components/*/integration.py` or `homeassistant/components/<platform>/<integration>.py`.\n- Replace brittle per-file entries with per-package patterns where appropriate, e.g.:\n  - `homeassistant/components/nest/*` instead of multiple nest-related files.\n  - `homeassistant/components/daikin/*`, `homeassistant/components/point/*`, `homeassistant/components/sonos/*`, etc.\n- Remove omit entries for files that no longer exist and add new ones for new packages when necessary.\n- Re-run coverage to ensure patterns are valid and behaving as expected.",
            "Step 7: Validate and adjust exceptions.\n- After the refactor, confirm that special-case components like UniFi device_tracker still behave correctly.\n- If an automated move breaks conceptual or architectural rules (e.g., moving a non-config-entry component into a config-flow layout), revert that component’s move and adjust tests/requirements/coverage accordingly.\n- Document clearly in code comments or architecture notes why certain integrations are exceptions to the new pattern.",
            "Step 8: Communicate the new recommended structure.\n- Update contributor docs and internal discussions to reflect the new standard (e.g., 'The future is `lifx/light.py`').\n- For new integrations, recommend starting with the new layout to avoid future moves.\n- Clarify that custom or third-party integrations can already adopt the same pattern if the platform supports it."
        ]
    }
}
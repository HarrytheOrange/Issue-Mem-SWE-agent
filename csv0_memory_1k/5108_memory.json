{
    "search_index": {
        "description_for_embedding": "Home Assistant Sharp Aquos TV media_player integration was unreliable and missing features. The PR updates the underlying control library (from sharp-aquos-rc 0.2 to sharp_aquos_rc 0.3.2), adds retry handling around all network calls to prevent crashes on OSError/TypeError/ValueError, correctly manages remote power-on capability via a configurable power_on_enabled option, and exposes additional media controls and input source selection (HDMI, component, etc.) through the media_player API.",
        "keywords": [
            "Home Assistant",
            "Sharp Aquos",
            "media_player",
            "aquostv",
            "network timeout",
            "OSError",
            "retry logic",
            "power on command settings",
            "input source selection",
            "sharp_aquos_rc",
            "dependency update",
            "remote control buttons",
            "STATE_OFF fallback",
            "configuration options",
            "timeout",
            "retries"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Sharp Aquos TV integration for Home Assistant (media_player.aquostv) was not robust and lacked several capabilities. Users reported problems (issue #4973) related to controlling the TV, particularly around power management and general reliability. The component relied on an older third-party library (sharp-aquos-rc 0.2) and did not expose all the TV's features (e.g., source selection, transport controls).\n\nTo address this, the PR upgraded the dependency to sharp_aquos_rc==0.3.2 (note the name change from `sharp-aquos-rc` to `sharp_aquos_rc` and the version bump). This allowed use of newer features and fixes in the underlying library.\n\nThe PR introduced a `_retry` decorator applied to all methods that perform network calls (`update`, `turn_off`, `volume_up`, `volume_down`, `set_volume_level`, `mute_volume`, `turn_on`, and media control methods). On each call it retries up to 5 times and, if all attempts fail due to OSError, TypeError, or ValueError, it sets the device state to `STATE_OFF` instead of letting exceptions propagate. This makes the integration more resilient to transient network or device issues.\n\nThe device initialization was extended with a `power_on_enabled` configuration option. When enabled, the integration will call `self._remote.power_on_command_settings(2)` in `update()` so the TV is configured to accept remote power-on commands; when disabled, it sets this to 0. The supported features bitmask (`SUPPORT_SHARPTV`) is dynamically updated so that `SUPPORT_TURN_ON` is only advertised when `power_on_enabled` is true.\n\nThe PR also added support for richer media controls: next/previous track, pause/play, and source selection. A `SOURCES` mapping translates numeric input codes to human-friendly names (e.g., 'HDMI_IN_1', 'COMPONENT IN', 'PC_IN'). The entity now exposes `source` and `source_list` properties and implements `select_source` by mapping the chosen label back to the numeric input and calling `self._remote.input(key)`. Transport control methods (`media_play_pause`, `media_play`, `media_pause`, `media_next_track`, `media_previous_track`) send specific remote button codes via `remote_button()`.\n\nFinally, the component now computes volume from the TV's 0–60 scale into the 0..1 Home Assistant volume range and vice versa, and it correctly derives mute status from the remote's `mute()` return value. Overall, the fix modernized the integration, improved reliability via retries and better error handling, and added configuration-driven power-on behavior and media/source controls.",
        "semantic_memory": "This fix illustrates several generalizable patterns for device integrations and networked components:\n\n1. **Keep third-party device libraries up to date**: When an integration depends on a vendor-specific or third-party library, outdated versions can cause reliability issues or missing features. Updating to a newer version (and sometimes a renamed package) can provide bug fixes, new APIs, and better device compatibility.\n\n2. **Wrap all network I/O in retry logic with graceful degradation**: Operations that perform network or device I/O (power, volume, mute, input, remote button presses) should not be assumed to always succeed. A lightweight retry mechanism that catches transient exceptions (OSError, TypeError, ValueError) and retries a limited number of times significantly improves robustness. When still failing, the integration should fall back to a safe, consistent state (e.g., treating the device as `STATE_OFF`) instead of crashing or leaving the state undefined.\n\n3. **Expose capabilities conditionally based on configuration and device support**: The feature bitmask exposed to the host system should reflect actual capabilities. In this case, `SUPPORT_TURN_ON` is only advertised when the TV is configured (`power_on_enabled`) to accept remote power-on. Conditional capabilities prevent the frontend or automations from offering actions that are known to fail.\n\n4. **Map device-specific codes to human-friendly abstractions**: Many devices use numeric or opaque codes (e.g., input 0–8) for inputs or commands. Introducing a mapping (e.g., SOURCES) to descriptive strings allows the integration to expose user-friendly `source` and `source_list` properties while still translating back to device-specific codes for control. This pattern is broadly applicable to any integration with enumerated or coded values.\n\n5. **Use consistent scaling and normalization for values**: Devices often operate on different ranges (e.g., volume 0–60) than the host platform (0..1). Consistent bi-directional conversion (divide/multiply by 60 here) ensures that UI controls, automations, and internal logic behave predictably.\n\n6. **Centralize error handling with decorators or helper functions**: A decorator like `_retry` avoids duplicating try/except and retry loops across multiple methods, making the code easier to maintain and ensuring consistent behavior whenever network calls are made.\n\n7. **Configuration options to control side-effectful or power-related behaviors**: Power-on via network commands may not always be desired or supported. Providing a configuration flag (`power_on_enabled`) and wiring it into the runtime behavior lets users opt in or out of potentially problematic device features and lets the integration behave conservatively by default.",
        "procedural_memory": [
            "When a device integration is unreliable or missing features, first verify whether the underlying third-party library is outdated or misnamed.",
            "Step 1: Inspect the reported issue and logs to identify failure modes (e.g., exceptions like OSError, TypeError, timeouts, or incorrect device state such as always OFF).",
            "Step 2: Check the integration's dependency versions in requirements files and compare them against the latest available version on PyPI or the vendor repository. Note any package name changes (e.g., hyphen vs underscore).",
            "Step 3: Upgrade the dependency to a newer, stable version that supports the needed APIs. Update the requirement in both the component file (if present) and the global requirements (e.g., requirements_all.txt).",
            "Step 4: Identify all methods in the integration that perform network or device I/O (power, volume, mute, input, specific command calls). Centralize robust error handling by wrapping them with a retry mechanism:",
            "  - Implement a decorator or helper that retries the wrapped function a fixed number of times when encountering transient exceptions (OSError, TypeError, ValueError, timeout errors, etc.).",
            "  - Within the decorator, if all retries fail, set the entity to a safe fallback state (e.g., mark it as OFF or unavailable) instead of propagating the exception.",
            "Step 5: Apply the retry decorator to `update()` and all control methods (turn_on, turn_off, volume controls, mute, media controls). Ensure the underlying calls are free of their own uncaught exceptions.",
            "Step 6: If the device has a separate configuration for remote power-on or special modes, add explicit management of that configuration. Expose a boolean configuration option (e.g., power_on_enabled) and, in the update or initialization logic, call the appropriate device method (e.g., power_on_command_settings) with the correct value depending on the configuration.",
            "Step 7: Adjust the supported-features bitmask so the integration only advertises capabilities that are truly available. For example, only include SUPPORT_TURN_ON when the device is configured for remote power-on, and add flags for new capabilities (NEXT_TRACK, PREVIOUS_TRACK, PAUSE, SELECT_SOURCE) when you implement them.",
            "Step 8: For any device-specific numeric codes (inputs, modes, etc.), create a dictionary mapping code -> human-readable string. Expose `source`/`source_list` or equivalent properties using the mapped strings, and implement `select_source` by reversing the mapping back to the numeric code and calling the appropriate device API.",
            "Step 9: Normalize value ranges between the device and the platform. For volume, convert from a device-specific integer range (e.g., 0–60) to the platform's float 0..1 range in getters, and convert back in setters.",
            "Step 10: Run the test suite (e.g., tox) and, if possible, test against a real device to confirm that network errors are handled gracefully, the TV no longer crashes the integration, the power-on behavior matches configuration, and new media/source controls function correctly.",
            "Step 11: Document any new configuration options (timeout, retry count, power_on_enabled, etc.) and mention behavior changes (like conditional SUPPORT_TURN_ON) so that users and maintainers understand the integration's new capabilities and limitations."
        ]
    }
}
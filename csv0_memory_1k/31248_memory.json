{
    "search_index": {
        "description_for_embedding": "Refinements to the Home Assistant Samsung TV integration: fix SSDP discovery filter, improve authentication/authorization handling (auth popup, timeout, re-auth flow), avoid storing non-serializable turn_on actions in config entries, and clean up naming and configuration flow logic.",
        "keywords": [
            "Samsung TV",
            "Home Assistant",
            "samsungtv integration",
            "SSDP discovery",
            "st vs deviceType",
            "authentication",
            "authorization",
            "AccessDenied",
            "reauth",
            "config_flow",
            "turn_on_action serialization",
            "Script not JSON serializable",
            "timeout handling",
            "socket.gethostbyname",
            "media_player"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Samsung TV integration for Home Assistant received multiple small but important fixes focused on discovery and authentication.\n\nFirst, SSDP discovery was using the `deviceType` key in the integration manifest and generated ssdp map, but the SSDP implementation expects `st` (search target). This mismatch meant some Samsung TVs were not being discovered or matched correctly. The manifest and generated `ssdp.py` entries were updated to use `\"st\": \"urn:samsung.com:device:RemoteControlReceiver:1\"`.\n\nSecond, the config flow and connection logic around authentication were improved. The integration talks to newer Samsung TVs that show an authorization popup and keep the socket open while waiting for user approval. The previous timeout was only 1 second, which meant Home Assistant often gave up before the user could authorize the connection. The timeout for connection attempts was increased to 31 seconds and logging was improved when OSError occurs. Error results from probing the TV were refined: `auth_missing` (no authorization / likely denied), `not_successful` (cannot connect), and `not_supported` (TV responds but not supported). The strings were updated to clarify that the TV asks for authorization, not authentication.\n\nThird, re-authorization was implemented and wired through properly. When the TV’s authorization is changed to DENY, the `SamsungRemote` constructor raises `AccessDenied`. The media_player entity’s `get_remote` now catches `samsungctl.exceptions.AccessDenied`, starts a new config entries flow with `context={\"source\": \"reauth\"}` and the current `config_entry.data`, and then re-raises. The config_flow includes an `async_step_reauth` implementation which reconstructs internal state from the passed data (host, id, ip, manufacturer, model, name, port) and reuses the `confirm` step to let the user re-authorize. Tests verify that a reauth flow shows up in `config_entries.flow.async_progress()` when `AccessDenied` is raised.\n\nFourth, there was a bug around storing the `turn_on_action` (an action script) inside the config entry data. This action is not JSON-serializable, which can break config entry persistence. The fix moves storage of the `CONF_ON_ACTION` out of the config entry and into `hass.data[DOMAIN]`, keyed by resolved IP address: during YAML-based setup (`async_setup`), the host is resolved asynchronously (`async_add_executor_job(socket.gethostbyname)`), and `hass.data[DOMAIN][ip_address] = {CONF_ON_ACTION: ...}` is set. Later, in `async_setup_entry`, the integration looks up the IP (`CONF_IP_ADDRESS` in entry data) in `hass.data[DOMAIN]` and, if a `CONF_ON_ACTION` is present, wraps it in a `Script` object. The config flow no longer includes `CONF_ON_ACTION` in the stored entry data. Tests are updated to patch `socket.gethostbyname` consistently so IP resolution is deterministic.\n\nAdditionally, naming and UX were cleaned up: the default name is now simply \"Samsung TV\"; SSDP-based flows set the entity name to `\"Samsung {model}\"` and use the model as the flow title; the friendly name from SSDP is no longer used directly. The unique ID is based on the IP address for duplicate detection; the UDN (`ATTR_UPNP_UDN`) is trimmed of the `uuid:` prefix and stored as the config entry `CONF_ID`. Flow titles now show `Samsung TV: {model}`. Text strings were polished (e.g., fixing typos, switching from \"authenticated\" to \"authorized\") and all tests were adjusted to match new behavior and timeouts.\n\nOverall, the PR makes Samsung TV discovery reliable, handles the TV’s auth popup correctly with longer timeouts, properly triggers re-auth flows when authorization is revoked, and avoids storing non-serializable objects in config entries.",
        "semantic_memory": "This change set illustrates several broader best practices when building network-device integrations and configuration flows:\n\n1. **Match discovery filters to the underlying protocol correctly.** When using SSDP (UPnP discovery), the right keys (`st`, `usn`, etc.) must be used as expected by the integration layer. Using a descriptive key like `deviceType` instead of the expected `st` will silently break discovery. Always confirm your manifest or discovery filters align with the framework’s documented schema.\n\n2. **Design around asynchronous device authorization flows.** Some devices require user authorization via an on-screen popup and keep a TCP socket open while waiting. A naive short timeout can cause premature failures that look like connectivity issues. Use realistic timeouts and understand that an open socket with no data can be a valid state (waiting for user input). Classify outcomes clearly into: missing authorization, unsupported device, and unreachable device.\n\n3. **Re-auth flows should be first-class citizens.** Device permissions may be revoked by the user at any time (e.g., the TV’s authorization list). Integrations should:\n   - Detect permission-specific exceptions (like `AccessDenied`).\n   - Initiate a re-auth configuration flow (`context.source = \"reauth\"`), passing enough existing config data to reconstruct the device context.\n   - Separate re-auth flows from initial configuration while reusing UI where possible.\n\n4. **Don’t store non-serializable objects in persistent config entries.** Configuration entries are typically stored as JSON. Storing complex objects (like callables or `Script`/automation structures) in `config_entry.data` can break persistence or migration. Instead, store only simple, serializable values in config entries, and keep runtime-only or complex objects in `hass.data` or other in-memory structures keyed by stable identifiers like IP or unique device ID.\n\n5. **Use IP resolution and unique identifiers consistently.** When migrating from YAML to config entries or mixing discovery sources, resolve hostnames to IP addresses in a background thread/executor and use those IPs as a stable basis for de-duplication and lookup. Also normalize IDs (e.g., strip `uuid:` prefix from UDNs) before comparing or storing.\n\n6. **Make configuration flows user-friendly and informative.** Including model information in flow titles, clarifying that a TV will ask for \"authorization\" rather than \"authentication\", and providing distinct abort reasons like `not_successful` vs `not_supported` helps users understand what went wrong and what to do next.\n\n7. **Ensure tests track behavioral and UX changes.** Whenever timeouts, naming, or control flow change, tests should be updated to reflect the new expectations (e.g., new timeout value of 31 seconds, new abort reason names, reauth flows appearing in `config_entries.flow.async_progress`). Mocking external dependencies like `socket.gethostbyname` is crucial to keep tests deterministic when logic depends on resolved IP addresses.\n\n8. **Log with sufficient context.** When catching network errors, log both the attempted configuration and the exception object so developers can diagnose connection problems. Naming exception variables (`err` vs `e`) is less important than including real context in logs.\n\nThese patterns apply broadly to integrations with TVs, IoT devices, and any system that mixes discovery, user-driven authorization, and persistent configuration.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Verify discovery configuration against platform expectations.\n- If your integration uses SSDP/UPnP discovery, check that your manifest (or equivalent) uses the exact keys the platform expects (e.g., `st` for search target in Home Assistant).\n- Compare your discovery filter against working examples or documentation.\n- If devices are not discovered, inspect SSDP dumps or logs to see real announcements and adjust filters accordingly.",
            "Step 2: Analyze connection failures and classify them.\n- Wrap initial connection attempts in a helper (`_try_connect`) that tests all relevant methods (e.g., websocket vs legacy).\n- Catch and distinguish exception types: authorization-related (`AccessDenied`), unsupported device (`UnhandledResponse` or equivalent), and network-level errors (`OSError`, timeouts).\n- Map each case to a clear result code (`auth_missing`, `not_supported`, `not_successful`) and surface that in the config flow abort reasons and user messaging.",
            "Step 3: Adjust timeouts for interactive authorization flows.\n- If a device requires user approval via on-screen popup, measure or estimate how long users typically take and set a generous timeout (e.g., 30 seconds) for the initial connection.\n- Document that an open socket might mean the device is waiting for user input, not that the connection is hung.\n- Update tests that assert on connection configs (e.g., timeout values) to match the new timeout.",
            "Step 4: Implement re-authentication for revoked permissions.\n- Identify the exception(s) raised when a device denies access (e.g., `samsungctl.exceptions.AccessDenied`).\n- At the point where you create or use the client (e.g., `SamsungRemote`), catch that exception and initiate a config entries flow with `context={\"source\": \"reauth\"}` and suitable `data` (usually the current `config_entry.data`).\n- Re-raise the exception after queueing the reauth flow so existing error handling remains consistent.",
            "Step 5: Add a reauth step in the config flow.\n- Add `async_step_reauth(self, user_input=None)` to your config flow handler.\n- In this step, reconstruct your internal attributes (`self._host`, `self._ip`, `self._id`, `self._manufacturer`, `self._model`, `self._name`, `self._port`) from the incoming `user_input` data.\n- Set a suitable title (e.g., model or name), populate `context[\"title_placeholders\"]`, set the unique id (e.g., IP), and then forward to an existing step such as `async_step_confirm` to reuse UI.\n- Write a test that triggers the AccessDenied path and asserts that a reauth flow appears in `config_entries.flow.async_progress()`.",
            "Step 6: Avoid storing non-serializable objects in config entries.\n- Review what you store in `config_entry.data` and `config_entry.options`. Ensure they are JSON-serializable types (str, int, float, bool, lists/dicts thereof).\n- If you previously stored complex objects (e.g., a `Script` or callback), migrate that logic:\n  - At setup time (`async_setup` or `async_setup_entry`), put such objects into `hass.data[DOMAIN][key]` where `key` is a stable identifier (like IP or unique ID).\n  - Store only the minimal, serializable data needed to reconstruct or look up these objects later (e.g., host, IP, device id).",
            "Step 7: Normalize identifiers and resolve hostnames asynchronously.\n- For any identifier coming from external sources (UPnP UDN, MAC, etc.), normalize it before storage (e.g., strip `uuid:` prefix).\n- Use `async_add_executor_job` to run `socket.gethostbyname` or other blocking operations when resolving hostnames to IPs.\n- Use the resolved IP as a unique_id or part of it if that makes sense for deduplication.\n- When migrating YAML configuration into config entries, store a mapping in `hass.data[DOMAIN][ip_address]` for additional data (like `CONF_ON_ACTION`).",
            "Step 8: Keep naming and UX consistent and descriptive.\n- Choose clear default names (e.g., \"Samsung TV\" rather than \"Samsung TV Remote\").\n- For auto-discovered devices, derive a friendly name like `\"Vendor Model\"` and a concise title based on the model.\n- Add `flow_title` and `title_placeholders` to give users context during configuration.\n- Update strings to use correct terminology (e.g., \"authorization\" instead of \"authentication\") and fix typos.",
            "Step 9: Update and extend tests in lockstep with behavior changes.\n- Adjust all tests that assert on configuration details: timeouts, names, titles, abort reasons, and data stored in entries.\n- Mock blocking calls (`socket.gethostbyname`) in tests that depend on IP resolution to ensure deterministic behavior.\n- Add tests for new paths: auth missing in SSDP, not_successful on OSError, reauth flow on AccessDenied, non-serialized turn_on_action handling, etc.\n- Use test helpers (e.g., `async_fire_time_changed`) to simulate scheduled updates and verify state transitions after error conditions.",
            "Step 10: Improve logging for troubleshooting.\n- When catching network or connection errors during probing (`_try_connect`), log both the config used and the exception message.\n- Use logs to differentiate between types of failures (auth vs connectivity vs unsupported device).\n- Ensure logs do not leak sensitive data but provide enough context to debug issues in the field."
        ]
    }
}
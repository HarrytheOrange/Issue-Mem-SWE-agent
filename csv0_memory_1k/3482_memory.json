{
    "search_index": {
        "description_for_embedding": "Introduced a new Jinja filter `regex_substring` in StackStorm to extract substrings from a string using regular expressions. The filter uses `re.findall` with an index to select which match to return, is registered in the Jinja environment, covered by unit tests, and demonstrated via example action chains. Behavior is to raise IndexError if no match or index is out of range.",
        "keywords": [
            "StackStorm",
            "st2",
            "jinja filters",
            "regex_substring",
            "regex_match",
            "regex_search",
            "regex_replace",
            "re.findall",
            "substring extraction",
            "IndexError",
            "action-chain examples",
            "Changelog entry"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set implements a new Jinja filter `regex_substring` in the StackStorm `st2common` package to support extracting substrings from text using regular expressions. Initially, the filter was implemented with `re.search` and `.groups()[group_index]`, returning an empty string in case of no matches or missing groups. Review feedback led to a refactor: the final implementation uses `re.findall(pattern, value, flags)[result_index]`, where `result_index` specifies which match to return. This design makes it easy to access multiple matches (e.g., first, second address in a string) while leveraging Python's regex behavior directly.\n\nThe filter is registered in the Jinja environment via `st2common/util/jinja.py` under the name `regex_substring`. Unit tests were added and then updated in `test_jinja_render_regex_filters.py` to cover:\n- A normal case where a street address is extracted from a sentence.\n- Selecting the second match explicitly, when multiple addresses exist.\n- Raising `IndexError` when the requested result index does not exist (either no second match or no match at all). The tests assert that Jinja rendering raises `IndexError` in these cases.\n\nAdditionally, a new example action chain `contrib/examples/actions/chains/regex_jinja_filter.yaml` and its metadata file demonstrate combined usage of the regex-related Jinja filters: `regex_match` (start-of-string match), `regex_replace` (replacement of all matches), `regex_search` (match anywhere), and `regex_substring` (extract first/second matched address). A minor typo in this example (using `regex_match` instead of `regex_replace`) was fixed in a follow-up patch. The `CHANGELOG.rst` was updated to document the new filter and credit the contributor.",
        "semantic_memory": "This PR illustrates how to extend a templating system (Jinja in this case) with a custom filter tailored to regex-based substring extraction and how to integrate it cleanly into a larger framework.\n\nKey concepts and patterns:\n\n1. **Custom Jinja Filters for Reusable Text Operations**:\n   - Implementing a custom filter allows common text-processing patterns (like regex-based substring extraction) to be embedded directly in templates or workflows, reducing boilerplate in actions/workflows.\n   - Registering the filter in a central `get_filters()` function ensures the filter is available across all template renderings.\n\n2. **Using `re.findall` vs `re.search` for Substring Extraction**:\n   - `re.findall(pattern, string, flags)` returns a list of all non-overlapping matches, which is more convenient when we want to address matches by index (e.g., first, second occurrence).\n   - Index-based access (`[result_index]`) naturally leverages Python's `IndexError` to signal when a match is missing or indices are out of range, rather than silently returning empty strings. This makes failures explicit and easier to debug.\n\n3. **Explicit Failure vs Silent Fallbacks**:\n   - The initial implementation returned `\"\"` for non-matching conditions. The refactored implementation raises `IndexError` for invalid indices or lack of matches. Explicit errors are preferable when template authors expect a match and consider its absence exceptional.\n   - Unit tests explicitly assert that an `IndexError` is raised when the requested match is not available, codifying the contract.\n\n4. **End-to-End Examples Improve Discoverability**:\n   - Providing example workflows/action-chains that demonstrate the use of multiple related filters (match, replace, search, extract) helps users understand capabilities and common idioms.\n   - Including descriptive comments inside example workflows serves as in-context documentation.\n\n5. **Cross-Cutting Hygiene**:\n   - Any new filter or feature should come with tests, documentation (CHANGELOG + docs), and examples where appropriate.\n   - Small follow-up patches can fix issues discovered in examples (like a wrong filter name), reinforcing the need to keep examples in sync with the actual API.",
        "procedural_memory": [
            "When adding a new Jinja filter for regex-based text processing or fixing related behavior, ensure you implement the filter, register it, cover it with tests, and provide examples.",
            "Step 1: Define the new filter function.\n- Implement the filter in the appropriate module (e.g., `st2common/jinja/filters/regex.py`).\n- Normalize inputs: if the value is not a string, cast it (`value = str(value)`) to avoid type errors.\n- Decide on the regex API:\n  - Use `re.findall(pattern, value, flags)` if you need to support multiple matches and index-based selection.\n  - Use `re.search` or `re.match` only if you need a single match or specific semantics.\n- Determine error semantics:\n  - If you want explicit errors, access the returned list or groups by index and let Python raise `IndexError` when invalid.\n  - If you prefer silent failure, wrap in `try/except` and return a default (e.g., empty string). Document this behavior clearly.\n- For case-insensitive support, factor out logic into a helper (e.g., `_get_regex_flags(ignorecase)`).",
            "Step 2: Register the filter in the Jinja environment.\n- Add the filter to the dictionary returned by a central registry function (e.g., `get_filters()` in `st2common/util/jinja.py`).\n- Use a descriptive key (e.g., `'regex_substring'`) that users will reference in templates: `{{ my_str | regex_substring(\"pattern\", index) }}`.",
            "Step 3: Write unit tests that cover normal and failure cases.\n- Use the same Jinja environment setup as production code (e.g., `env = jinja_utils.get_jinja_environment()`).\n- Test typical success scenarios:\n  - Single match extraction.\n  - Multiple matches with different indices.\n- Test edge/error cases:\n  - Requesting an out-of-range match (e.g., index 1 when only one match exists) should raise `IndexError` if that's the intended behavior.\n  - No match at all should raise `IndexError` or return a fallback, depending on the spec.\n- Assert both the expected returned values and the expected exceptions.",
            "Step 4: Provide end-to-end examples for user workflows.\n- Add sample workflows/action chains demonstrating how to use the new filter together with related ones, e.g.:\n  - `regex_match` for checking if a pattern matches at the beginning of a string.\n  - `regex_replace` for substituting all matches.\n  - `regex_search` for matching anywhere.\n  - `regex_substring` for extracting the nth matching substring.\n- Include comments in the example files to explain what each step does and what users should expect.\n- Validate these workflows manually or via integration tests, as examples can easily go stale.",
            "Step 5: Update documentation and changelog.\n- Add an entry in the changelog documenting the new filter, a short description of its purpose, and credit if applicable.\n- Update higher-level documentation (e.g. st2docs) to include the new filter, its parameters, examples of usage, and error behavior.",
            "Step 6: When debugging issues with such filters in the future.\n- Reproduce the behavior in isolation using unit tests and simple Jinja templates.\n- Check how the regex is written (grouping vs non-grouping, use of `?:`, etc.) and confirm whether `findall` returns strings or tuples.\n- Verify that the Jinja environment is picking up the correct filter implementation (e.g., by printing `env.filters.keys()` in a debug context).\n- Adjust indices or error handling depending on whether the absence of a match should be considered an error or a valid empty result."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Migration of Home Assistant's ffmpeg integration to ha-ffmpeg 1.0 and full asyncio usage. Introduces an FFmpegManager stored in hass.data, replaces global config and synchronous helpers, updates camera and binary_sensor ffmpeg platforms to use the new async API, and adds start/stop/restart services for ffmpeg-based binary sensors with an initial_state option.",
        "keywords": [
            "homeassistant",
            "ffmpeg component",
            "ha-ffmpeg 1.0",
            "asyncio migration",
            "FFmpegManager",
            "binary_sensor.ffmpeg",
            "camera.ffmpeg",
            "DATA_FFMPEG",
            "DATA_FFMPEG_DEVICE",
            "ffmpeg_start",
            "ffmpeg_stop",
            "ffmpeg_restart",
            "async_setup_platform",
            "hass.data",
            "service registration",
            "event bus",
            "Test vs TestAsync",
            "ImageFrame vs ImageSingleAsync",
            "CameraMjpeg vs CameraMjpegAsync"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This change set updates Home Assistant's ffmpeg integration to use the new ha-ffmpeg 1.0 library and fully migrate the integration to asyncio.\n\nPreviously, the ffmpeg component relied on ha-ffmpeg 0.15 and a mix of synchronous helpers and async wrappers:\n- Global module-level configuration (FFMPEG_CONFIG) and a cache (FFMPEG_TEST_CACHE) controlled the ffmpeg binary path and input test results.\n- Helper functions get_binary(), run_test(), and async_run_test() provided access to the binary and validated input sources, with run_test() using run_coroutine_threadsafe to bridge into the event loop.\n- Camera ffmpeg used ImageSingleAsync and CameraMjpegAsync, and exposed a blocking camera_image() method that wrapped async_camera_image() via run_coroutine_threadsafe.\n- Binary_sensor ffmpeg created sensors synchronously, used global state (DEVICES) to track entities, and only exposed a restart service; ffmpeg processes were automatically started and stopped, but there was no explicit start/stop control per entity and the lifecycle logic was not fully async.\n\nThe patch introduces ha-ffmpeg==1.0 and refactors everything around it:\n1. Core ffmpeg component (homeassistant/components/ffmpeg.py):\n   - Updates REQUIREMENTS from ha-ffmpeg==0.15 to ha-ffmpeg==1.0.\n   - Replaces global configuration with an FFmpegManager stored in hass.data[DATA_FFMPEG]. FFmpegManager encapsulates:\n     - The ffmpeg binary path (binary property).\n     - A per-input cache of test results.\n     - An async_run_test(input_source) coroutine that uses the new ha-ffmpeg Test class (no longer TestAsync) and the Home Assistant loop (self.hass.loop) to validate inputs. Results are cached and errors are logged if a test fails.\n   - async_setup() initializes FFmpegManager with the configured ffmpeg_bin and run_test flag.\n\n2. Camera ffmpeg platform (homeassistant/components/camera/ffmpeg.py):\n   - Uses async_setup_platform only, with no synchronous wrapper.\n   - Validates the input via hass.data[DATA_FFMPEG].async_run_test instead of the old async_run_test/get_binary functions.\n   - Stores a reference to the FFmpegManager in each FFmpegCamera instance (self._manager = hass.data[DATA_FFMPEG]).\n   - Uses the new ha-ffmpeg 1.0 classes:\n     - ImageFrame instead of ImageSingleAsync.\n     - CameraMjpeg instead of CameraMjpegAsync.\n   - Removes the synchronous camera_image() method that used run_coroutine_threadsafe, leaving only async_camera_image(), so callers are expected to be async-aware.\n\n3. Binary sensor ffmpeg platform (homeassistant/components/binary_sensor/ffmpeg.py):\n   - Converts setup_platform to async_setup_platform, and uses hass.data[DATA_FFMPEG].async_run_test to validate input streams.\n   - Each sensor entity is now constructed with access to hass and FFmpegManager; FFmpegBinarySensor stores self._manager = hass.data[DATA_FFMPEG] and creates its ha-ffmpeg object with (self._manager.binary, hass.loop, self._async_callback).\n   - The callback from ha-ffmpeg is now _async_callback(), which sets the internal state and schedules an async state update via hass.async_add_job(self.async_update_ha_state()).\n   - The former synchronous _start_ffmpeg() and restart_ffmpeg() methods are replaced by async_start_ffmpeg(), async_shutdown_ffmpeg(), and async_restart_ffmpeg():\n     - async_start_ffmpeg() is implemented in subclasses FFmpegNoise and FFmpegMotion using the new async API (open_sensor(...) on the ha-ffmpeg SensorNoise/SensorMotion objects) and the stored config.\n     - async_shutdown_ffmpeg() returns self._ffmpeg.close().\n     - async_restart_ffmpeg() chains shutdown then start as coroutines.\n   - Lifecycle integration with Home Assistant events is made fully async:\n     - async_shutdown(event) calls entity.async_shutdown_ffmpeg() and is registered via hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, async_shutdown) (note: the callback function is passed directly, not called).\n     - An initial_state config option (CONF_INITIAL_STATE, default True) controls whether the ffmpeg processing starts automatically at Home Assistant startup. If enabled, async_start(event) is registered on EVENT_HOMEASSISTANT_START to call entity.async_start_ffmpeg().\n   - The previous global DEVICES list is replaced by hass.data[DATA_FFMPEG_DEVICE], which tracks all ffmpeg-based binary sensor entities once the first one is set up.\n   - New services are added for binary_sensor.ffmpeg:\n     - ffmpeg_start: Start processing for selected ffmpeg-based sensors.\n     - ffmpeg_stop: Stop processing.\n     - ffmpeg_restart: Restart processing.\n     All three share a common async service handler that:\n       - Resolves entity_ids into the corresponding devices using hass.data[DATA_FFMPEG_DEVICE].\n       - Builds a list of coroutines (async_start_ffmpeg, async_shutdown_ffmpeg, async_restart_ffmpeg depending on the service name).\n       - Awaits them concurrently using asyncio.wait(..., loop=hass.loop).\n     - Service schemas are unified into SERVICE_FFMPEG_SCHEMA with an optional entity_id.\n   - Services are declared in homeassistant/components/binary_sensor/services.yaml with appropriate descriptions and examples for ffmpeg_start, ffmpeg_stop, and ffmpeg_restart.\n\nThe patches also fix several small issues during the migration:\n- Correcting import syntax from 'from os' to 'import os'.\n- Fixing the use of hass.loop inside FFmpegManager.async_run_test (switching from hass.loop to self.hass.loop).\n- Correcting typos in async_add_devices and event registration (passing function objects to async_listen_once instead of calling them).\n\nOverall, the incident was not a crash bug but a library/API migration and architectural cleanup. The updated ffmpeg integration now:\n- Uses ha-ffmpeg 1.0's asyncio-native API consistently.\n- Avoids run_coroutine_threadsafe bridges and global mutable module state.\n- Centralizes ffmpeg configuration and testing in FFmpegManager.\n- Provides explicit start/stop/restart control over ffmpeg-based binary sensors via services and configuration.",
        "semantic_memory": "This change illustrates several generalizable patterns for integrating an asyncio-based library into an application framework and for evolving an integration as dependencies change:\n\n1. Encapsulate external library configuration and shared state in a manager:\n   - Instead of module-level globals and helper functions, create a manager object (e.g., FFmpegManager) responsible for:\n     - Holding configuration (binary path, feature flags like run_test).\n     - Managing caches (e.g., per-input test cache) to avoid repeated work.\n     - Exposing high-level async methods that abstract away direct use of the third-party library (e.g., async_run_test).\n   - Store the manager in a framework-level shared registry (here hass.data[DATA_FFMPEG]) so that all platforms (camera, binary_sensor, etc.) can access consistent configuration without duplicating logic or risking desynchronization.\n\n2. Prefer fully async flows over sync-async bridging:\n   - Avoid run_coroutine_threadsafe or equivalent when the surrounding framework is already asyncio-based. Instead:\n     - Expose async API methods (async_camera_image, async_start_ffmpeg, async_shutdown_ffmpeg).\n     - Ensure setups (async_setup, async_setup_platform) are also async so that they can await library operations directly.\n   - This leads to simpler code paths, fewer threading issues, and better performance due to reduced context switching and thread usage.\n\n3. Mirror lifecycle management in the framework's event system:\n   - For long-running tasks like ffmpeg processing, align start/stop behavior with framework events:\n     - Use startup events (e.g., EVENT_HOMEASSISTANT_START) to trigger initial start when desired.\n     - Use shutdown events (e.g., EVENT_HOMEASSISTANT_STOP) to gracefully close resources.\n   - Use async event listeners properly by passing the callback function itself (not its result) and ensuring the callback is a coroutine when it needs to await library operations.\n\n4. Entity-centric control and service exposure:\n   - Expose entity lifecycle operations as methods on the entity (async_start_ffmpeg, async_shutdown_ffmpeg, async_restart_ffmpeg) so they can be reused by event handlers, services, and internal logic.\n   - Use a centralized registry of entities (e.g., hass.data[DATA_FFMPEG_DEVICE]) to implement services that operate on multiple entities by entity_id.\n   - Implement services that share a common handler but vary behavior based on service name, which reduces duplication and helps keep logic consistent across start/stop/restart operations.\n\n5. Adapting to library API changes:\n   - When a dependency changes its API (e.g., class name changes from TestAsync to Test, ImageSingleAsync to ImageFrame, etc.), use the opportunity to:\n     - Align usage with the library's intended patterns (e.g., using the new async-native classes instead of legacy async wrappers).\n     - Simplify internal abstractions (remove now-unneeded \"Async\" wrappers, remove synchronous front-ends when they no longer make sense in an async environment).\n   - Provide a minimal surface in your own code that depends on the third-party API, centralizing call sites so future migrations are simpler.\n\n6. Configurable initial state and lifecycle:\n   - Introduce configuration flags like initial_state to control whether an integration starts automatically on startup or remains idle until explicitly started.\n   - This is particularly important for resource-intensive or external-process integrations (like ffmpeg), where users may want explicit control over when processing occurs.\n\nThese patterns apply broadly to any asynchronous integration of external processes or I/O-heavy libraries inside a larger application framework that itself has an event loop and lifecycle management (e.g., Home Assistant, async web servers, bot frameworks).",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues when migrating an integration to a new async-capable library or refactoring synchronous code into asyncio:",
            "Step 1: Analyze the current integration and identify sync/async boundaries.",
            "- Identify all entry points into the integration (setup functions, entity methods, services, event handlers).",
            "- Find where the existing code uses thread-based bridges (e.g., run_coroutine_threadsafe, thread pools) to run async code from sync contexts.",
            "- Identify global configuration and shared mutable state that may not be safe or flexible in an async context.",
            "",
            "Step 2: Understand the new library API and differences from the old version.",
            "- Read the new library's changelog or migration guide to understand how classes, methods, and naming changed (e.g., TestAsync -> Test, *Async classes removed).",
            "- Confirm whether the library is now fully asyncio-native (requires a loop, returns coroutines, etc.).",
            "- Map old usage patterns to new equivalents, listing needed changes in each integration module.",
            "",
            "Step 3: Introduce a manager object to encapsulate library usage.",
            "- Create a class (e.g., FFmpegManager) that owns:\n   - The configured binary path or other global settings.\n   - Caches (e.g., input test results) and policy flags (run_test).",
            "- Implement methods on the manager for common operations (e.g., async_run_test(input_source)).",
            "- Ensure the manager accepts a reference to the framework core (e.g., hass) so it can access the event loop or logging facilities.",
            "- Store a single instance of the manager in the framework's shared data store (e.g., hass.data[DATA_FFMPEG]).",
            "",
            "Step 4: Convert setup functions to async and wire in the manager.",
            "- Change synchronous setup/setup_platform functions to async equivalents (async_setup, async_setup_platform) as supported by the framework.",
            "- During async_setup, parse configuration, construct the manager, and store it in shared data (hass.data).",
            "- In platform setups (e.g., camera, binary_sensor), use the manager (hass.data[DATA_FFMPEG]) to perform input validation or other library calls instead of calling global helper functions.",
            "",
            "Step 5: Refactor entities to be async-first.",
            "- Update entity constructors to accept hass and a reference to the manager, storing them as attributes (self._manager, self.hass).",
            "- Replace synchronous methods that internally bridged to async (e.g., camera_image using run_coroutine_threadsafe) with pure async methods (async_camera_image) and drop the sync wrappers when possible.",
            "- Define async lifecycle methods on entities for long-running operations (e.g., async_start_ffmpeg, async_shutdown_ffmpeg, async_restart_ffmpeg).",
            "- Ensure callbacks from the library into your code are compatible with asyncio (e.g., schedule state updates via hass.async_add_job(self.async_update_ha_state())).",
            "",
            "Step 6: Align resource lifecycle with framework events.",
            "- Register async callbacks on startup/shutdown events (e.g., EVENT_HOMEASSISTANT_START/STOP) using the framework's async event registration (hass.bus.async_listen_once).",
            "- Pass the callback function to async_listen_once, not the result of calling it; callbacks should be coroutines if they await anything.",
            "- Optionally, introduce configuration flags (like initial_state) to control whether resources should be started on startup or only on-demand.",
            "",
            "Step 7: Replace global entity tracking with framework-backed registries.",
            "- Instead of a module-level DEVICES list, store entity lists in hass.data[...] or the equivalent in your framework.",
            "- Populate these lists from async_setup_platform when creating entities.",
            "- Use these lists to implement services that act on multiple entities, filtering by entity_id if provided.",
            "",
            "Step 8: Implement and register async services for lifecycle control.",
            "- Define service schemas (e.g., ffmpeg_start, ffmpeg_stop, ffmpeg_restart) with optional entity_id fields.",
            "- Implement a shared async service handler that:\n   - Resolves entity_ids to entities using the registry in hass.data.\n   - Based on the service name, collects the appropriate coroutines (async_start_ffmpeg, async_shutdown_ffmpeg, async_restart_ffmpeg) into a list.\n   - Awaits them concurrently using asyncio.wait or asyncio.gather, with the proper event loop reference.",
            "- Register services via the framework's async service registration API (hass.services.async_register) with appropriate descriptions and schemas.",
            "",
            "Step 9: Update tests and validate behavior.",
            "- Run existing tests and add new ones if necessary to cover:\n   - Input validation via async_run_test.\n   - Entity lifecycle behavior (start/stop/restart) and services.\n   - Correct handling of startup/shutdown events and initial_state configuration.",
            "- Manually verify that long-running processes (e.g., ffmpeg) start/stop as expected and do not leak on shutdown.",
            "",
            "Step 10: Clean up and remove deprecated or obsolete code paths.",
            "- Remove unused global helpers and configuration variables (e.g., FFMPEG_CONFIG, FFMPEG_TEST_CACHE, run_test, async_run_test) once all consumers are migrated to the manager.",
            "- Remove sync wrappers that are no longer needed in an async context, especially those using run_coroutine_threadsafe.",
            "- Ensure imports and class names are updated consistently to the new library API, and fix any minor issues (e.g., wrong import syntax, incorrect attribute usage like hass.loop vs self.hass.loop)."
        ]
    }
}
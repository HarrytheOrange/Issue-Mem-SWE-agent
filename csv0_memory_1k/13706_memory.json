{
    "search_index": {
        "description_for_embedding": "Home Assistant media_player gained generic sound mode support (service, attributes, feature flag) and the DenonAVR platform was updated to denonavr 0.7.0 to implement it, including custom sound mode mappings and exposure of raw sound mode as a state attribute.",
        "keywords": [
            "home-assistant",
            "media_player",
            "denonavr",
            "sound mode",
            "SUPPORT_SELECT_SOUND_MODE",
            "select_sound_mode service",
            "ATTR_SOUND_MODE",
            "ATTR_SOUND_MODE_LIST",
            "sound_mode_raw",
            "denonavr==0.7.0",
            "backend feature implementation",
            "device state attributes"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request introduced generic sound mode support into Home Assistant's media_player component and implemented it for the DenonAVR integration.\n\nPreviously, media_player had support for selecting input source (ATTR_INPUT_SOURCE, ATTR_INPUT_SOURCE_LIST, select_source service) but no equivalent concept for \"sound modes\" (e.g., Movie, Music, Game, Stereo) that AV receivers frequently support. The DenonAVR library had gained sound mode APIs in version 0.7.0, but the HA integration and core media_player API did not yet expose them.\n\nTo solve this, the author:\n1. **Updated the DenonAVR dependency** from denonavr==0.6.1 to denonavr==0.7.0 in both the integration module and requirements_all.txt to gain access to new sound mode methods (sound_mode, sound_mode_raw, sound_mode_list, set_sound_mode, set_sound_mode_dict).\n\n2. **Extended the core media_player API**:\n   - Added a new service `select_sound_mode` with schema validation via voluptuous.\n   - Introduced new attributes: `ATTR_SOUND_MODE` (current sound mode) and `ATTR_SOUND_MODE_LIST` (available modes).\n   - Added a new support flag `SUPPORT_SELECT_SOUND_MODE` (bit value 65536).\n   - Updated the media_player domain's service handler to route `select_sound_mode` to a new async method `async_select_sound_mode`, which delegates to a synchronous `select_sound_mode` method on each platform class.\n   - Added properties `sound_mode` and `sound_mode_list` to the `MediaPlayerDevice` base class (defaulting to None) and a `support_select_sound_mode` helper property that checks the feature flag.\n\n3. **Implemented sound mode support in the DenonAVR platform**:\n   - Added configuration options:\n     - `sound_mode` (boolean, default True) to enable/disable sound mode support per receiver.\n     - `sound_mode_dict` (mapping of string to list of strings) to allow custom mapping between HA sound mode names and multiple underlying receiver sound mode strings, passed through to `set_sound_mode_dict` on the library.\n   - When setting up Denon receivers, the platform now passes these sound mode config values into the `DenonDevice` instances.\n   - The `DenonDevice` class was extended to track:\n     - `_sound_mode_support`: whether sound mode support is enabled.\n     - `_sound_mode`: the current (matched) sound mode.\n     - `_sound_mode_raw`: the raw sound mode string coming from the receiver.\n     - `_sound_mode_list`: either the library-provided list or the keys of the custom `sound_mode_dict`.\n   - During `update()`, the entity refreshes `_sound_mode` and `_sound_mode_raw` from the receiver when sound mode support is enabled.\n   - The `supported_features` property was refactored to use a base mask `_supported_features_base`, which includes `SUPPORT_SELECT_SOUND_MODE` when sound mode is enabled, and adds `SUPPORT_MEDIA_MODES` only when the current source supports network audio.\n   - Implemented `select_sound_mode(self, sound_mode)` to call `self._receiver.set_sound_mode(sound_mode)`.\n\n4. **Exposed additional state attributes**:\n   - Introduced `ATTR_SOUND_MODE_RAW` at the DenonAVR integration level and implemented `device_state_attributes` to expose `sound_mode_raw` in the entity state.\n   - The raw attribute is only included when sound mode support is enabled, `_sound_mode_raw` is not None, and the receiver power state is 'ON'. This avoids stale or misleading raw mode info when the device is off.\n\nAlong the way, some cleanup was done (removing unused OrderedDict import, fixing minor formatting/spacing issues). The net effect is that Home Assistant now has a generic, reusable mechanism for sound mode selection, and DenonAVR receivers can use it out of the box with optional custom mapping of sound modes. Other media_player platforms (e.g., Onkyo, Sonos, Songpal) can implement the same interface and support flag to add sound mode selection consistently.",
        "semantic_memory": "This change illustrates how to introduce a new capability across a framework-level abstraction (media_player) and a specific integration (DenonAVR) in a backward-compatible, extensible way.\n\nKey generalizable concepts:\n\n1. **Feature flags and capabilities**:\n   - When adding a new optional capability (e.g., sound mode selection) to a generic device abstraction, define a new support flag (like SUPPORT_SELECT_SOUND_MODE) and expose properties/methods only when appropriate. This avoids breaking existing platforms and allows front-ends to feature-detect support.\n\n2. **Service-oriented API extension**:\n   - For consistent control across different devices, define a new domain-level service (here, `select_sound_mode`) with a clear schema, then map it to per-platform async/sync methods (async_select_sound_mode/select_sound_mode). This pattern unifies how automations and external clients invoke the feature.\n\n3. **Mirroring existing patterns to maintain architecture consistency**:\n   - The design of sound mode support closely mirrors existing source selection (ATTR_INPUT_SOURCE, ATTR_INPUT_SOURCE_LIST, select_source service). Reusing patterns reduces cognitive load, simplifies review, and makes it easier for other developers to extend their platforms.\n\n4. **Library-driven device capabilities**:\n   - When an integration depends on a device library, upgrade the library to a version that exposes the needed functionality instead of re-implementing protocol logic in the integration. This keeps low-level logic centralized and reusable.\n\n5. **Configurable abstractions via mapping dictionaries**:\n   - `sound_mode_dict` allows users to define human-friendly or grouped sound mode names that map to multiple low-level device modes. This approach is broadly applicable: use mapping dictionaries to reconcile generic UI concepts with device-specific enumerations.\n\n6. **State attributes vs. friendly abstractions**:\n   - Exposing both a user-friendly mode (sound_mode) and a raw mode (sound_mode_raw) allows automations and power users to leverage precise device states while keeping the main attribute simple for general use. This pattern is useful whenever underlying devices have complex state strings.\n\n7. **Guarding state attributes by power/availability**:\n   - Only exposing `sound_mode_raw` when the device is ON avoids presenting stale or meaningless values. More generally, derived attributes should be conditioned on the device being in a valid state.\n\n8. **Asynchronous wrapper around synchronous drivers**:\n   - The base entity exposes async methods that schedule synchronous driver calls via `hass.async_add_job`. This pattern is important anytime an asynchronous framework interacts with blocking I/O libraries.\n\nOverall, the PR is a template for cleanly adding a new optional feature to a device abstraction layer and implementing it for a specific integration while keeping configuration flexible and the public API coherent.",
        "procedural_memory": [
            "How to add a new optional device capability (e.g., sound mode selection) to a Home Assistant-like media player framework and implement it in a specific integration:",
            "Step 1: Design the capability and align with existing patterns",
            "  - Identify an existing, similar feature (e.g., input source selection) and copy its architecture: attributes, service, support flag, base class methods, and front-end expectations.",
            "  - Decide what needs to be exposed: a current value attribute, a list of valid values, a service to change it, and a feature flag for capability detection.",
            "Step 2: Extend the core constants and flags",
            "  - Add new constants for the attributes (e.g., ATTR_SOUND_MODE, ATTR_SOUND_MODE_LIST).",
            "  - Add a new support flag in the capabilities bitmask (e.g., SUPPORT_SELECT_SOUND_MODE = 65536) and ensure it does not collide with existing bits.",
            "Step 3: Define a new service and schema",
            "  - Declare a new service name (e.g., SERVICE_SELECT_SOUND_MODE).",
            "  - Create a voluptuous schema for the service, extending a base media player schema, and requiring any necessary parameters (e.g., ATTR_SOUND_MODE: cv.string).",
            "  - Register the service in the service map with its handler method name (e.g., 'async_select_sound_mode') and schema.",
            "Step 4: Wire the service into the service handler",
            "  - In the domain's async service handler, detect the new service name and extract the corresponding parameter from the service data.",
            "  - Pass the parameter into the `params` dict that is forwarded to each targeted entity (e.g., `params['sound_mode'] = service.data.get(ATTR_SOUND_MODE)`).",
            "Step 5: Extend the base device class",
            "  - Add new properties for the capability to the base class (e.g., sound_mode, sound_mode_list) with default `None` implementations.",
            "  - Add a helper property that checks the support flag (e.g., `support_select_sound_mode = bool(self.supported_features & SUPPORT_SELECT_SOUND_MODE)`).",
            "  - Add a synchronous method (e.g., `select_sound_mode(self, sound_mode)`) raising NotImplementedError by default.",
            "  - Add an async wrapper method (e.g., `async_select_sound_mode(self, sound_mode)`) that schedules the sync method via the event loop (`return self.hass.async_add_job(self.select_sound_mode, sound_mode)`).",
            "Step 6: Update the integration's dependency (if needed)",
            "  - If the integration relies on a third-party library that recently added support for the new capability, update the `REQUIREMENTS` in the platform module and the global `requirements_all.txt` to the new version.",
            "  - Confirm that the new library version exposes the necessary methods and properties (e.g., sound_mode, sound_mode_raw, sound_mode_list, set_sound_mode, set_sound_mode_dict).",
            "Step 7: Add configuration options to the platform (optional but often needed)",
            "  - Extend the platform's schema with any configuration flags related to the feature (e.g., `sound_mode` boolean to enable/disable support, and `sound_mode_dict` to accept a mapping of user-friendly modes to device-specific modes).",
            "  - Provide sensible defaults (e.g., sound mode support enabled by default).",
            "Step 8: Initialize platform entities with the new capability",
            "  - When creating entity instances (e.g., DenonDevice), pass the new configuration values (sound_mode_support, sound_mode_dict).",
            "  - In the entity `__init__`, store these values and initialize cached state (e.g., `_sound_mode`, `_sound_mode_raw`, `_sound_mode_list`).",
            "  - If a mapping dictionary is provided, call into the device library to configure it (e.g., `receiver.set_sound_mode_dict(sound_mode_dict)`) and set your list to `list(sound_mode_dict)`.",
            "Step 9: Integrate with the device state update cycle",
            "  - In the entity's `update()` method, refresh the new state properties from the device library only when support is enabled. For example:\n    - `self._sound_mode = self._receiver.sound_mode`\n    - `self._sound_mode_raw = self._receiver.sound_mode_raw`",
            "  - Ensure this update runs in the same place where other device state (power, volume, etc.) is updated so state is consistent.",
            "Step 10: Update supported_features calculation",
            "  - Compute a base supported features mask for the device, including the new feature flag when the capability is enabled (e.g., `_supported_features_base = SUPPORT_DENON; if sound_mode_support: _supported_features_base |= SUPPORT_SELECT_SOUND_MODE`).",
            "  - In `supported_features`, build on this base and conditionally OR other flags like `SUPPORT_MEDIA_MODES` depending on the current context (e.g., only when current source is a network audio function).",
            "Step 11: Implement the platform-specific control method",
            "  - Implement the synchronous control method added to the base class (e.g., `select_sound_mode(self, sound_mode)`) to call the underlying device library (e.g., `return self._receiver.set_sound_mode(sound_mode)`).",
            "  - Ensure error handling is consistent with other control methods in the platform.",
            "Step 12: Expose additional diagnostic or raw attributes (optional)",
            "  - If the device library provides a more detailed raw state (e.g., sound_mode_raw), define a platform-specific attribute name (e.g., ATTR_SOUND_MODE_RAW) and expose it via `device_state_attributes` or equivalent.",
            "  - Guard the exposure by conditions such as capability enabled, attribute not None, and device being in a valid state (e.g., power == 'ON') to avoid stale or confusing values.",
            "Step 13: Test end-to-end",
            "  - Verify that the updated integration loads correctly and that the device entities report the expected supported_features flag (including SUPPORT_SELECT_SOUND_MODE).",
            "  - Validate that the new attributes (sound_mode, sound_mode_list, sound_mode_raw) show up in the entity state when appropriate.",
            "  - Call the new service (select_sound_mode) via the developer tools or an automation and confirm that the device changes mode and state updates correctly.",
            "  - Test with and without `sound_mode_dict` to ensure mapping works and does not break when omitted.",
            "Step 14: Ensure backward compatibility and cleanliness",
            "  - Confirm that platforms not implementing the new capability behave as before; their supported_features should not include the new flag, and the new service should be a no-op for unsupported entities.",
            "  - Remove unused imports and fix any spacing/formatting issues introduced while editing.",
            "  - Update documentation and examples to show how to configure and use the new feature (e.g., adding sound_mode and sound_mode_dict entries for DenonAVR in configuration.yaml)."
        ]
    }
}
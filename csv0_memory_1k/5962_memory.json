{
    "search_index": {
        "description_for_embedding": "PokemonGo-Bot sniper worker fixes: skip external map entries that hide or obfuscate latitude/longitude, parse IV values as floats to support fractional IVs, correct the comparison logic for special_iv so that only Pokémon at or above the threshold are treated as special, and add configurable post-snipe cooldown and loiter behavior to reduce detection risk.",
        "keywords": [
            "PokemonGo-Bot",
            "sniper",
            "sniper.py",
            "SniperSource",
            "JSON API",
            "external data source",
            "hidden coordinates",
            "latitude",
            "longitude",
            "IV parsing",
            "float vs int",
            "special_iv threshold",
            "comparison bug",
            "cooldown",
            "loiter_after_snipe",
            "cooldown_enabled",
            "rate limiting",
            "anti-ban",
            "bot detection"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the PokemonGo-Bot sniper task had several issues related to data handling and behavior:\n\n1) Some external snipe sources (e.g., web map APIs) hide or obfuscate Pokémon coordinates unless the user has a subscription, returning non-numeric latitude/longitude values. The existing implementation tried to use these values as floats, which could cause errors or lead the bot to attempt to snipe impossible locations. The fix adds a numeric validation step in SniperSource.fetch(): after extracting latitude and longitude from the response, it attempts to cast both to float in a try/except block. If casting fails (ValueError), that Pokémon entry is skipped, preventing invalid snipe attempts from blocked sources.\n\n2) IV values were parsed as integers (`int(iv or 0)`), which loses precision when sources provide fractional IVs (e.g., 96.7). This affects decision logic that relies on fine-grained IV thresholds. The fix changes IV parsing to `float(iv or 0)`, preserving fractional IV values.\n\n3) The sniper's `is_snipeable` method contained a logic bug around the `special_iv` threshold. The code comment states that `special_iv` should cause the bot to treat Pokémon with IV greater than or equal to the threshold as special (i.e., worth catching even if not on the catch list). However, the condition was implemented as `pokemon.get('iv', 0) <= self.special_iv`, which actually triggered on *low*-IV Pokémon and suppressed the catch/vip filtering for them. The fix changes this comparison to `>= self.special_iv` and expands the log message to show the IV value when a Pokémon is treated as having a 'decent IV'.\n\n4) To reduce the apparent 'teleporting all over the world' behavior that might be used for bot detection by Niantic, a new cooldown mechanism was introduced. In Sniper.initialize, two new configuration flags are added: `cooldown_enabled` and `loiter_after_snipe`, both defaulting to false. The worker maintains `self.no_snipe_until`, a timestamp after which sniping can resume.\n\n   - At the start of `work()`, if `no_snipe_until` is set and still in the future, the task returns early without sniping.\n   - During `work()`, a flag `sniped` tracks whether any snipe attempt occurred in this cycle.\n   - After processing targets, if `sniped` is true and `loiter_after_snipe` is enabled, the bot sleeps for a random 20–40 seconds, simulating loitering at the location.\n   - If `cooldown_enabled` is true, the bot then picks a random cooldown between 60 and 360 seconds, sets `self.no_snipe_until` accordingly, and logs the time until which sniping is on cooldown.\n\n5) Additional small fixes include: ensuring the sniper returns early (and logs) when catching is globally disabled, minor indentation fixes in validation error collection, and consistently resetting `TelegramSnipe.ENABLED` to False after work is done.\n\nThe net result is a more robust sniper that ignores invalid source data, handles fractional IVs correctly, honors the intended special_iv semantics, and can optionally throttle its sniping behavior via configurable cooldown and loitering.",
        "semantic_memory": "This fix illustrates several generalizable lessons for integrating and controlling automated behavior based on external data sources:\n\n1) **Validate external numeric data before use**: When consuming coordinates or statistics (e.g., lat/long, IVs) from third-party APIs, values may be obfuscated or replaced with placeholders for non-subscribers. Never assume apparent numeric fields are actually numeric. Attempt to parse them and, on failure, discard or gracefully skip those entries. This prevents both runtime errors and nonsensical behavior (like teleporting to 'hidden' coordinates).\n\n2) **Preserve precision when the domain demands it**: Game stats or metrics can use fractional values (e.g., 96.7% IV). Parsing them as integers silently discards information and can break threshold-based logic. Use `float` (or a precise numeric type) for any field that may legitimately be fractional. Align the data type with the domain semantics, not just the current examples.\n\n3) **Be careful with threshold comparison direction**: Logic involving thresholds (`>=`, `>`, `<=`, `<`) is easy to invert, especially when the requirement is expressed in natural language (\"greater than or equal to\" vs \"less than\"). Confirm that the implemented comparison matches the intended behavior and unit tests reflect that. In this case, a single swapped operator silently caused the bot to favor low-IV Pokémon instead of high-IV ones.\n\n4) **Use explicit, timestamp-based cooldowns for rate-limiting behavior**: To moderate aggressive or suspicious behavior (e.g., teleporting worldwide in a game), keep a `next_allowed_time` (here `no_snipe_until`) and short-circuit work if the current time is before that. This approach cleanly decouples the execution loop from rate-limiting behavior and makes it straightforward to configure via flags.\n\n5) **Separate concerns: loiter vs cooldown**: Introducing both `loiter_after_snipe` (a blocking sleep right after action) and `cooldown_enabled` (a non-blocking deferment of future executions) demonstrates two distinct throttling patterns:\n   - *Loiter* simulates realistic, human-like dwell time after an action.\n   - *Cooldown* prevents repeated actions over a period without blocking the entire process.\n   These can be toggled independently depending on the desired behavior.\n\n6) **Configuration-driven behavior with safe defaults**: New behavior that may affect long-established setups (e.g., adding cooldowns that change performance) should be optional and default to preserving the previous behavior. Adding `cooldown_enabled` and `loiter_after_snipe` with default `false` achieves backward compatibility while offering new anti-detection options.\n\n7) **Guard tasks when global constraints are active**: When higher-level flags (like global catch-disabled due to softban or other conditions) are active, each task should recognize and respect them, returning early and logging clearly. This avoids conflicting behaviors between modules and improves observability.\n\nOverall, the changes demonstrate robust API consumption, careful threshold logic, and configurable self-throttling—patterns that can be reused in any automation interacting with external systems that may impose limits or attempt to detect automated behavior.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Reproduce and isolate the problem\n- Observe misbehavior in the automation (e.g., bot teleporting to impossible coordinates, catching low-IV targets instead of high-IV, or acting too aggressively).\n- Collect logs around where external data is used (e.g., sniper targeting logs, IV and coordinate logs).\n- Identify which code paths and external responses correspond to incorrect behavior.",
            "Step 2: Inspect external API responses\n- Log the raw JSON (or sample it in a debug environment) returned by the external source(s).\n- Verify types and values of key fields: coordinates, IDs, IVs, expiration times.\n- Look for cases where supposedly numeric fields are strings like 'hidden', null, or missing, and note any precision (e.g., fractional IV values).",
            "Step 3: Add robust parsing and validation for external data\n- For each critical numeric field (latitude, longitude, IV, etc.), explicitly attempt to cast to the correct type (usually float) inside a try/except block.\n- If parsing fails (TypeError, ValueError), log or trace that the entry is invalid and skip it instead of proceeding.\n- Ensure that downstream code only sees already-validated, correctly-typed data.",
            "Step 4: Align data types with domain semantics\n- Identify fields where precision matters (e.g., scores, percentages, IVs).\n- Change parsing from `int(...)` to `float(...)` or another suitable numeric type where fractional values are possible.\n- Update any type hints, documentation, or configuration comments to match the new expectations.\n- Add tests to confirm fractional values are preserved and correctly handled in logic (thresholds, sorting, etc.).",
            "Step 5: Verify threshold and comparison logic\n- Re-express the intended behavior in clear terms (e.g., 'treat Pokémon as special if IV >= special_iv').\n- Locate the conditional logic implementing the threshold and check if the comparison operator matches the requirement.\n- Correct inverted or incorrect operators (e.g., change `<=` to `>=` when necessary).\n- Add or adjust unit tests to cover boundary conditions (just below, equal to, and just above the threshold).",
            "Step 6: Introduce cooldown and throttling mechanisms if behavior is too aggressive\n- Add a timestamp field (e.g., `next_allowed_action` or `no_snipe_until`) as part of the worker/task state.\n- At the start of the task's `work()` method, check if the current time is earlier than this timestamp; if so, return early without performing the action.\n- After performing one or more actions, compute a random or fixed cooldown interval and set `next_allowed_action = now + interval`.\n- Optional: Add a configurable flag (e.g., `cooldown_enabled`) to toggle this behavior, defaulting to the previous behavior for backward compatibility.",
            "Step 7: Optionally simulate human-like behavior via loitering\n- Add a configuration flag (e.g., `loiter_after_action`) that, when enabled, calls `time.sleep()` for a random short interval after an action.\n- Log the loiter duration to make the behavior observable during debugging.\n- Ensure this sleep occurs after critical state (like teleporting back) but before resuming the main loop.",
            "Step 8: Respect global constraints and coordination flags\n- If there is a global flag indicating that a class of actions is currently disabled (e.g., `catch_disabled`), check it at the top of `work()`.\n- If disabled, log a clear message indicating when or under what condition the task will resume, and return success without performing the action.\n- Avoid executing further logic (cooldowns, fetching targets) in this case to prevent inconsistent state.",
            "Step 9: Update configuration and documentation\n- Add new config fields (e.g., `cooldown_enabled`, `loiter_after_snipe`) with defaults in example configuration files.\n- Document their behavior and defaults in relevant docs (e.g., configuration_files.md), explaining why and when to use them.\n- Ensure existing users are not forced into new behavior unless they opt in.",
            "Step 10: Test end-to-end behavior\n- Use both normal and problematic sources (including ones with hidden/invalid coordinates and fractional IV values) to test.\n- Confirm that invalid entries are skipped without errors, IV thresholds behave correctly, and that cooldown/loiter behavior matches configuration.\n- Check logs to ensure messages are informative (e.g., show IV values when treated as special, show cooldown end times, and loiter durations)."
        ]
    }
}
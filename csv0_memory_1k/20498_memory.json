{
    "search_index": {
        "description_for_embedding": "Home Assistant locative integration: fix load/unload of device_tracker entities when using config entries by embedding the platform under the locative component, forwarding config entry setup/unload to the device_tracker domain, and correctly managing dispatcher subscriptions and coroutine awaiting.",
        "keywords": [
            "home-assistant",
            "locative",
            "device_tracker",
            "config_entry",
            "async_setup_entry",
            "async_unload_entry",
            "async_forward_entry_setup",
            "async_forward_entry_unload",
            "dispatcher",
            "TRACKER_UPDATE",
            "webhook",
            "entity unloading",
            "subscription cleanup",
            "coroutine awaiting bug"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant locative integration needed to correctly load and unload device_tracker entities that are created via config entries (webhook-based setup).\n\nPreviously, the locative device_tracker lived at `components/device_tracker/locative.py` and used the legacy `async_setup_scanner` API and `async_load_platform` from the locative component. This made config-entry-based lifecycle management (especially unloading) hard to handle. Also, there was no explicit cleanup of dispatcher subscriptions used to update tracker entities, and the integration originally misused async task creation vs awaiting when forwarding config entries.\n\nThe fix involved several coordinated changes:\n\n1. **Move the platform under the component**: The locative device_tracker platform file was moved from `homeassistant/components/device_tracker/locative.py` to `homeassistant/components/locative/device_tracker.py`, embedding the platform under the locative component namespace.\n\n2. **Use config entry forwarding for setup**: In `homeassistant/components/locative/__init__.py`, the component stopped calling `async_load_platform` in `async_setup`. Instead, `async_setup_entry` now registers the webhook and then forwards the config entry to the device_tracker domain using:\n   - `hass.async_create_task(hass.config_entries.async_forward_entry_setup(entry, DEVICE_TRACKER))`\n   so that device_tracker entities are created as part of the locative config entry setup.\n\n3. **Use config entry forwarding for unload**: The matching `async_unload_entry` unregisters the webhook and then awaits the unload of the forwarded entry via:\n   - `await hass.config_entries.async_forward_entry_unload(entry, DEVICE_TRACKER)`.\n   An earlier patch incorrectly awaited the setup coroutine and scheduled unload as a task; the final version corrects this so setup is scheduled (fire-and-forget) while unload is properly awaited, which matches Home Assistant’s config entry lifecycle expectations.\n\n4. **Update device_tracker platform to config-entry style**: The locative device_tracker module now exposes `async_setup_entry` (instead of `async_setup_scanner`) and `async_unload_entry`. It connects to the `TRACKER_UPDATE` dispatcher signal using `async_dispatcher_connect` and stores the unsubscribe callback in `hass.data` under a composite key based on the locative and device_tracker domains. On unload, `async_unload_entry` calls this stored unsubscribe callback to remove the listener.\n\n5. **Fix dispatcher subscription cleanup and testing**: A new test `test_load_unload_entry` in `tests/components/locative/test_init.py` asserts that setting up a locative config entry registers a dispatcher listener for `TRACKER_UPDATE`, and unloading the entry removes it (checking `hass.data[DATA_DISPATCHER][TRACKER_UPDATE]` length goes from 1 to 0). This test is `xfail` because the core device_tracker component doesn’t yet support unloading, but it documents the intended behavior and ensures the locative side is correct once device_tracker gains unload support.\n\n6. **Coroutine awaiting fix**: During review, it was discovered that the wrong coroutine was being awaited (setup vs. unload). The final patch set ensures that `async_forward_entry_setup` is run via `hass.async_create_task(...)` (not awaited), while `async_forward_entry_unload` is awaited directly in `async_unload_entry`, avoiding lifecycle issues and ensuring deterministic teardown.\n\nOverall, the bug was that locative device_tracker entities were not properly managed across setup and unload in a config-entry-based environment, and dispatcher subscriptions weren’t correctly cleaned up. The fix was to align the locative integration with Home Assistant’s config entry forwarding patterns, manage dispatcher listeners explicitly in `hass.data`, and correctly await the appropriate async operations.",
        "semantic_memory": "This fix illustrates several general best practices for asynchronous, component-based architectures, particularly in Home Assistant but also more broadly:\n\n1. **Align platform lifecycle with the host component via config entries**:\n   - When an integration is driven by config entries (or similar configuration constructs), platforms (such as device_tracker, sensor, etc.) should expose `async_setup_entry` and `async_unload_entry` rather than legacy setup functions.\n   - The parent component should use entry forwarding (`async_forward_entry_setup` / `async_forward_entry_unload`) instead of older discovery APIs like `async_load_platform`. This ensures that all resources created for a configuration entry can be tied to that entry and later cleanly unloaded.\n\n2. **Always pair setup with explicit teardown**:\n   - Any resource or subscription created during setup (dispatcher listeners, event listeners, tasks, timers, etc.) must have a corresponding teardown step in `async_unload_entry`.\n   - Store unsubscribe callbacks or references in a centralized registry (e.g., `hass.data` under a predictable key) so they can be accessed and called when unloading.\n\n3. **Use dispatcher/event buses safely**:\n   - When using a dispatcher/event bus abstraction, treat the registration call as resource allocation: the returned unsubscribe handle must be retained and invoked on unload.\n   - Tests can assert on underlying dispatcher data structures to verify that listeners are added and removed, even when high-level entity unloading is not yet fully supported.\n\n4. **Correct async usage: when to await vs. schedule a task**:\n   - Long-running or independent setup operations can be scheduled via `async_create_task` to avoid blocking the calling coroutine, especially in frameworks where `async_setup_entry` is allowed to complete while other setup continues in the background.\n   - Teardown/unload operations that must complete before the integration is considered fully unloaded should generally be awaited. This ensures deterministic cleanup and avoids dangling resources.\n   - Be careful to await the correct coroutine: confusing setup/unload or mixing schedule vs. await can lead to partially initialized components or incomplete teardown.\n\n5. **Testing lifecycle behavior, even when not fully supported**:\n   - Adding tests that describe the intended future behavior (marked `xfail` when some underlying framework pieces are missing) provides a contract for future framework changes and protects the design.\n   - Lifecycle tests should inspect both external behavior (entities present/absent) and internal state (dispatcher registrations, stored callbacks) when possible.\n\n6. **Namespace and ownership clarity by colocating code**:\n   - Embedding platform modules under their parent component’s package (e.g., `components/locative/device_tracker.py`) clarifies ownership and reduces coupling to generic domains. This aids reasoning about lifecycle, configuration, and internal communication patterns.\n\nThese principles generalize to any system with modular plugins and async lifecycles: clearly tie resources to their configuration context, implement symmetrical setup/teardown, use dispatcher/event bus APIs with explicit unsubscribe logic, and manage async operations with careful choice between scheduling and awaiting.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify lifecycle symptoms\n- Look for issues where entities, listeners, or subscriptions created by an integration are not removed when a configuration entry is removed or reloaded.\n- Check logs and internal state (e.g., dispatcher listener lists, event buses) after unloading/removing an integration to see if resources remain registered.",
            "Step 2: Verify that the integration uses config-entry-based APIs\n- Confirm that the parent component defines `async_setup_entry` and `async_unload_entry` rather than only legacy setup functions.\n- For platforms (e.g., device_tracker, sensor, light), ensure they expose `async_setup_entry` / `async_unload_entry` instead of legacy APIs like `async_setup_platform` or `async_setup_scanner` when the integration is driven by config entries.",
            "Step 3: Replace legacy platform loading with config entry forwarding\n- In the parent component (`__init__.py`):\n  - Remove calls to `async_load_platform` or similar discovery-based APIs in `async_setup`.\n  - In `async_setup_entry`, after any local setup (e.g., webhook registration), call:\n    - `hass.async_create_task(hass.config_entries.async_forward_entry_setup(entry, TARGET_DOMAIN))`\n  - In `async_unload_entry`, call and **await**:\n    - `await hass.config_entries.async_forward_entry_unload(entry, TARGET_DOMAIN)`\n- Choose which operations to await vs schedule:\n  - Setup forwarding can often be scheduled via `async_create_task` to avoid blocking.\n  - Unload should typically be awaited so cleanup finishes before returning.",
            "Step 4: Implement platform `async_setup_entry` / `async_unload_entry`\n- Move platform code under the owning component package if needed (e.g., from `components/device_tracker/x.py` to `components/x/device_tracker.py`) for clarity.\n- In the platform module:\n  - Implement `async_setup_entry(hass, entry, async_see_or_add_entities)` (or the domain-appropriate signature).\n  - Create any dispatcher/event bus listeners here and store the unsubscribe callbacks in `hass.data` under a predictable key (e.g., `f\"{PARENT_DOMAIN}.{PLATFORM_DOMAIN}\"`).\n  - Return `True` on successful setup.\n- Implement `async_unload_entry(hass, entry)`:\n  - Retrieve and call the stored unsubscribe callbacks.\n  - Clean up any platform-specific resources.\n  - Return `True` when unloading is complete.",
            "Step 5: Manage dispatcher/event subscriptions explicitly\n- When using a dispatcher/event bus (e.g., `async_dispatcher_connect`):\n  - Capture the return value (unsubscribe callback) and store it:\n    - `hass.data[key] = async_dispatcher_connect(hass, SIGNAL, handler)`\n  - On unload, call the stored callback: `hass.data[key]()`.\n- Optionally, remove the key from `hass.data` to avoid stale references.",
            "Step 6: Correct async patterns (await vs async_create_task)\n- For setup paths (`async_setup_entry`):\n  - Schedule long-running or dependent setup operations via `hass.async_create_task(...)` when they need not block the completion of the function.\n- For teardown (`async_unload_entry`):\n  - Await cleanup coroutines that must finish before the system considers the integration unloaded, e.g.:\n    - `await hass.config_entries.async_forward_entry_unload(entry, DOMAIN)`\n- Double-check that you are awaiting the correct coroutine (unload vs setup) and not accidentally awaiting a scheduled task handle.",
            "Step 7: Add and refine tests for load/unload behavior\n- Write tests that:\n  - Create a mock config entry and call `async_setup_entry` for the component.\n  - Wait for all tasks (`await hass.async_block_till_done()`).\n  - Assert that dispatcher/event bus subscriptions or other resources are registered (e.g., `len(hass.data[DATA_DISPATCHER][SIGNAL]) == 1`).\n  - Call `async_unload_entry` and wait again.\n  - Assert that these resources are removed (e.g., length goes back to 0).\n- If the core framework component (like device_tracker) doesn’t yet support unloading, mark the test as `xfail` with a clear reason, so it acts as a future contract.",
            "Step 8: Validate entity behavior end-to-end\n- After fixes, run the system and:\n  - Configure the integration via a config entry (e.g., a webhook-based flow).\n  - Trigger events (like webhook calls) and confirm that entities update as expected.\n  - Remove or disable the config entry and ensure entities and subscriptions are removed and no further updates occur.",
            "Step 9: Document the lifecycle expectations\n- Document that for this integration:\n  - Setup is driven by config entries and uses forwarding.\n  - All dispatcher/event bus listeners are tied to the config entry and cleaned up on unload.\n- This helps maintain future patches and ensures consistent behavior across components and platforms."
        ]
    }
}
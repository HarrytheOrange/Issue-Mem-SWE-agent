{
    "search_index": {
        "description_for_embedding": "Fix for media_player image fetching crash in Home Assistant when the upstream HTTP Content-Type header included a charset parameter (e.g., 'image/jpeg;charset=UTF-8'). aiohttp.web.Response forbids passing charset inside the content_type argument, so the fix strips the charset and only passes the MIME type (e.g., 'image/jpeg') before returning the response.",
        "keywords": [
            "Home Assistant",
            "media_player",
            "image fetch",
            "Content-Type header",
            "charset parameter",
            "aiohttp.web.Response",
            "ValueError: charset must not be in content_type argument",
            "HTTP header parsing",
            "bugfix"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant’s media_player component crashed when serving images whose upstream HTTP Content-Type header included a charset parameter, such as 'Content-Type: image/jpeg;charset=UTF-8'. The image fetch coroutine _async_fetch_image(reading from an external URL) passed response.headers['Content-Type'] directly into aiohttp.web.Response as the content_type argument. aiohttp raises a ValueError if charset is included in content_type, resulting in an error: 'ValueError: charset must not be in content_type argument'. The fix took the Content-Type header and split it on ';', using only the first segment (the bare MIME type), e.g., 'image/jpeg', before passing it to web.Response. This removed any charset or other parameters and prevented aiohttp from throwing the exception.",
        "semantic_memory": "HTTP client/server frameworks often impose stricter semantics on parameters like content_type and charset. In aiohttp, content_type must be a bare MIME type while charset must be passed as a separate parameter. Passing a full Content-Type header value (including parameters such as ';charset=UTF-8') directly into such APIs can cause runtime errors. When consuming HTTP responses and re-emitting them or mapping their metadata into framework-specific objects, it is important to normalize and sanitize header values—particularly Content-Type—by stripping parameters or splitting them into the appropriate fields. Additionally, header fields may be missing or malformed, so code should defensively handle None or unexpected formats before calling .split or similar operations. This pattern is broadly applicable when bridging between low-level HTTP headers and high-level framework APIs that make stronger assumptions about input.",
        "procedural_memory": [
            "When diagnosing HTTP-related runtime errors involving Content-Type and charset in frameworks like aiohttp, first inspect the exact header values being passed into API methods (e.g., web.Response) and compare them against the framework’s expectations.",
            "Step 1: Reproduce the error and capture logs/traceback. Identify the line where the framework raises an exception (e.g., aiohttp.web_response.__init__ raising 'ValueError: charset must not be in content_type argument').",
            "Step 2: Log or print the exact Content-Type header value from the upstream response (e.g., response.headers.get('Content-Type')). Check whether it includes parameters such as ';charset=UTF-8'.",
            "Step 3: Read the framework’s documentation for the method in question (e.g., aiohttp.web.Response). Verify what format it expects for content_type and charset. Confirm whether charset must be passed separately or omitted.",
            "Step 4: Normalize the Content-Type value before passing it into the framework API. Typically, split on ';' and take the first part as the MIME type: mime_type = header_value.split(';', 1)[0]. Strip whitespace. If the header may be absent, guard with a None check before splitting.",
            "Step 5: If needed, separately handle the charset parameter: parse the portion after ';' (e.g., 'charset=UTF-8') and feed it into the API’s dedicated charset argument instead of embedding it in content_type.",
            "Step 6: Add defensive coding around header usage. Use response.headers.get('Content-Type') and check for None before operations like .split. Fall back to a default mime type or omit content_type when the header is missing.",
            "Step 7: Add tests (or reproduce scenarios) with: (a) Content-Type including charset, (b) Content-Type without charset, and (c) no Content-Type header. Ensure all cases are handled without raising errors and that the correct content_type is sent to the client.",
            "Step 8: Run the project’s test suite (e.g., tox) and re-verify the specific feature (image fetching/serving) in the UI or API to confirm that images load correctly and no ValueError is raised."
        ]
    }
}
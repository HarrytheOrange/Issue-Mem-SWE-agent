{
    "search_index": {
        "description_for_embedding": "CI bundle builds for napari were failing due to using different briefcase versions on macOS vs other platforms. macOS GitHub Actions used 'briefcase>=0.3.5', which introduced regressions (#2965), while other platforms used briefcase==0.3.1. The fix removed the macOS-specific step so all platforms consistently use briefcase==0.3.1 in .github/workflows/make_bundle.yml.",
        "keywords": [
            "napari",
            "briefcase",
            "bundle build",
            "GitHub Actions",
            "make_bundle.yml",
            "packaging",
            "app bundling",
            "macOS",
            "version pinning",
            "CI configuration bug",
            "plugin install error",
            "cellpose plugin",
            "#2965"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari’s distributable bundles (notably on macOS) were affected by a regression introduced by newer versions of the Briefcase packaging tool. The GitHub Actions workflow `.github/workflows/make_bundle.yml` had a platform-specific step: for all platforms it installed `briefcase==0.3.1` but then, on macOS only, it ran an extra step `python -m pip install briefcase>=0.3.5` (later briefly changed to `==0.3.4`). This override meant that macOS bundles were built with a different Briefcase version than Linux/Windows, and the newer Briefcase version was associated with install issues such as errors when installing plugins (e.g. the cellpose plugin) from within the bundled app, tracked under issue #2965 and discussed on the Image.sc forum.\n\nInitially, a PR attempted to constrain macOS to `briefcase==0.3.4` as a temporary fix, but after discussion it became clear that 0.3.1 was the last well-tested version and there was no benefit to upgrading. The final change in the PR removed the macOS-specific installation step entirely. The workflow now only has a single platform-independent step that installs `briefcase==0.3.1` (along with tomlkit, wheel, dmgbuild, PySide2, and the napari package itself). As a result, all platforms use the same, known-good Briefcase version, eliminating the version-induced bundling/install problems on macOS. The PR is explicitly labeled as a temporary workaround; the longer-term plan is to add tests that exercise bundle installation behavior and eventually move to newer Briefcase versions safely.",
        "semantic_memory": "This case highlights several generalizable lessons about build tooling and CI configuration:\n\n1. **Avoid 'latest' or loose version ranges for critical build tools.** Using `briefcase>=0.3.5` on macOS meant that CI could silently pick up new Briefcase releases with behavior changes that were neither tested nor coordinated with the application’s release cycle. For packaging or deployment infrastructure, pinning to a known-good version (e.g., `==0.3.1`) is safer.\n\n2. **Keep build tool versions consistent across platforms.** Having macOS use a different Briefcase version than Linux/Windows introduced platform-specific behavior and bugs. Aligning versions across all CI jobs reduces the risk of platform-only failures and simplifies debugging.\n\n3. **Beware of OS-specific overrides in CI workflows.** Extra steps conditioned on `runner.os` can unintentionally undo earlier constraints (e.g., re-installing a dependency with a different version). Such overrides should be clearly justified and periodically reviewed.\n\n4. **Treat CI configuration as critical code.** A seemingly minor change in a workflow file (adding or modifying a `pip install` line) can break production artifacts, like installers or bundles, without any changes in the application code. Workflow files should be reviewed and tested with the same rigor as application logic.\n\n5. **Introduce tests for installable artifacts and runtime behavior.** Bugs surfaced when users tried to install plugins into the bundled app. Tests that build bundles and then verify runtime operations (like plugin installs) would catch regressions from build tool upgrades early.\n\n6. **Use temporary pins as a controlled mitigation, but track long-term fixes.** When upstream tools regress, pinning to a working version is often the fastest safe mitigation. However, this should be explicitly documented as temporary, with a follow-up issue to track upgrading once proper tests and fixes are in place.\n\nOverall, the pattern is: treat build tools as dependencies with their own compatibility constraints, pin them, and keep CI configs simple, consistent, and test-backed.",
        "procedural_memory": [
            "When bundle builds or installers fail or behave differently across platforms, systematically investigate CI configuration and build tool versions.",
            "Step 1: Reproduce and characterize the problem.\n- Confirm which artifacts are failing (e.g., macOS bundle vs Linux/Windows).\n- Collect user reports and logs (e.g., plugin install errors, stack traces) from the problematic environment.\n- Verify that the issue is specific to bundles/packaged builds, not source installs.",
            "Step 2: Compare CI workflows and dependency versions across platforms.\n- Inspect the relevant GitHub Actions workflows (e.g., `.github/workflows/make_bundle.yml`).\n- Look for OS-specific `if: runner.os == '...'` blocks and extra `pip install` steps.\n- Identify any differences in package version constraints between platforms (e.g., one platform using `tool>=x` while others use `tool==y`).",
            "Step 3: Identify and test a known-good version of the build tool.\n- Determine the last version of the tooling (e.g., Briefcase) that produced working artifacts (e.g., bundles where plugin installation worked).\n- Rebuild locally or in a throwaway CI branch using that version to confirm that it resolves the issue.",
            "Step 4: Pin the build tool version consistently across all platforms.\n- In the workflow file, replace loose or range-based constraints (e.g., `>=` or no version) with an exact version pin for the build tool (e.g., `briefcase==0.3.1`).\n- Remove or refactor OS-specific steps that re-install or override the pinned dependency.\n- Ensure that all jobs which produce release artifacts reuse a common, version-pinned setup block.",
            "Step 5: Simplify and clean up OS-specific overrides.\n- If a platform had a special step solely to ‘install the latest’ version of a tool, remove this step unless strictly needed.\n- Where platform differences are needed (e.g., extra dependencies like `dmgbuild` for macOS), separate them cleanly from the shared, pinned tooling setup to avoid accidental overrides.",
            "Step 6: Validate the fixed workflow.\n- Run the CI workflow to build bundles for all platforms using the pinned build tool version.\n- Manually test the resulting artifacts, including previously failing scenarios (e.g., installing a plugin such as cellpose from within the app).\n- Confirm that behavior is now consistent across platforms.",
            "Step 7: Document the pin and plan for a long-term solution.\n- Note in the PR/issue that the pin is a temporary workaround for a specific upstream regression (e.g., #2965).\n- Open or update an issue to track: (a) adding automated tests for bundle/runtime behavior (like plugin installations), and (b) safely upgrading the build tool in the future.\n- Optionally add comments in the workflow file explaining why the pin exists and under what conditions it can be relaxed.",
            "Step 8: For future upgrades, follow a cautious upgrade path.\n- Test new versions of the build tool in a dedicated branch with expanded integration tests, including building and exercising bundles.\n- Only update the pinned version in CI once those tests pass and known problem scenarios are verified.\n- Avoid using open-ended constraints (`>=`, `~=`) for core build tooling in production workflows."
        ]
    }
}
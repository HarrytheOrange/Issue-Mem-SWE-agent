{
    "search_index": {
        "description_for_embedding": "Fix crash in napari when viewing stacked binary (boolean) TIFF images. The image layer status message formatter treated numpy bool values as floats and applied a precision format specifier, causing a ValueError. The fix treats numpy booleans like integers during message formatting and adds a regression test for bool image data.",
        "keywords": [
            "napari",
            "image layer",
            "boolean TIFF",
            "stacked binary tiffs",
            "np.bool_",
            "np.integer",
            "status message formatting",
            "ValueError",
            "Precision not allowed in integer format specifier",
            "dtype handling",
            "image viewer crash"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari crashed when opening certain stacked binary TIFF images. These images were read by skimage.io.read as numpy arrays of dtype bool. When the user hovered over the image, napari's Image layer tried to generate a status message in get_message(). For scalar values, the code distinguished only between numpy integers and other types: integers were converted to strings directly, but non-integers were formatted using an f-string with a precision specifier (f'{value:0.3}'). Because numpy booleans (np.bool_) are not instances of np.integer, they were treated as non-integers and passed to the float-style formatter. This led to a ValueError: 'Precision not allowed in integer format specifier' whenever a boolean pixel value was formatted. The fix was to update the type check to treat booleans like integers during formatting: `isinstance(value, (np.integer, np.bool_))`. In that case, the value is converted with `str(value)` instead of using a precision-based format. A new test, test_bool_image, was added to ensure that Image layers constructed with bool data behave correctly (no crash, correct shape, ndim, multichannel flag, and _data_view shape). This specific change prevents crashes when loading stacked boolean TIFF images and ensures proper handling of boolean image data in napari.",
        "semantic_memory": "When formatting values for display (e.g., UI status messages, logs, or tooltips), relying solely on simple type distinctions like 'integer vs non-integer' can break for special numeric-like types such as numpy scalars (np.integer, np.bool_, np.float32, etc.). Booleans in particular—especially numpy's np.bool_—are not instances of np.integer, yet they are also not floats and do not support float-style format specifiers like ':0.3'. Applying float precision specifiers to non-float or integer-like types can raise errors ('Precision not allowed in integer format specifier'). A robust pattern is to explicitly handle boolean and integer types together, formatting them as plain strings without precision, and only applying precision-based formatting to true floating-point values. Furthermore, any function that constructs user-facing messages from heterogeneous numeric data should be careful to account for numpy scalar types, not just Python built-in types, since scientific image data frequently uses numpy dtypes. Adding regression tests that cover non-standard or less-common dtypes (bool, uint16, etc.) helps prevent future regressions in numerical formatting and display logic.",
        "procedural_memory": [
            "When diagnosing crashes related to display or formatting of image data, start by reproducing the error using the exact data type and shape that triggered the crash.",
            "Step 1: Reproduce the crash with the problematic data type.\n- Load the file or generate synthetic data that matches the failing case (e.g., a boolean numpy array representing a binary TIFF).\n- Run the application and perform the action that triggers the display or status message update (e.g., opening the image and hovering over it). Capture the full traceback.",
            "Step 2: Inspect the stack trace and identify the formatting or display code.\n- Look at the last few frames of the traceback to find the exact line where the exception is raised.\n- If you see formatting-related errors like `ValueError: Precision not allowed in integer format specifier`, search for f-strings or format() calls near that line.\n- Check what type of value is being formatted (use type() or isinstance checks in a local reproduction).",
            "Step 3: Analyze type handling and numpy scalar behavior.\n- Determine what dtypes are being passed (e.g., np.bool_, np.integer subclasses, np.float32).\n- Verify how the code distinguishes between these types (e.g., isinstance(value, np.integer) vs isinstance(value, numbers.Integral)).\n- Remember that numpy booleans (np.bool_) are not np.integer but often need similar handling to integers for display purposes.",
            "Step 4: Adjust the type checks and formatting logic.\n- Extend type checks to explicitly include numpy boolean scalars in appropriate branches, for example:\n  `if isinstance(value, (np.integer, np.bool_)):`\n- For integer-like and boolean values, format them using simple string conversion (str(value)) or integer-specific formatting without precision specifiers.\n- Reserve precision-based formats (e.g., `'{value:0.3f}'` or similar) for known-floating types (numpy floating dtypes or Python float).",
            "Step 5: Add regression tests for the problematic dtype.\n- Create a dedicated unit test that constructs an image or data structure using the problematic dtype (e.g., bool) and passes it through the path that previously crashed (e.g., creating an Image layer and accessing _data_view or get_message()).\n- Assert correct behavior: no crash, correct shape and metadata, and possibly correct message formatting if accessible.\n- For libraries dealing with images or numeric arrays, add tests for multiple dtypes (bool, int, float, different bit depths) to ensure robust handling.",
            "Step 6: Run the full test suite and validate in the UI.\n- Execute the test suite to confirm that the change does not break other code paths.\n- Manually test the UI or API with several image types, including the previously failing one, to verify that status messages and displays work as expected without errors.",
            "Step 7: Document the fix and lessons learned.\n- Note in code comments or documentation why specific dtype checks are present (e.g., 'np.bool_ must be handled like integers to avoid precision formatting errors').\n- Share the knowledge that numpy scalar types can behave differently from Python built-ins and require explicit handling in formatting and display logic."
        ]
    }
}
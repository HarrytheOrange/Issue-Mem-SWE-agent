{
    "search_index": {
        "description_for_embedding": "Home Assistant Z-Wave integration emitted a misleading 'zwave not ready after 30 seconds' warning on every startup because OpenZWave networks can take several minutes to initialize. The fix reworked the startup wait to be non-blocking using asyncio, and increased the readiness timeout from 30 to 300 seconds, adjusting tests accordingly.",
        "keywords": [
            "Home Assistant",
            "Z-Wave",
            "OpenZWave",
            "startup timeout",
            "zwave not ready after 30 seconds",
            "asyncio.sleep",
            "blocking executor thread",
            "NETWORK_READY_WAIT_SECS",
            "event loop",
            "non-blocking wait",
            "integration startup",
            "device initialization"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant Z-Wave component logged a warning at every startup: 'zwave not ready after 30 seconds, continuing anyway'. Users reported this as misleading because OpenZWave is known to take several minutes to fully initialize, so the warning suggested a problem even under normal operation.\n\nOriginally, the Z-Wave startup sequence called `network.start()` and then performed a blocking loop using `time.sleep(1)` up to `NETWORK_READY_WAIT_SECS` (30 seconds). This both blocked an executor/worker thread and used a timeout that was too short for typical Z-Wave networks. If the network state did not reach `STATE_AWAKED` within 30 seconds, Home Assistant logged a warning and continued.\n\nThe fix was implemented in several steps:\n\n1. The waiting logic was first refactored to avoid blocking a worker thread by scheduling periodic checks instead of spinning with `time.sleep`. It used `dt_util.utcnow()` and `track_point_in_utc_time` to re-schedule checks every second until the network reached `STATE_AWAKED` or the timeout expired. On success, it logged 'Z-Wave ready after X seconds' and called a `_finalize_start()` function; on timeout it logged a warning and then also called `_finalize_start()`.\n\n2. The constant `NETWORK_READY_WAIT_SECS` in `homeassistant/components/zwave/const.py` was increased from 30 to 300 seconds to better match realistic OpenZWave initialization times, postponing the warning and preventing normal startups from looking broken.\n\n3. The unit test `test_zwave_ready_wait` was updated to match the new asynchronous behavior. Instead of patching `time.sleep`, the test now mocks `dt_util.utcnow` and the scheduling mechanism (first `track_point_in_utc_time`, then `asyncio.sleep`) to simulate passing time and to assert the correct number of wait iterations and the presence of the warning log when the timeout is reached.\n\n4. The waiting logic was later simplified again to use an async coroutine with `asyncio.sleep` rather than Home Assistant's `track_point_in_utc_time`. The new `_check_awaked` function is an `asyncio.coroutine` that:\n   - Records `start_time = dt_util.utcnow()`.\n   - Loops, on each iteration computing how many seconds have elapsed.\n   - If `network.state >= network.STATE_AWAKED`, logs 'Z-Wave ready after X seconds' and breaks.\n   - Else if the elapsed time exceeds `NETWORK_READY_WAIT_SECS`, logs 'Z-Wave not ready after X seconds, continuing anyway' plus the final network state, then breaks.\n   - Otherwise, `yield from asyncio.sleep(1, loop=hass.loop)` and repeats.\n   - After breaking, schedules `_finalize_start` with `hass.async_add_job(_finalize_start)`.\n\n   This coroutine is scheduled by `hass.add_job(_check_awaked)` after `network.start()` and the initial event fire. This ensures the wait is non-blocking and runs in the event loop.\n\n5. The associated test was updated to patch `asyncio.sleep` instead of `time.sleep` or the event scheduler. The test stores sleep durations into a `sleeps` list and uses a custom `utcnow` implementation based on the number of sleeps, which simulates time progression. It asserts that the number of sleeps is equal to `NETWORK_READY_WAIT_SECS` and that the warning log uses the correct wait value.\n\nMinor lint and compatibility details were also addressed: explicitly passing `loop=hass.loop` to `asyncio.sleep` in the component code, and naming the `loop` parameter explicitly as `loop` when delegating to the original `asyncio_sleep` in the test.\n\nOverall, the bug fix both corrected the misleading early warning and improved the startup logic to be asynchronous and non-blocking.",
        "semantic_memory": "This change illustrates several generalizable patterns and best practices for asynchronous, device-oriented applications:\n\n1. **Don’t use short timeouts for slow hardware initialization**: Hardware or networked subsystems (e.g., Z-Wave, Zigbee, Bluetooth, cloud APIs) often have startup times measured in tens or hundreds of seconds. Using a short hardcoded timeout (e.g., 30 seconds) can mislead users with spurious warnings. Timeouts should align with realistic hardware behavior and, ideally, be configurable.\n\n2. **Avoid blocking threads with `time.sleep` in asynchronous frameworks**: In an async event-loop-based system such as Home Assistant (based on asyncio), blocking calls like `time.sleep` in critical paths (e.g., component setup, startup handlers) waste worker threads and can stall other tasks. Use `asyncio.sleep` or the framework’s scheduling utilities instead.\n\n3. **Use asynchronous wait loops for readiness conditions**: When waiting for an external subsystem to reach a specific state (e.g., `STATE_AWAKED`), implement an asynchronous loop that:\n   - Periodically checks a shared state.\n   - Uses non-blocking sleep between iterations.\n   - Enforces a maximum wait duration.\n   - Logs clearly in both success and timeout cases.\n   - Invokes finalization logic once the wait ends.\n\n4. **Decouple startup from readiness**: Components can start their network connection and then asynchronously wait for readiness before enabling dependent features. This allows the overall application to continue starting while the slower subsystem catches up.\n\n5. **Leverage the event loop instead of custom schedulers when possible**: Using `asyncio.sleep` and async coroutines can simplify code relative to custom scheduling callbacks (`track_point_in_utc_time` or similar), while still remaining non-blocking, as long as you integrate properly with the framework’s event loop (`loop=hass.loop`).\n\n6. **Test asynchronous time-dependent logic by mocking time and sleep**: For logic that depends on timeouts and periodic checks, tests should not use real-time delays. Instead, they can:\n   - Mock time sources (e.g., `dt_util.utcnow`) to simulate progression.\n   - Patch `asyncio.sleep` to record durations and immediately yield control.\n   - Assert on the number of sleep iterations and log output rather than real elapsed time.\n\n7. **Log messages should reflect typical behavior**: Warnings should be reserved for truly abnormal conditions. If a condition is expected under normal operation (e.g., a Z-Wave network taking a couple of minutes to start), the system should not emit warnings early. Logging should differentiate between normal slow startup and genuine failures.\n\n8. **Finalize initialization in a separate async job**: When a readiness wait is complete, scheduling finalization (`hass.async_add_job`) rather than calling directly from inside the wait loop maintains clean control flow and avoids blocking the loop, especially if finalization itself may perform async or I/O-heavy work.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify misleading or premature warnings\n- Review logs around application startup for warnings or errors that occur consistently but do not correspond to actual failures.\n- Confirm with documentation or hardware specs whether the timing is realistic (e.g., Z-Wave networks can take several minutes to be ready).\n- Determine which module and code path emit the warning and under what conditions.",
            "Step 2: Inspect the readiness wait implementation\n- Locate the code that waits for the external subsystem to become 'ready' (e.g., checks on `network.state` or similar flags).\n- Check if it uses blocking operations like `time.sleep`, tight loops, or synchronous I/O in startup or event handlers.\n- Identify the maximum wait time configured (constants like `NETWORK_READY_WAIT_SECS`) and how that compares to real-world startup durations.",
            "Step 3: Redesign the wait to be asynchronous and non-blocking\n- Convert the readiness wait into an async coroutine where appropriate.\n- Replace `time.sleep` with `await asyncio.sleep(x)` or `yield from asyncio.sleep(x, loop=<loop>)` depending on your async style.\n- If your framework provides its own scheduling utilities, use them in a non-blocking way (e.g., schedule callbacks instead of sleeping on the main or worker threads).\n- Ensure that the wait loop periodically checks the real state, enforces a maximum timeout, and breaks correctly on either success or timeout.",
            "Step 4: Adjust timeout values to match realistic hardware behavior\n- Revisit constants that control startup timeouts (e.g., 30 seconds vs 300 seconds).\n- Choose a timeout that matches documented or observed behavior of the slowest expected hardware.\n- If possible, make the timeout configurable via settings while keeping a sensible default.\n- Update any comments and documentation to reflect the new timeout behavior.",
            "Step 5: Keep startup responsive and finalize initialization cleanly\n- Ensure that the application’s main startup sequence does not block on long waits; instead, trigger the slow subsystem startup and then spawn an async task or scheduled callback to wait for readiness.\n- Once the wait completes (success or timeout), schedule finalization logic (e.g., `async_add_job(_finalize_start)`), rather than executing heavy logic within the waiting loop.\n- Finalization should enable dependent features, register entities, or fire events once the subsystem is ready or after you choose to proceed despite timeout.",
            "Step 6: Update and extend tests for async and time-dependent behavior\n- Replace tests that patch `time.sleep` with tests that patch `asyncio.sleep` or the framework’s scheduling functions.\n- Mock time sources (e.g., `utcnow`) to simulate time passing without real delays; relate the mocked time progression to the number of sleep calls or callbacks executed.\n- Assert that:\n  - The expected number of iterations/sleeps occurs before timeout.\n  - The correct log messages (info on success, warning on timeout) are emitted with the expected elapsed time.\n  - Finalization logic is invoked after the wait finishes.\n- Pay attention to loop arguments (e.g., `loop=hass.loop`) in both code and tests to avoid event-loop-related issues.",
            "Step 7: Verify behavior in real scenarios\n- Run the application with the modified code on a system with typical hardware (e.g., real Z-Wave network) and observe startup logs.\n- Confirm that:\n  - No warning is logged during normal startup within the extended timeout.\n  - If the network never becomes ready (e.g., disconnected controller), the warning appears only after the configured timeout.\n  - The UI and other components remain responsive during the wait, indicating that no blocking calls remain in the startup path.",
            "Step 8: Document the behavior for users and contributors\n- Document expected startup times and what the warning actually means (e.g., 'Z-Wave not ready after 300 seconds, continuing anyway').\n- Clarify that slow initialization can be normal and that the system will continue operating while the subsystem catches up.\n- For contributors, document the pattern: use async waits and non-blocking scheduling for any new integrations that involve slow hardware or network initialization."
        ]
    }
}
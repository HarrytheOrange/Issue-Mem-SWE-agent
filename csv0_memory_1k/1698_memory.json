{
    "search_index": {
        "description_for_embedding": "Introduced a first-class Pack model and persistence layer, added lazy/late pack registration during content bootstrap based on pack.yaml manifests, and exposed a new /v1/packs API endpoint to list installed packs. Uninstall now also removes the Pack DB object, and pack registration failures are logged but non-fatal.",
        "keywords": [
            "StackStorm",
            "pack management",
            "PackDB",
            "PackAPI",
            "/v1/packs",
            "lazy registration",
            "content bootstrap",
            "pack.yaml",
            "MongoEngine",
            "ResourceController",
            "RBAC preparation"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the team added first-class support for StackStorm \"packs\" as persistent objects, plus an API to list them. Previously, packs were not represented as a dedicated DB model, and pack visibility was tightly coupled to the install workflow and content registration. This limited discoverability (no way to list installed packs via API/CLI) and complicated future RBAC work that would need to assign permissions at the pack level.\n\nTo address this, a new PackDB MongoEngine model was introduced with fields ref (unique identifier, typically the pack directory name), name, description, keywords, version, author, and email. A corresponding persistence class (st2common.persistence.pack.Pack) and API model (PackAPI) were added. PackAPI includes JSON schema validation, a to_model method that maps API objects into PackDB (ensuring keywords defaults to [], casting version to string, and copying ref, author, and email), and will be the boundary between the REST API and DB.\n\nThe resource bootstrapping flow was extended to perform lazy/late registration of packs whenever content (actions, sensors, rules, aliases, policies) is registered from disk. The new ResourceRegistrar methods register_packs and register_pack use a ContentPackLoader to discover packs in base directories by the presence of pack.yaml (MANIFEST_FILE_NAME) and load their metadata via MetaLoader. Each pack's manifest is validated: the file must exist and not be empty. The pack's ref is set to the directory name, and PackAPI + Pack.add_or_update are used to create or update the PackDB record. A REGISTERED_PACKS_CACHE prevents re-registering the same pack multiple times within a single run. Failures in pack registration are logged but treated as non-fatal, so content registration can proceed.\n\nAll relevant registrars (actionsregistrar, sensorsregistrar, rulesregistrar, aliasesregistrar, policiesregistrar) were updated to register packs first when processing base directories or a single pack, ensuring that PackDB entries exist before any content that refers to the pack. A minor cleanup renamed the policies module to policiesregistrar for consistency and updated imports/tests accordingly.\n\nThe uninstall workflow (contrib/packs/actions/pack_mgmt/unload.py) was updated so that packs.uninstall not only unregisters sensors, triggers, and actions but also deletes the corresponding PackDB object. The code was refactored to use specific persistence access classes (SensorType, TriggerType, Trigger, Action, and the new Pack) instead of the older reactor/action modules, and a dedicated _unregister_pack method deletes the pack DB record if it exists.\n\nOn the API side, a new PacksController was added under st2api/controllers/v1/packs.py. It extends ResourceController, binds to PackAPI and Pack persistence, supports filtering by name and ref, and sorts results by ref. The v1 root controller exposes this as /v1/packs, enabling clients to list installed packs and query them by name or ref. Dummy pack fixtures in tests were updated to include empty pack.yaml files to satisfy the new manifest requirement. Finally, the changelog was updated to mention the new /v1/packs endpoint as a feature.",
        "semantic_memory": "This change illustrates several generalizable design and implementation patterns:\n\n1. **Introduce a first-class model when a domain entity gains importance**: As packs became central for RBAC and discoverability, moving from ad-hoc handling to a dedicated PackDB model and persistence layer clarified ownership, enabled consistent querying (get_by_ref, get_by_name), and simplified future feature work. When a concept is used across subsystems (install, RBAC, discovery, API), giving it a first-class model is beneficial.\n\n2. **Separate concerns via layered models (DB, persistence, API)**: The code uses a consistent pattern: MongoEngine DB models (PackDB) for storage, persistence access wrappers (Pack) for data access and common operations, and API models (PackAPI) for validation and external representation. This separation allows schema evolution, API validation, and storage-specific behavior to be managed in the right place without leaking details across layers.\n\n3. **Lazy/late registration of metadata based on manifests**: Rather than tying registration to a single install workflow, the system registers packs when content is loaded from disk. This makes dev/symlinked packs and packs installed by other mechanisms visible, and reduces assumptions about install processes. The presence of a manifest file (pack.yaml) is used as the canonical signal that a directory is a pack.\n\n4. **Resilient bootstrap: failures should be non-fatal where possible**: Pack registration is wrapped in try/except and failures are logged but do not stop content registration. This pattern is important in bootstrap/initialization code, where it's often better to partially bring the system up and log issues than to crash on a single malformed resource. At the same time, clear error messages are raised for truly invalid conditions (missing or empty manifest) within the registration method.\n\n5. **Use canonical identifiers (ref) separate from user-visible names**: By adding and using a ref field (distinct from name), the system can refer to packs via a stable, unique identifier (often tied to directory/package name) while still allowing more flexible user-facing naming. APIs and persistence accessors (get_by_ref) are built around this canonical identifier.\n\n6. **Avoid repeated work via short-lived caches**: REGISTERED_PACKS_CACHE prevents redundant DB operations during a single register-content run. For scripts or batch processes, process-local caches can be an effective and simple optimization, especially when they avoid repeated DB upserts.\n\n7. **Consistency in naming and module structure**: Renaming the policies module to policiesregistrar to match other *registrar modules highlights the importance of consistent naming conventions for discoverability and maintainability.\n\n8. **Tidy uninstall flows that clean up all related state**: Updating the uninstall workflow to remove the PackDB record ensures that logical state matches physical state (no orphaned packs in DB). This pattern applies widely: when removing a resource, ensure associated metadata, registry entries, and DB objects are also cleaned up.",
        "procedural_memory": [
            "When adding a new first-class entity (like a pack) plus an API to list/manage it, follow a structured approach that covers modeling, persistence, bootstrap integration, and API exposure.",
            "Step 1: Define the DB model\n- Identify the fields needed for the entity (e.g., ref, name, description, keywords, version, author, email).\n- Create a MongoEngine (or ORM) model (e.g., PackDB) with appropriate field types and constraints (ref and name unique, email as EmailField, etc.).\n- Expose a specialized access object (e.g., pack_access = MongoDBAccess(PackDB)) and ensure standard accessors like get_by_id, get_by_name, and get_by_ref exist in the shared base class.",
            "Step 2: Create a persistence access layer\n- Implement a persistence wrapper class (e.g., class Pack(base.Access): impl = pack_access) that delegates to the underlying DB access.\n- Add classmethods to the base persistence class for common lookups (get_by_ref, get_by_name, get_by_id) so callers don’t touch the ORM directly.\n- Use add_or_update on this persistence layer for upsert semantics when registering or modifying entities.",
            "Step 3: Define the API model and validation\n- Implement an API model (e.g., PackAPI) inheriting from a base API class (BaseAPI).\n- Define a JSON schema describing the exposed fields (id, ref, name, description, keywords, version, author, email), which fields are required, and sensible defaults (e.g., keywords default to []).\n- Implement a to_model classmethod that takes an API object and returns a DB model, setting defaults and performing necessary type conversions (e.g., ensure version is a string, propagate ref, author, email).",
            "Step 4: Integrate manifest-based registration\n- Decide on a manifest filename for the entity (e.g., MANIFEST_FILE_NAME = 'pack.yaml') and add a constant for it.\n- Extend your content loader (e.g., ContentPackLoader) to:\n  - Discover packs by scanning base directories for subdirectories containing the manifest file.\n  - Return a mapping of pack_name -> pack_dir (get_packs).\n- Extend your registration base class (ResourceRegistrar) to:\n  - Implement register_packs(base_dirs) that calls loader.get_packs and then register_pack for each.\n  - Implement register_pack(pack_name, pack_dir) that:\n    - Uses a process-local cache to avoid duplicate registration in the same run.\n    - Calls a private _register_pack that:\n      - Verifies the manifest file exists and is non-empty.\n      - Loads the manifest content via MetaLoader.\n      - Injects or computes fields like ref based on directory name.\n      - Builds a PackAPI instance, converts it to PackDB, and uses Pack.add_or_update.\n      - Preserves the DB id if an existing record is found via get_by_ref, enabling updates instead of blindly creating duplicates.",
            "Step 5: Make registration resilient\n- Wrap calls to the low-level registration (_register_pack) in try/except at the higher level (register_pack).\n- On exceptions, log with context (pack name, path, stack trace), but continue running so other packs and content can still be registered.\n- Only raise explicit exceptions inside _register_pack for invariants that should be considered hard failures (e.g., missing or empty manifest if you want to prevent that pack from being used).",
            "Step 6: Ensure pack registration precedes content registration\n- For each specific content registrar (actions, sensors, rules, aliases, policies), ensure that:\n  - In register_*_from_packs(base_dirs), you call self.register_packs(base_dirs=base_dirs) before loading and registering content.\n  - In register_*_from_pack(pack_dir), you derive pack name, then call self.register_pack(pack_name=pack, pack_dir=pack_dir) before processing that pack’s content.\n- This guarantees that any DB records referring to the pack can safely assume the PackDB entry exists.",
            "Step 7: Add or update the REST API endpoint\n- Implement a controller (e.g., PacksController) extending a generic ResourceController.\n- Bind it to the API model and persistence layer (model = PackAPI, access = Pack).\n- Define supported_filters mapping external query params to DB fields (e.g., 'name': 'name', 'ref': 'ref').\n- Configure query options like default sort order (e.g., sort by ref).\n- Wire the controller into your API root (e.g., RootController.packs = PacksController()) so it is exposed as /v1/packs.\n- Optionally, update changelog and API docs to reflect the new endpoint.",
            "Step 8: Update uninstall / cleanup logic\n- Identify the existing uninstall workflows or actions (e.g., packs.uninstall) that remove content like sensors, triggers, and actions.\n- Extend them to also remove the entity’s DB object (PackDB) by:\n  - Looking it up via the canonical identifier (Pack.get_by_ref or get_by_name as appropriate).\n  - Deleting it with Pack.delete.\n  - Handling missing entries (ValueError) and deletion errors gracefully while logging issues.\n- Use persistence access classes (SensorType, TriggerType, Trigger, Action, Pack) consistently instead of older or more generic modules.",
            "Step 9: Adjust tests and fixtures\n- Add or update fixture data to comply with the new manifest requirement (e.g., ensure dummy pack directories contain a pack.yaml, even if empty, or better, minimally valid metadata).\n- Update imports and module names if you renamed registrars for consistency (e.g., from st2common.content.policies to st2common.content.policiesregistrar).\n- Add tests for the new API endpoint (/v1/packs), ensuring listing, filtering by ref/name, and ordering work as expected.",
            "Step 10: Validate and iterate\n- Run unit and integration tests to confirm packs are discovered, registered, and exposed via the API.\n- Check that dev/symlinked packs and packs installed outside the primary install workflow are now visible.\n- Verify uninstall removes both content and pack metadata.\n- Confirm that malformed or missing manifest files produce clear logs without crashing the entire registration process."
        ]
    }
}
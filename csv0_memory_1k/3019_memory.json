{
    "search_index": {
        "description_for_embedding": "Removed the deprecated StackStorm `packs.info` action that depended on the obsolete `.gitinfo` file. New pack management uses real git checkouts, so pack version/metadata should be retrieved via `st2 pack get` and Exchange, making the old action and file unnecessary.",
        "keywords": [
            "StackStorm",
            "packs.info",
            ".gitinfo",
            "pack management",
            "deprecated action",
            "API cleanup",
            "backwards compatibility",
            "remove dead code"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the StackStorm team removed the `packs.info` action and its implementation because the underlying mechanism it relied on (`.gitinfo` files inside packs) was deprecated by a newer pack management system. Previously, `packs.info` read a `.gitinfo` JSON file from a pack directory in one of the configured `packs_base_paths` to return metadata about the deployed pack (like version or source info). With the new model, pack directories are full git checkouts and `.gitinfo` is no longer created or used. Keeping `packs.info` would at best provide no data for new-style packs and at worst confuse users by exposing a broken or obsolete interface. The PR deletes `contrib/packs/actions/info.yaml` and `contrib/packs/actions/pack_mgmt/info.py`, completely removing the action, and adds a CHANGELOG entry documenting that `packs.info` was removed because `.gitinfo` has been deprecated. Backwards compatibility for users is handled at the content level: old StackStorm versions use packs from `st2contrib` that still reference the old `packs` actions, while newer StackStorm versions will use updated Exchange packs that reference the new pack management commands (such as `pack get`). This aligns user behavior with the new system and avoids maintaining redundant legacy code paths.",
        "semantic_memory": "This PR illustrates how to properly retire a deprecated feature in a system that evolves its architecture. When a core mechanism (like pack metadata storage) changes, any public actions or APIs that depend on the old mechanism should either be adapted to the new model or removed to prevent confusion and technical debt. In this case, the `.gitinfo` file used for pack metadata became unnecessary once pack directories were actual git repositories managed by a new pack management workflow. Instead of trying to retrofit the `packs.info` action around the new system, the team opted to remove it and encourage users to use an already-existing, better-aligned command (`pack get`) for pack information. Good practice here includes: (1) clearly identifying that a feature is no longer supported or meaningful in the new architecture; (2) verifying that a functional alternative exists; (3) coordinating compatibility at the content/distribution level (old packs versus new Exchange packs) rather than keeping obsolete core code; and (4) documenting the removal in a changelog and broader communication (e.g., release notes, blog posts) so users can adjust workflows accordingly. This pattern is applicable anywhere a platform migrates from file-based metadata to source-controlled or API-driven metadata and needs to retire thin compatibility layers that only make sense in the old world.",
        "procedural_memory": [
            "Step-by-step guidance for deprecating and removing an obsolete action or API that depends on a deprecated metadata mechanism:",
            "Step 1: Identify the old dependency and its usage scope",
            " • Locate the code that depends on the deprecated mechanism (here: `packs.info` reading `.gitinfo`).\n • Map where and how this functionality is used (internal code, packs, rules, external documentation).",
            "Step 2: Confirm the new canonical mechanism and its coverage",
            " • Ensure there is a clear replacement that covers the same core user need (e.g., using `pack get` to inspect installed pack versions/metadata).\n • Verify that the new mechanism works across all configurations where the old one was used (e.g., all pack locations are proper git checkouts).",
            "Step 3: Decide between adaptation and removal",
            " • Evaluate whether adapting the old interface to the new mechanism is worth the added complexity.\n • If the old interface is thin, redundant, or misleading in the new architecture, plan to remove it instead of keeping a confusing alias.",
            "Step 4: Design a compatibility strategy outside the core code",
            " • For content-driven systems (like StackStorm packs), manage backward compatibility in content versions rather than core product code.\n • Ensure older platform versions continue using content (packs/rules) that depend on the old APIs, while newer platform versions point to updated content that uses the new APIs.",
            "Step 5: Remove the obsolete code and definitions",
            " • Delete the action metadata/registration file (e.g., `info.yaml`) so the action is no longer exposed.\n • Delete the corresponding implementation file(s) (e.g., `pack_mgmt/info.py`) and any associated imports or references.\n • Run tests and linters to ensure nothing else references the removed code.",
            "Step 6: Update documentation and changelog",
            " • Add a clear changelog entry describing what was removed, why, and what should be used instead.\n • Update any docs, examples, or blog posts to point users to the new mechanism (`pack get` in this case).\n • If appropriate, include migration notes or scripts to help users adjust.",
            "Step 7: Audit external usages and ecosystem content",
            " • Search external repositories (e.g., community packs, extension marketplace/Exchange) for references to the removed action or API.\n • Update or deprecate those references, releasing new versions that target the new interface.\n • If some users must remain on older versions, maintain old content branches for them instead of keeping old code in the mainline.",
            "Step 8: Communicate in release cycles",
            " • Ensure the removal is clearly called out in release notes and possibly blog posts if the feature was widely used.\n • Provide guidance: \"Use X instead of Y\" and briefly explain the architectural change so users understand the rationale.",
            "Step 9: Monitor after release",
            " • After release, watch for error reports or confusion related to the removed feature.\n • If necessary, add more documentation or transition tips, or provide a temporary compatibility shim only if the impact is higher than anticipated."
        ]
    }
}
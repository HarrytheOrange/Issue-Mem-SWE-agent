{
    "search_index": {
        "description_for_embedding": "Updated the VSCode dev container for Home Assistant to use the same Alpine-based `homeassistant/home-assistant:latest` image as production instead of the Debian-based `python:3.7` image, installing required tools via `apk`, adding a non-root `vscode` user, and adjusting Python dependency installation so local development matches the production runtime.",
        "keywords": [
            "VSCode dev container",
            "Dockerfile.dev",
            "homeassistant/home-assistant:latest",
            "Alpine",
            "Debian",
            "python:3.7",
            "apk",
            "apt-get",
            "development environment parity",
            "non-root user",
            "build-base",
            "pip install",
            "Home Assistant"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the project’s VSCode dev container configuration was updated to better mirror the production environment of Home Assistant. Previously, `.devcontainer/devcontainer.json` pointed at `Dockerfile.dev`, which used `FROM python:3.7` (a Debian-based image). Production, however, runs on `homeassistant/home-assistant:latest`, which is Alpine-based and has a different system library set, package manager, and pre-built Python wheels.\n\nThis mismatch meant that developers worked and ran tests in a Debian/Python image while production used an Alpine Home Assistant image. That could lead to subtle discrepancies, especially around compiled dependencies, system libraries, and pre-built wheels.\n\nThe PR changes `Dockerfile.dev` to use `FROM homeassistant/home-assistant:latest`. Because the base image is now Alpine, it replaces the previous `apt-get` usage with `apk` to install tools and libraries. It adds packages like `git`, `bash`, `openssh-client`, `curl`, `wget`, `unzip`, `less`, `procps`, `coreutils`, `ca-certificates`, and some low-level libs. A non-root `vscode` user is created with configurable UID/GID via build args, added to sudoers with passwordless sudo, and set as the default user at the end of the Dockerfile. The image installs `build-base` before running `pip3 install -r requirements_test.txt -c package_constraints.txt` so that Python packages that need compilation can build correctly on Alpine.\n\nInitially, `.devcontainer/devcontainer.json` was updated to pass `\"--net\", \"host\"` in `runArgs` to give the container host networking alongside `-e GIT_EDITOR=code --wait`. In the follow-up patch, `--net host` was removed, returning `runArgs` to only `[\"-e\", \"GIT_EDITOR=code --wait\"]`, likely to avoid unnecessary host networking configuration or portability issues. The `appPort` remains 8123 for Home Assistant.\n\nIn discussion, maintainers note that while this setup uses the production base image and leverages pre-built wheels, there were known issues with the VSCode Python language server/extensions crashing under this Alpine environment. An upstream issue was filed for the language server; the PR itself focuses on environment parity rather than solving the language server problem directly.",
        "semantic_memory": "Generalizable lessons from this change:\n\n1. **Development environment should mirror production**: Using a dev container based on a generic language image (e.g., `python:3.7` on Debian) when production uses a more specialized or different base (e.g., an Alpine-based application image) can create environment drift. This drift may surface as differences in dependency resolution, compiled binary behavior, or runtime bugs that only occur in one environment. Aligning the dev container base image with production reduces these discrepancies and makes local tests more representative.\n\n2. **Base image changes require toolchain and package-manager adjustments**: Switching from Debian to Alpine means moving from `apt-get` to `apk`, and from `build-essential` to `build-base`, plus adapting library names and available packages. Any scripts or Dockerfile steps that assume a specific distro must be updated. This pattern recurs whenever changing from one distro family to another (e.g., Debian to Alpine, Ubuntu to Fedora).\n\n3. **Non-root dev users improve safety and editor integration**: For editor-based remote development (e.g., VSCode Remote Containers), creating a dedicated non-root user (here `vscode`) with a stable UID/GID that matches the host or defaults (e.g., 1000) avoids permission issues on bind-mounted volumes and aligns with best practices for not running as root. Adding sudo access enables developer tooling that expects privilege elevation while keeping the default user non-root.\n\n4. **Python on Alpine often needs explicit build tool installation**: Many Python packages provide wheels only for glibc-based distros; on musl-based Alpine, they may fall back to source builds. Installing `build-base` and other dev headers is a recurring requirement to ensure `pip` installations succeed. Without these, builds will fail with compiler or header-not-found errors.\n\n5. **Editor tooling may lag in supporting non-standard environments**: VSCode Python extensions and language servers sometimes assume glibc-based systems or certain distro layouts. Running them in Alpine or heavily customized images can expose crashes or unsupported paths. It’s important to consider tool compatibility when choosing a base image and to track upstream issues for language servers and extensions.\n\n6. **Avoid unnecessary container host networking flags**: Using `--net host` grants the container direct access to the host network, which can complicate debugging, reduce portability, and introduce security concerns. If simple port mappings suffice, it is cleaner to omit host networking. This PR demonstrates reverting such a change when it turned out not to be required.\n\nThese concepts extend beyond this project to any Docker-based dev workflow: strive for environment parity, understand distro-specific tooling, use non-root users for dev containers, and be mindful of the interaction between editor tooling and the base image choice.",
        "procedural_memory": [
            "To diagnose and fix a mismatch between a dev container and production environment:",
            "Step 1: Identify the production base image and runtime environment. Determine the exact container image and OS/distro used in production (e.g., `homeassistant/home-assistant:latest` on Alpine).",
            "Step 2: Compare the dev container base image with production. Check your `Dockerfile.dev` or devcontainer Dockerfile for differences (e.g., `python:3.7` Debian vs a custom Alpine-based image). Document system-level differences (package manager, libc, pre-installed tools, etc.).",
            "Step 3: Decide whether to align the dev container base with production. If reproducibility and parity are important (tests, compiled wheels, OS-level behavior), plan to base the dev container on the same image as production.",
            "Step 4: Update the Dockerfile base image. Change the `FROM` line to the production image (e.g., `FROM homeassistant/home-assistant:latest`). Make sure this image is suitable for interactive and tooling-heavy use (or consider extending it).",
            "Step 5: Adjust system package installation to match the new distro. If moving from Debian/Ubuntu to Alpine, replace `apt-get` commands with `apk` equivalents and update package names. For Debian → Alpine, `apt-get update && apt-get install -y ...` becomes `apk update && apk add --no-cache ...`, and `build-essential` is replaced by `build-base`.",
            "Step 6: Ensure needed dev tools and shells are present. Install tools required by developers and VSCode Remote Containers: `git`, `openssh-client`, `bash`, `curl`, `wget`, `unzip`, `less`, and any system libraries required by Python dependencies (e.g., libssl, zlib).",
            "Step 7: Create a non-root user for editor integrations. Add build args for UID/GID (e.g., `ARG USERNAME=vscode`, `ARG USER_UID=1000`, `ARG USER_GID=1000`). Create the group and user with those IDs, set a home directory, and optionally add the user to sudoers with passwordless sudo if necessary for development.",
            "Step 8: Install Python build tooling before dependencies. For Alpine-based images, add `apk add --no-cache build-base` (and any headers) before running `pip install`. Then install test/dev requirements using your constraints file to mirror production (e.g., `pip3 install -r requirements_test.txt -c package_constraints.txt`).",
            "Step 9: Set the default user and shell. Use `USER <non-root-user>` at the end of the Dockerfile and set `ENV SHELL /bin/bash` (or to your preferred shell) so interactive shells and tooling use the expected environment.",
            "Step 10: Review and adjust devcontainer.json. In `.devcontainer/devcontainer.json`, ensure the `dockerFile` points to the updated Dockerfile. Configure `postCreateCommand` to install your package in editable mode (e.g., `pip3 install -e .`). Set `appPort` to the service port and set `runArgs` only to what is required (e.g., `-e GIT_EDITOR=code --wait`), avoiding `--net host` unless absolutely necessary.",
            "Step 11: Rebuild and test the dev container. Rebuild the VSCode dev container or run `docker build` manually. Open the project in VSCode Remote Containers, verify that dependencies install successfully, tests run, and the application starts on the expected port.",
            "Step 12: Verify editor tooling behavior. Confirm that Python extensions, language servers, and debugging tools work inside the new base image. If they crash (often on Alpine), check their logs, review known issues for Alpine compatibility, and consider filing or following upstream issues.",
            "Step 13: Iterate on missing dependencies or permissions. If developers hit permission issues (e.g., with mounted volumes), adjust the user UID/GID to match host or refine sudo permissions. If Python packages fail to build, install additional system headers or libraries.",
            "Step 14: Document the environment and rationale. Update project documentation to explain that the dev container is aligned with production, outline any prerequisites, and note any known limitations (e.g., partial support for certain language servers on Alpine)."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Enhancement to Home Assistant's Broadlink switch send_packet service to support repeated sending of IR/RF packets with configurable repeat count and delay between sends, using a validated service schema and async delay handling.",
        "keywords": [
            "Home Assistant",
            "Broadlink",
            "switch.broadlink",
            "send_packet",
            "IR packet repeat",
            "delay between packets",
            "voluptuous schema",
            "cv.positive_int",
            "cv.small_float",
            "asyncio.sleep",
            "retry logic",
            "base64 padding",
            "service registration"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Broadlink switch integration in Home Assistant was enhanced to support sending IR/RF packets multiple times with a configurable delay between each send. Previously, the Broadlink `send_packet` service accepted only a `packet` list and sent each packet exactly once. This was limiting for use cases like controlling TV volume with a slider, where a single packet must be repeated several times to simulate holding a remote button.\n\nTo address this, the contributor introduced a dedicated `SEND_PACKET_SCHEMA` using Voluptuous validation, which now requires `packet` and adds optional `repeat` and `delay` parameters with defaults:\n- `packet`: list of base64-encoded packets (existing behavior)\n- `repeat`: positive integer, default 1, how many times to send the packet(s)\n- `delay`: small float, default 0, delay in seconds between repeated sends\n\nThe `_send_packet` handler was updated to:\n1. Read `packet`, `repeat`, and `delay` from `call.data` (with defaults supplied by the schema).\n2. Loop `repeat` times (`for _ in range(0, repeat)`), and within each iteration, loop through each packet.\n3. For each packet, perform up to `DEFAULT_RETRY` retries:\n   - Ensure proper base64 padding on the packet string.\n   - Decode the packet with `b64decode`.\n   - Schedule `broadlink_device.send_data(payload)` via `hass.async_add_job`.\n   - Yield `asyncio.sleep(delay)` between iterations to avoid blocking the event loop.\n   - On decoding or timeout errors, try re-authenticating the Broadlink device; on repeated failures, log an error.\n\nThe service registration was changed from an inline schema that only required `packet` to registering with the new `SEND_PACKET_SCHEMA`, thereby making `repeat` and `delay` officially part of the service API. The contributor also iteratively cleaned up the code to match Home Assistant style: using defaults in the schema instead of manual defaulting, removing redundant zero-repeat checks (because `cv.positive_int` forbids zero), making loop variables unused (`_`), and adjusting formatting and docstring spacing.\n\nAlthough the PR eventually went stale and was closed due to CLA not being signed, it represents a concrete enhancement pattern: adding configurable repetition and delay parameters to an existing Home Assistant service while preserving async behavior and robust retry logic.",
        "semantic_memory": "This change illustrates several generalizable patterns for extending async service handlers, especially in Home Assistant or similar frameworks:\n\n1. **Extending service APIs via schema changes**: When you need to add new parameters (like `repeat` and `delay`) to an existing service, define or extend a shared validation schema (e.g., a `vol.Schema`). This keeps parameter definitions, default values, and validation centralized, and ensures that callers receive clear error messages when they supply invalid data.\n\n2. **Using default values in the schema instead of ad hoc defaults**: Instead of manually defaulting values with `call.data.get('param', default)`, set defaults in the schema (`vol.Optional('repeat', default=1)`). At call time you can safely read `call.data['repeat']` or `call.data.get('repeat')` knowing it exists and has been validated. This reduces duplication, keeps behavior consistent, and eliminates redundant logic like checking for zero when a positive-int validator already forbids it.\n\n3. **Non-blocking repetition with delays in async code**: To repeat an operation `N` times with a delay in an async environment, use a loop plus `asyncio.sleep(delay)` instead of time.sleep. Wrapping I/O in `hass.async_add_job` (or equivalent) ensures that device I/O runs off the main event loop, while `asyncio.sleep` yields control so other tasks can run. This pattern scales well for multiple concurrent service calls.\n\n4. **Robust network interaction with retry and re-auth**: When sending data to a network device, transient errors (socket timeouts, decoding issues) are common. The code uses a retry loop with a bounded number of attempts (`for retry in range(DEFAULT_RETRY)`) and tries to re-authenticate on failures. Only after all retries does it log an error. This pattern—retry, attempt recovery (auth), then log or fail—is a good general strategy for device integrations.\n\n5. **Defensive handling of base64 payloads**: The Broadlink packets are base64-encoded strings that may arrive without proper padding. Dynamically adding the required '=' padding based on `len(packet) % 4` before decoding ensures more robust handling of these payloads and avoids unnecessary exceptions.\n\n6. **Service usability for continuous actions**: Many hardware actions (like holding a volume-up button) are modeled as repeated discrete commands. Adding `repeat` and `delay` parameters to a single service call is a clean, reusable way to represent \"press and hold\" or \"multi-press\" behavior, and can be generalized to other devices (lights, blinds, etc.). This leads to more expressive automations while keeping the service interface compact.\n\nOverall, the PR encapsulates best practices for: evolving a service API without breaking existing users, validating and defaulting configuration via a schema, writing non-blocking asynchronous loops with delays, and implementing resilient network interactions with retries and proper logging.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the limitation or requirement\n- Observe the current behavior of your service or command handler (e.g., it sends a packet only once with no timing control).\n- Collect user needs or use cases (e.g., \"I need to send the same IR packet multiple times with a small delay to simulate holding the TV volume button\").\n- Decide what additional parameters you need (e.g., `repeat`, `delay`).",
            "Step 2: Design the extended service interface\n- Decide on parameter names and types (`repeat` as an integer, `delay` as a float representing seconds).\n- Determine safe defaults (e.g., `repeat=1`, `delay=0`) that preserve existing behavior when the new parameters are not specified.\n- If using a schema/validation system (e.g., Voluptuous in Home Assistant), update or create a schema object that describes the new service payload.",
            "Step 3: Update the validation schema\n- Define a schema that includes both existing and new parameters, for example:\n  - `vol.Required('packet'): cv.ensure_list`\n  - `vol.Optional('repeat', default=1): cv.positive_int`\n  - `vol.Optional('delay', default=0): cv.small_float`\n- Use validators that enforce valid ranges (e.g., `cv.positive_int` to disallow zero or negative repetitions).\n- Replace any inline or ad hoc schemas in the service registration code with this reusable schema.",
            "Step 4: Wire the schema into service registration\n- Find where the service is registered (e.g., `hass.services.register`).\n- Change the registration to use the new schema, e.g.: `hass.services.register(..., schema=SEND_PACKET_SCHEMA)`.\n- This ensures that all incoming service calls are validated and get defaulted before reaching your handler.",
            "Step 5: Implement the repeat and delay logic in the handler\n- In the service handler (e.g., `_send_packet(call)`), read the validated parameters from `call.data`:\n  - `packets = call.data.get('packet', [])`\n  - `repeat = call.data.get('repeat')`  (defaults already applied by schema)\n  - `delay = call.data.get('delay')`\n- Implement a nested loop structure:\n  - Loop `repeat` times (`for _ in range(0, repeat):`).\n  - Inside, iterate over each packet in `packets`.\n  - For each packet, perform the send operation, including any necessary preprocessing (e.g., base64 padding and decoding).",
            "Step 6: Preserve async behavior and avoid blocking\n- If the handler is or will be async, avoid `time.sleep`; instead use `yield from asyncio.sleep(delay)` or `await asyncio.sleep(delay)`.\n- Offload blocking or I/O-bound operations (like device communication) using the framework's async helpers (e.g., `yield from hass.async_add_job(broadlink_device.send_data, payload)`).\n- Ensure that the delay is placed in the appropriate location—typically after each send, within the repeat loop—so the timing semantics match user expectations.",
            "Step 7: Maintain and/or improve retry and error handling\n- Keep or introduce a bounded retry loop around your network calls: `for retry in range(DEFAULT_RETRY):`.\n- Catch common transient errors (e.g., `socket.timeout`, `ValueError`) and perform recovery steps such as re-authentication.\n- Only after all retries fail should you log an error (e.g., `_LOGGER.error(\"Failed to send packet to device\")`).\n- Avoid swallowing exceptions silently; always log enough detail for later diagnosis.",
            "Step 8: Handle data encoding/decoding robustly\n- For payloads like base64 strings, ensure they are in a valid form before decoding. For example:\n  - Compute `extra = len(packet) % 4` and, if `extra > 0`, pad the packet: `packet += '=' * (4 - extra)`.\n  - Then decode with `b64decode(packet)`.\n- This prevents unnecessary decoding errors caused by missing padding or malformed input.",
            "Step 9: Clean up for style and maintainability\n- Remove redundant logic that is already enforced by the schema (e.g., explicit `if repeat == 0: return` if the validator disallows zero).\n- Use conventional variable names and patterns, such as `_` for unused loop counters.\n- Ensure docstrings, imports, and spacing match the project's style guidelines.\n- Keep all service-related constants (schemas, defaults) near the top of the module for discoverability.",
            "Step 10: Test and document the new behavior\n- Add or update tests to cover:\n  - Default behavior (no `repeat`/`delay` provided → one send, no delay).\n  - Non-default values (e.g., `repeat=5`, `delay=0.2`) and confirm that the right number of calls and delays occur.\n  - Error paths: invalid payloads, timeouts, and retry behavior.\n- Update user-facing documentation or examples to show how to use the new parameters (e.g., a script that sends a TV volume-up command `repeat: 5` with `delay: 0.2`).\n\nFollowing these steps helps you safely extend existing async service handlers with new parameters like repeat counts and delays, keep behavior robust against network errors, and maintain consistency with the surrounding framework."
        ]
    }
}
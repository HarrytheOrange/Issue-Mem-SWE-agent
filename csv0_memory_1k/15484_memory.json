{
    "search_index": {
        "description_for_embedding": "Fix for Home Assistant light component where unsupported light properties were accessed unconditionally, causing errors for devices that do not implement all features. The fix makes the state attribute construction conditional on supported_features, filters out None values, and corrects MQTT light supported_features detection (effect support based on effect_command_topic). Tests updated to explicitly set supported_features and MQTT topics.",
        "keywords": [
            "Home Assistant",
            "light component",
            "supported_features",
            "unsupported properties",
            "state_attributes",
            "SUPPORT_COLOR",
            "SUPPORT_BRIGHTNESS",
            "SUPPORT_EFFECT",
            "MQTT light",
            "effect_command_topic",
            "attribute access error",
            "device capabilities",
            "integration tests"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant light component assumed all light attributes (brightness, color temperature, color, white value, effects) were safe to access whenever a light was on. The code iterated over a static PROP_TO_ATTR mapping and unconditionally called properties like self.brightness, self.color_temp, self.hs_color, etc., regardless of whether the underlying platform/device actually supported those features. Some light platforms implement multiple products with differing capabilities, and certain properties might not exist or be valid for a given device. This could lead to runtime errors or incorrect behavior when unsupported properties were accessed.\n\nThe fix refactored LightEntity.state_attributes to honor supported_features and only access properties that are actually supported by the device:\n- It cached supported_features in a local variable and gated attribute population on the corresponding SUPPORT_* flags.\n- For brightness, color_temp, white_value, and effect/effect_list, the code now checks SUPPORT_BRIGHTNESS, SUPPORT_COLOR_TEMP, SUPPORT_WHITE_VALUE, and SUPPORT_EFFECT, respectively, before reading the properties.\n- For color, it checks SUPPORT_COLOR and that hs_color is truthy before using it. It then rounds the HS values, and derives RGB and XY only from this verified hs_color.\n- At the end, it returns a dictionary filtered to exclude any keys whose values are None.\n\nAdditionally, the MQTT light implementation incorrectly determined effect support based on the presence of effect_state_topic instead of effect_command_topic. This meant supported_features could be wrong for MQTT lights, causing mismatches between reported capabilities and actual command topics. The fix changed this to use CONF_EFFECT_COMMAND_TOPIC when setting the SUPPORT_EFFECT bit.\n\nTests were updated to align with the new behavior:\n- Group light tests now set supported_features on member lights so that effect and effect_list attributes are exposed and aggregated correctly.\n- MQTT and MQTT template tests now specify the appropriate command topics (brightness, RGB, color temperature, effect, white value, xy) and effect_list so that supported_features reflect the full set of capabilities, and effect behavior remains correct under the new gating logic.",
        "semantic_memory": "When designing device/entity abstractions that support a superset of features, it is crucial to respect the device's advertised capabilities (e.g., supported_features) when accessing properties and constructing state. Accessing optional attributes unconditionally can break platforms that legitimately do not implement those features.\n\nA robust pattern is:\n- Use feature flags (bitmasks or capability descriptors) to determine which properties may be safely read or written.\n- Condition attribute access and state representation on those flags so that unsupported properties are never accessed.\n- Filter out None or invalid values from state payloads to avoid exposing meaningless data to consumers.\n\nFor communication-based integrations (e.g., MQTT), supported_features should be derived from the configuration topics or capabilities that actually allow control (command topics), not merely from state topics. Otherwise, you might mark a feature as supported when you can observe it but not control it, or vice versa.\n\nTests must be aligned with this capability-driven model: fixtures need to declare supported_features consistent with the attributes they use, and configuration for protocol-based integrations must declare the topics/features required for the expected state and commands. This ensures that refactors which enforce capability checks do not silently break tests or integrations.\n\nMore generally, when a core framework aggregates state (e.g., groups) or computes derived attributes (like color conversions), it should only operate on data that the underlying entities explicitly claim to support, to prevent unexpected errors across a heterogeneous ecosystem of devices.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom. Look for runtime errors, log traces, or inconsistent behavior where a platform/entity is accessing attributes that some devices do not implement (e.g., AttributeError or property access failures on brightness, color_temp, etc.). Also check if certain attributes appear unexpectedly missing or cause errors only for some device models.",
            "Step 2: Locate where generic state/attribute construction happens. In frameworks like Home Assistant, this is typically in a base entity/component (e.g., LightEntity.state_attributes) or a shared helper that builds the state dict for all platforms.",
            "Step 3: Check for unconditional attribute access. Look for loops or mappings (like PROP_TO_ATTR) that blindly call getattr(self, 'brightness') or similar properties without first checking device capabilities or supported_features.",
            "Step 4: Identify capability flags or descriptors. Most frameworks provide a mechanism (e.g., supported_features bitmask, capabilities dict) indicating what features a device supports. Find where those are defined (constants like SUPPORT_COLOR, SUPPORT_BRIGHTNESS, SUPPORT_EFFECT, etc.) and how they are used.",
            "Step 5: Gate attribute access on capabilities. Refactor the state construction logic so that each optional property is only read if its corresponding capability is set. For example:\n- If supported_features & SUPPORT_BRIGHTNESS: read and include brightness.\n- If supported_features & SUPPORT_COLOR_TEMP: read and include color_temp, min/max mireds.\n- If supported_features & SUPPORT_COLOR: safely read hs_color, then derive RGB/XY.\n- If supported_features & SUPPORT_EFFECT: include effect and effect_list.",
            "Step 6: Filter out None values. Even when a feature is supported, the current value may be None. After building the state dict, remove keys whose values are None to avoid misleading consumers and simplify downstream logic.",
            "Step 7: Validate integration-specific capability detection. For integrations like MQTT, verify that supported_features is derived from the actual control capabilities (e.g., presence of specific command topics), not just state topics. Adjust logic so that a feature is marked supported only when you can control it (e.g., use effect_command_topic to set SUPPORT_EFFECT).",
            "Step 8: Update and extend tests. Ensure tests set supported_features consistently with the attributes they expect. For protocol-based tests, include all relevant command topics and effect_list entries so supported_features bits are set correctly. Update group/aggregate tests to match the new behavior where attributes are present only if members support them.",
            "Step 9: Run the test suite and regression checks. Execute all relevant tests (unit, integration) to confirm no regressions. Pay special attention to heterogeneous device setups and group entities, which are more likely to surface capability-related issues.",
            "Step 10: Document assumptions and patterns. In developer docs or comments, note that platforms must declare supported_features accurately and that core code will only access attributes guarded by these flags. This helps future maintainers avoid reintroducing unconditional property accesses."
        ]
    }
}
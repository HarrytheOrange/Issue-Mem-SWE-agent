{
    "search_index": {
        "description_for_embedding": "Home Assistant SolarEdge integration migrated from YAML monitored_conditions to config entries with a new config flow. Adds async-safe API validation, imports legacy YAML config into config entries, removes monitored_conditions from configuration.yaml, centralizes constants, and improves test coverage while excluding untested __init__.py from coverage.",
        "keywords": [
            "SolarEdge",
            "homeassistant.components.solaredge",
            "config_flow",
            "config entries",
            "YAML import",
            "monitored_conditions removal",
            "integration migration",
            "async_add_executor_job",
            "HTTPError",
            "ConnectTimeout",
            "SCAN_INTERVAL",
            "SENSOR_TYPES",
            "coverage omit",
            "breaking change"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set, the Home Assistant SolarEdge integration was updated to support configuration via the UI using config entries and a config flow, deprecating the old YAML-based configuration with monitored_conditions.\n\nPreviously, SolarEdge sensors were configured exclusively in configuration.yaml using a PLATFORM_SCHEMA that required api_key and site_id and optionally a name and monitored_conditions. The sensors module contained constants like SCAN_INTERVAL and SENSOR_TYPES, and a synchronous setup_platform function directly instantiated the solaredge client and accessed the API. This design had several issues: it did not support the new config entries mechanism, used the soon-to-be-removed monitored_conditions pattern, and performed blocking I/O directly in the event loop.\n\nThe PR introduced:\n\n1. A new const.py for the solaredge integration defining DOMAIN, CONF_SITE_ID, DEFAULT_NAME, update intervals, and SENSOR_TYPES (now including a default flag in each sensor definition).\n2. A new config_flow.py implementing SolarEdgeConfigFlow. It:\n   - Ensures uniqueness of site_id values across config entries via solaredge_entries and _site_in_configuration_exists.\n   - Validates connectivity and site status using a helper _check_site that calls solaredge.Solaredge(api_key).get_details(site_id).\n   - Maps different failure modes to specific user-facing errors: `site_not_active` if the site status is not 'active', `api_failure` on KeyError when parsing response, and `could_not_connect` for HTTPError or ConnectTimeout.\n   - Performs API validation in an executor (async_add_executor_job) so as not to block the event loop.\n   - Implements async_step_user (interactive UI setup) and async_step_import (for YAML import), slugifying the name for the entry title and aborting if a site_id is already configured.\n\n3. A component-level __init__.py for solaredge:\n   - Adds CONFIG_SCHEMA at the component level instead of in the sensor platform, with DOMAIN: {name, api_key, site_id}.\n   - async_setup now checks if DOMAIN is in the config; if so, it initializes a config entry flow with SOURCE_IMPORT and the config[DOMAIN] data. This bridges legacy YAML config into the new config entry system.\n   - async_setup_entry forwards the config entry to the 'sensor' platform using async_forward_entry_setup.\n\n4. The sensor platform (sensor.py) was refactored:\n   - Removed PLATFORM_SCHEMA and any direct configuration parsing from the sensor platform.\n   - async_setup_platform now simply returns/does nothing and exists only for backward compatibility (old configurations).\n   - async_setup_entry is now the main entrypoint, taking the config entry, building a solaredge.Solaredge client with CONF_API_KEY, and validating site details with get_details executed via hass.async_add_executor_job.\n   - It verifies that the site status is 'active' and logs errors when the API is unreachable or returns errors.\n   - It uses SolarEdgeSensorFactory with entry.title and entry.data[CONF_SITE_ID], creating one sensor per type listed in SENSOR_TYPES (no longer restricted by monitored_conditions from YAML).\n\n5. Removal of monitored_conditions:\n   - CONF_MONITORED_CONDITIONS was removed from the schema; configuration.yaml can no longer define monitored conditions – this is an intentional breaking change in line with Home Assistant’s deprecation of monitor conditions.\n\n6. Translations and strings:\n   - Added .translations/en.json and strings.json for the config flow (title, fields, and errors), then later removed the unused options flow strings when options flow was not implemented.\n\n7. Testing and infrastructure:\n   - Added solaredge to generated config_flows.py and requirements (script.gen_requirements_all and requirements_test_all.txt) so tests can import the solaredge library.\n   - Added tests/components/solaredge/test_config_flow.py, including:\n     * test_user: asserts a successful user-driven configuration flow, including title slugification.\n     * test_import: asserts correct behavior when importing config from YAML, with and without a custom name.\n     * test_abort_if_already_setup: ensures that a duplicate site_id in either import or user steps is rejected with 'site_exists'.\n     * test_asserts: validates error handling paths in _check_site for inactive sites, malformed API responses, and connection/HTTP errors (mapping to the correct error codes).\n   - The tests use a fixture that mocks solaredge.Solaredge to control the responses and exceptions of get_details.\n   - __init__.py and sensor.py were added to the coverage omit list, with __init__.py explicitly added in this PR, acknowledging that these are thin wrappers around framework wiring that are impractical to unit test directly.\n\nOverall, this PR completed the migration of the SolarEdge integration to Home Assistant’s config entry and config flow architecture, removed deprecated monitored_conditions YAML configuration, made network calls async-safe, and improved error handling and test coverage.",
        "semantic_memory": "This work embodies several generalizable patterns and best practices for modern Home Assistant integrations and, more broadly, event-loop-based applications:\n\n1. Migrating from static configuration to dynamic config entries:\n   - For integrations originally configured via static YAML and platform-level schemas, the modern pattern is to move configuration to the component (__init__.py) and support config entries through a config_flow. The component-level async_setup function is responsible for detecting legacy YAML configuration and initiating an import into the config entry system using SOURCE_IMPORT. After that, the platform-level setup functions (e.g., async_setup_platform) become no-ops or thin compatibility shims, and async_setup_entry becomes the canonical entry point.\n\n2. Deprecating monitored_conditions / selector-style configuration:\n   - Home Assistant deprecated monitored_conditions as a way to select which sensors to expose. This PR demonstrates how to remove monitored_conditions from configuration.yaml and instead treat the integration’s sensor set as defined by constants (e.g., SENSOR_TYPES) and/or future options flows. This simplifies configuration and aligns with architectural guidelines.\n\n3. Centralizing integration constants:\n   - Moving domain-specific constants (DOMAIN, CONF_SITE_ID, DEFAULT_NAME, update intervals, and sensor metadata) into a dedicated const.py improves maintainability, avoids duplication across modules (sensor, config_flow, __init__), and makes it easier to share configuration across the integration.\n\n4. Async-safe I/O in event-driven frameworks:\n   - Blocking network calls like solaredge.Solaredge(api_key).get_details(site_id) must not run directly in async contexts. Instead, they should be executed via hass.async_add_executor_job or equivalent mechanisms, keeping the event loop responsive. This pattern was consistently applied both in the config_flow (validation) and in async_setup_entry (initial data validation).\n\n5. Robust error handling and user feedback in config flows:\n   - Config flows should translate low-level exceptions (ConnectTimeout, HTTPError) and semantic validation failures (inactive site, malformed response) into clear, user-facing error codes. This allows forms to present actionable feedback rather than generic failures.\n   - The pattern here uses a helper function (_check_site) that encapsulates calling the external API, interpreting its response, and setting specific error codes on the flow instance (e.g., site_not_active, api_failure, could_not_connect), while returning a simple boolean for the flow logic.\n\n6. Enforcing uniqueness of configuration entries:\n   - When an integration can be configured multiple times (e.g., multiple SolarEdge sites), an explicit uniqueness constraint is needed (here, on CONF_SITE_ID). The pattern uses a helper (solaredge_entries) that enumerates existing config entries for the DOMAIN and a _site_in_configuration_exists helper to enforce uniqueness in both user and import flows, aborting or returning form errors as appropriate.\n\n7. Testing config flows and edge cases:\n   - Effective testing of config flows involves:\n     * Instantiating the flow class directly and injecting a hass instance.\n     * Using unittest.mock.patch to replace external API clients (like solaredge.Solaredge) with mocks, controlling both successful responses and error conditions.\n     * Asserting on flow result types (FORM, CREATE_ENTRY, ABORT), step IDs, entry titles, entry data, and error messages.\n   - Comprehensive tests should cover happy paths, duplicate configuration, and each type of anticipated failure (e.g., inactive resources, bad data, network errors).\n\n8. Managing coverage expectations:\n   - For modules that are thin framework glue (__init__.py in a Home Assistant integration, often just wiring config entries to platforms), it is acceptable to exclude them from coverage if unit tests would bring little value relative to complexity. This is documented by adding the file to .coveragerc and focusing tests where behavior is more complex (config_flow, data-handling code).\n\nThese patterns are applicable to any integration or service migration where configuration is moving from static files to a dynamic, UI-driven system, especially in async/event-loop-based applications like Home Assistant, Node.js services, or asyncio-based Python apps.",
        "procedural_memory": [
            "Step-by-step guidelines for migrating a Home Assistant integration from YAML + monitored_conditions to config entries with a config flow and safe async I/O:",
            "Step 1: Centralize constants.",
            "- Create a const.py for the integration.",
            "- Define DOMAIN, any custom CONF_* keys (e.g., CONF_SITE_ID), DEFAULT_NAME, update intervals, and sensor metadata (SENSOR_TYPES).",
            "- Replace duplicated constants in sensor.py, config_flow.py, and __init__.py with imports from const.py.",
            "",
            "Step 2: Move configuration schema from the platform to the component.",
            "- If the integration currently has PLATFORM_SCHEMA in sensor.py (or other platforms), remove or simplify it.",
            "- In homeassistant/components/<domain>/__init__.py, define a CONFIG_SCHEMA for DOMAIN that describes the legacy YAML structure (e.g., name, api_key, site_id).",
            "- Use voluptuous (vol.Schema, vol.Required, vol.Optional) and cv.* helpers for validation.",
            "",
            "Step 3: Implement async_setup to import legacy YAML as a config entry.",
            "- In __init__.py, implement async_setup(hass, config):",
            "  - If DOMAIN not in config, just return True (nothing to import).",
            "  - Otherwise, schedule a config entry flow init:",
            "    hass.async_create_task(",
            "        hass.config_entries.flow.async_init(",
            "            DOMAIN, context={\"source\": SOURCE_IMPORT}, data=dict(config[DOMAIN])",
            "        )",
            "    )",
            "  - Return True.",
            "- This turns static YAML into a SOURCE_IMPORT config entry, enabling the UI config flow to handle it uniformly with user-created entries.",
            "",
            "Step 4: Add a config_flow implementing config entries.",
            "- Create config_flow.py and a ConfigFlow subclass:",
            "  - Set domain=DOMAIN, VERSION, and CONNECTION_CLASS appropriately.",
            "  - Implement a helper (e.g., solaredge_entries) to retrieve existing entries for the domain and a helper (e.g., _site_in_configuration_exists) to enforce uniqueness based on a key like site_id.",
            "  - Implement a validation helper (e.g., _check_site(site_id, api_key)) that:",
            "    * Instantiates the external API client.",
            "    * Calls an appropriate method (e.g., get_details).",
            "    * Interprets the response, checking semantic conditions like \"status\" == \"active\".",
            "    * Catches KeyError and assigns an api_failure error.",
            "    * Catches ConnectTimeout and HTTPError (or other network errors) and assigns a could_not_connect error.",
            "    * Returns True/False for success/failure.",
            "  - In async_step_user:",
            "    * Reset error state (self._errors = {}).",
            "    * If user_input is provided:",
            "      - Slugify the name (using slugify) or default to DEFAULT_NAME.",
            "      - Check for duplicate configuration via _site_in_configuration_exists; if duplicate, set an appropriate error (e.g., site_exists).",
            "      - Otherwise, schedule _check_site using await hass.async_add_executor_job(self._check_site, site, api).",
            "      - If validation passes, call async_create_entry with title=name and data={CONF_SITE_ID: site, CONF_API_KEY: api}.",
            "    * If user_input is None, prepare default form values and return async_show_form with a voluptuous Schema that prompts for name, site_id, and api_key.",
            "  - In async_step_import:",
            "    * If the site_id is already configured, return async_abort(reason=\"site_exists\").",
            "    * Otherwise, delegate to async_step_user, passing the imported config.",
            "",
            "Step 5: Wire the config entry to the platform in async_setup_entry.",
            "- In __init__.py, implement async_setup_entry(hass, entry):",
            "  - Use hass.async_create_task(hass.config_entries.async_forward_entry_setup(entry, \"sensor\")) (and other platforms if applicable).",
            "  - Return True.",
            "- This ensures that the sensor platform can initialize its entities based on the config entry data.",
            "",
            "Step 6: Refactor the platform (sensor.py) to use config entries and async-safe I/O.",
            "- Remove or deprecate old PLATFORM_SCHEMA and direct parsing of config; rely on the config entry instead.",
            "- Implement async_setup_platform(hass, config, async_add_entities, discovery_info=None) as a no-op or simple backward-compat shim (e.g., pass or return True) to avoid breaking existing references but prevent new YAML-based setups.",
            "- Implement async_setup_entry(hass, entry, async_add_entities):",
            "  - Create the external API client using entry.data[CONF_API_KEY].",
            "  - Validate connectivity and site status using get_details, wrapped in hass.async_add_executor_job to avoid blocking the event loop.",
            "  - If validation fails (inactive site, exceptions), log appropriate errors and return without adding entities.",
            "  - Instantiate any factories (like SolarEdgeSensorFactory) with entry.title and entry.data[CONF_SITE_ID], and create sensor entities for each entry in SENSOR_TYPES.",
            "  - Call async_add_entities(entities).",
            "",
            "Step 7: Remove deprecated monitored_conditions / selectors from YAML configuration.",
            "- Delete CONF_MONITORED_CONDITIONS and any monitored_conditions keys from platform schemas and code paths.",
            "- Ensure sensors are created based on SENSOR_TYPES or future options flow logic instead of YAML selectors.",
            "- Communicate this as a breaking change in issue/PR description and external documentation (e.g., home-assistant.io).",
            "",
            "Step 8: Add and adjust translation/strings for the config flow.",
            "- Add .translations/en.json and strings.json under the integration directory for config flow UI strings:",
            "  - Provide titles, field labels (name, site_id, api_key), and error messages (site_exists, site_not_active, api_failure, could_not_connect).",
            "- Remove or avoid strings for options flows unless you implement the options flow itself.",
            "",
            "Step 9: Update requirements and generated config_flows.",
            "- Ensure the integration's library is in manifest.json requirements and in requirements_test_all.txt for tests.",
            "- Run the generator scripts (e.g., python3 -m script.gen_requirements_all and python3 -m script.hassfest) to update generated files like homeassistant/generated/config_flows.py.",
            "",
            "Step 10: Write tests for the config flow, including error cases.",
            "- Create tests/components/<domain>/test_config_flow.py.",
            "- Use pytest and unittest.mock.patch to mock the external API client (e.g., patch(\"solaredge.Solaredge\", return_value=api_mock)).",
            "- Test scenarios:",
            "  - Happy path user flow: validate the form is shown, then a valid submission yields RESULT_TYPE_CREATE_ENTRY with correct title and data.",
            "  - Happy path import flow: import data with/without name yields entries with correct titles and data.",
            "  - Duplicate configuration: set up a MockConfigEntry with a given site_id, then ensure both import and user flows reject the same site_id with reason \"site_exists\".",
            "  - Error conditions: configure the mock to return inactive status, malformed responses, and raise ConnectTimeout or HTTPError, and assert that the flow returns FORM with the correct error codes for each case.",
            "",
            "Step 11: Manage coverage expectations.",
            "- If __init__.py (or similar glue code) is thin and mostly just forwards config entries, consider excluding it from coverage by adding it to .coveragerc's omit list.",
            "- Focus coverage on config_flow, data handling logic, and any complex entity behavior.",
            "",
            "Step 12: Verify and document the breaking change.",
            "- Run the full test suite (tox or equivalent) and fix any failures.",
            "- Clearly note in documentation and changelog that monitored_conditions in configuration.yaml are no longer supported, and that configuration should now be done via the UI (config entries).",
            "- Provide migration guidance where appropriate, explaining that existing YAML configuration will be imported as a config entry on startup."
        ]
    }
}
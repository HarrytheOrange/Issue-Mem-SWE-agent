{
    "search_index": {
        "description_for_embedding": "Fix for StackStorm runner/querier loader that repeatedly reloaded Python modules with imp.load_source, causing intermittent 'super(type, obj): obj must be an instance or subtype of type' errors at runtime. The solution introduces caching of runner and querier modules in global dictionaries so they are loaded once and reused, plus associated tests and minor cleanup in a Mistral querier.",
        "keywords": [
            "StackStorm",
            "runner loader",
            "query module loader",
            "imp.load_source",
            "module reload",
            "plugin loader caching",
            "super(type, obj) error",
            "Python class identity mismatch",
            "dynamic plugin loading",
            "st2common.util.loader",
            "RUNNER_MODULES",
            "QUERIER_MODULES",
            "mistral_v2 querier",
            "get_instance",
            "get_query_instance"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, StackStorm executions would occasionally fail with a Python super() error: 'super(type, obj): obj must be an instance or subtype of type'. This occurred for runners such as LocalShellRunner and PythonRunner when calling super(...).pre_run(). The failures were intermittent and often appeared on the first action execution after a period of inactivity, then disappeared on subsequent retries.\n\nInvestigation showed that runner and querier Python modules were being loaded dynamically on each use via imp.load_source in st2common.util.loader.register_runner and register_query_module. Each call reloaded the module, creating new class objects with the same names. Instances created earlier referenced the old class definitions, while super() resolved against the new class definitions, leading to a type mismatch where `obj` (self) was no longer an instance or subtype of the reloaded `type`.\n\nThe fix introduced global module caches: RUNNER_MODULES and QUERIER_MODULES in st2common.util.loader. The loader functions now check these dicts and only call imp.load_source the first time a module_name is requested. Subsequent calls return the cached module object instead of reloading it. Informational log messages were added to indicate whether a module is newly loaded or reused from cache.\n\nNew tests in st2common/tests/unit/test_util_loader.py mock imp.load_source to ensure it is called exactly once per module_name and that subsequent calls to register_runner/register_query_module return the same module object and do not trigger another load. Test fixtures under st2common/tests/fixtures/mock_runner provide minimal runner and querier implementations for this purpose.\n\nAdditionally, the Mistral v2 querier module had a duplicate factory function: both get_query_instance and get_instance returned a MistralResultsQuerier. The duplicate get_query_instance was removed, get_instance was kept as the canonical factory, and the tests were updated to import the module as mistral_querier and call get_instance().\n\nAfter these changes, runner and query modules are no longer repeatedly reloaded, eliminating the random super() type errors and stabilizing runner behavior across executions.",
        "semantic_memory": "This fix illustrates a common pitfall when dynamically loading Python modules for plugin systems: repeatedly reloading modules can break type identity and interfere with inheritance semantics.\n\nIn Python, each call to imp.load_source (or similar mechanisms like importlib.reload) creates a new module object and new class objects, even if the source code is identical. If the rest of the system holds onto instances or types from previous loads, you can end up with objects that are instances of an 'old' class, while other code refers to a 'new' class with the same name but a different identity. This breaks checks and mechanisms that depend on consistent type identity, such as isinstance, issubclass, and super(). The specific manifestation here was super(type, obj) raising because obj was not an instance/subtype of the newly loaded type.\n\nA robust pattern for plugin loaders is:\n- Load plugin modules only once per process and cache the resulting module objects keyed by module name or path.\n- Reuse the cached module objects across all uses during the lifetime of the process, unless you explicitly support hot-reloading and carefully manage the lifecycle of old instances.\n- Avoid mixing multiple versions of the same module's classes in the same process unless you isolate them (e.g., by separate processes or environments).\n\nThis case also highlights the importance of clear, single entry points for factory functions in plugins (e.g., a single get_instance function) to avoid confusion and inconsistent usage patterns.\n\nGeneralizable lessons:\n- Dynamic module reloading in long-running services is risky unless managed very carefully.\n- Type identity problems can surface as cryptic super() or isinstance/issubclass failures.\n- Caching dynamically loaded modules is often simpler and more reliable than supporting runtime reload in production.\n- Add logging around plugin/module loading paths to make it easier to see when modules are loaded vs reused.\n- Write unit tests that assert not just functional behavior, but also invariants like 'module is only loaded once' to protect against regressions.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Observe and capture the error pattern.\n- Look for intermittent type-related errors like `super(type, obj): obj must be an instance or subtype of type`, unexpected isinstance/issubclass failures, or behavior differences between first and subsequent runs.\n- Note whether errors occur after long idle periods, restarts, or configuration reloads.",
            "Step 2: Identify dynamic loading/reloading of modules.\n- Search the codebase for use of imp.load_source, importlib.reload, or custom plugin/module loaders.\n- Focus on loader utilities (e.g., util.loader, plugin managers) used for runners, plugins, or extensions.\n- Check whether these loaders are invoked on every use or only once at startup.",
            "Step 3: Check for repeated loads of the same module.\n- Instrument the loader with logging around module loading (e.g., log module path and whether it's loaded or reused).\n- In tests or a dev environment, add counters or mocks around imp.load_source/importlib to see how many times they are called for the same module.\n- Verify whether multiple module objects with the same name are being created in a single process.",
            "Step 4: Reason about class and instance identity.\n- Confirm whether instances created at one point in time use classes from an earlier load, while other code (e.g., super(), isinstance checks, base framework code) is referencing classes from a later load.\n- Use id() or direct equality checks on class objects to see if they differ between different module loads:\n  - e.g., `print(id(old_module.MyClass), id(new_module.MyClass))`.",
            "Step 5: Introduce a module cache in the loader.\n- Add global dictionaries keyed by module_name or module path (e.g., RUNNER_MODULES, QUERIER_MODULES).\n- In the loader function, before calling imp.load_source/importlib, check if the module is already in the cache:\n  - If not present: log that the module is being loaded, call load_source/importlib, store the module in the cache.\n  - If present: log that the cached module is being reused and return it without reloading.\n- Ensure that all code paths go through this loader instead of calling imp.load_source/importlib directly.",
            "Step 6: Add and update tests to lock in the behavior.\n- Write unit tests that:\n  - Mock imp.load_source/importlib and verify it is called only once per module_name even if the loader is called multiple times.\n  - Assert that repeated calls return the same module object.\n- If fixtures are needed, add minimal mock runner/querier implementations that exercise the loader.\n- Run the full test suite, including tests that use these runners/plugins.",
            "Step 7: Clean up and standardize module factory APIs.\n- Ensure each plugin/querier/runner module exposes a single, well-defined factory function (e.g., get_instance or get_runner).\n- Remove duplicate or deprecated factory functions (e.g., get_query_instance) to avoid inconsistent usage and confusion.\n- Update tests and callers to use the canonical factory function.",
            "Step 8: Deploy and monitor.\n- Deploy the change to a staging or test environment.\n- Observe logs for the new messages (e.g., 'Loading runner module...' vs 'Reusing runner module from cache.') to verify caching is working.\n- Re-run the scenarios that previously triggered the intermittent super() or type errors (e.g., first execution after idle, multiple sequential runs) and confirm the errors no longer occur.\n- Once stable, roll out to production and keep an eye on any new type-related errors.",
            "Step 9: If hot-reloading is required, design it explicitly.\n- If the product needs to support reloading plugins without process restart, design an explicit reload mechanism that:\n  - Safely discards or isolates old instances.\n  - Ensures new instances only use the latest module/classes.\n  - Avoids mixing old and new class identities in the same execution path.\n- Document the behavior and limitations clearly."
        ]
    }
}
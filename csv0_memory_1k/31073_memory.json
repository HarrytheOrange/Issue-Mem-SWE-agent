{
    "search_index": {
        "description_for_embedding": "Modbus entities in Home Assistant did not correctly report availability when Modbus communication failed. Reads and writes would raise exceptions (AttributeError, ConnectionException, ModbusException) that only produced logs, leaving entity states unchanged and spamming logs. The fix adds explicit availability tracking to Modbus binary_sensor, sensor, climate, and switch entities, wraps Modbus read/write calls in helpers that catch pymodbus exceptions, treat ExceptionResponse as failure, mark entities unavailable once, and restore availability on successful communication.",
        "keywords": [
            "Home Assistant",
            "modbus",
            "pymodbus",
            "binary_sensor",
            "sensor",
            "climate",
            "switch",
            "availability",
            "entity.available",
            "ConnectionException",
            "ModbusException",
            "ExceptionResponse",
            "error handling",
            "logging spam",
            "No response from hub",
            "read_coils",
            "read_discrete_inputs",
            "read_input_registers",
            "read_holding_registers",
            "write_coil",
            "write_register",
            "write_registers"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this pull request, the Modbus integration for Home Assistant had a usability issue: when Modbus communication failed, entities (binary_sensors, sensors, climates, and switches) did not change their state to unavailable. The code relied on AttributeError from pymodbus responses to log errors, but the entity state remained whatever it was previously, so the UI did not reflect connectivity loss. Additionally, write operations had no connectivity checks, so repeated failures spammed the logs.\n\nSpecifically, calls like read_coils, read_discrete_inputs, read_input_registers, and read_holding_registers assumed that a successful response object with bits or registers would be returned. On failure, pymodbus can raise ConnectionException or return specialized ModbusException/ExceptionResponse objects instead of the expected result, leading either to AttributeError when accessing .bits/.registers, or to unhandled errors and heavy logging. Writes (write_coil, write_register, write_registers) similarly lacked error handling and could continuously log failures without updating entity availability.\n\nThe fix introduces explicit availability tracking and robust error handling across all Modbus entity types:\n\n- Each entity class now has an _available flag and an available property exposing it to Home Assistant.\n- Read logic in BinarySensorModbus, SensorModbus, ModbusCoilSwitch, ModbusRegisterSwitch, and the ModbusClimate is wrapped in helper methods that:\n  - Call the appropriate pymodbus read function inside a try/except ConnectionException.\n  - Treat any result that is a ModbusException or ExceptionResponse as a failure.\n  - On failure, call a shared _set_unavailable() method that logs a single 'No response from hub ...' error and marks _available = False, but exits early if already unavailable to prevent log spam.\n  - On success, parse bits or registers as before, update the internal value/state, and set _available = True.\n- For writes:\n  - ModbusClimate uses _write_register() around write_registers.\n  - ModbusCoilSwitch uses _write_coil() around write_coil.\n  - ModbusRegisterSwitch uses _write_register() around write_register (only for holding registers), and respects the verify_state flag.\n  - These write helpers catch ConnectionException and call _set_unavailable() instead of letting errors bubble and log repeatedly.\n\nThe result is that when the Modbus server or TCP gateway goes down, entities become unavailable in the UI, the error is logged once per entity on transition to unavailable, and normal operation resumes (availability flips back to True) once communication succeeds again. Log growth due to entity-level errors is significantly reduced, and the user can now build automations based on Modbus availability.",
        "semantic_memory": "This change illustrates several generalizable best practices for hardware/integration error handling and availability reporting in a home automation/system-integration context:\n\n1. **Explicit availability state for external integrations**\n   When an entity depends on an external device or service (e.g., Modbus devices), it should explicitly track and expose an availability flag. The system UI and automations can then respond to connectivity loss (e.g., show the sensor as unavailable, trigger recovery automations) rather than silently showing stale values.\n\n2. **Centralized error handling around I/O operations**\n   All I/O to external systems should be wrapped in small helper methods (e.g., _read_register, _write_register, _read_coil, _write_coil) that:\n   - Catch library-specific connection errors (e.g., pymodbus.ConnectionException).\n   - Detect error return objects (e.g., ModbusException, ExceptionResponse) and treat them as failures instead of trying to parse them as successful responses.\n   - Normalize the error handling behavior: mark the entity unavailable, log a concise error message, and prevent further noisy exceptions.\n\n3. **Avoid using incidental exceptions for flow control**\n   Originally, the code relied on AttributeError from trying to access .bits or .registers on a failed result. This pattern is fragile and obscures the real error modes. Instead, handle the documented error types explicitly (ConnectionException or explicit error response objects) and avoid generic exception-based flow control.\n\n4. **Guard logging to avoid log spam during persistent failures**\n   In unreliable environments, repeated polling or write attempts can generate huge volumes of log messages. A simple pattern is to log only when transitioning from available to unavailable (or vice versa) and skip logging if the availability state has not changed. This reduces log noise while preserving useful diagnostic information on state changes.\n\n5. **Restore availability on success**\n   When communication resumes, the entity should automatically flip back to available as soon as a successful read or write occurs. This provides a self-healing behavior: no manual reset or restart is required, and the system accurately reflects the current connectivity.\n\n6. **Encapsulate type-specific logic but standardize behavior**\n   Although different entity types (sensor, switch, climate, etc.) read and write different kinds of Modbus data (coils vs registers, input vs holding), they share the same error-handling and availability semantics. Encapsulating the low-level calls per entity type while using a common pattern (_set_unavailable, available property) yields consistent behavior across the integration.\n\nThese patterns apply broadly to any integration working with external APIs/devices: gracefully detect errors, expose availability to the higher-level system, and minimize log noise while preserving useful state transitions.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the symptom\n- Observe that an integration's entities continue to show old values or appear normal in the UI even when the underlying device or service is unreachable.\n- Check logs for repetitive connection errors or attribute errors when reading from or writing to the device (e.g., AttributeError when accessing response fields, connection refused messages, or library-specific exceptions).",
            "Step 2: Inspect current read/write code paths\n- Find where the integration performs I/O, e.g., functions like read_coils, read_input_registers, read_holding_registers, write_coil, write_register, etc.\n- Look for patterns like:\n  - Direct use of the response without checking its type (e.g., result.bits[0], result.registers[0]).\n  - Reliance on generic exceptions (AttributeError, generic Exception) instead of library-specific error types.\n  - No entity.available implementation or equivalent availability signal.",
            "Step 3: Understand the library's error model\n- Review the external library documentation (e.g., pymodbus) to identify:\n  - Which exceptions are thrown on connectivity issues (e.g., ConnectionException).\n  - Which result types signal protocol-level errors (e.g., ModbusException, ExceptionResponse) even when no Python exception is raised.\n- Confirm how a successful response should look (e.g., having .bits or .registers attributes with expected lengths).",
            "Step 4: Introduce an availability flag on entities\n- Add a private attribute (e.g., self._available = True) and an available property on each entity class that interacts with the external device:\n  - @property\n    def available(self) -> bool:\n        return self._available\n- Ensure that Home Assistant or the host framework uses this property to mark entities as unavailable in the UI.",
            "Step 5: Centralize read logic in helper methods\n- For each mode of reading (coils, discrete inputs, input registers, holding registers), create helper methods:\n  - def _read_register(...):\n  - def _read_coil(...):\n- Within these helpers:\n  - Wrap the library call in try/except for the library's connection error (e.g., ConnectionException).\n  - After the call, check if the result is an error object (e.g., isinstance(result, (ModbusException, ExceptionResponse))).\n  - On any failure, call a shared _set_unavailable() method and return None.\n  - On success, parse bits or registers as needed, update internal values, and set self._available = True.",
            "Step 6: Centralize write logic in helper methods\n- For each type of write (coils, holding registers, etc.) create helper methods:\n  - def _write_coil(...):\n  - def _write_register(...):\n- In each helper:\n  - Wrap the write call in try/except ConnectionException (or equivalent).\n  - On failure, call _set_unavailable() and return early.\n  - On success, set self._available = True.\n- If the entity supports \"optimistic\" state (no verification), update self._is_on or similar only after a successful write.",
            "Step 7: Implement a shared _set_unavailable() with guarded logging\n- In each entity class, implement:\n  - def _set_unavailable(self):\n        if not self._available:\n            return  # avoid repeated logging\n        _LOGGER.error(\"No response from hub %s, slave %s, <address/register/coil> %s\", ...)\n        self._available = False\n- The early return prevents log spam when repeated read/write attempts fail while the device is down.",
            "Step 8: Update update() methods to use helpers\n- Replace direct I/O calls in update() with calls to the new helper methods.\n- For example:\n  - self._is_on = self._read_coil(self._coil)\n  - self._target_temperature = self._read_register(self._target_temperature_register)\n- Ensure that update() handles None from helpers gracefully (e.g., skip further processing if the helper returned None due to a failure).",
            "Step 9: Test failure and recovery scenarios\n- Simulate or force the external device/service to go offline (e.g., stop Modbus server, disconnect network).\n- Confirm that:\n  - The first failed call triggers an error log and sets available to False.\n  - Subsequent polling attempts do not generate additional identical log messages.\n  - Entities appear as unavailable in the UI.\n- Restore the device/service and confirm that:\n  - The next successful read/write sets available to True.\n  - Entity values/state update correctly again.",
            "Step 10: Monitor logs and adjust granularity\n- Ensure that the error messages include enough context (hub name, slave ID, register/coil/address) to diagnose issues without being overly verbose.\n- If the underlying library itself logs excessively on connection failures (as with pymodbus), consider additional configuration or upstream changes to reduce log verbosity, but keep entity-level logging concise and state-transition-based."
        ]
    }
}
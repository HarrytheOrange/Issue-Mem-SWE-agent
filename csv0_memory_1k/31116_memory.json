{
    "search_index": {
        "description_for_embedding": "Home Assistant SimpliSafe integration could get stuck after SimpliSafe cloud 500/502 errors corrupted simplisafe-python’s in-memory access and refresh tokens, causing repeated InvalidCredentialsError and requiring a full HA restart. The fix adds an emergency re-authentication path using the refresh token persisted in the config entry, ensures this path is only attempted once, stops further polling if it still fails, and centralizes refresh token persistence after successful updates.",
        "keywords": [
            "SimpliSafe",
            "simplisafe-python",
            "Home Assistant",
            "integration",
            "InvalidCredentialsError",
            "500",
            "502",
            "Bad Gateway",
            "auth",
            "refresh token",
            "access token",
            "cloud instability",
            "resilient polling",
            "DATA_LISTENER",
            "config_entry",
            "CONF_TOKEN"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the Home Assistant SimpliSafe integration was failing intermittently when the SimpliSafe cloud returned 500/502 errors. These server-side errors sometimes left the underlying simplisafe-python client in a bad state where both the access token and in-memory refresh token became invalid. Subsequent requests raised `InvalidCredentialsError` repeatedly. The integration did not automatically recover and effectively required a Home Assistant restart to re-establish authentication.\n\nThe maintainer observed logs showing 502 errors followed by repeated 401s and `InvalidCredentialsError`, despite simplisafe-python attempting to refresh the access token. Investigation revealed that while simplisafe-python's internal tokens could be corrupted, the refresh token persisted in Home Assistant's config entry (`config_entry.data[CONF_TOKEN]`) remained valid. This created an opportunity for a last-resort recovery path.\n\nThe fix introduced an emergency re-authentication mechanism inside the SimpliSafe coordinator's `_update_system` method. When a system update raises `InvalidCredentialsError`, the code now:\n\n1. Checks whether an emergency refresh has already been attempted via a boolean flag `_emergency_refresh_token_used`.\n2. If not yet used, logs a warning, sets `_emergency_refresh_token_used = True`, and calls `self._api.refresh_access_token(self._config_entry.data[CONF_TOKEN])` to re-auth using the config entry's stored refresh token.\n3. If an `InvalidCredentialsError` occurs again and `_emergency_refresh_token_used` is already True, it logs an error instructing the user to restart Home Assistant and then stops the scheduled listener by popping and invoking the stored `remove_listener` from `hass.data[DOMAIN][DATA_LISTENER]`. This prevents further pointless polling attempts.\n4. After a successful system update and event retrieval, if `_emergency_refresh_token_used` is True, it resets the flag to False, indicating the integration is back in a healthy state.\n\nAdditionally, the code was refactored so that refresh token persistence back to the config entry happens once per full update cycle in `async_update` (after all systems have been updated) instead of per-system within `_update_system`. This ensures that if the API refresh token changed (`self._api.refresh_token_dirty`), the updated token is reliably saved to the config entry only after all update tasks complete. The now-unneeded helper `_async_get_refresh_token` was removed, and the code now references `config_entry.data[CONF_TOKEN]` directly.\n\nOverall, the integration is now more resilient to transient SimpliSafe cloud issues, can self-recover from certain auth corruption scenarios without a full HA restart, and stops polling cleanly when recovery is not possible.",
        "semantic_memory": "This fix illustrates a robust pattern for handling third-party cloud authentication instability in long-running integrations:\n\n1. **Separation of token persistence from in-memory state**: In-memory tokens maintained by a client library (e.g., access/refresh tokens) can become inconsistent or corrupted during error storms (500/502/Bad Gateway, etc.). Persisting a known-good refresh token in a higher-level configuration store (config entry, database, or secure storage) provides a fallback mechanism independent of the client library's state.\n\n2. **Emergency authentication paths**: Introducing an \"emergency\" re-authentication path that uses the persisted token allows an integration to recover from otherwise fatal auth errors (like repeated `InvalidCredentialsError`), without requiring a system restart or user intervention.\n\n3. **One-shot fallbacks with clear failure states**: Emergency paths should be attempted only once (or a small, bounded number of times) and tracked with explicit flags. If the fallback also fails, the system should:\n   - Stop repeated retry loops (which can spam logs and exhaust resources), and\n   - Surface a clear, actionable error to the user (e.g., \"authentication disconnected, please restart\" or re-auth via UI).\n\n4. **Centralized token update and persistence**: Saving updated tokens to persistent storage is best done at well-defined points in the lifecycle (e.g., after a batch of successful updates) rather than scattered across per-resource update functions. This reduces race conditions, ensures consistency, and makes reasoning about token lifecycle easier.\n\n5. **Graceful shutdown of periodic tasks on unrecoverable errors**: When an integration can no longer operate (for example, after authentication fails even with an emergency fallback), it should cleanly dispose of timers, listeners, or schedulers to avoid unnecessary work and errors. In Home Assistant, this often means popping a listener from `hass.data` and invoking it to cancel updates.\n\n6. **Resilience to provider flakiness**: When dealing with undocumented/unstable third-party APIs, defensive strategies—like layered token handling, explicit error categorization, and fallback tokens—are critical. Code should assume that even standard flows like token refresh may fail in unexpected ways during provider incidents.\n\nThese concepts generalize to any long-running integration with remote services: maintain a reliable persistent token source, add bounded fallback logic for auth failures, and ensure clean teardown when recovery is impossible.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar issues.",
            "Step 1: Identify the failure pattern\n- Monitor logs for patterns like repeated authentication errors (`401`, `InvalidCredentialsError`, or similar) that persist even after the client library attempts to refresh tokens.\n- Look for preceding server-side errors (`500`, `502`, `Bad Gateway`, timeouts) that may correlate with the onset of the auth failures.\n- Confirm that the integration only recovers after a full application restart or manual re-authentication.",
            "Step 2: Determine token storage layers\n- Inspect the integration and its underlying client library to understand where tokens are stored:\n  - In-memory client state (e.g., `api.access_token`, `api.refresh_token`).\n  - Persisted configuration or secrets (e.g., `config_entry.data[CONF_TOKEN]`, database, key vault).\n- Verify whether the persisted token remains valid when the in-memory tokens fail (e.g., by manually re-authenticating or running a quick script).",
            "Step 3: Design an emergency fallback mechanism\n- Implement an emergency auth path that uses the persisted token as a last resort when encountering persistent auth errors:\n  - Add a flag (e.g., `_emergency_refresh_token_used`) to track whether this path has already been used.\n  - In your periodic update function (or equivalent), catch the specific auth exception (e.g., `InvalidCredentialsError`).\n  - If the flag is false, log a warning and call `refresh_access_token` (or equivalent) using the persisted refresh token.\n  - Set the flag to true so you do not repeatedly attempt the emergency path in a tight loop.",
            "Step 4: Handle repeated failures gracefully\n- If a subsequent update still raises the auth exception and the emergency flag is already true:\n  - Log an error with a clear message indicating that authentication is disconnected and manual intervention is needed (restart, re-auth, etc.).\n  - Stop the periodic update mechanism to avoid continuous failing calls:\n    - In Home Assistant, for example, pop the listener from `hass.data[DOMAIN][DATA_LISTENER]` using the `config_entry.entry_id` and invoke it to cancel the scheduled updates.\n  - Ensure the method returns early after this cleanup.",
            "Step 5: Reset the emergency state after successful recovery\n- After a successful update cycle where data is fetched and no auth exceptions occur:\n  - If the emergency flag is true, reset it to false, indicating that the integration has re-stabilized.\n  - This allows a future emergency fallback attempt if another incident occurs while preventing redundant attempts during the same incident.",
            "Step 6: Centralize token persistence\n- Move the logic that persists updated tokens (e.g., `refresh_token`) out of per-resource update functions and into a higher-level method that runs after all updates complete.\n- Example pattern in Home Assistant:\n  - In `async_update`, gather all update tasks via `asyncio.gather`.\n  - After they complete, check `self._api.refresh_token_dirty` (or equivalent flag from the client library).\n  - If dirty, call a helper (e.g., `_async_save_refresh_token(hass, config_entry, self._api.refresh_token)`) to update the config entry.\n- This ensures consistent token updates and reduces the chance of persisting intermediate or invalid values.",
            "Step 7: Simplify and remove unnecessary helpers\n- If you previously had helpers to fetch the stored refresh token (e.g., `_async_get_refresh_token`), consider removing them and reading directly from your configuration structure (e.g., `config_entry.data[CONF_TOKEN]`) if it doesn't add complexity.\n- Keep token handling code minimal and explicit to ease maintenance and debugging.",
            "Step 8: Test under simulated failure conditions\n- Write or run tests that simulate:\n  - Initial `500/502` responses followed by `InvalidCredentialsError` on subsequent calls.\n  - A successful emergency re-authentication using the persisted token.\n  - A failed emergency re-authentication path to validate that the listener is stopped and appropriate logs are emitted.\n- In manual testing, temporarily invalidate in-memory tokens while keeping a known-good refresh token in config to ensure recovery works as expected.",
            "Step 9: Communicate behavior to users\n- Update documentation or release notes to explain that the integration will:\n  - Automatically attempt a one-time emergency auth recovery using the stored token.\n  - Stop updates and ask for manual intervention if even the emergency path fails.\n- This sets user expectations and helps them understand why updates might stop and what to do about it."
        ]
    }
}
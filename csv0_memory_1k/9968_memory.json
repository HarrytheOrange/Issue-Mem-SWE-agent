{
    "search_index": {
        "description_for_embedding": "Home Assistant yamaha_musiccast media_player integration updated to support multi-zone Yamaha MusicCast receivers by creating one entity per zone and routing commands via per-zone objects. User-configurable name was removed in favor of device-derived names, a new interval_seconds configuration was added to control status update intervals, and pymusiccast was bumped to 0.1.3.",
        "keywords": [
            "Home Assistant",
            "media_player",
            "yamaha_musiccast",
            "Yamaha MusicCast",
            "multi-zone support",
            "zones",
            "pymusiccast",
            "interval_seconds",
            "breaking change",
            "entity naming",
            "device discovery",
            "configuration schema"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change set for Home Assistant's yamaha_musiccast media_player integration, the goal was to expose multi-zone capabilities of Yamaha MusicCast receivers as individual media player entities. Previously, the component effectively treated the receiver as a single zone: commands such as power, mute, volume, and input selection were sent to the receiver object (set_power, set_mute, set_volume, set_input), and only one MediaPlayerDevice entity was created per configured device.\n\nThe updated implementation switches to using the zones exposed by the underlying pymusiccast library (McDevice). In setup_platform, after successfully creating a McDevice, the code now iterates over receiver.zones and calls add_devices once per zone, creating a YamahaDevice for each zone instead of just one for the entire receiver. Each YamahaDevice holds references to the overall receiver (self._recv) and its specific zone (self._zone), and it calls self._recv.set_yamaha_device(self) and self._zone.set_yamaha_device(self) so that the library can push updates back to the correct entity.\n\nAll zone-specific operations (power, mute, volume, input selection) are now routed through the zone object instead of the receiver: set_power, set_mute, set_volume, and set_input calls were changed from self._receiver.* to self._zone.*. Playback transport commands (play, pause, stop, previous, next) remain routed through the receiver object via self._recv.set_playback(), as handled by pymusiccast.\n\nThe configuration schema was simplified: the optional name parameter was removed from the platform configuration. The YamahaDevice now uses the device-derived name (recv.name) and appends zone information in the name property so entities reflect actual device/zone names instead of a user-specified name that can fall out of sync. This was communicated as a breaking change: users must adjust their configurations and automations as the entity naming scheme changes.\n\nAdditionally, a new configuration option interval_seconds was introduced, with a default of 480 seconds. This value is passed to pymusiccast.McDevice as mc_interval, allowing users to tune the polling/heartbeat interval that the library uses to maintain up-to-date state information. The previous, more complex update logic in update() that checked receiver.update_status_timer.is_alive() to reinitialize after system suspend was removed; instead, update() now simply calls self._recv.update_status() and self._zone.update_status(), delegating scheduling and robustness to the library.\n\nFinally, pymusiccast was bumped from 0.1.2 to 0.1.3 in both the component REQUIREMENTS and requirements_all.txt to pick up library changes necessary for the new behavior. Users reported that the new implementation correctly recognized multiple zones on devices like the RX-V581 where the older Yamaha integration (based on the rxv library) did not.",
        "semantic_memory": "This change illustrates several general patterns and best practices for device integrations in home automation systems:\n\n1. **Model sub-resources as separate entities**: When a hardware device exposes multiple independently controllable sub-resources (e.g., zones, channels, rooms), it is often better to create one logical entity per sub-resource rather than one coarse-grained entity. This allows finer-grained control, clearer state representation, and easier automation. The integration moved from a single receiver entity to one entity per MusicCast zone.\n\n2. **Route commands to the correct abstraction level**: For multi-zone devices, some operations belong at the device level (e.g., global playback controls) while others are zone-specific (power, volume, input selection). Correct routing of API calls (receiver vs. zone) is crucial to avoid unintended side effects (e.g., turning off all zones when only one should be affected).\n\n3. **Prefer device-derived names over user-configured names when appropriate**: Allowing users to override device names can cause divergence between the actual physical labels and the UI, especially when devices are discoverable and already have meaningful names. Using the canonical device name plus sub-resource identifiers (e.g., deviceName_zone) ensures consistency and supports automated discovery and multi-entity creation. However, this can be a breaking change and must be clearly communicated.\n\n4. **Expose tunable timing parameters through configuration instead of hard-coding**: Polling intervals or heartbeat timers (here, interval_seconds mapped to mc_interval) can have different optimal values depending on the environment (network stability, number of devices, latency). Making them configurable while providing sensible defaults improves robustness and flexibility.\n\n5. **Delegate responsibility to the underlying library when possible**: Rather than duplicating scheduling logic (e.g., maintaining an update_status_timer and checking is_alive()), the integration now relies on the library's own update_status and mc_interval behavior. This reduces complexity and the risk of subtle bugs (e.g., timers not restarting after suspend) in the integration layer.\n\n6. **Guard against duplicate devices during setup**: The setup code normalizes the host IP and maintains a known_hosts list in hass.data to avoid adding the same device multiple times. This pattern of tracking discovered/registered endpoints in a shared data structure is widely applicable for preventing duplicate entities.\n\n7. **Coordinate library version bumps with feature changes**: When an integration starts using new capabilities of its underlying library (multi-zone support, interval handling), the version requirement must be updated accordingly in both the integration and the global requirements list to ensure consistent, tested behavior.",
        "procedural_memory": [
            "When extending a device integration to support multi-zone or sub-resource behavior:",
            "Step 1: Understand the underlying library's abstraction model. Identify how zones or sub-resources are represented (e.g., a zones dict on a device object) and what methods are available for device-level vs. zone-level control.",
            "Step 2: Adjust the platform setup to create one entity per sub-resource. In setup_platform or equivalent, iterate over the device's zones (or channels/rooms) after successfully instantiating the device object, and call add_devices once per zone, passing both the root device and the specific zone object into the entity constructor.",
            "Step 3: Update the entity class to hold references to both the overall device and the specific sub-resource. For example, store self._recv for receiver-level interactions and self._zone for zone-level operations. Ensure the library can callback into the entity if needed (e.g., set_yamaha_device(self) on both device and zone).",
            "Step 4: Route operations to the correct object. For zone-specific actions (power, mute, volume, input), call methods on the zone object. For global or transport actions (play, pause, stop, next/previous track) that apply across zones, call methods on the device object if that matches the library's behavior. Carefully audit all existing method calls (turn_on, turn_off, mute_volume, set_volume_level, select_source, etc.) to avoid leaving any that incorrectly operate at the wrong level.",
            "Step 5: Revisit naming strategy. If devices already have meaningful names and now produce multiple entities, consider using the device-derived name plus a zone identifier instead of a user-configurable name. Update the name property to reflect this scheme and remove now-misleading configuration options (like a single name for a multi-entity device). Clearly document resulting breaking changes and how users should update their configurations and automations.",
            "Step 6: Add configuration for timing or polling behavior if the library supports it. For example, introduce an interval_seconds option with a sensible default, extend the platform schema, and pass this as mc_interval or similar to the library constructor. This allows users to tune how often the integration checks or receives updates.",
            "Step 7: Simplify the update path. If the underlying library handles recurring updates or has its own timers, avoid replicating that logic in the integration. Implement the entity's update() method to invoke the library's update_status or equivalent, and call sub-resource update methods as needed. Remove fragile checks such as manual timer is_alive() monitoring unless they are truly required.",
            "Step 8: Update dependency versions. If you rely on new features of the library, bump its version in both the integration's REQUIREMENTS and any global requirement files. Run the project's dependency generation scripts if required (e.g., script/gen_requirements_all.py) and ensure tests pass.",
            "Step 9: Maintain a registry of known hosts/devices to prevent duplicates. Normalize host addresses (resolve DNS to IP) and keep a list of already-registered IPs in a shared data structure (like hass.data). Skip setup for hosts already in the list.",
            "Step 10: Communicate breaking changes and new options. Update the documentation to describe the new multi-zone behavior, naming scheme, and interval_seconds configuration. Highlight that the name option is removed and that entity IDs/names will change, so users must adjust their automations.",
            "Step 11: Test with real multi-zone hardware. Verify that each zone appears as a separate entity, that commands only affect the intended zone, that state updates propagate correctly, and that the configurable update interval behaves as expected."
        ]
    }
}
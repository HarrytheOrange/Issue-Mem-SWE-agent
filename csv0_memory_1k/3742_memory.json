{
    "search_index": {
        "description_for_embedding": "Fixes an import error in napari test fixtures caused by scikit-image (skimage) 0.19 moving image_fetcher to a new module. The fix uses the skimage version to select the correct image_fetcher import path or a fallback implementation for older versions.",
        "keywords": [
            "napari",
            "skimage",
            "scikit-image",
            "image_fetcher",
            "import error",
            "API change",
            "version check",
            "backwards compatibility",
            "conftest.py",
            "test fixtures"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, napari's test suite started failing after scikit-image (skimage) released version 0.19. The failures were due to an ImportError when trying to import `image_fetcher` from `skimage.data`. Upstream, skimage had refactored its data fetching utilities in PR skimage/skimage#5996, moving `image_fetcher` into `skimage.data._fetchers` for version 0.19 and later. Napari's `conftest.py` previously handled differences via a try/except ImportError: it attempted `from skimage.data import image_fetcher`, and on ImportError it fell back to using `data_dir` and defining a custom `image_fetcher` class. After the upstream change, the original import location was no longer valid for newer skimage versions, causing CI to fail. The fix added an explicit `import skimage`, parsed `skimage.__version__` into a tuple, and used version-based branching: for skimage >= 0.19, import `image_fetcher` from `skimage.data._fetchers`; for 0.16 <= version < 0.19, import `image_fetcher` from `skimage.data` as before; and for versions older than 0.16, keep the old fallback that uses `data_dir` and a custom `image_fetcher`. This restored compatibility across multiple scikit-image versions and fixed the test failures.",
        "semantic_memory": "This case illustrates a common compatibility problem when a project depends on external libraries whose internal APIs or module layouts change across versions. Here, scikit-image moved `image_fetcher` to a new module path, breaking code that imported it from the old location. Depending solely on a single import path or relying on ImportError-based detection can become brittle when libraries refactor internals or change behavior without raising the same exceptions. A robust pattern is to introduce a compatibility layer that centralizes version- or feature-based checks and selects the appropriate import path or implementation. Version-based checks (e.g., parsing `__version__`) can be useful when a breaking change is clearly associated with a known version boundary. However, feature detection (checking for attribute/module presence) is often preferable when feasible, because it decouples your code from exact version strings. For test fixtures in particular, it is important to handle multiple dependency versions gracefully, since CI often runs against a range of versions. Abstracting these compatibility shims into a single location (like `conftest.py` or a dedicated compat module) simplifies maintenance when upstream dependencies change again.",
        "procedural_memory": [
            "When diagnosing and fixing import errors caused by upstream library API changes, follow these steps:",
            "Step 1: Reproduce and inspect the error",
            "Run the failing tests or application code and capture the exact traceback. Confirm that the error is an ImportError (or ModuleNotFoundError) and identify the specific symbol and module (e.g., `from skimage.data import image_fetcher`) that can no longer be imported.",
            "Step 2: Check upstream library changes and versions",
            "Determine which version of the dependency is being used (e.g., `import skimage; print(skimage.__version__)` in a Python shell or via logs). Consult the dependency's changelog, release notes, or relevant pull requests to see if the symbol was moved, renamed, or deprecated in that version.",
            "Step 3: Identify the new import path or replacement API",
            "From upstream documentation or code, find the new location or replacement for the symbol (e.g., `skimage.data._fetchers.image_fetcher` in skimage >= 0.19). Verify in a REPL that the new import works for that version.",
            "Step 4: Design a compatibility layer",
            "Centralize the dependency-specific logic in one place (e.g., a compat module or `conftest.py` for tests). Decide whether to use version-based detection (parsing `__version__`) or feature-based detection (checking for module/attribute existence). For clear, version-bound changes, version checks can be straightforward.",
            "Step 5: Implement conditional imports or fallbacks",
            "Implement logic that selects the correct import path or fallback based on the detected version or feature. For example:\n- If version >= X: import from new module path.\n- Else if version >= Y: import from old module path.\n- Else: provide a minimal custom implementation or legacy fallback using other available APIs.",
            "Step 6: Ensure fallbacks cover older versions",
            "If your project supports older dependency versions, include a branch that gracefully handles those versions (e.g., using `data_dir` and a custom `image_fetcher` when `image_fetcher` does not exist at all). Test these code paths where possible.",
            "Step 7: Test across supported dependency versions",
            "Run the test suite against multiple versions of the dependency (e.g., oldest supported, a mid-range, and latest) locally or via CI matrix builds. Confirm that imports succeed and behavior is correct in each environment.",
            "Step 8: Document the compatibility logic",
            "Add comments near the conditional import explaining why it exists, the associated upstream change, and which version boundaries it targets. This makes future maintenance easier when the dependency changes again.",
            "Step 9: Monitor for further upstream changes",
            "Keep an eye on upstream library release notes. When older versions are no longer supported by your project, you can simplify or remove legacy branches from the compatibility layer."
        ]
    }
}
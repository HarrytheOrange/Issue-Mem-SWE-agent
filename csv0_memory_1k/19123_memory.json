{
    "search_index": {
        "description_for_embedding": "Fix for inaccurate Philips Hue colors in Home Assistant by making RGB/HS ↔ XY color conversion aware of device-specific color gamuts (A/B/C), adding gamut-clamping math to the shared color utility and wiring Hue lights to use bridge-reported gamut data from aiohue. This improves high-saturation colors (especially pure blue) and prevents the bridge from doing suboptimal clamping.",
        "keywords": [
            "Philips Hue",
            "color gamut",
            "gamut A",
            "gamut B",
            "gamut C",
            "RGB to xy",
            "xy to hs",
            "Home Assistant",
            "util.color",
            "aiohue",
            "color conversion",
            "CIE 1931",
            "triangle clamp",
            "out of gamut",
            "light.hue",
            "test_hue",
            "rgbxy removal"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, Home Assistant users reported that some Philips Hue lights (especially those using color gamut A or C, like certain Living Colors and LED strips) could not reproduce certain colors correctly when controlled via Home Assistant. The most visible symptom was that pure blue (RGB [0,0,255]) appeared too purple when set through HA, even though the same hardware could display a more accurate blue in the official Hue app.\n\nThe root cause was that Home Assistant's color conversion utilities (util.color) were gamut-agnostic. The system converted RGB/HS colors to CIE 1931 xy coordinates assuming the full theoretical gamut and then sent those xy values to the Hue bridge. The Hue bridge then clamped out-of-gamut coordinates to the nearest color in the bulb’s actual gamut. Because HA didn't know each bulb's specific triangle (A/B/C), the coordinates it sent were not optimal for the bridge’s clamping, leading to visibly incorrect colors, especially at high saturation. Additionally, HA implicitly assumed color gamut B behavior for all lights.\n\nThe initial attempt to fix this imported the external `rgbxy` library directly into the Hue component and added it as a dependency. That approach worked functionally but duplicated logic already partly present in `homeassistant.util.color` and was considered the wrong architectural layer; maintainers preferred keeping device-agnostic conversion logic in the shared color utilities and device-specific metadata in aiohue.\n\nThe final solution was to extend `homeassistant.util.color` with explicit gamut-awareness and then wire the Hue component to use it:\n\n- In `util.color`, the author introduced two attr-based helper classes: `XYPoint` (CIE 1931 xy coordinate) and `GamutType` (a triangle of three XYPoints: red, green, blue). They then added geometric helpers adapted from Benjamin Knight’s rgbxy project (with attribution): `cross_product`, `get_distance_between_two_points`, `get_closest_point_to_line`, `get_closest_point_to_point`, and `check_point_in_lamps_reach`.\n- The RGB↔xy and xy↔hs conversion functions were extended with an optional `GamutType` parameter:\n  - `color_RGB_to_xy` / `color_RGB_to_xy_brightness` now compute xy as before and, if a gamut is provided and the xy lies outside the triangle, they compute and return the closest point on the triangle edges.\n  - `color_xy_to_RGB` / `color_xy_brightness_to_RGB` similarly clamp xy to the triangle before converting to RGB.\n  - `color_xy_to_hs` and `color_hs_to_xy` were updated to support an optional gamut and delegate through the gamut-aware RGB/xy conversions.\n- In the Hue integration (`homeassistant/components/light/hue.py`), the `HueLight` class was updated:\n  - The constructor no longer creates a `rgbxy.Converter`. Instead, for non-group lights, it reads `colorgamuttype` and `colorgamut` from the aiohue light object (`self.light.colorgamuttype` and `self.light.colorgamut`), which itself is populated from the Hue bridge’s `capabilities.control.colorgamuttype` and `colorgamut` fields. Those coordinates are wrapped into `XYPoint` instances and grouped into a `GamutType` object. For Hue groups or lights with missing gamut data, the gamut is set to `None`, and a warning is logged if the gamut is unexpectedly absent.\n  - `hs_color` now, when `colormode` is `'xy'` or `'hs'` and `xy` is present, calls `color.color_xy_to_hs(*source['xy'], self.gamut)` so that conversion from xy to hs accounts for the device’s color triangle.\n  - `async_turn_on` now, when `ATTR_HS_COLOR` is specified, converts HS directly to xy via `color.color_hs_to_xy(*kwargs[ATTR_HS_COLOR], self.gamut)` and sends that xy command to the bridge. This ensures HA’s own clamping is used instead of relying on unspecified bridge behavior.\n  - Support for exposing gamut details in state attributes was removed in the final iteration to avoid polluting the state with low-level geometry data; only the functional conversion uses the gamut.\n  - An `effect` property was added that exposes `self.light.state.get('effect')`, properly handling both single lights and groups.\n\nTests for Hue were updated to accommodate the new fields. A shared `LIGHT_RAW` dictionary with `capabilities.control.colorgamuttype`, `colorgamut`, and a `swversion` was introduced and added to mocked lights in `tests/components/light/test_hue.py` (e.g., `light=Mock(state=..., raw=LIGHT_RAW)`) to prevent KeyErrors when the code accesses `self.light.colorgamut` via aiohue. Tests for `hs_color` and availability were adjusted to include this raw data.\n\nEarlier commits that added `rgbxy` as a requirement and used it directly were reverted. `rgbxy` was removed from `requirements_all.txt`, `requirements_test_all.txt`, and `script/gen_requirements_all.py`, satisfying maintainers’ desire to avoid redundant external dependencies when equivalent logic is implemented in the shared color utilities.\n\nThe net effect is that Home Assistant now produces significantly more accurate colors for Philips Hue lights across all supported gamuts, particularly for high saturation hues like pure blue, matching more closely what users expect from the official Hue app.",
        "semantic_memory": "This fix illustrates several generalizable engineering lessons around device-specific color handling, library design, and test maintenance:\n\n1. **Device-specific color gamuts must be accounted for in color conversion**\n   Many RGB-capable devices, especially lighting hardware, cannot reproduce the full sRGB gamut. Each has its own color triangle (e.g., Philips Hue gamuts A/B/C). If a control system converts RGB/HS to xy coordinates assuming an idealized gamut and sends those coordinates to the device or its bridge, the device will clamp them to its own gamut in an undocumented or non-optimal way, leading to perceptually incorrect results—especially at high saturation colors.\n\n   Therefore, color conversion functions should accept a description of the target device’s gamut (typically a triangle in CIE 1931 xy space) and clamp or adjust out-of-gamut colors to the closest point on that triangle before sending commands.\n\n2. **Centralize color conversion logic in shared utilities**\n   The first proposed solution directly used an external `rgbxy` library inside the Hue component, which duplicated functionality and increased coupling. A better design is to treat color conversion as a cross-cutting concern and implement it in a shared utility module (here, `homeassistant.util.color`) so that all integrations can benefit from the same math and behavior. Device integrations then only supply device-specific parameters like the gamut triangle.\n\n   This separation of concerns improves testability, reuse, and consistency: any bug fix or improvement in the color math automatically benefits all components.\n\n3. **Use geometry to handle out-of-gamut colors robustly**\n   Mapping out-of-gamut colors to the closest reproducible color is a geometric problem. Representing the gamut as a triangle of three points in xy space and using vector math to:\n   - Check if a point lies within the triangle (`check_point_in_lamps_reach` based on barycentric coordinates/cross products), and\n   - When it does not, project the point onto each edge and choose the closest projected point (`get_closest_point_to_line` and `get_closest_point_to_point`),\n   yields a mathematically sound and predictable clamping behavior. This approach is broadly applicable to any device that exposes its gamut as a polygon or convex hull.\n\n4. **Let device or protocol libraries expose metadata, not behavior**\n   The maintainers made a clear distinction between:\n   - Metadata/structure: e.g., `aiohue` should expose `colorgamut` and `colorgamuttype` from the Hue API, and possibly classify models into known gamuts.\n   - Behavior/logic: color conversion, gamut clamping, etc., should reside in the application’s utility layer, not inside the API wrapper.\n\n   This pattern—libraries as thin protocol representations and higher-level utilities for logic—keeps the protocol library reusable and reduces the temptation to embed application-specific behaviors in it.\n\n5. **Be cautious about adding external dependencies when equivalent logic exists**\n   Importing a specialized library (`rgbxy`) for color conversion solved the immediate problem, but it violated a project guideline against duplicating existing functionality. When the same domain logic (Philips’ own example code) is already the basis for in-house utilities, it's usually better to extend those utilities than to wrap another implementation. This reduces dependency overhead, licensing concerns, and integration complexity.\n\n6. **Mocks must include any newly accessed fields**\n   Introducing new code paths that read previously unused fields (like `light.raw['capabilities']['control']['colorgamut']`) will break unit tests unless mocks are updated accordingly. Defining shared mock structures (e.g., a `LIGHT_RAW` dict) avoids duplication and keeps tests maintainable when the schema evolves. This is a general principle: whenever production code starts relying on new fields from an external API, test fixtures must mimic those fields.\n\n7. **Expose only meaningful attributes in state**\n   Although gamut type and coordinates are technically available, they are implementation details rarely needed in user-visible state. The final version removes gamut attributes from the entity’s state attributes. This reflects a general design guideline: avoid cluttering user-facing state with low-level technical details unless there is a clear use case, and instead focus on behaviors and capabilities.\n\n8. **Small properties like `effect` should be normalized across entity types**\n   The addition of an `effect` property that safely reads `state.get('effect')` ensures both single lights and groups can expose their effect in a consistent way. This highlights a broader pattern: wrap raw API fields in thin properties that normalize behavior (presence/absence, defaults) and keep calling code simple.",
        "procedural_memory": [
            "Step-by-step strategy to diagnose and fix inaccurate colors for RGB lighting devices with limited gamuts:",
            "Step 1: Identify and characterize the symptom",
            "- Observe which colors appear incorrect when set via your system versus the vendor’s official app (e.g., pure blue looks purple on certain Hue bulbs).",
            "- Focus on high-saturation, edge-of-gamut colors; these are most likely to reveal gamut and clamping issues.",
            "- Verify that the hardware itself can reproduce the expected color using the official app to rule out hardware defects.",
            "",
            "Step 2: Inspect existing color conversion pipeline",
            "- Trace how your system converts user-facing color inputs (RGB/HSV/HS) into the device’s native color space (often CIE 1931 xy).",
            "- Check if conversion functions assume a full, idealized color space or if they account for device-specific gamut limitations.",
            "- Determine where clamping for out-of-gamut colors currently happens (in your app, in a library, or implicitly in the device/bridge).",
            "",
            "Step 3: Determine device-specific gamut information",
            "- Consult the device’s API or documentation to see if it exposes its color gamut (e.g., Philips Hue’s `capabilities.control.colorgamut` and `colorgamuttype`).",
            "- If using an API wrapper (like aiohue), see whether these fields are already surfaced as attributes (e.g., `colorgamut`, `colorgamuttype`) on the device objects.",
            "- Model the gamut as a simple geometric object, such as a triangle in CIE 1931 xy space defined by red, green, and blue primaries.",
            "",
            "Step 4: Centralize gamut-aware conversion logic",
            "- Avoid implementing gamut logic inside a specific integration (like a Hue component) if you have a shared color utility module.",
            "- Extend the shared utility with:\n  - Data structures to represent points and gamuts (e.g., `XYPoint`, `GamutType` using attrs or simple tuples).\n  - Geometry helpers:\n    * `check_point_in_lamps_reach(point, gamut)` to test whether an xy point lies inside the triangle (using cross products or barycentric coordinates).\n    * `get_closest_point_to_line(A, B, P)` to project a point onto a line segment.\n    * `get_closest_point_to_point(xy, gamut)` to find the closest reproducible xy on the triangle edges for an out-of-gamut point.",
            "",
            "Step 5: Make conversion functions optionally gamut-aware",
            "- Update existing color conversion functions to accept an optional gamut parameter rather than forcing all callers to supply one:\n  - `color_RGB_to_xy(r, g, b, gamut=None)` and `color_RGB_to_xy_brightness(r, g, b, gamut=None)`:\n    * Compute xy as usual.\n    * If `gamut` is not None and the point is out of reach, compute the closest point on the gamut triangle and return that instead.\n  - `color_xy_to_RGB(x, y, gamut=None)` and `color_xy_brightness_to_RGB(x, y, brightness, gamut=None)`:\n    * If `gamut` is not None and the point is out of reach, clamp it to the triangle before converting to RGB.\n  - `color_xy_to_hs(x, y, gamut=None)` and `color_hs_to_xy(h, s, gamut=None)`:\n    * Implement these in terms of the gamut-aware RGB/xy functions so the entire conversion chain respects the device’s gamut.",
            "",
            "Step 6: Wire device integrations to provide the gamut",
            "- In your device integration (e.g., Hue), update the device model class to read the gamut from the underlying API object once during initialization:\n  - For example, in `__init__` of `HueLight`, set `self.gamut_typ = self.light.colorgamuttype` and `self.gamut = self.light.colorgamut` where `colorgamut` is shaped into a `GamutType` or similar.\n  - For groups or devices that do not expose a gamut, set `self.gamut = None` and, optionally, `self.gamut_typ = 'None'` and log a warning if that situation is unexpected.",
            "- Update any color-related properties/methods to pass the gamut into utility functions:\n  - When reading a color from the device (\n    * If you have xy values and want HS, call `color_xy_to_hs(x, y, self.gamut)`.\n  - When sending colors to the device:\n    * For HS to xy, call `color_hs_to_xy(h, s, self.gamut)`.\n    * For RGB to xy, call `color_RGB_to_xy(r, g, b, self.gamut)` if your pipeline uses RGB.",
            "",
            "Step 7: Keep protocol libraries thin and reusable",
            "- Ensure your protocol/device library (e.g., aiohue) only exposes raw metadata like gamut coordinates and types and does not embed application-specific conversion logic.",
            "- If a function like `get_gamut()` is useful to many consumers, place it in the protocol library; keep high-level color conversions in the app’s color utility module.",
            "",
            "Step 8: Update and repair tests",
            "- When production code starts reading new fields from device objects (e.g., `light.colorgamut`, `light.colorgamuttype`, or `light.raw['capabilities']['control']`), update mock objects in tests to include these fields.",
            "- Create shared fixtures (e.g., `LIGHT_RAW`) with realistic capability data so that several tests can reuse them.",
            "- Verify existing tests still pass and add focused tests for:\n  - Conversion of in-gamut colors (should remain unchanged).\n  - Clamping of out-of-gamut colors (ensure output xy lies on the triangle and is stable).",
            "",
            "Step 9: Clean up temporary design choices",
            "- If you initially introduced an external dependency (like `rgbxy`) as a quick fix, remove it once equivalent logic exists in your own utilities:\n  - Delete `REQUIREMENTS` entries and remove the package from `requirements_all`, `requirements_test_all`, and any generator scripts.\n  - Replace direct uses of the library with calls to your shared utility functions.",
            "- Avoid exposing internal geometric details (like gamut coordinates) as state attributes unless there is a concrete user-facing need.",
            "",
            "Step 10: Validate behavior with real devices",
            "- Deploy the updated code to an environment with actual devices that represent different gamuts (A, B, C).",
            "- Test critical cases visually, such as pure blue and other edge-of-gamut colors, comparing Home Assistant outputs to the vendor app.",
            "- Confirm that behavior for in-gamut colors has not regressed and that the user experience now matches expectations."
        ]
    }
}
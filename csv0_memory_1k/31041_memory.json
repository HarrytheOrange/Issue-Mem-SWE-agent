{
    "search_index": {
        "description_for_embedding": "Home Assistant Plugwise/Anna integration: bump haanna library to 0.14.0 to fix multiple thermostat issues (including two Annas on one system and haanna issue #14) and update climate.py to derive heating_state for on/off heaters from boiler_state. PR was closed because of incomplete/incorrect dependency updates and missing gen_requirements_all run, highlighting the need to follow HA contribution checklist.",
        "keywords": [
            "home-assistant",
            "plugwise",
            "anna",
            "haanna",
            "library bump",
            "dependency update",
            "climate.py",
            "boiler_state",
            "heating_state",
            "on/off heater",
            "multiple devices",
            "two annas",
            "integration bugfix",
            "requirements_all.txt",
            "script.gen_requirements_all",
            "manifest.json"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, a contributor attempted to fix several Home Assistant issues related to the Plugwise (Anna thermostat) integration by updating its underlying library and some integration logic. The goal was to bump the haanna library to version 0.14.0, which included fixes for at least three reported HA issues (#28815, #28947, #30714), haanna issue #14, and an additional problem reported by a user (fwestenberg) involving two Anna thermostats being used within the same Home Assistant instance. Alongside the version bump, the contributor modified climate.py to correctly detect the heating_state for on/off-type heaters by reading the boiler_state attribute instead of (or in addition to) the previous logic.\n\nAlthough the contributor reported that the changes worked locally, the pull request ended up with incomplete/incorrect changes when pushed to GitHub: requirements were not consistently updated, and the required `python3 -m script.gen_requirements_all` step had not been run. A codeowner (Quentame) noticed these issues, questioned whether the code was truly tested, and ultimately closed the PR with instructions to open a new, clean one. The maintainer requested that the new PR contain a single commit that only bumps the haanna version, with the derived requirements files regenerated by the proper script. The climate.py changes were mentioned as important, but due to the messy state of the PR, the maintainer preferred a fresh, well-structured submission.\n\nThe episode highlights two aspects: (1) the actual functional fix—updating the haanna dependency and adding logic that maps boiler_state to heating_state for simple on/off heating systems, and (2) the process failure—pushing partially updated files and skipping the prescribed tooling, which led to the PR being closed even though the underlying ideas were valid.",
        "semantic_memory": "This case illustrates several generalizable lessons about maintaining integrations that rely on external libraries and contributing to large, tool-driven projects:\n\n1. **External library bumps often carry bugfixes critical to the integration.** When an integration wraps a third-party library (like haanna for Plugwise/Anna), many field-reported bugs are actually fixed upstream. Properly bumping the dependency and regenerating the ecosystem’s requirement files can resolve multiple issues at once. This is common in plugin-based systems.\n\n2. **Mapping device-specific states into platform-agnostic attributes must handle device variations.** For climate integrations, not all heaters expose rich state; some simply provide a binary boiler_state (on/off). A robust integration translates such low-level device signals into the platform’s standard concepts, like heating_state, to ensure UI consistency and correct automations. Correctly connecting `boiler_state` to `heating_state` is a pattern: inspect device-specific flags and derive standardized state.\n\n3. **Project-specific contribution workflows matter as much as code correctness.** In large projects like Home Assistant, contributors must follow tooling and checklist requirements: updating manifests, regenerating central requirement files with provided scripts, and keeping PRs small and focused. Even if local testing passes, skipping required scripts or pushing hand-edited derived files often results in invalid or inconsistent repo state and causes PRs to be rejected.\n\n4. **Keep PRs focused and atomic.** Maintainers prefer a clean, single-purpose PR (e.g., \"Bump haanna version to 0.14.0\") instead of a mixed set of changes. This makes review easier, minimizes merge conflicts, and reduces the risk that an otherwise good fix is blocked by process or structural issues.\n\n5. **Multi-device scenarios expose assumptions in integrations.** The issue with two Anna thermostats in one HA system shows that many integrations are initially implemented with a single-device mental model. Supporting multiple instances often requires careful handling of identifiers, configuration flows, and addressing to avoid collisions or misrouting data.\n\nTogether, these lessons emphasize that robust integration work requires both: (a) good abstraction of device signals into the platform’s model, and (b) disciplined use of the project’s tooling and guidelines when shipping the fixes.",
        "procedural_memory": [
            "How to update an integration that depends on an external library and ensure the PR is acceptable in a large project like Home Assistant:",
            "Step 1: Identify the upstream fix and target version.\n- Confirm that the external library (e.g., haanna) has released a version that fixes the issues you’re addressing.\n- Read the library’s changelog and relevant issue references (e.g., haanna issue #14) to ensure the new version actually contains the needed fixes.",
            "Step 2: Verify the fix locally with the new library version.\n- In your development environment, install the new library version (e.g., via pip install -e or editing your local requirements).\n- Run Home Assistant (or the relevant project) against real or simulated devices (e.g., one or two Anna thermostats) and confirm the issues are resolved.\n- Specifically test edge cases: multiple devices, on/off-only heaters, different boiler states, etc.",
            "Step 3: Update the integration’s dependency declaration.\n- In Home Assistant, bump the version in the integration’s manifest.json (e.g., requirement 'haanna==0.14.0').\n- Do not manually edit generated central requirements files; use the prescribed scripts instead.",
            "Step 4: Regenerate derived requirement files using project tooling.\n- Run the official script (for HA: `python3 -m script.gen_requirements_all`).\n- This will update `requirements_all.txt` and any other derived files consistently.\n- Verify these changes are minimal and match the new version you expect.",
            "Step 5: Update integration logic to expose new/changed behavior.\n- If the library exposes new attributes (e.g., `boiler_state`) that should map into platform attributes (e.g., `heating_state`), update the integration code (e.g., climate.py) to perform this mapping.\n- Ensure the mapping is robust and handles all known values (e.g., boiler on/off, error states, unknown).",
            "Step 6: Add or adjust tests.\n- Add unit tests that cover the new behavior, such as verifying that when boiler_state == 'on', the climate entity’s heating_state (or equivalent) is reported as heating.\n- If applicable, add tests for multi-device scenarios (e.g., two Anna thermostats) to ensure entities are correctly separated and no data collisions occur.",
            "Step 7: Run the full local test suite and linting.\n- Execute the project’s test command (in HA: `tox` or the recommended test invocation).\n- Fix any test or lint failures before creating the PR.",
            "Step 8: Prepare a clean, focused PR.\n- Ensure your branch has only the necessary changes: manifest version bump, regenerated requirements, and relevant integration code changes.\n- Avoid unrelated formatting, refactors, or unrelated feature additions.\n- If requested by maintainers, consider splitting the work: one PR for the library bump, another for climate logic changes, etc.",
            "Step 9: Follow the PR template and checklist.\n- Fill in the issue references, description, and checklist honestly (tests run, scripts executed).\n- Explicitly mention new behaviors (e.g., \"heating_state is now deduced from boiler_state for on/off heaters\").\n- Note any breaking changes or configuration impacts.",
            "Step 10: Respond to maintainer feedback and iterate.\n- If maintainers request changes (e.g., single commit, or only the version bump), adjust your branch accordingly: squash commits, drop extra changes, or open a fresh PR from a clean branch.\n- Keep the PR small and consistent with the project’s contribution guidelines to improve the chances of acceptance.",
            "Step 11: For similar state-mapping bugs in the future:\n- Inspect the device/library for a low-level status flag (like boiler_state).\n- Map that flag into the platform’s canonical state attributes (like heating, idle, off).\n- Add tests that validate the mapping for each possible value.\n- Re-run tests before pushing and ensure derived files are always generated by scripts, not hand-edited."
        ]
    }
}
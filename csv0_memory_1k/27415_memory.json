{
    "search_index": {
        "description_for_embedding": "Refactor of Home Assistant's wake_on_lan integration to move the third-party wakeonlan import from inside functions and class initializers to module-level imports, aligning with project standards and fixing related tests and integration behavior.",
        "keywords": [
            "wake_on_lan",
            "wakeonlan",
            "Home Assistant",
            "top-level imports",
            "lazy imports",
            "integration tests",
            "refactor",
            "code style",
            "component initialization",
            "Python import location"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In the Home Assistant core repository, the wake_on_lan integration had its dependency on the third-party 'wakeonlan' library imported inside runtime code paths: within the async_setup() function in __init__.py and inside the WOLSwitch.__init__ constructor in switch.py. This pattern deviated from the project's expectation that external dependencies be imported at module level and contributed to test issues and style violations. A pull request was created to move 'import wakeonlan' to the top of both modules and remove the inner imports, making the dependency explicit at import time and simplifying the code. However, there were process issues: the contributor removed the PR template and hadn't signed the CLA, so maintainers requested these be fixed, and later noted that the integration had been fixed in a different PR (#28100). The technical change itself was straightforward: add 'import wakeonlan' alongside other imports at the top of wake_on_lan/__init__.py and wake_on_lan/switch.py, and delete the redundant imports inside async_setup() and WOLSwitch.__init__.",
        "semantic_memory": "In Python projects, especially large frameworks like Home Assistant, third-party library imports are generally expected to be declared at the top of the module instead of inside functions or class methods. Top-level imports make dependencies explicit, allow import-time failures to surface early, simplify static analysis and linting, and often align with testing infrastructure that inspects modules. While lazy imports (inside functions) can be useful to reduce startup time or optional dependencies, they can also hide missing dependencies until a specific code path is executed and complicate reasoning about module behavior. Many projects adopt a convention that if a dependency is required for the module to function at all, it should be imported at module level. Only truly optional or heavy dependencies that are not always needed (and are guarded by availability checks) should use lazy imports. Ensuring that imports obey project conventions can also prevent subtle issues in tests, dependency analyzers, and code generation tools that rely on static import graphs.",
        "procedural_memory": [
            "To fix issues or style violations caused by imports inside functions or methods, first identify where non-standard or lazy imports are used.",
            "Step 1: Scan the module for 'import' statements inside functions, methods, or class bodies, particularly for third-party libraries that are required for normal operation.",
            "Step 2: Determine whether each such dependency is truly optional or required. If the code cannot reasonably run without it (e.g., core functionality depends on it), treat it as a required dependency.",
            "Step 3: For required dependencies, move the 'import some_library' statement to the top of the file with the other imports. Remove the corresponding inner import statements from functions or constructors.",
            "Step 4: If the project uses dependency metadata (requirements files, manifest, setup.py, etc.), verify that the dependency is correctly declared so that importing it at module level will consistently succeed in supported environments.",
            "Step 5: Run the project's test suite and linters to confirm there are no import errors, circular import issues, or style violations. Pay special attention to tests that import the module directly, as they may previously have passed due to lazy imports masking missing dependencies.",
            "Step 6: For cases where lazy imports are needed (e.g., optional features or heavy dependencies), document the reasoning in comments and ensure that call sites handle ImportError gracefully, possibly via feature flags or configuration checks.",
            "Step 7: When contributing to a large project, ensure process requirements are met (e.g., do not delete PR templates, sign the CLA, follow contribution guidelines) so that technical fixes like refactoring imports can be reviewed and merged without administrative blockers."
        ]
    }
}
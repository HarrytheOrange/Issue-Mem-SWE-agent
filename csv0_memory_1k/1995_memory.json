{
    "search_index": {
        "description_for_embedding": "Pack file view API responses were using Cache-Control max-age caching, causing clients to receive stale workflow/pack files for up to 90 seconds. The fix adds proper HTTP conditional request support with Last-Modified and ETag headers based on file mtime, returns 304 Not Modified when appropriate, removes Cache-Control for these resources, and disables framework-level content-type guessing in gunicorn/pecan.",
        "keywords": [
            "HTTP caching",
            "ETag",
            "Last-Modified",
            "If-None-Match",
            "If-Modified-Since",
            "304 Not Modified",
            "Cache-Control removal",
            "st2api",
            "packviews",
            "static file serving",
            "Pecan response headers",
            "gunicorn_config guess_content_type_from_ext",
            "stale content",
            "conditional GET"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this incident, the StackStorm API endpoint for serving pack files (`st2api.controllers.v1.packviews.FilesController`) used a `Cache-Control: public, max-age=86400` header (later reduced to 90 seconds) without conditional validation. This meant that when users edited workflow definitions or other pack files, browsers and intermediate caches could keep serving a cached version for the full max-age period, even if the underlying file changed. As noted in the discussion, this caused situations where requesting a workflow definition within the 90-second window always returned the previous version, ignoring updates.\n\nTo fix this, the developer implemented HTTP conditional GET semantics using ETag and Last-Modified headers based on the file's modification time. Internally, `_get_file_size` was refactored into `_get_file_stats`, returning both file size and `st_mtime`. A new helper `_is_file_changed` reads `If-None-Match` and `If-Modified-Since` from the incoming request via `pecan.request`. If the ETag (represented as `repr(file_mtime)`) matches `If-None-Match`, or the formatted Last-Modified timestamp matches `If-Modified-Since`, the method concludes the file has not changed and the endpoint returns a `304 Not Modified` response instead of the file body. If no conditional headers are present, it assumes the file has changed and returns the full content.\n\nA helper `_add_cache_headers` was added to set `Last-Modified` and `ETag` consistently on both 200 and 304 responses, ensuring clients can reliably validate their caches. Initially this helper also set `Cache-Control: public, max-age=90`, but due to concerns that any fixed lifetime was incorrect for these dynamic resources, the Cache-Control header was removed entirely, leaving only the validators (ETag and Last-Modified).\n\nUnit tests were added in `st2api/tests/unit/controllers/v1/test_packs_views.py` to verify the new behavior: confirming the presence of ETag and Last-Modified on successful responses, and ensuring that subsequent requests with matching `If-None-Match` or `If-Modified-Since` headers yield 304 Not Modified, while mismatched headers correctly return 200 OK with content.\n\nAdditionally, the gunicorn/pecan app configuration `st2api/st2api/gunicorn_config.py` was updated to include `'guess_content_type_from_ext': False`. This disables automatic content-type guessing based on file extensions at the framework layer, which can interfere with APIs that explicitly set `Content-Type`, and aligns better with the controllerâ€™s own content-type handling.",
        "semantic_memory": "This fix illustrates how to implement correct HTTP caching behavior for file-serving endpoints and why naive use of Cache-Control can be problematic for dynamic or frequently-changing resources.\n\nKey concepts and patterns:\n\n1. **Use Validators (ETag, Last-Modified) for Dynamic Resources:**\n   For resources where you cannot confidently define a 'correct' freshness lifetime (like configuration or workflow files that may change at any time), relying solely on `Cache-Control: max-age` is dangerous. Instead, provide validators (ETag and/or Last-Modified) so clients can perform conditional GETs and the server can return `304 Not Modified` when appropriate.\n\n2. **ETag and Last-Modified Derivation:**\n   - ETag should ideally be a content-based hash, but when that is too expensive, file metadata such as modification time can be used as a practical heuristic.\n   - Last-Modified should be a properly formatted HTTP-date. Using `wsgiref.handlers.format_date_time(file_mtime)` is a standard and library-supported way to produce this value.\n\n3. **Conditional Request Handling Logic:**\n   - If `If-None-Match` is present, compare it against the current ETag. If it matches, return 304 and do not send the body.\n   - Else if `If-Modified-Since` is present, compare it to the current Last-Modified date. If unchanged, return 304.\n   - If neither header is provided, assume the resource is changed and return the full body.\n   This respects HTTP/1.1 semantics while remaining simple to implement.\n\n4. **Avoid Over-Confident Cache-Control for Non-Static Assets:**\n   Setting a non-zero `max-age` on resources that can change unpredictably can force clients and intermediaries to remain on stale data for the duration of that max-age. Removing or minimizing Cache-Control for such resources, while using validators, provides a safer and more accurate caching model.\n\n5. **Consistent Headers on 200 and 304 Responses:**\n   Returning ETag and Last-Modified on both successful (200) and Not Modified (304) responses ensures client caches remain consistent and can continue to use conditional requests effectively.\n\n6. **Tests for Caching Behavior:**\n   Caching behavior can be subtle and easy to break. Unit tests that verify both presence of headers and correctness of 304/200 responses under various request headers are important for maintaining correctness.\n\n7. **Framework-Level Content-Type Guessing:**\n   When building an API that explicitly sets `Content-Type`, global or framework-level auto-guessing (e.g., based on file extension) may cause mismatches or unexpected behavior. Disabling such guessing (`guess_content_type_from_ext = False`) ensures explicit headers from the controller take precedence and keeps behavior predictable.",
        "procedural_memory": [
            "Step-by-step methodology to diagnose and fix stale file responses and incorrect HTTP caching behavior in an API that serves files.",
            "Step 1: Reproduce and confirm the stale caching behavior.\n- Make repeated requests to the file-serving endpoint (e.g., `/packs/views/file/...`).\n- Modify the underlying file contents on disk within the configured cache max-age window.\n- Observe whether the client still receives the old content (confirm via response body and possibly cache headers). If the content does not reflect recent changes, caching is likely too aggressive or incorrectly configured.",
            "Step 2: Inspect existing cache-related headers.\n- Log or capture the HTTP response headers from the API.\n- Look for `Cache-Control`, `ETag`, `Last-Modified`, `Expires`, and related fields.\n- If there is a `Cache-Control: max-age=...` without ETag/Last-Modified, and resources change more frequently than `max-age`, the design is likely flawed.",
            "Step 3: Decide caching strategy for the resource type.\n- Determine if the resource is truly static (e.g., versioned assets) or logically dynamic (e.g., config files, workflow definitions).\n- For static assets: using `Cache-Control: max-age` plus validators is fine.\n- For dynamic assets: strongly consider removing or minimizing `Cache-Control`, relying mainly on validators (ETag/Last-Modified) so freshness is validated on each request.",
            "Step 4: Implement ETag and Last-Modified generation.\n- At the point where you read or identify the file, obtain its metadata:\n  - Use `os.stat(file_path)` to get `st_size` and `st_mtime` (size and modification time).\n- Define helper functions:\n  - `_get_file_stats(file_path) -> (size, mtime)` that returns `(None, None)` when the file is missing.\n  - Optionally `_get_file_size` that wraps `_get_file_stats` if needed for other checks.\n- Convert `file_mtime` into HTTP date format using `format_date_time(file_mtime)` from `wsgiref.handlers`.\n- Choose an ETag strategy:\n  - Ideal: hash of file contents (e.g., SHA-1) when performance allows.\n  - Pragmatic: `repr(file_mtime)` or a combination of size and mtime if hashing is too expensive.\n- Ensure these headers are set on the response:\n  - `response.headers['Last-Modified'] = format_date_time(file_mtime)`\n  - `response.headers['ETag'] = repr(file_mtime)` (or your chosen format)",
            "Step 5: Implement conditional GET handling.\n- Expose the request object (e.g., `from pecan import request`).\n- Implement a helper `_is_file_changed(file_mtime)` that:\n  - Reads `if_none_match = request.headers.get('If-None-Match')`.\n  - Reads `if_modified_since = request.headers.get('If-Modified-Since')`.\n  - If `if_none_match` is present:\n    - Compute the current ETag and compare: `return repr(file_mtime) != if_none_match`.\n  - Else if `if_modified_since` is present:\n    - Compare with the current Last-Modified: `return if_modified_since != format_date_time(file_mtime)`.\n  - If neither header is present:\n    - Return `True` (assume file changed so client gets a fresh copy).",
            "Step 6: Use conditional logic in the controller.\n- After obtaining `file_size, file_mtime = _get_file_stats(file_path)`:\n  - If the file does not exist, raise an appropriate not-found error.\n  - Before reading file contents, call `_is_file_changed(file_mtime)`:\n    - If it returns `False`:\n      - Call `_add_cache_headers(file_mtime)` so response has ETag/Last-Modified.\n      - Set `response.status = http_client.NOT_MODIFIED` (304).\n      - Return the response without a body.\n    - If it returns `True`:\n      - Apply any size checks (e.g., compare to `MAX_FILE_SIZE`).\n      - Set `Content-Type` explicitly (e.g., using `mimetypes.guess_type` or a known type).\n      - Call `_add_cache_headers(file_mtime)` to add ETag/Last-Modified.\n      - Read and assign the file content to `response.body`.\n      - Return the 200 OK response.",
            "Step 7: Adjust Cache-Control as appropriate.\n- Re-evaluate the need for `Cache-Control` on this endpoint:\n  - If the resource is dynamic and you cannot define safe lifetimes, remove `Cache-Control` or set it to a conservative value like `no-cache` or `max-age=0`.\n  - In this specific fix, `Cache-Control: public, max-age=90` was removed entirely from `_add_cache_headers` to avoid serving stale workflow files for any fixed time period.\n- Ensure that your decision aligns with any intermediaries (e.g., nginx) and their caching behavior.",
            "Step 8: Ensure consistent setting of caching headers.\n- Implement a helper `_add_cache_headers(file_mtime)` that:\n  - Sets `Last-Modified` and `ETag` using the same logic used in `_is_file_changed`.\n- Call this helper in both code paths (200 OK and 304 Not Modified) so clients always receive up-to-date validators.",
            "Step 9: Update and add tests.\n- Add unit tests that:\n  - Verify that a normal GET returns 200 OK and includes non-null `ETag` and `Last-Modified` headers.\n  - Make a second GET with `If-None-Match` set to the previous ETag and assert 304 Not Modified.\n  - Make another GET with `If-Modified-Since` set to the previous Last-Modified and assert 304 Not Modified.\n  - Make GETs with mismatched `If-None-Match` and `If-Modified-Since` values and assert 200 OK with the expected body.\n- This ensures that both branches of your conditional logic are covered and correct.",
            "Step 10: Review framework-level content-type handling.\n- Check whether your framework (gunicorn, Pecan, etc.) automatically guesses `Content-Type` based on file extension (`guess_content_type_from_ext`).\n- If your API explicitly sets `Content-Type`, disable this guessing to avoid conflicts:\n  - For example, set `'guess_content_type_from_ext': False` in the gunicorn/pecan configuration.\n- Verify that your responses still carry correct `Content-Type` values as set in your controller.",
            "Step 11: Deploy and monitor.\n- Deploy the changes to a staging environment first.\n- Use browser dev tools or tools like `curl` to confirm:\n  - Presence of ETag and Last-Modified on file responses.\n  - Correct 304 responses when using conditional headers.\n  - Absence or correctness of Cache-Control for these endpoints.\n- Observe logs and client behavior to ensure that updated files are served immediately after changes and that superfluous full-body transfers are reduced via 304 responses."
        ]
    }
}
{
    "search_index": {
        "description_for_embedding": "Introduced a Zeroconf-based discovery pipeline for Home Assistant config entries. Integrations can now declare mDNS service types in their manifest, hassfest generates a central mapping (generated/zeroconf.py), and the zeroconf component listens for those services via aiozeroconf, converts ServiceInfo into a normalized dict (host, port, hostname, type, name, properties), and starts config entry flows with source 'zeroconf'. Axis was migrated off legacy discovery to this new mechanism, and tests/mocks were added for Zeroconf service discovery.",
        "keywords": [
            "Home Assistant",
            "zeroconf",
            "mDNS",
            "aiozeroconf",
            "service discovery",
            "config entries",
            "config_flow",
            "hassfest",
            "generated/zeroconf.py",
            "Axis integration",
            "discovery deprecation",
            "ServiceBrowser",
            "ServiceInfo",
            "unicode decode error",
            "test mocking async network"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This pull request implemented Zeroconf-based discovery for Home Assistant config entries and began migrating integrations away from the legacy discovery/netdisco mechanism.\n\nPreviously, integrations like Axis used the generic discovery component (netdisco) and a discovery-specific config_flow step (async_step_discovery). Discovery logic was largely centralized and less declarative.\n\nThe PR introduced a dedicated zeroconf integration that both advertises Home Assistant on the network and listens for remote devices using aiozeroconf:\n- A new `homeassistant/components/zeroconf/__init__.py` sets up a single `Zeroconf` instance and registers Home Assistant under `_home-assistant._tcp.local.` using `ServiceInfo` with metadata (version, base URL, etc.).\n- For discovery, it reads a generated mapping from `homeassistant/generated/zeroconf.py` (named `zeroconf_manifest`), which maps mDNS service types (e.g. `\"_axis-video._tcp.local.\"`) to integration domains (e.g. `\"axis\"`).\n- For each service type in that mapping, it starts an `aiozeroconf.ServiceBrowser`. When `ServiceStateChange.Added` occurs, it calls `get_service_info`, passes the result to `info_from_service`, and logs a debug message.\n\n`info_from_service` converts an `aiozeroconf.ServiceInfo` into a normalized dict:\n- Extracts IP address from `service.address` or `service.address6` using `ipaddress.ip_address`.\n- Adds `host`, `port`, `hostname`, `type`, `name`.\n- Iterates over `service.properties`, decoding keys and values from bytes to UTF-8 strings with a `try/except UnicodeDecodeError`. If a property cannot be decoded, it logs a warning instead of failing.\n- Packs the decoded properties into a `properties` dict.\n\nFor each domain listed under `SERVICE_TYPES[service_type]`, the zeroconf component starts a config entry flow:\n- `hass.config_entries.flow.async_init(domain, context={'source': 'zeroconf'}, data=info)`\n\nThe Axis integration was the first consumer of this pipeline:\n- `axis/manifest.json` was updated with a `\"zeroconf\": [\"_axis-video._tcp.local.\"]` entry.\n- Axis was removed from `discovery.CONFIG_ENTRY_HANDLERS`, effectively moving it off the legacy discovery integration.\n- Axis's config flow renamed `async_step_discovery` to `async_step_zeroconf` so that config entries initiated with `source='zeroconf'` are routed correctly. Tests were updated to use the `zeroconf` source instead of `discovery`.\n\nThe hassfest tooling was extended to support this new declarative zeroconf model:\n- The manifest schema gained an optional `zeroconf` field (list of service-type strings).\n- A new `script/hassfest/zeroconf.py` plugin scans all integration manifests, collects their `zeroconf` entries, and generates `homeassistant/generated/zeroconf.py` containing `SERVICE_TYPES = {service_type: [domains...]}`.\n- `hassfest.validate` compares the on-disk `generated/zeroconf.py` with the freshly generated content and errors if it is out of date, instructing developers to run `python3 -m script.hassfest`.\n\nTests were added to validate the zeroconf setup logic:\n- `tests/components/zeroconf/test_init.py` patches `zeroconf.ServiceBrowser` so that its side effect directly invokes the handler with a fake `ServiceStateChange.Added`, and patches `Zeroconf.get_service_info` to return a crafted `ServiceInfo` containing a `macaddress` property and a fixed IP (address bytes `b'\\n\\x00\\x00\\x14'`).\n- The test runs `async_setup_component(hass, 'zeroconf', { 'zeroconf': {} })`, waits for tasks to complete, and asserts that one `ServiceBrowser` was instantiated and one config flow was started.\n\nAdditional changes:\n- Added `aiozeroconf==0.1.8` to `requirements_test_all.txt` and whitelisted it in `script/gen_requirements_all.py`.\n- Added empty test package scaffolding under `tests/components/zeroconf/`.\n- Cleaned up some minor implementation details: removed unused imports, improved docstrings, added `ATTR_TYPE` and `ATTR_NAME` fields, and replaced print statements with proper logging.\n\nThe net effect is a robust, extensible Zeroconf-based discovery system where integrations declaratively specify their mDNS service types, hassfest generates the mapping, the zeroconf component listens and translates mDNS ServiceInfo into a standard dict, and config flows are started consistently using `source='zeroconf'`.\n",
        "semantic_memory": "This change demonstrates a general pattern for implementing network service discovery in a modern, maintainable way:\n\n1. **Declarative discovery configuration per integration**\n   - Each integration declares the network service types it cares about (here, mDNS/zeroconf service types like `_axis-video._tcp.local.`) directly in its manifest.\n   - A central tool (hassfest) collects these declarations and generates a canonical mapping (service-type -> list of integration domains) used by the discovery subsystem.\n   - This decouples discovery from specific integrations and removes ad-hoc, hardcoded mappings scattered throughout the codebase.\n\n2. **Single discovery component with a unified pipeline**\n   - A dedicated component (zeroconf) owns discovery responsibilities for that protocol, instead of each integration implementing discovery separately.\n   - It sets up a single underlying library instance (`Zeroconf` from aiozeroconf) and reuses it across all service browsers and lookups to avoid duplicated sockets and state.\n   - For each service type in the manifest-generated mapping, it starts a `ServiceBrowser`, listens for `ServiceStateChange.Added`, and fetches `ServiceInfo` via `get_service_info`.\n\n3. **Normalization of raw discovery data**\n   - A helper (`info_from_service`) reduces raw library structures (e.g., `ServiceInfo`) to a simple, consistent schema: host, port, hostname, type, name, and a properties dict.\n   - It handles encoding concerns robustly by decoding bytes to strings and logging (not crashing) on `UnicodeDecodeError`.\n   - It derives address information using `ipaddress` to get human-friendly IP strings and to support both IPv4 and IPv6.\n   - Having a stable data contract (the normalized dict) makes it easy for config flows or other subsystems to consume discovery data without needing to know about the underlying library.\n\n4. **Integration with config entry flows**\n   - Discovery events are converted into config-entry flows via `hass.config_entries.flow.async_init(domain, context={'source': 'zeroconf'}, data=info)`, where `source` names the mechanism that initiated the flow.\n   - Config flows must implement an appropriately named step (`async_step_zeroconf`) that accepts `discovery_info` and handles known/unknown devices, link-local addresses, and duplicate configuration appropriately.\n   - This pattern cleanly separates external discovery from internal configuration logic; the integration only sees a structured `discovery_info` dict and a source label.\n\n5. **Migration away from legacy discovery systems**\n   - Existing discovery mechanisms (e.g., netdisco) can be incrementally deprecated by:\n     - Removing integrations from old handler tables and adding `zeroconf` declarations to their manifests.\n     - Updating their config flows to handle `source='zeroconf'` and, if necessary, maintain backward compatibility for legacy flows.\n   - This enables a gradual migration without a disruptive breaking change.\n\n6. **Tooling-driven correctness and consistency**\n   - Code generation plus validation (via hassfest) ensures the generated mapping (`generated/zeroconf.py`) is kept in sync with manifests.\n   - CI can fail if the generated file is out of date, guiding developers to run the generator.\n   - This approach eliminates a class of subtle bugs where a developer forgets to update a shared mapping when adding or modifying an integration.\n\n7. **Testing async, network-dependent code through mocking**\n   - Rather than performing real network I/O, tests patch the discovery library’s entry points (e.g., `ServiceBrowser` and `Zeroconf.get_service_info`) to simulate events and responses.\n   - The mocked `ServiceBrowser` immediately invokes the provided handler with a crafted `ServiceStateChange.Added`, and `get_service_info` returns a known `ServiceInfo` object.\n   - This verifies that the component reacts correctly to discovery events (starting a config flow) without requiring an actual mDNS environment.\n\nThese patterns generalize to any system that needs to discover networked devices or services using protocols like mDNS, SSDP, or custom discovery protocols: use declarative configuration, centralize and normalize discovery data, unify the trigger path into configuration flows, provide robust decoding and error handling, and rely on tooling and tests to keep generated discovery metadata in sync.\n",
        "procedural_memory": [
            "Step-by-step guide to implementing or migrating to a Zeroconf-based discovery system for integrations:",
            "Step 1: Add declarative zeroconf configuration to the integration manifest",
            "- In the integration’s `manifest.json`, add a `\"zeroconf\"` key listing the mDNS service types your devices advertise.",
            "- Example:\n  ```json\n  {\n    \"domain\": \"axis\",\n    \"name\": \"AXIS\",\n    \"requirements\": [\"axis==23\"],\n    \"dependencies\": [],\n    \"documentation\": \"https://www.home-assistant.io/components/axis\",\n    \"zeroconf\": [\"_axis-video._tcp.local.\"],\n    \"codeowners\": [\"@kane610\"]\n  }\n  ```",
            "Step 2: Extend or implement a centralized zeroconf component",
            "- Ensure you have a component responsible for zeroconf discovery (e.g., `components/zeroconf/__init__.py`).",
            "- In `async_setup`, create a single `Zeroconf` instance and register your own application’s service if needed:\n  - Compose a service name, e.g. `f\"{hass.config.location_name}._home-assistant._tcp.local.\"`.\n  - Use `ServiceInfo` to describe the service (port, hostname, properties) and call `zeroconf.register_service(info)`. Always make sure to unregister and close in a cleanup callback on shutdown.\n- Import the generated mapping module (e.g., `from homeassistant.generated import zeroconf as zeroconf_manifest`).",
            "Step 3: Generate and maintain the mapping from service types to domains",
            "- Implement a build-time/tooling plugin (like hassfest’s `zeroconf.py`) that:\n  - Iterates over all integrations and reads their `manifest.json`.\n  - Aggregates all declared `zeroconf` service types into a dict: `{service_type: [domains...]}`.\n  - Writes a Python module (e.g., `homeassistant/generated/zeroconf.py`) with a constant like `SERVICE_TYPES = { ... }`.\n- Add a validation step that compares the generated content with the on-disk file and raises a fixable error if they differ, telling developers to run the generator.\n- Integrate this into CI to ensure the mapping is always fresh.",
            "Step 4: Watch for zeroconf services and normalize the data",
            "- In your zeroconf component, for each `service_type` in `zeroconf_manifest.SERVICE_TYPES`:\n  - Create a `ServiceBrowser(zeroconf, service_type, handlers=[service_update])`.\n  - Implement `service_update(_, service_type, name, state_change)` to react to `ServiceStateChange.Added` and ignore or handle other events as needed.\n  - On `Added`, call an async helper `new_service(service_type, name)` that:\n    - Calls `service_info = await zeroconf.get_service_info(service_type, name)`.\n    - Passes `service_info` into `info_from_service` to build a normalized dict.\n    - Logs the discovery via the logger (debug level), not `print`.\n    - For each domain in `zeroconf_manifest.SERVICE_TYPES[service_type]`, starts a config flow via:\n      ```python\n      hass.async_create_task(\n          hass.config_entries.flow.async_init(\n              domain,\n              context={\"source\": \"zeroconf\"},\n              data=info,\n          )\n      )\n      ```",
            "Step 5: Implement `info_from_service` to convert raw ServiceInfo into a stable schema",
            "- Write a helper that takes a `ServiceInfo` and returns a dict similar to:\n  ```python\n  def info_from_service(service):\n      properties = {}\n      for key, value in service.properties.items():\n          try:\n              if isinstance(value, bytes):\n                  value = value.decode(\"utf-8\")\n              properties[key.decode(\"utf-8\")] = value\n          except UnicodeDecodeError:\n              _LOGGER.warning(\"Unicode decode error on %s: %s\", key, value)\n\n      address = service.address or service.address6\n\n      return {\n          \"host\": str(ipaddress.ip_address(address)),\n          \"port\": service.port,\n          \"hostname\": service.server,\n          \"type\": service.type,\n          \"name\": service.name,\n          \"properties\": properties,\n      }\n  ```\n- Ensure this function is tolerant of invalid/undecodable bytes: catch `UnicodeDecodeError`, log a warning, and continue.\n- This normalized data model becomes the contract that config flows rely on.",
            "Step 6: Update the integration’s config flow to handle zeroconf source",
            "- In the integration’s config flow (`config_flow.py`), add a step method named after the discovery source, e.g. `async_step_zeroconf(self, discovery_info)`.\n- This method should:\n  - Inspect `discovery_info` (host, properties, etc.).\n  - Abort if the device is already configured (e.g., matching a stored MAC address or host).\n  - Abort if the host is a link-local address or otherwise invalid for configuration.\n  - Otherwise, pre-fill or transition into the normal `user` step.\n- Update tests and any references to the old `async_step_discovery` to use `async_step_zeroconf` and `context={\"source\": \"zeroconf\"}`.",
            "Step 7: Remove integration from legacy discovery handlers",
            "- If migrating from an older discovery system (like netdisco), remove the integration’s key from any legacy handler tables (e.g., `CONFIG_ENTRY_HANDLERS` in a `discovery` component).",
            "Step 8: Add or adjust tests to simulate zeroconf discovery",
            "- Create tests under the zeroconf component to assert that:\n  - `async_setup_component(hass, 'zeroconf', {...})` sets up the component.\n  - Service browsers are created for each service type.\n  - A simulated `ServiceStateChange.Added` event causes a config entry flow to start.\n- Use mocking to avoid actual network traffic:\n  - Mock `ServiceBrowser` so that its constructor calls the supplied handler(s) with a crafted (service_type, name, `ServiceStateChange.Added`).\n  - Mock `Zeroconf.get_service_info` to return a deterministic `ServiceInfo` instance (with a known address and property set).\n  - Assert that `hass.config_entries.flow.async_init` or `hass.config_entries.flow` was called as expected.",
            "Step 9: Ensure dependencies and requirements are correctly updated",
            "- Add the zeroconf library (e.g. `aiozeroconf`) to test or runtime requirements as appropriate:\n  - In test requirements: `aiozeroconf==<version>`.\n  - Add to the allowed list in your requirement generation script (like `script/gen_requirements_all.py`).",
            "Step 10: Run tooling and formatting",
            "- Run the generator (e.g., `python3 -m script.hassfest`) to update `homeassistant/generated/zeroconf.py`.\n  - Run your test suite (`tox`, `pytest`, etc.) to ensure the new zeroconf pipeline is covered and passes.\n  - Fix any static analysis complaints (unused imports, line length, missing docstrings) and replace any temporary `print` debugging with proper logging calls before merging."
        ]
    }
}
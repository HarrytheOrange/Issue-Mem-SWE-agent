{
    "search_index": {
        "description_for_embedding": "Introduced application‑wide distance units in Home Assistant (config.distance_unit), including a centralized distance conversion utility, configuration validation, auto‑detection based on location, and integration into the proximity component and core distance() API. Also extended the flux switch to support color temperature modes (xy, mired, kelvin) and improved proximity to handle multiple zones.",
        "keywords": [
            "distance_unit",
            "distance conversion",
            "homeassistant.util.distance",
            "homeassistant.config",
            "hass.config.distance_unit",
            "unit_of_measurement",
            "proximity component",
            "multiple proximities",
            "flux switch",
            "mired mode",
            "kelvin mode",
            "unit validation",
            "metric vs imperial",
            "auto-detect location units",
            "LocationInfo.use_miles"
        ]
    },
    "agent_memory": {
        "episodic_memory": "This PR implemented an application‑wide distance unit configuration in Home Assistant and integrated it throughout the system, while also enhancing a few related components.\n\nInitially, distances were implicitly handled in meters or kilometers and individual components (like proximity) hard‑coded their units (e.g., proximity always reported in km and manually divided meters by 1000). There was no global configuration for distance units, which made it awkward to support both metric and imperial users consistently.\n\nTo address this, the author introduced a new utility module `homeassistant.util.distance` with:\n- Unit symbols: `km`, `m`, `ft`, `mi` and constants `KILOMETERS_SYMBOL`, `METERS_SYMBOL`, `FEET_SYMBOL`, `MILES_SYMBOL`.\n- A `VALID_UNITS` list and a `UNIT_LABELS` dict mapping symbols to human‑readable names.\n- A single `convert(value, unit_1, unit_2)` function that converts between any supported units via a canonical intermediate (meters). It validates that `value` is numeric (using `numbers.Number`) and that both units are in `VALID_UNITS`, otherwise raising `TypeError` or `ValueError` and logging a clear error.\n\nThe conversion logic went through several iterations: initially there were many pairwise conversion helpers (kilometers_to_miles, miles_to_kilometers, etc.) with some mistakes (e.g., km↔m factors inverted) and complicated branching. These were gradually corrected and then refactored down to a normalized approach: convert the input unit to meters (via private helpers like `__miles_to_meters`, `__feet_to_meters`, `__kilometers_to_meters`), then convert meters to the target unit (`__meters_to_miles`, `__meters_to_feet`, `__meters_to_kilometers`). This reduced complexity and made it easier to reason about unit conversions.\n\nComprehensive tests were added in `tests/util/test_distance.py`:\n- Verifying identity conversions (same unit in/out).\n- Checking correct numeric conversions between all unit pairs (mi↔km↔m↔ft) with explicit expected values.\n- Ensuring invalid unit symbols raise `ValueError` and non‑numeric values raise `TypeError`.\n\nNext, the core configuration was extended to support a distance unit:\n- Added `CONF_DISTANCE_UNIT = 'distance_unit'` to `homeassistant.const`.\n- In `homeassistant.config`, imported `UNIT_LABELS`, `KILOMETERS_SYMBOL`, and `MILES_SYMBOL` and constructed a human‑readable `DISTANCE_DESCRIPTION` for the core YAML example (e.g., `\"km for kilometers, mi for miles\"`).\n- Updated `DEFAULT_CORE_CONFIG` to include `(CONF_DISTANCE_UNIT, KILOMETERS_SYMBOL, None, DISTANCE_DESCRIPTION)`, making kilometers the default when auto‑discovery isn't used.\n- Extended the core config schema to accept `CONF_DISTANCE_UNIT` using a new validator `cv.distance_unit`, which checks membership in `homeassistant.util.distance.VALID_UNITS`.\n\nLocation auto‑detection was also updated:\n- `homeassistant.util.location.LocationInfo` gained a `use_miles` field in addition to `use_fahrenheit`.\n- `detect_location_info()` now sets `use_miles` based on the detected country code (US, LR, MM use miles), similar to how `use_fahrenheit` is computed.\n- `create_default_config()` uses `LocationInfo` to prefill `distance_unit` to miles if `use_miles` is true.\n- `process_ha_core_config()` was refactored: time‑zone setting and auto‑discovery logic were split into helper functions `__set_time_zone` and `__auto_discover` (and `__auto_discover_units`) to satisfy linting constraints. Auto‑discovery now also fills in `distance_unit` if missing: miles where `use_miles` is true, otherwise kilometers.\n\n`homeassistant.core.Config` was extended to actually use this new distance unit:\n- Added `self.distance_unit` to `Config.__init__` and to `as_dict()`.\n- The `Config.distance(lat, lon)` method, which previously returned a distance in meters using `homeassistant.util.location.distance`, now wraps that value in a call to `distance_util.convert(..., 'm', self.distance_unit)`. Thus all consumer code calling `hass.config.distance()` now receives values in the configured application‑wide unit instead of implicit meters.\n- A temporary debug `print` inside `distance()` was later removed.\n\nTests were updated to respect the new distance config:\n- `get_test_home_assistant()` now sets `hass.config.distance_unit = KILOMETERS_SYMBOL` by default.\n- Config tests were updated so the mocked `LocationInfo` returns both `use_fahrenheit` and `use_miles`, and expectations were extended to assert the correct `distance_unit` is set in various scenarios (default config, auto‑discovery success/failure, explicit YAML config overriding to `ft`, etc.).\n- `tests/helpers/test_template.py` explicitly sets `self.hass.config.distance_unit = 'm'` in its setup to keep existing distance‑related template expectations in meters.\n\nThe proximity component was refactored and integrated with the new distance unit:\n- Previously, `homeassistant/components/proximity.py` handled a single proximity config and always reported distance in km by dividing meters by 1000.\n- The PR added support for multiple proximity entries by introducing `setup_proximity_component(hass, config)` and modifying `setup(hass, config)` to handle both a single dict config or a list of proximity configs.\n- Each proximity config validates the presence of `'devices'` and logs an error / returns False if missing. Ignored zones, tolerance, and the target zone are extracted per config.\n- `unit_of_measure` for each proximity is now taken from the per‑component config `unit_of_measurement` if provided, else falls back to `hass.config.distance_unit` (the global distance unit).\n- Proximity entities now use that unit for `unit_of_measurement` and for the numeric distance calculation. The raw distance from `homeassistant.util.location.distance` (in meters) is fed into `distance_util.convert(dist_to_zone, 'm', self.unit_of_measure)` before being rounded.\n- The entity ID and zone IDs are constructed using string formatting instead of concatenation, and the default placeholders like `'not set'` were centralized as constants (`NOT_SET`, `DEFAULT_DIST_TO_ZONE`, etc.).\n- A couple of small bugs during refactoring—like misuse of `lstrip` on strings and a typo referencing `zone` instead of `zone_id`—were fixed.\n\nNew proximity tests were added in `tests/components/test_proximity.py`:\n- `test_proximities` verifies a list of proximities can be loaded (`home` and `work`), that they start in `'not set'` state with `'not set'` attributes, and that they can change state.\n- `test_proximities_missing_devices` ensures that if any proximity config in the list lacks `'devices'`, setup fails (returns False).\n\nFinally, the flux switch was enhanced to support additional color temperature modes:\n- In `homeassistant/components/switch/flux.py`:\n  - Added a new `mode` config option with allowed values `xy`, `mired`, `kelvin`, and constants `MODE_XY`, `MODE_MIRED`, `MODE_KELVIN`, `DEFAULT_MODE`.\n  - Extended `PLATFORM_SCHEMA` to validate `mode` as one of these values.\n  - Introduced `set_lights_temp(hass, lights, kelvin, mode)` to set color temperature directly via `color_temp`: if mode is `mired`, it converts the kelvin value to mired (`1_000_000 / kelvin`); if `kelvin`, uses the kelvin value as is. It loops over lights that are on and calls `turn_on` with `color_temp` and a transition.\n  - Updated `FluxSwitch` to store `_mode` and to compute a `temp` along the day/night color‑temperature curve, just as before. After computing `temp`, the code now decides whether to convert it to xy color with brightness (`MODE_XY`) or call `set_lights_temp` (for mired/kelvin modes). Logging was simplified to a common path that logs either xy values or temp with a shared `percentage_complete` and `time_state` (day/night).\n- Tests `test_flux_with_mired` and `test_flux_with_kelvin` were added in `tests/components/switch/test_flux.py`:\n  - They set up a test light, configure flux with `mode: 'mired'` or `mode: 'kelvin'`, run the flux update at a specific time, and assert that the final service call to `light.turn_on` has the expected `color_temp` (269 for mired, 3708 for kelvin in the chosen test scenario).\n\nOverall, this PR centralized distance unit handling for the entire application, provided robust conversion and validation, integrated it into core APIs and components (especially proximity), and extended flux with new color temperature modes. Along the way, tests were expanded and refactored to cover error conditions, configuration paths, and new behavior.",
        "semantic_memory": "General lessons and patterns from this change:\n\n1. **Centralize unit conversion and configuration**\n   - Instead of having multiple components manually convert or assume specific units, provide a single utility module (`util.distance`) with a canonical conversion path and a single public `convert` API.\n   - Represent units by simple, unambiguous symbols (e.g., `'m'`, `'km'`, `'ft'`, `'mi'`) and expose constants for them. This prevents mismatches across the codebase and makes validation trivial.\n   - Store application‑wide configuration (like distance units) in a shared configuration object (`hass.config.distance_unit`) and ensure all components derive their behavior from that instead of hard‑coding assumptions.\n\n2. **Normalize to a base unit to reduce complexity**\n   - When supporting multiple units, converting via a single base unit (meters) greatly simplifies the logic compared to maintaining every possible pairwise conversion.\n   - This pattern generalizes beyond distance: for any physical quantity (temperature, energy, time, etc.), choose a canonical base unit, convert inputs to that, then convert to the desired output unit.\n\n3. **Combine validation, logging, and error signaling**\n   - Validation functions should both log meaningful errors and raise explicit exceptions (`ValueError`, `TypeError`) when input is invalid (e.g., unsupported unit symbol, non‑numeric value). This enables both developer debugging and robust error handling by callers.\n   - Config validation (via `voluptuous` helper functions like `cv.distance_unit`) is a good place to enforce allowed values early and provide clear error messages to users.\n\n4. **Auto‑detection logic should be modular and testable**\n   - Breaking auto‑discovery into helper functions (`__set_time_zone`, `__auto_discover`, `__auto_discover_units`) makes the code easier to understand and to test, and allows incremental changes like adding a new unit (`distance_unit`) without overcomplicating a single giant function.\n   - Using a location abstraction (`LocationInfo`) that encapsulates both `use_fahrenheit` and `use_miles` makes it straightforward to auto‑configure units based on country code.\n\n5. **Backwards compatibility and defaults**\n   - When adding new configuration options (e.g., `distance_unit`, `mode` on flux), always provide sensible defaults that match existing behavior (kilometers and `xy`, respectively) so existing setups continue to work.\n   - Allow per‑component overrides (e.g., proximity can override the global distance unit if needed) but default to global settings to maintain consistency across the app.\n\n6. **Component refactoring: from single to multiple instances**\n   - Moving from a single configuration block to a list of configs (proximity) requires factoring out a `setup_*_component` helper that can be called for each item. This pattern is reusable whenever a component should support multiple instances (zones, trackers, etc.).\n   - Always validate key fields early (`'devices'` in proximity), fail fast for missing mandatory config, and ensure tests cover misconfiguration scenarios.\n\n7. **Linting and maintainability considerations**\n   - Limit branching complexity by splitting complex logic into helper functions (as with `convert`, auto‑discovery, and time‑zone setting). This not only satisfies linter constraints but also improves readability.\n   - Prefer string formatting (`'{}.{}'.format(domain, name)`) over manual concatenation to reduce subtle bugs.\n\n8. **Comprehensive testing strategy**\n   - When introducing a core utility (like distance conversion) that other code will rely on, provide extensive tests that:\n     - Verify correct results for a variety of inputs.\n     - Assert behavior on invalid units and types.\n     - Cover edge cases (zero, negative values, same unit conversion).\n   - Whenever you modify default configuration behavior, tests should be updated to assert both new defaults and override behavior.\n   - Adding tests for new modes or branches (flux `mode` values, multiple proximities) protects against regressions and documents intended behavior.\n\n9. **Design for extensibility**\n   - Encoding units and modes as constants and using validation schemas (`vol.Any(MODE_XY, MODE_MIRED, MODE_KELVIN)`) makes future expansion (e.g., adding more units or modes) straightforward and safe.\n\nThese principles—centralization of unit logic, normalizing to base units, strong validation, modular auto‑discovery, and comprehensive tests—are broadly applicable to any system that must handle user‑configurable measurement units or multiple behavioral modes.",
        "procedural_memory": [
            "How to add or fix application‑wide unit handling and conversions:",
            "Step 1: Introduce or extend a dedicated utility module for the quantity in question (e.g., `util.distance`). Define clear unit symbols as constants and a list of valid units.",
            "Step 2: Implement a single public conversion function `convert(value, from_unit, to_unit)` that:\n- Validates the numeric type of `value` (e.g., using `numbers.Number`).\n- Validates that `from_unit` and `to_unit` are in the valid units list.\n- Converts `value` to a canonical base unit (e.g., meters) and then from that base to the target unit.\n- Raises clear `TypeError` or `ValueError` on invalid input and logs informative error messages.",
            "Step 3: Add configuration support for the unit:\n- Define a new configuration constant (e.g., `CONF_DISTANCE_UNIT`).\n- Extend the core configuration schema (in `config.py`) to include this setting with a default value and description.\n- Implement a config validation helper (e.g., `cv.distance_unit`) that checks the value against your valid units list and normalizes (e.g., lowercasing).",
            "Step 4: Integrate auto‑detection and location data:\n- Attach unit preferences (e.g., `use_miles`) to your location abstraction (`LocationInfo`).\n- In your config creation and auto‑discover routines, use these flags to set sensible default units (e.g., miles in certain countries, kilometers otherwise).\n- Keep auto-detection logic in small helper functions so adding a new unit or preference doesn’t blow up complexity.",
            "Step 5: Wire the global config into core APIs:\n- Add a corresponding attribute on the global configuration object (`hass.config.distance_unit`).\n- Update methods that compute the quantity (e.g., `Config.distance(lat, lon)`) to return values in the configured unit by calling your `convert` function on the raw base-unit result.",
            "Step 6: Update and refactor components to use the utility and global setting:\n- Replace ad‑hoc conversions in components (e.g., dividing by 1000, assuming km) with calls to `util.distance.convert`.\n- Where appropriate, default component units of measurement to the global config (e.g., `unit_of_measurement = hass.config.distance_unit`), but allow per‑component overrides.\n- For components that may have multiple instances (like proximity to multiple zones), factor out a `setup_component` helper and make `setup()` iterate through a list or a single config value.",
            "Step 7: Strengthen tests:\n- Add unit tests for the new utility module verifying correct conversions, identity cases, invalid unit symbols, and non‑numeric values.\n- Extend configuration tests to cover new config options: defaults, auto‑discovery behavior, and explicit user overrides.\n- Add or update component tests (e.g., proximity, flux) to exercise new behaviors: multiple instances, new modes (mired/kelvin), and the effect of changing global units.",
            "Step 8: Clean up and ensure maintainability:\n- Remove temporary debug prints and unused code.\n- Address linter concerns by splitting overly complex functions into helpers and reducing unnecessary branches.\n- Use consistent string formatting and constants to avoid subtle bugs in entity IDs and unit names.",
            "Step 9: Validate end‑to‑end behavior:\n- Run integration tests or manual scenarios that compute distances or set color temperatures to confirm that values now reflect the configured units/modes.\n- Verify that existing setups behave as before when using default settings (backwards compatibility) while new configurations (e.g., imperial distance, flux mired mode) behave as expected."
        ]
    }
}
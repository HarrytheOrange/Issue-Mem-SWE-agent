{
    "search_index": {
        "description_for_embedding": "CronTimer trigger JSON schema was too strict (integers only) and did not accept cron-like expressions (a-b, */a, lists). The fix relaxes schema constraints to allow string or integer for cron fields and adds semantic validation by instantiating apscheduler CronTrigger, plus pins apscheduler to a compatible version and adds tests for invalid cron expressions.",
        "keywords": [
            "CronTimer",
            "CronTrigger",
            "apscheduler",
            "JSON schema validation",
            "cron-like expressions",
            "a-b ranges",
            "*/a step syntax",
            "day_of_week validation",
            "st2 timer triggers",
            "input validation",
            "ValueError",
            "API BAD_REQUEST",
            "dependency pinning"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In this change, the CronTimer trigger in StackStorm needed to support richer cron-like notation (ranges such as `a-b`, steps such as `*/a`, and lists like `x,y,z`) as already supported by apscheduler's CronTrigger. The existing JSON schema for CronTimer parameters enforced integer-only types for fields like `year`, `month`, `day`, `week`, `day_of_week`, `hour`, `minute`, and `second`, which prevented users from specifying these more advanced cron expressions. To enable this feature, the schema for each of those fields was changed from a simple `type: integer` to `anyOf: [string, integer]`, keeping numeric ranges (minimum/maximum) where applicable but allowing string input. However, by allowing arbitrary strings, schema-level validation alone was no longer sufficient to guarantee that the provided values formed a valid CronTrigger expression.\n\nTo address this, additional validation was added to the API-side trigger parameter validator (`st2common/st2common/validators/api/reactor.py`). After the JSON schema validation succeeds, if the trigger type is `core.st2.CronTimer` (now referenced via the `CRON_TIMER_TRIGGER_REF` constant), the code attempts to instantiate `apscheduler.triggers.cron.CronTrigger(**parameters)`. CronTrigger's constructor will raise a `ValueError` if the cron expression is invalid (e.g., out-of-range day_of_week values or unknown weekday names), and this integrates into the existing API validation error handling, returning HTTP 400 BAD_REQUEST to the client with the underlying error message.\n\nNew unit tests were added in `st2api/tests/unit/controllers/v1/test_rules.py` along with three fixtures defining invalid CronTimer rules. The tests post rules with bad `day_of_week` values: an excessively large integer (1000), an invalid weekday name string (\"abcdef\"), and a malformed expression (\"a-1\"). Each is expected to result in HTTP 400 BAD_REQUEST with an error message derived from either JSON schema (for the 1000 > max 6 case) or CronTrigger's validation (for invalid weekday names). The code also refactors trigger reference usage by defining constants `INTERVAL_TIMER_TRIGGER_REF`, `DATE_TIMER_TRIGGER_REF`, and `CRON_TIMER_TRIGGER_REF` in `st2common/constants/triggers.py`, reducing duplication.\n\nBecause this behavior depends on apscheduler's CronTrigger semantics, the requirements were updated to pin apscheduler to a compatible version range (`>=3.0.5,<3.1` both in `fixed-requirements.txt` and `requirements.txt`), and `apscheduler` was added to `st2common/in-requirements.txt` to ensure the validator has the dependency. The changelog was updated to communicate that `core.st2.CronTimer` now supports more cron-like expressions.",
        "semantic_memory": "This change illustrates several generalizable practices for feature enhancements that involve relaxing input validation while maintaining correctness:\n\n1. **Combining structural and semantic validation**: JSON schema (or similar) is excellent for structural constraints (types, required fields, numeric ranges), but it cannot express complex semantics such as 'this string must be a valid cron expression'. When schema constraints are relaxed (e.g., from integer to `string | integer`) to support richer syntax, it's necessary to complement schema validation with an additional semantic validation step that uses the domain library (here, apscheduler's CronTrigger) to validate the input. This prevents accepting syntactically invalid or semantically nonsensical strings.\n\n2. **Validating via the underlying engine/library**: When an external library is ultimately responsible for interpreting configuration (e.g., apscheduler parsing cron expressions), the most robust validation is to invoke that library as early as possible (e.g., during API request validation) rather than reimplementing its rules. Using the library's constructor or parser both ensures parity with runtime behavior and reduces the chance of drift when the library evolves.\n\n3. **Error surfacing and UX**: By letting the library raise specific exceptions (like ValueError with detailed messages) and propagating them into API responses, users get precise feedback such as 'Invalid weekday name \"abcdef\"' rather than a generic 'invalid parameter' error. This supports better usability and faster troubleshooting.\n\n4. **Dependency version pinning to preserve behavior**: When relying on specific validation behavior of a third-party library, it's important to pin library versions to ranges that are known to be compatible. Otherwise, future library changes could alter validation logic or error messages in ways that break tests or user expectations.\n\n5. **Centralizing identifiers via constants**: Replacing hard-coded string references (e.g., 'core.st2.CronTimer') with shared constants like `CRON_TIMER_TRIGGER_REF` improves maintainability, prevents typos, and makes it easier to change underlying naming conventions.\n\n6. **Testing negative cases for validation**: For validation logic, it's crucial to test both positive and negative scenarios. In particular, tests that assert specific error messages and HTTP codes for invalid input guard against regressions when schemas or underlying libraries change.",
        "procedural_memory": [
            "When you need to support richer string-based syntax (e.g., cron expressions) for existing numeric-only configuration fields and still keep robust validation:",
            "Step 1: Identify all fields that require richer syntax support (e.g., cron timer fields: year, month, day, week, day_of_week, hour, minute, second).",
            "Step 2: Relax the JSON/schema types for those fields from a strict numeric type (integer) to a union that includes string (e.g., `anyOf: [{\"type\": \"string\"}, {\"type\": \"integer\"}]`) while preserving applicable numeric constraints (minimum, maximum) for when integers are used.",
            "Step 3: Add a post-schema semantic validation step in the API or model layer that is executed after the initial schema validation. In this step, detect the relevant context (e.g., `if trigger_type_ref == CRON_TIMER_TRIGGER_REF`) using centralized constants rather than raw strings.",
            "Step 4: In the semantic validation step, instantiate or invoke the underlying domain library responsible for interpreting the configuration (e.g., create `apscheduler.triggers.cron.CronTrigger(**parameters)`). Rely on this constructor or parser to raise exceptions (such as `ValueError`) for invalid expressions.",
            "Step 5: Integrate the exceptions from the domain library into your error handling framework. Convert them into meaningful API responses (e.g., HTTP 400 BAD_REQUEST) with clear error messages so clients understand why their configuration is invalid.",
            "Step 6: Add unit tests for:\n- Valid cases using the new syntax (ranges, steps, lists) to ensure they pass schema and semantic validation.\n- Invalid numeric cases (e.g., out-of-range values like day_of_week: 1000) to ensure schema constraints still work.\n- Invalid string expressions (e.g., unknown names like day_of_week: \"abcdef\" or malformed ranges like \"a-1\") to ensure the semantic validator (CronTrigger) catches them and that the exposed error messages are correct.",
            "Step 7: If your validation depends on specific behavior of an external library (e.g., how CronTrigger parses weekday names or formats error messages), pin the library version (in both runtime and fixed requirements) to a known compatible range, and declare the dependency in any module-specific requirement files.",
            "Step 8: Refactor any repeated resource references (e.g., trigger type strings) into constants in a common module, update all call sites to use these constants, and ensure that tests still pass.",
            "Step 9: Update documentation and changelog to describe the new syntax support and any changes in validation behavior so that users are aware of the richer expression options and potential error messages.",
            "Step 10: For future similar features (e.g., other triggers or config fields needing complex syntax), reuse this pattern: broaden schema types, then add domain-library-based semantic validation, test edge cases, and maintain stable dependencies."
        ]
    }
}
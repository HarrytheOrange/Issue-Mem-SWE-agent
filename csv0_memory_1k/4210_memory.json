{
    "search_index": {
        "description_for_embedding": "Fix EULA rendering in docs, update installer EULA URLs, restrict packaging/signing steps that use secrets to scheduled GitHub Actions runs, and update conda-bundle recipe patching to use local source instead of remote URLs.",
        "keywords": [
            "EULA",
            "licensing",
            "Sphinx include",
            "markdown literal",
            "installer license URL",
            "GitHub Actions",
            "secrets",
            "scheduled workflow",
            "conda bundle",
            "conda-smithy",
            "meta.yaml patching",
            "signing",
            "notarization",
            "napari"
        ]
    },
    "agent_memory": {
        "episodic_memory": "After merging prior PRs that introduced a new EULA/licensing flow and conda-based bundling, several issues were observed:\n\n1) The EULA page on the documentation site (`community/licensing.html`) was rendering the EULA markdown as literal code instead of formatted text. The docs used a Sphinx `{include}` directive with `:literal: true`, which told Sphinx to render the included markdown as literal text. This caused the EULA to appear incorrectly in the published docs.\n\n2) The installer license texts (`resources/bundle_license.rtf` and `resources/bundle_license.txt`) pointed to an outdated URL: `https://github.com/napari/napari/blob/main/LICENSE`, which no longer matched the new EULA structure. The EULA content had moved to `EULA.md` in the `latest` branch, so installers were sending users to the wrong license location.\n\n3) The new conda-bundle GitHub Actions workflow (`.github/workflows/make_bundle_conda.yml`) included steps that required secrets (Anaconda token, Apple certificates) but were not properly gated. This meant that PRs or non-scheduled runs could, in principle, attempt to access secrets / deploy artifacts, which is both a security risk and undesirable behavior. Additionally, there was duplication and confusion around where the `latest` Git tag was being updated.\n\n4) The workflow also patched the conda-forge recipe (`recipe/meta.yaml`) to build from local source, but the `sed` script assumed an older `meta.yaml` structure (using `git_url`/`git_rev`). The recipe had changed to use multiple `url` entries (PyPI tarball, raw GitHub files, with `folder` and `sha256` keys), so the previous patching logic no longer correctly rewrote the recipe.\n\nFixes applied:\n\n- In `docs/community/licensing.md`, the `:literal: true` option was removed from the `{include} ../../EULA.md` directive, allowing Sphinx to render the EULA markdown normally instead of as raw text. This fixed the formatting of the EULA on the licensing page.\n\n- In `resources/bundle_license.rtf` and `resources/bundle_license.txt`, the documentation URL was updated from the generic `LICENSE` on `main` to the correct EULA document on the `latest` branch: `https://github.com/napari/napari/blob/latest/EULA.md`. The RTF hyperlink target was updated accordingly.\n\n- In `.github/workflows/make_bundle_conda.yml`:\n  - The \"Upload to anaconda.org\" step was gated with `if: github.event_name == 'schedule'`, ensuring that uploads to Anaconda only occur in scheduled (nightly) runs that have access to the Anaconda token, not on every push or PR.\n  - Steps that load and use Apple/Windows signing certificates were also restricted to scheduled runs. Specifically:\n    - \"Load signing certificate (MacOS)\" now runs only when `runner.os == 'macOS' && github.event_name == 'schedule'`.\n    - \"Load signing certificate (Windows)\" now runs only when `runner.os == 'Windows' && github.event_name == 'schedule'`, and sets `CONSTRUCTOR_SIGNING_CERTIFICATE`, `CONSTRUCTOR_PFX_CERTIFICATE_PASSWORD`, and `CONSTRUCTOR_SIGNTOOL_PATH` in the GitHub environment.\n    - The Windows signing environment variables, previously provided as `env` to the \"Make Bundle (MacOS/Windows)\" step, are now set within the Windows certificate-loading step instead.\n    - macOS notarization and stapling steps (`Notarize Bundle (macOS)` and `Staple Bundle (macOS)`) are similarly gated with `&& github.event_name == 'schedule'`.\n  - The \"Update latest tag\" step at the bottom of the job was commented out with a note indicating there is a duplicate tag-update mechanism in another workflow (`make_bundle`), and the team needs to decide which one to keep. This prevents conflicting or redundant `latest` tag updates.\n\n- The conda recipe patching in the workflow was updated to match the new `meta.yaml` layout. The `sed` expression was changed to:\n  - Update the `version` Jinja variable based on `NAPARI_VERSION` (`{% set version = \"...\" %}`).\n  - Replace the `- url: https://pypi...` line with `path: ${source_path}`, switching the build to use the local source tree instead of downloading from PyPI.\n  - Remove `- url: https://raw.github...` entries, and any associated `folder` and `sha256` lines, so that the recipe no longer pulls extra raw files from GitHub and doesn't expect a checksum for the replaced sources.\n\nAltogether, these changes fixed the EULA rendering and links, tightened security and behavior around packaging/signing workflows by gating secret-using steps to scheduled runs, and updated the recipe-patching logic to match the current conda-forge recipe format.",
        "semantic_memory": "Key generalizable lessons from this fix:\n\n1) **Sphinx include directives and literal rendering**:\n   - The Sphinx `{include}` directive can render included content either as normal markup or as literal text, depending on options like `:literal: true`.\n   - If you include a markdown file into another markdown or reStructuredText document and see it rendered as raw text or code, check whether the directive is forcing literal rendering and remove `:literal:` when you want normal formatting.\n   - When changing how legal or EULA content is structured in a docs project, always verify how the content appears on the built site; include mechanics are easy to misconfigure.\n\n2) **Keep installer license/EULA URLs in sync with project structure**:\n   - Installer license screens (RTF/text resources) often contain URLs into your repository or documentation. When you move or rename license/EULA files (e.g., from `LICENSE` to `EULA.md`, or from `main` to `latest` branch), those URLs must be updated as well.\n   - Pointing installers to a high-level LICENSE file may be insufficient if you maintain a more detailed EULA or a list of third-party licenses elsewhere; keep the URL aligned with where end-users should really look for legal terms.\n\n3) **Restricting CI steps that use secrets**:\n   - GitHub Actions workflows frequently contain steps that require sensitive credentials (e.g., Anaconda tokens, Apple signing certificates, notarization credentials). These should be carefully gated so that they only run in trusted contexts.\n   - A common pattern is to gate deployment or signing steps on `github.event_name == 'schedule'` (nightly builds) or `github.ref == 'refs/heads/main'` and possibly `github.event_name == 'push'`, rather than on PRs. This protects secrets and prevents accidental publishing.\n   - For cross-platform workflows (Linux/Mac/Windows), combine OS checks with event checks (e.g., `if: runner.os == 'macOS' && github.event_name == 'schedule'`) so that secrets are only used where they are needed.\n\n4) **Managing signing & notarization in multi-OS build pipelines**:\n   - macOS notarization and Windows signing should not run for every CI execution; limit them to release or nightly builds where artifacts are intended for distribution.\n   - Keep environment variables that point to certificate files and signing tools close to where the certificates are loaded, to avoid reliance on global env config and to make the workflow easier to reason about.\n\n5) **Recipe patching must match the current schema**:\n   - When programmatically patching packaging recipes (e.g., conda-forge `meta.yaml`), your patch logic must track changes to the recipe format over time. If the upstream recipe changes from `git_url`/`git_rev` to multiple `url` entries with `sha256` and `folder` keys, any regex or `sed` scripts need to be updated accordingly.\n   - A robust pattern for local source builds is to replace the primary source `url` with `path: /path/to/local/source` and remove redundant remote `url` entries and associated checksums.\n\n6) **Avoid duplicated responsibilities in CI (e.g., updating tags)**:\n   - When multiple workflows perform overlapping tasks (e.g., both updating a `latest` tag), it can cause conflicts and unpredictable behavior. Consolidate such responsibilities to a single well-defined workflow or step.\n\nTaken together, these practices improve documentation correctness, legal/EULA clarity, security of CI/CD pipelines, and robustness of automated packaging workflows.",
        "procedural_memory": [
            "How to diagnose and fix mis-rendered included markdown (EULA) in Sphinx docs:",
            "Step 1: Open the generated documentation page (e.g., licensing/EULA page) and look for symptoms such as the entire included document showing up as raw markdown or code instead of formatted content.",
            "Step 2: Locate the source of that page in the docs (e.g., `docs/community/licensing.md`) and find the Sphinx `{include}` or `{mdinclude}` directive referencing the external markdown (`EULA.md`).",
            "Step 3: Check whether the directive has a `:literal:` option or other flags that would force literal rendering. If you want normal markdown rendering, remove `:literal: true`.",
            "Step 4: Rebuild the documentation locally (e.g., `make docs` or `tox -e docs`) and confirm that the included EULA now displays with proper formatting.",
            "Step 5: Commit the change and re-deploy docs, then re-verify the hosted EULA page.",
            "",
            "How to update installer license/EULA links when legal files move:",
            "Step 1: Identify where your installer license texts are stored (e.g., `resources/bundle_license.rtf` and `bundle_license.txt`).",
            "Step 2: Open these files and search for any URLs pointing to your repository's LICENSE/EULA (e.g., `https://github.com/<org>/<repo>/blob/main/LICENSE`).",
            "Step 3: Determine the correct current location of your EULA or third-party license list (e.g., `EULA.md` in branch `latest`, or a docs page).",
            "Step 4: Update the URLs in all installer resources to point to the correct target (e.g., change `.../blob/main/LICENSE` to `.../blob/latest/EULA.md`). For RTF, update the hyperlink field target; for plain text, update the raw URL.",
            "Step 5: Rebuild the installer and verify that the license screen shows the new link and that it opens the correct EULA page.",
            "",
            "How to restrict secret-using steps (signing, notarization, uploads) to scheduled GitHub Actions runs:",
            "Step 1: Open the relevant GitHub Actions workflow file (e.g., `.github/workflows/make_bundle_conda.yml`).",
            "Step 2: Identify steps that require secrets or perform deployment-like actions, such as uploading to package registries, loading certificates, signing artifacts, or notarizing binaries.",
            "Step 3: Add an `if` condition that limits these steps to safe event types, for example: `if: github.event_name == 'schedule'` or a combination like `if: github.ref == 'refs/heads/main' && github.event_name == 'push'`.",
            "Step 4: For OS-specific signing/notarization, combine `runner.os` checks with the event check (e.g., `if: runner.os == 'macOS' && github.event_name == 'schedule'`).",
            "Step 5: If environment variables for certificates/tools were previously set on a different step, move those assignments into the step that loads or uses the certificates to keep scoping tight and clear.",
            "Step 6: Push a branch and run the workflow in different contexts (PR, push to main, scheduled run) to confirm that secret-using steps only run in the intended contexts.",
            "",
            "How to clean up duplicated tag-update logic in CI:",
            "Step 1: Search all workflows for steps that modify tags (e.g., use of `EndBug/latest-tag` or raw `git tag` commands).",
            "Step 2: Decide which workflow should own the responsibility of updating the tag (e.g., the canonical release or nightly workflow).",
            "Step 3: In the other workflows, comment out or remove redundant tag-update steps, and add a comment explaining where tag updates are now managed.",
            "Step 4: Monitor subsequent releases to ensure tag updates occur correctly from the single chosen workflow.",
            "",
            "How to patch a conda-forge recipe to use local source instead of remote URLs:",
            "Step 1: Inspect the current `recipe/meta.yaml` structure to see how sources are specified (e.g., `- url: https://pypi...`, additional `- url: https://raw.github...` entries, `folder`, and `sha256` keys).",
            "Step 2: In your CI step that prepares the recipe, compute the desired version (e.g., from your project: `NAPARI_VERSION`) and the local source path (e.g., `/home/conda/feedstock_root/<project>-source`).",
            "Step 3: Use `sed` or a script to update the Jinja `version` variable in `meta.yaml`, for example: replace `{% set version = \"...\" %}` with `{% set version = \"${NAPARI_VERSION}\" %}`.",
            "Step 4: Replace the main source `url` line (e.g., `- url: https://pypi...`) with `path: ${source_path}` to instruct conda-build to use the local source tree.",
            "Step 5: Remove any additional `url` entries pointing to raw GitHub paths and their associated metadata (`folder`, `sha256`), so the recipe no longer expects to download those files.",
            "Step 6: Run `conda-smithy rerender` or analogous tooling to update the feedstock after patching.",
            "Step 7: Test the conda build locally or in CI to ensure it correctly uses the local source and no longer attempts to fetch remote tarballs or raw files."
        ]
    }
}
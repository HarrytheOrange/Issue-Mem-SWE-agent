{
    "search_index": {
        "description_for_embedding": "Fix for Qt high-DPI scaling in napari by enabling Qt's AA_EnableHighDpiScaling attribute at the correct time: inside the event loop setup before QApplication is instantiated, instead of creating a QApplication early just to inspect monitor DPI. This resolves mis-scaled sliders on HiDPI displays and avoids Qt test failures/timeouts caused by premature QApplication creation.",
        "keywords": [
            "Qt",
            "high DPI",
            "HiDPI",
            "Qt AA_EnableHighDpiScaling",
            "QApplication.setAttribute",
            "QApplication.instance",
            "napari gui_qt",
            "event_loop.py",
            "qtpy",
            "Qt event loop",
            "pytest-qt timeouts",
            "QApplication creation order",
            "GUI scaling bug",
            "monitor DPI",
            "IPython %gui qt"
        ]
    },
    "agent_memory": {
        "episodic_memory": "In napari, sliders and other themed widgets were not scaling correctly on high-DPI screens (e.g., Retina or scaled Linux displays). An initial attempt to fix this involved querying monitor DPI, which required creating a QApplication early, from module import code. That approach caused problems in tests: once a QApplication existed unexpectedly, downstream tests using pytest-qt and napari's Viewer behaved incorrectly, leading to failures such as RuntimeError not being raised in `test_no_qt_loop`, animation worker threads never finishing (`qtbot.waitSignal` timeouts), and even segmentation faults during teardown.\n\nA key insight was that Qt provides a built-in high DPI switch: `QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)`, but this attribute only takes effect if set before the QApplication is instantiated. Placing the logic in `__init__.py` or DPI helper functions was too late or caused side effects. Additionally, trying to compute monitor DPI by creating a temporary QApplication instance directly interfered with napari's own event loop and IPython/Jupyter integration.\n\nThe final fix simplified the approach: rather than manually measuring DPI, napari now lets Qt handle high DPI scaling automatically, as long as the attribute is set at the correct time. The patch modified `napari/_qt/event_loop.py` in the `gui_qt` context manager, which is the central place napari starts its own Qt event loop:\n\n- Import `Qt` from `qtpy.QtCore`.\n- In `gui_qt`, before creating a new QApplication, check if one exists.\n- If no QApplication exists, call `QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)` and then instantiate `app = QApplication(sys.argv)`.\n\nThis ensures that whenever napari is responsible for starting Qt (via `napari.gui_qt()`), high-DPI scaling is enabled globally and early enough. If an application already exists (e.g. created by IPython `%gui qt` or `--gui qt`), then napari does not attempt to change attributes and assumes the embedding environment is responsible. A companion PR to IPython enabled AA_EnableHighDpiScaling there too, so the interactive workflows also benefit.\n\nAfter this change, high-DPI UI elements rendered correctly, and the earlier test failures and timeouts (caused by premature QApplication creation for DPI detection) disappeared. The file `qt_hidpi_settings.py` and any import-time DPI logic were removed in favour of this centralized event-loop-based solution.",
        "semantic_memory": "Generalizable lessons from this fix revolve around Qt's high DPI handling and the lifecycle of QApplication:\n\n1. **High DPI in Qt should use built-in attributes, not ad-hoc DPI detection.** Instead of manually measuring monitor DPI and applying custom scaling, use `QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)` (and related attributes like `AA_UseHighDpiPixmaps`) and let Qt adapt. This avoids complex and OS-specific code.\n\n2. **The timing of `QApplication.setAttribute` is critical.** Qt attributes like `AA_EnableHighDpiScaling` must be set before the global QApplication object is created. Setting them after `QApplication()` has been instantiated has no effect on that app, which leads to confusion if the attribute is sprinkled throughout the codebase.\n\n3. **Never create a hidden QApplication just to query information (like DPI) from module import code.** Instantiating QApplication has global side effects: it changes process-wide state, affects future GUI initialization, and can break expectations in tests (e.g., tests that assume no event loop exists or that they control its lifetime). It can also conflict with host environments (IPython, Jupyter, PyCharm, etc.) that may own the Qt loop.\n\n4. **Centralize event-loop and QApplication management.** In larger applications, there should be a single, well-defined entry point that is responsible for creating the QApplication and setting process-wide Qt attributes. All high-level convenience APIs (`gui_qt`, CLI entry points, embedding hooks) should funnel through this central point. This makes it easy to add global behaviours (like HiDPI, application name, icons, styling) and prevents scattered, conflicting initialization logic.\n\n5. **Guard against existing QApplication instances.** Libraries that may be embedded in other Qt applications (e.g., via IPython `%gui qt`, PyCharm, or other frameworks) should check `QApplication.instance()` before creating a new app or setting attributes. If an instance exists, the library should typically not alter global attributes, and instead rely on the host to configure Qt appropriately.\n\n6. **Qt test failures (timeouts, threads not finishing) can be symptoms of incorrect QApplication lifecycle management.** When Qt tests that use pytest-qt (`qtbot`) start timing out or behave non-deterministically, one common underlying cause is that widgets, timers, or threads are being created under an unexpected or pre-existing QApplication, or that the event loop is not owned where the tests expect. Properly structuring app creation often resolves these issues.\n\n7. **IPython/Jupyter integration is tightly coupled to how the event loop is started.** When your library must work both as a standalone app and inside IPython/Jupyter, align your configuration with the way those environments start Qt (e.g., `%gui qt`), or submit upstream patches so that they set required Qt attributes before application creation.\n\nThese principles apply broadly to any Qt-based Python application or library (not just napari) that must support high-DPI displays, embedding in interactive environments, and robust automated testing.",
        "procedural_memory": [
            "Step-by-step instructions on how to diagnose and fix similar high-DPI and QApplication lifecycle issues:",
            "Step 1: Identify high-DPI symptoms and context.\n- Observe UI problems such as tiny sliders, mis-scaled icons, or inconsistent widget sizes on high-DPI displays.\n- Check whether the issue occurs only when launching through certain entry points (CLI, IPython `%gui qt`, PyCharm, etc.).",
            "Step 2: Check how and where QApplication is created.\n- Search the codebase for `QApplication(` (or `QCoreApplication`) to find all instantiation points.\n- Also look for any import-time creation (e.g., inside module-level functions that might run at import) and helper utilities that create a QApplication solely to read information.\n- Verify whether your library assumes that it owns the Qt event loop, or might be embedded in an environment that already has a QApplication.",
            "Step 3: Ensure Qt high-DPI attributes are set before QApplication instantiation.\n- Decide on a single central place where your application starts Qt (e.g., a `gui_qt` or `run_app` function).\n- At the top of that function, before any `QApplication(...)` call, import Qt and set the high DPI attribute:\n  ```python\n  from qtpy.QtCore import Qt\n  from qtpy.QtWidgets import QApplication\n\n  def gui_qt(...):\n      app = QApplication.instance()\n      if not app:\n          QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)\n          app = QApplication(sys.argv)\n      ...\n  ```\n- Avoid setting this attribute elsewhere in the lifecycle for the same app instance—it will not have effect after the app is created.",
            "Step 4: Remove or refactor code that creates a QApplication just to query DPI or other global state.\n- Find helper functions that do something like:\n  ```python\n  def dpis():\n      app = QApplication.instance() or QApplication([])\n      ... # query screen DPI\n  ```\n- This pattern can silently create a QApplication early and interfere with the main event loop.\n- Refactor so that such functions assume an app already exists (and document this), or move the logic into your central initialization path, or use OS APIs that do not require a QApplication.\n- If you absolutely must compute something before the main event loop and cannot avoid Qt, consider isolating that logic in a separate process (e.g. subprocess) to avoid affecting the main process's QApplication state, but this is rarely necessary if you use Qt's high-DPI attributes.",
            "Step 5: Guard against pre-existing QApplication instances.\n- In your central event loop function, always call `QApplication.instance()` first.\n- If an instance exists, do not call `QApplication.setAttribute(...)` (attributes won't take effect for the existing instance anyway) and do not create a second application—just reuse the existing app.\n- Document that in embedded contexts (e.g., IPython `%gui qt`), the host is responsible for enabling high DPI and other attributes.",
            "Step 6: Coordinate with host environments (IPython/Jupyter, IDEs).\n- If your library needs high DPI scaling when launched inside IPython or Jupyter, examine how those environments start Qt (usually via `%gui qt` or `--gui qt`).\n- If necessary, submit upstream patches so that they call `QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)` before creating a QApplication.\n- Once merged, your library can assume high DPI is handled correctly when embedded.",
            "Step 7: Re-run GUI test suites and look for Qt-specific failures.\n- Use pytest-qt (`qtbot`) tests to ensure all animations, timers, and widgets behave correctly.\n- If you see timeouts like `pytestqt.exceptions.TimeoutError` waiting for signals (e.g., `.finished` on animation threads), verify that:\n  - The event loop is running under the expected QApplication.\n  - You aren't accidentally starting a second QApplication or creating widgets with no active loop.\n- Fix any remaining lifecycle issues by routing all GUI construction through the central event-loop code.",
            "Step 8: Validate visually on multiple display types and configurations.\n- Test on:\n  - Normal DPI screens (no OS scaling).\n  - High-DPI screens with OS scaling (e.g., 150%, 200%).\n  - Multi-monitor setups with mixed DPI.\n- Confirm that fonts, icons, sliders, and other widgets scale consistently and that your styling (e.g., theme stylesheets) respects scaling (prefer point-based units where possible instead of fixed px).",
            "Step 9: Document the initialization pattern for contributors and users.\n- Document that all Qt attribute configuration and QApplication creation go through `gui_qt` (or equivalent).\n- Clarify how to embed the library in IPython/Jupyter or other apps, including any required environment configuration to get correct HiDPI behaviour.",
            "Step 10: Avoid regression by adding targeted tests or checks.\n- Add at least one test that verifies the absence of a QApplication in contexts that expect none (e.g., a `test_no_qt_loop`-style test).\n- Optionally, add a simple test that imports your library and checks that `QApplication.instance()` is still `None` unless explicitly requested via the public `gui_qt` API.\n- This helps catch future regressions where someone reintroduces implicit QApplication creation at import time."
        ]
    }
}